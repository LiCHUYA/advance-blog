import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const _imports_0 = "/advance-blog/assets/20210924220113.jpg-37.PpNN1wAh.jpg";
const _imports_1 = "/advance-blog/assets/20210920112302.jpg-39.TtOqKLWI.jpg";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/10-浏览器缓存2-渐进增强——强大而又难以驾驭的 Service Worker.md","filePath":"src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/10-浏览器缓存2-渐进增强——强大而又难以驾驭的 Service Worker.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/10-浏览器缓存2-渐进增强——强大而又难以驾驭的 Service Worker.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<p>在浏览器缓存的世界中，不同的缓存扮演着不同的角色，缓存存储的位置的也不尽相同，除了上文介绍的内存和磁盘外，本文将介绍在服务器与浏览器间扮演中间人角色的缓存 —— <code>Service Worker</code>。</p><p>提及 Service Worker 有些人可能会觉得陌生，因为不是所有的项目都适合使用它，但如果你的网页正在追求一种极致的性能体验，那么 Service Worker 可以帮你达成这一目标，而要了解 Service Worker 首先还得从渐进式 Web 应用说起。</p><h2 id="从渐进式-web-应用开始" tabindex="-1">从渐进式 Web 应用开始 <a class="header-anchor" href="#从渐进式-web-应用开始" aria-label="Permalink to &quot;从渐进式 Web 应用开始&quot;">​</a></h2><p>随着移动互联网的发展，为了满足用户在手机上操作页面的便捷性，诸多 PC 应用也纷纷推出了自己的移动版本，而移动原生应用不管在用户体验还是功能上都比传统的 web 应用强大得多，比如快速的页面加载、及时的信息推送和离线可用等，而这些功能当时在 web 应用中都存在着限制，于是成千上万个采用 iOS、Android 原生技术开发的应用如雨后春笋般出现，成功打下了该领域的一片“江山”。</p><p>为了让 web 技术在移动时代的浪潮中能够分得一杯羹，各大浏览器厂商便纷纷开始支持及推进渐进式 Web 应用（<code>Progressive Web Apps</code>）的使用，即我们熟知的 PWA。</p><p>那么什么是渐进式 Web 应用？</p><p><strong>从本质上讲，渐进式 Web 应用程序仍然是 Web 应用程序，但其支持渐进式增强，在现代浏览器中可以使用新功能，如果新功能不可用，用户仍然可以获得核心的体验。</strong></p><p>其特性主要体现在：</p><ul><li>功能强大（在现代 API、WebAssembly 和新的即将推出的 API 之间，Web 应用程序比以往任何时候都更强大）</li><li>可靠性（无论网络如何，可靠的渐进式 Web 应用程序都会让用户感觉到快速）</li><li>可安装（已安装的渐进式 Web 应用程序在独立窗口中运行，而不是在浏览器 tab 页中运行）</li></ul><p>而实现以上特性的关键技术就是本文的主人公 Service Worker。</p><h2 id="service-worker-登场" tabindex="-1">Service Worker 登场 <a class="header-anchor" href="#service-worker-登场" aria-label="Permalink to &quot;Service Worker 登场&quot;">​</a></h2><h3 id="概念" tabindex="-1">概念 <a class="header-anchor" href="#概念" aria-label="Permalink to &quot;概念&quot;">​</a></h3><p>Service Worker 本质上是一种用 JavaScript 编写的脚本，其作为一个独立的线程，它可以使应用程序能够控制网络请求，缓存这些请求以提高性能，并提供对缓存内容的离线访问。</p><p>![Service Worker 中间人.png](./images/Service Worker 中间人.png-36.jpg)</p><p>Service Worker 依赖两个 API 使应用程序离线工作：<a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noreferrer">Cache</a>（应用程序数据的持久性内容存储）和   <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Fetch_API" target="_blank" rel="noreferrer">Fetch</a>（一种从网络检索内容的标准方法）。<strong>Service Worker 缓存是持久的，独立于浏览器缓存或网络状态。</strong></p><h3 id="生命周期与缓存" tabindex="-1">生命周期与缓存 <a class="header-anchor" href="#生命周期与缓存" aria-label="Permalink to &quot;生命周期与缓存&quot;">​</a></h3><p>Service Worker 在其生命周期中会经历以下三个步骤：</p><ul><li>注册</li><li>安装</li><li>激活</li></ul><p>通常我们会编写以下脚本进行 Service Worker 的注册：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;serviceWorker&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> in</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> navigator) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  navigator.serviceWorker</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/sw.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">registration</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Registration successful, scope is:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, registration.scope);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">catch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">error</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Service worker registration failed, error:&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, error);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>首先判断浏览器支不支持 <code>serviceWorker</code> API，支持后注册时会去读取对应的 sw.js 文件，默认情况下 Service Worker 的作用范围不能超出其脚本所在的路径，如果上述脚本放在根目录下，那么代表项目根目录下的所有请求都可以代理。当然也可以在注册时指定对应的作用域：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">navigator.serviceWorker.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">register</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/sw.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  scope: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;/xxx&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p>此时 Service Worker 只会代理 xxx 目录下的请求。</p><p>一旦浏览器执行了注册流程后，在 sw.js 文件中，其便会尝试执行 Service Worker 的 install 安装事件，该事件只会触发一次，即在首次注册或者有新的 Service Worker 之后执行。在安装事件中我们可以下载并预缓存应用的部分内容，以便在用户下次访问时立即得到加载。以 Chrome 官网的例子为例：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// sw.js</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 此版本的 Service Worker 中使用的两个缓存的名称，更新任意一个缓存名称，都将再次触发安装事件</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> PRECACHE</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;precache-v1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> RUNTIME</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;runtime&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 想被缓存的本地资源列表</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> PRECACHE_URLS</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;index.html&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;./&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// index.html 的别名</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;styles.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;../../styles/main.css&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>\n<span class="line"><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">  &quot;demo.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 安装事件中缓存预先我们想要缓存的资源</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;install&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">waitUntil</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 调用浏览器 CacheStorage open 方法</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    caches</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">PRECACHE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cache</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addAll</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">PRECACHE_URLS</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">))</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">skipWaiting</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// self.skipWaiting 可以阻止等待，让新的 Service Worker 安装成功后立即激活</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  );</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p>在安装事件中我们会缓存预先想要缓存的资源，成功安装 Service Worker 后，它会过渡到激活阶段。如果有前一个 Service Worker 控制的打开页面存在，则新的 Service Worker 会进入一个 waiting 状态。新的 Service Worker 仅在不再加载任何仍在使用旧 Service Worker 的页面时激活，这确保在任何给定时间只有一个版本的 Service Worker 正在运行。</p><p>我们也可以调用 <code>skipWaiting()</code> 方法阻止 Service Worker 等待，让新的 Service Worker 安装成功后立即激活。</p><p>当新的 Service Worker 激活时，其会触发 <code>active</code> 事件，我们可以使用 <code>addEventListener</code> 来监听 activate 事件。在此事件中我们通常会清理过期的缓存：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// sw.js</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// active 事件负责清理过期缓存</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;activate&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> currentCaches</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">PRECACHE</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">RUNTIME</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">waitUntil</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    caches</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">keys</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cacheNames</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cacheNames.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">filter</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">          (</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cacheName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> !</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">currentCaches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">includes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(cacheName)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        );</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cachesToDelete</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> Promise</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">all</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">          cachesToDelete.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">map</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cacheToDelete</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">delete</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(cacheToDelete); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 删除不存在的过期缓存</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">          })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        );</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      .</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> self.clients.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">claim</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()) </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 启用新的 Service Worker</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  );</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p>上述我们在 active 生命周期中通过调用浏览器的 <a href="https://developer.mozilla.org/zh-CN/docs/Web/API/Cache" target="_blank" rel="noreferrer">Cache</a> API 的 delete 方法将过期的缓存进行了删除操作，防止过期缓存影响现有的功能。</p><p>一旦激活，Service Worker 将控制在其范围内加载的所有页面，新的 Service Worker 只会在我们关闭并重新打开应用时启用，或者调用 <code>clients.claim()</code> 方法。</p><p>至此相信大家对 Service Worker 在其生命周期中会经历的三个步骤“注册、安装和激活”以及如何将资源添加到缓存中已经有了一定的认识，那么下面我们再来了解下 Service Worker 如何拦截网络请求并从缓存中获取资源。</p><h3 id="优先从缓存中获取资源" tabindex="-1">优先从缓存中获取资源 <a class="header-anchor" href="#优先从缓存中获取资源" aria-label="Permalink to &quot;优先从缓存中获取资源&quot;">​</a></h3><p>如果大家想让自己的网页离线可用，那么拦截网络请求并从缓存中获取资源是最主要的方法，当然前提是缓存中已经存在了所要访问的资源。</p><p>我们一般会采用<strong>缓存回退网络</strong>的方式进行代码的编写，即拦截请求时如果缓存中存在该资源则直接获取，否则再向服务端请求资源并进行缓存。示例代码如下：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// sw.js</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// fetch 处理事件会处理同源资源的响应，如果缓存中存在，则会直接返回缓存资源</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">self.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;fetch&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, (</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // 跳过跨域请求</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (event.request.url.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">startsWith</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(self.location.origin)) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">respondWith</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 从缓存中匹配请求的资源</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">match</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.request).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cachedResponse</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        // 存在则直接返回</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (cachedResponse) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">          return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cachedResponse;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">        // 不存在则回退网络请求</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">        return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> caches.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">open</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">RUNTIME</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">cache</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">          return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> fetch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.request).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">response</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">            // 拷贝响应资源存入 runtime 缓存.</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">            return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> cache.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">put</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(event.request, response.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">clone</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">()).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">then</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(() </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">              return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> response;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">          });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        });</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      })</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    );</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p>上述代码我们通过监听 <code>fetch</code> 事件处理程序进行资源请求的拦截操作，实现了 Service Worker 基本的优先从缓存中获取资源的功能。</p><p>最终我们将代码组合起来便完成了一个简单的可离线访问功能。当浏览器命中 Service Worker 缓存时，资源在开发者工具中将被显示为从 ServiceWorker 获取。</p><p><img src="' + _imports_0 + '" alt="20210924220113.jpg"></p><p>当然除了上述介绍的 <code>install</code>、<code>activate</code>、<code>fetch</code> 事件，Service Worker 还有其他几个主要的事件，通过按需集成这些事件我们便可以开发强大而体验友好的渐进式 web 应用程序。</p><p>这里笔者用一张图汇总了 Service Worker 的一些主要事件，大家有兴趣可以继续探索。</p><p>![Service Worker 主要事件.png](./images/Service Worker 主要事件.png-38.jpg)</p><h3 id="兼容性" tabindex="-1">兼容性 <a class="header-anchor" href="#兼容性" aria-label="Permalink to &quot;兼容性&quot;">​</a></h3><p>虽然 Service Worker 具有强大的功能，但不同浏览器及其版本对它的兼容性都有所不同，从 <a href="https://caniuse.com/?search=Service%20Worker" target="_blank" rel="noreferrer">caniuse</a> 中查询 Service Worker 的浏览器兼容性结果如下：</p><p><img src="' + _imports_1 + '" alt="20210920112302.jpg"></p><p>因此出于渐进式体验的考虑，在不支持 Service Worker 的低版本浏览器中，我们可能仍然需要进行一些兼容处理，使用户可以使用其主要功能。</p><p><strong>同时出于安全考虑，Service worker 只能在 https 及 localhost 下被使用。</strong></p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p><strong>渐进增强和优雅降级是程序开发中常用的两种手段</strong>，而渐进增强是渐进式 web 应用的核心所在，Service Worker 在传统网页中的使用也正是渐进增强手段的体现。</p><p>当然并不是所有的网页都适合使用 Service Worker 技术，一般当你的应用趋于稳定并且用户体验决定着用户存留的时候，此时不妨可以试试它。比如 Twitter 在使用渐进式 Web 应用后的结果让人印象深刻：</p><blockquote><p>Twitter 每次会话的页面增加了 65%，推文增加了 75%，跳出率降低了 20%，同时其应用程序的大小减少了 97% 以上。改用 PWA 后，日均自然流量增加了 2.3 倍，订阅增加了 58%，每日活跃用户增加了 49%。</p></blockquote>', 51);
const _hoisted_52 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_52);
}
const _10______2_________________Service_Worker = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _10______2_________________Service_Worker as default
};
