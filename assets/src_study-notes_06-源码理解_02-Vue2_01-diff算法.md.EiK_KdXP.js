import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/06-源码理解/02-Vue2/01-diff算法.md","filePath":"src/study-notes/06-源码理解/02-Vue2/01-diff算法.md","lastUpdated":1739881735000}');
const _sfc_main = { name: "src/study-notes/06-源码理解/02-Vue2/01-diff算法.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h3 id="一、vue-2-diff-算法的核心源码" tabindex="-1">一、Vue 2 diff 算法的核心源码 <a class="header-anchor" href="#一、vue-2-diff-算法的核心源码" aria-label="Permalink to &quot;一、Vue 2 diff 算法的核心源码&quot;">​</a></h3><p>Vue 2 的 <strong>diff 算法</strong> 实际上在 Vue 的核心源码中是通过 <code>patch</code> 函数来实现的。我们将以最简化的方式介绍该算法的核心部分。</p><h4 id="_1-patch-函数" tabindex="-1">1. <code>patch</code> 函数 <a class="header-anchor" href="#_1-patch-函数" aria-label="Permalink to &quot;1. `patch` 函数&quot;">​</a></h4><p><code>patch</code> 函数是 Vue 用于更新 DOM 的核心，它会根据 <strong>虚拟 DOM</strong>（VNode）来比较新旧节点，执行必要的 DOM 操作。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// src/core/vdom/patch.js</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> patch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">hydrating</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">removeOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // 如果没有旧虚拟节点，创建一个新的 DOM</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oldVnode) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    createElm</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(vnode); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 直接创建节点</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 继续比较新旧虚拟节点</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    update</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVnode, vnode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><ul><li><code>oldVnode</code> 和 <code>vnode</code> 分别是旧的和新的虚拟 DOM。</li><li><code>hydrating</code> 和 <code>removeOnly</code> 是一些标志，用于处理特定的更新策略（这里可以先不深入）。</li></ul><h4 id="_2-更新策略-update-函数" tabindex="-1">2. 更新策略：<code>update</code> 函数 <a class="header-anchor" href="#_2-更新策略-update-函数" aria-label="Permalink to &quot;2. 更新策略：`update` 函数&quot;">​</a></h4><p><code>update</code> 函数负责比较新旧节点，决定需要更新的部分。这部分是 Vue diff 算法的核心。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 核心的比较方法</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> update</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldVnode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> vnode) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 如果两个节点完全相同，直接返回</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldVnode.tag </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">!==</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> vnode.tag) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 如果节点类型不同，完全替换</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    replaceNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVnode, vnode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 如果节点类型相同，比较属性、子节点等</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    updateNodeAttributes</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVnode, vnode);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    updateChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVnode, vnode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><ul><li><code>replaceNode</code> 负责替换旧节点为新节点。</li><li><code>updateNodeAttributes</code> 更新节点的属性（如 <code>class</code>, <code>style</code> 等）。</li><li><code>updateChildren</code> 比较子节点的差异。</li></ul><h4 id="_3-子节点比较-updatechildren" tabindex="-1">3. 子节点比较：<code>updateChildren</code> <a class="header-anchor" href="#_3-子节点比较-updatechildren" aria-label="Permalink to &quot;3. 子节点比较：`updateChildren`&quot;">​</a></h4><p><code>updateChildren</code> 负责比较节点的子元素。这部分会使用 <strong>key</strong> 来提高对比效率，尤其是在处理 <code>v-for</code> 渲染的列表时。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> updateChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> oldChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldVnode.children;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> newChildren</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> vnode.children;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> &amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> j </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newChildren.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> oldChild</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldChildren[i];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> newChild</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newChildren[j];</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldChild.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newChild.key) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 如果节点的 key 相同，认为是相同的元素，复用</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">      update</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldChild, newChild);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      j</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 处理 key 不同的情况，可能是新增或者删除</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 这里只是伪代码，实际中 Vue 会使用优化策略</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">      replaceNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldChild, newChild);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>这个 <code>updateChildren</code> 函数的核心思想是：</p><ol><li><strong>同层比较</strong>：只有在相同层级的节点中进行比较。</li><li><strong>key 匹配</strong>：如果节点的 <code>key</code> 相同，就复用该节点，否则就需要替换节点。</li></ol><h3 id="二、diff-算法的优化策略" tabindex="-1">二、diff 算法的优化策略 <a class="header-anchor" href="#二、diff-算法的优化策略" aria-label="Permalink to &quot;二、diff 算法的优化策略&quot;">​</a></h3><h4 id="_1-同层比较" tabindex="-1">1. <strong>同层比较</strong> <a class="header-anchor" href="#_1-同层比较" aria-label="Permalink to &quot;1. **同层比较**&quot;">​</a></h4><p>Vue 2 假设节点顺序不会发生改变（如果不使用 <code>key</code>，Vue 会按照旧的节点顺序更新）。因此，它会尽可能在同一层级节点之间进行比较。对于 DOM 结构中没有变化的部分，Vue 会直接复用节点。</p><h4 id="_2-key-的使用" tabindex="-1">2. <strong>key 的使用</strong> <a class="header-anchor" href="#_2-key-的使用" aria-label="Permalink to &quot;2. **key 的使用**&quot;">​</a></h4><p>当我们在渲染列表时，为每个列表项指定一个唯一的 <code>key</code>，Vue 会利用 <code>key</code> 来提高 diff 的性能。<code>key</code> 可以帮助 Vue 跳过不必要的节点比较，并且避免错误的节点复用。</p><h3 id="三、diff-算法源码和示例结合" tabindex="-1">三、diff 算法源码和示例结合 <a class="header-anchor" href="#三、diff-算法源码和示例结合" aria-label="Permalink to &quot;三、diff 算法源码和示例结合&quot;">​</a></h3><p>接下来，我们结合一个 <strong>实际示例</strong> 来演示 Vue 2 是如何使用这些核心源码来进行虚拟 DOM 比较和更新的。</p><h4 id="示例-列表更新" tabindex="-1">示例：列表更新 <a class="header-anchor" href="#示例-列表更新" aria-label="Permalink to &quot;示例：列表更新&quot;">​</a></h4><p>假设我们有一个简单的列表，里面渲染了三个项：</p><div class="language-vue vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">vue</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> v-for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;item in items&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> :key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;item.id&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;{{ item.text }}&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">template</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> default</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">  data</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">() </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      items: [</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        { id: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      ],</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    };</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  methods: {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    updateList</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>\n<span class="line"><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">      this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.items[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">].text </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;Updated Item 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 更新第二项</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">}</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>假设我们调用 <code>updateList</code> 方法来更新第二项的文本，Vue 会执行以下操作：</p><ol><li><strong>创建虚拟 DOM</strong>：Vue 会为初始的 <code>items</code> 数组生成虚拟 DOM 树。</li><li><strong>调用 <code>patch</code> 函数</strong>：当数据更新时，<code>patch</code> 函数会被调用，比较新旧虚拟 DOM 树。</li><li><strong>更新差异</strong>：由于 <code>items[1]</code> 的 <code>text</code> 内容发生了变化，Vue 会找到对应的 <code>li</code> 元素，并更新它的文本内容。</li></ol><h4 id="diff-过程简化" tabindex="-1">diff 过程简化 <a class="header-anchor" href="#diff-过程简化" aria-label="Permalink to &quot;diff 过程简化&quot;">​</a></h4><ol><li>初次渲染时，虚拟 DOM 树为：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span></code></pre></div><ol start="2"><li>当我们调用 <code>updateList</code> 更新 <code>items[1].text</code> 时，新的虚拟 DOM 树为：</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">[</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Updated Item 2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  { tag: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;li&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, key: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">3</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, text: </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;Item 3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> },</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span></code></pre></div><ol start="3"><li>Vue 会执行 <strong>diff</strong>，首先根据 <code>key</code> 比较 <code>li</code> 标签。当找到 <code>key: 2</code> 对应的项时，它会更新第二个 <code>li</code> 元素的文本，而不会重新渲染整个 <code>ul</code> 元素。</li></ol><h4 id="通过-key-来优化" tabindex="-1">通过 <code>key</code> 来优化 <a class="header-anchor" href="#通过-key-来优化" aria-label="Permalink to &quot;通过 `key` 来优化&quot;">​</a></h4><p>如果没有 <code>key</code>，Vue 会默认进行深度对比，比较每一项并进行替换，但如果元素数量很多，这样会非常低效。而有了 <code>key</code>，Vue 能够精确地找到变化的元素，进行局部更新。</p><h3 id="四、总结" tabindex="-1">四、总结 <a class="header-anchor" href="#四、总结" aria-label="Permalink to &quot;四、总结&quot;">​</a></h3><p>Vue 2 的 <strong>diff 算法</strong> 通过以下几个策略实现了高效的 DOM 更新：</p><ul><li><strong>同层比较</strong>：只在相同层级的节点之间进行比较，减少不必要的比较。</li><li><strong>key 的使用</strong>：通过 <code>key</code> 提高对比效率，避免错误复用节点。</li><li><strong>最小化更新</strong>：通过生成最小的更新操作，避免不必要的 DOM 操作。</li><li><strong>静态节点复用</strong>：对于静态内容，Vue 会跳过对比，直接复用旧节点。</li></ul><p>通过这些优化策略，Vue 2 实现了高效的虚拟 DOM 更新，使得在大型应用中，UI 更新依然能够保持高性能。</p>', 39);
const _hoisted_40 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_40);
}
const _01Diff__ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _01Diff__ as default
};
