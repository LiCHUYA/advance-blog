import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/13-尾篇-笔者寄语.md","filePath":"src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/13-尾篇-笔者寄语.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/13-尾篇-笔者寄语.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<p>时间总是在不知不觉中流逝，也到了是时候说再见的地方，不管是一路阅读还是撰写，陪伴着自己的只有这枯燥的文字。</p><p>倘若这些枯燥的文字能够带给屏幕前的你一点点力量，那也没有浪费它微不足道的价值。</p><h2 id="回顾与总结" tabindex="-1">回顾与总结 <a class="header-anchor" href="#回顾与总结" aria-label="Permalink to &quot;回顾与总结&quot;">​</a></h2><p>前端缓存是一个涵盖很多技术点的知识体系，本小册立足前端缓存，将前端缓存分为了两大部分：HTTP 缓存和浏览器缓存，以此建立起了小册的目录和结构体系。</p><p>在 HTTP 缓存章节我们率先从浏览器请求头出发，开门见山式的介绍了与 HTTP 缓存息息相关的首部字段，继而顺水推舟引出了<strong>强缓存</strong>与<strong>协商缓存</strong>的概念。在后续的一步步学习过程中，一些和 HTTP 缓存相关的名词也逐渐进入大家的视野，比如<strong>缓存新鲜度</strong>、<strong>使用期算法</strong>和<strong>启发式缓存</strong>等。而后我们结合 HTTP 缓存相关的理论知识，回归实际，分析并总结了在前端应用中与 HTTP 缓存相关的最佳实践方案。</p><p>而在浏览器缓存章节，我们以与 HTTP 缓存密切相关的<strong>磁盘和内存缓存</strong>为切入点，循序渐进的打开了浏览器缓存的大门，随后我们认识了 <strong>Service Worker 缓存</strong>和一系列的<strong>存储型缓存</strong>，从中也寻得了相应的前端缓存方案。</p><p>从缓存技术中探寻缓存方案是本小册内容的最终目的，回过头来我们再来看一下小册标题“前端缓存技术与缓存方案解析”，也正蕴含着这层意思。</p><h2 id="笔者寄语" tabindex="-1">笔者寄语 <a class="header-anchor" href="#笔者寄语" aria-label="Permalink to &quot;笔者寄语&quot;">​</a></h2><p>伏尔泰曾经说过“书读得越多而不加思索，你就会觉得你知道得很多；而当你读书而思考得越多的时候，你就会越清楚地看到，你知道得还很少。”读完本小册，虽然你可能会有所“获”，但也一定要有所“惑”，因为“惑”才是开启未知世界的大门。</p><p>虽然小册在此终结，但关于前端缓存的学习和探索之路并没有以此结束，后面还有很长的路要走，期望大家能以此为起点，继续挑战新的“高峰”。</p><p>感谢每一位读者的阅读，相信未来可期。</p>', 11);
const _hoisted_12 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_12);
}
const _13________ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _13________ as default
};
