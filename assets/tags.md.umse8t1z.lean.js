import { _ as _export_sfc, g as getPrefixCls, b as isNumber$2, m as configProviderInjectionKey, s as setGlobalConfig, c as getComponentPrefix, p as getFirstComponent, I as IconLoading, k as isObject$1, o as isComponentInstance, C as isBoolean$1, w as IconHover, q as useFormItem, i as isArray$2, j as isUndefined$1, t as isNull$1, n as isString$1, v as isFunction$1, r as useSize$1, T as Tag, x as IconClose, D as isEmptyObject, a as getAllElements$1, B as Button, h as getQueryParam } from "./chunks/index.2Idoq-Jx.js";
import { a as ListItem, L as ListItemMeta, d as data$2 } from "./chunks/article.data.7XXEWs8p.js";
import { _ as __unplugin_components_4 } from "./chunks/ArticleMetadata.l7JwFtuX.js";
import { d as defineComponent, g as computed, o as openBlock, c as createElementBlock, n as normalizeClass, O as normalizeStyle, k as createBaseVNode, N as inject, I as createVNode, F as Fragment, ab as cloneVNode, h as ref, b as createBlock, w as withCtx, a1 as withModifiers, T as Transition, j as onMounted, D as resolveComponent, M as mergeProps, r as renderSlot, e as createCommentVNode, y as watch, a4 as toRefs, J as resolveDynamicComponent, a9 as withDirectives, a8 as vShow, P as nextTick, Z as provide, a6 as reactive, C as onUpdated, af as onBeforeUnmount, t as toDisplayString, a as createTextVNode, a7 as getCurrentInstance, E as renderList, al as TransitionGroup, z as watchEffect, ae as isVNode, A as onUnmounted, m as unref, p as pushScopeId, q as popScopeId, _ as _export_sfc$1 } from "./chunks/framework.b55ravPP.js";
import { d as useI18n, h as on, i as off, j as ResizeObserver$1, k as getRelativeRect, E as Enter, o as omit$2, l as INPUT_EVENTS, p as pick$2, R as ResizeObserver$2, F as FeedbackIcon, B as Backspace, m as IconSearch, I as IconDown, T as Trigger, n as useResponsiveState, G as GridContextInjectionKey, q as GridDataCollectorInjectionKey, g as Row, C as Col, b as Input, a as IconRight } from "./chunks/grid-col.-5NRhahx.js";
import "./chunks/ResizeObserver.es.O3MJSaTq.js";
const Shape$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Base() {
    return ShapeBase$1;
  },
  get Circle() {
    return Circle$2;
  },
  get Ellipse() {
    return Ellipse$1;
  },
  get Image() {
    return ImageShape;
  },
  get Line() {
    return Line$3;
  },
  get Marker() {
    return Marker$1;
  },
  get Path() {
    return Path$2;
  },
  get Polygon() {
    return Polygon$2;
  },
  get Polyline() {
    return PolyLine;
  },
  get Rect() {
    return Rect$2;
  },
  get Text() {
    return Text$1;
  }
}, Symbol.toStringTag, { value: "Module" }));
const Shape = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  get Base() {
    return ShapeBase;
  },
  get Circle() {
    return Circle$1;
  },
  get Dom() {
    return Dom;
  },
  get Ellipse() {
    return Ellipse;
  },
  get Image() {
    return Image$1;
  },
  get Line() {
    return Line$2;
  },
  get Marker() {
    return Marker;
  },
  get Path() {
    return Path$1;
  },
  get Polygon() {
    return Polygon$1;
  },
  get Polyline() {
    return Polyline;
  },
  get Rect() {
    return Rect$1;
  },
  get Text() {
    return Text;
  }
}, Symbol.toStringTag, { value: "Module" }));
var commonjsGlobal = typeof globalThis !== "undefined" ? globalThis : typeof window !== "undefined" ? window : typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : {};
function getDefaultExportFromCjs(x) {
  return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, "default") ? x["default"] : x;
}
const _sfc_main$m = defineComponent({
  name: "IconEmpty",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value2) => {
        return ["butt", "round", "square"].includes(value2);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value2) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value2);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-empty`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber$2(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
const _hoisted_1$7 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
const _hoisted_2$6 = /* @__PURE__ */ createBaseVNode("path", { d: "M24 5v6m7 1 4-4m-18 4-4-4m28.5 22H28s-1 3-4 3-4-3-4-3H6.5M40 41H8a2 2 0 0 1-2-2v-8.46a2 2 0 0 1 .272-1.007l6.15-10.54A2 2 0 0 1 14.148 18H33.85a2 2 0 0 1 1.728.992l6.149 10.541A2 2 0 0 1 42 30.541V39a2 2 0 0 1-2 2Z" }, null, -1);
const _hoisted_3$6 = [
  _hoisted_2$6
];
function _sfc_render$k(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_3$6, 14, _hoisted_1$7);
}
var _IconEmpty = /* @__PURE__ */ _export_sfc(_sfc_main$m, [["render", _sfc_render$k]]);
const IconEmpty = Object.assign(_IconEmpty, {
  install: (app, options) => {
    var _a2;
    const iconPrefix = (_a2 = options == null ? void 0 : options.iconPrefix) != null ? _a2 : "";
    app.component(iconPrefix + _IconEmpty.name, _IconEmpty);
  }
});
var Empty$1 = defineComponent({
  name: "Empty",
  props: {
    description: String,
    imgSrc: String,
    inConfigProvider: {
      type: Boolean,
      default: false
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("empty");
    const {
      t
    } = useI18n();
    const configCtx = inject(configProviderInjectionKey, void 0);
    return () => {
      var _a2, _b, _c, _d;
      if (!props.inConfigProvider && (configCtx == null ? void 0 : configCtx.slots.empty) && !(slots.image || props.imgSrc || props.description)) {
        return configCtx.slots.empty({
          component: "empty"
        });
      }
      return createVNode("div", {
        "class": prefixCls
      }, [createVNode("div", {
        "class": `${prefixCls}-image`
      }, [(_b = (_a2 = slots.image) == null ? void 0 : _a2.call(slots)) != null ? _b : props.imgSrc ? createVNode("img", {
        "src": props.imgSrc,
        "alt": props.description || "empty"
      }, null) : createVNode(IconEmpty, null, null)]), createVNode("div", {
        "class": `${prefixCls}-description`
      }, [(_d = (_c = slots.default) == null ? void 0 : _c.call(slots)) != null ? _d : props.description || t("empty.description")])]);
    };
  }
});
const Empty = Object.assign(Empty$1, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + Empty$1.name, Empty$1);
  }
});
const DOT_NUMBER = 5;
var DotLoading = defineComponent({
  name: "DotLoading",
  props: {
    size: {
      type: Number
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("dot-loading");
    return () => {
      const style = props.size ? {
        width: `${props.size}px`,
        height: `${props.size}px`
      } : {};
      return createVNode("div", {
        "class": prefixCls,
        "style": {
          width: props.size ? `${props.size * 7}px` : void 0,
          height: props.size ? `${props.size}px` : void 0
        }
      }, [Array(DOT_NUMBER).fill(1).map((_, index2) => createVNode("div", {
        "class": `${prefixCls}-item`,
        "key": index2,
        "style": style
      }, null))]);
    };
  }
});
var _Spin = defineComponent({
  name: "Spin",
  props: {
    size: {
      type: Number
    },
    loading: Boolean,
    dot: Boolean,
    tip: String,
    hideIcon: {
      type: Boolean,
      default: false
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("spin");
    const configCtx = inject(configProviderInjectionKey, void 0);
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-loading`]: props.loading,
      [`${prefixCls}-with-tip`]: props.tip && !slots.default
    }]);
    const renderIcon = () => {
      if (slots.icon) {
        const iconVNode = getFirstComponent(slots.icon());
        if (iconVNode) {
          return cloneVNode(iconVNode, {
            spin: true
          });
        }
      }
      if (slots.element) {
        return slots.element();
      }
      if (props.dot) {
        return createVNode(DotLoading, {
          "size": props.size
        }, null);
      }
      if (configCtx == null ? void 0 : configCtx.slots.loading) {
        return configCtx.slots.loading();
      }
      return createVNode(IconLoading, {
        "spin": true,
        "size": props.size
      }, null);
    };
    const renderSpinIcon = () => {
      var _a2, _b, _c;
      const style = props.size ? {
        fontSize: `${props.size}px`
      } : void 0;
      const hasTip = Boolean((_a2 = slots.tip) != null ? _a2 : props.tip);
      return createVNode(Fragment, null, [!props.hideIcon && createVNode("div", {
        "class": `${prefixCls}-icon`,
        "style": style
      }, [renderIcon()]), hasTip && createVNode("div", {
        "class": `${prefixCls}-tip`
      }, [(_c = (_b = slots.tip) == null ? void 0 : _b.call(slots)) != null ? _c : props.tip])]);
    };
    return () => createVNode("div", {
      "class": cls.value
    }, [slots.default ? createVNode(Fragment, null, [slots.default(), props.loading && createVNode("div", {
      "class": `${prefixCls}-mask`
    }, [createVNode("div", {
      "class": `${prefixCls}-mask-icon`
    }, [renderSpinIcon()])])]) : renderSpinIcon()]);
  }
});
const Spin = Object.assign(_Spin, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Spin.name, _Spin);
  }
});
const _sfc_main$l = defineComponent({
  name: "Thumb",
  props: {
    data: {
      type: Object
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    alwaysShow: {
      type: Boolean,
      default: false
    },
    both: {
      type: Boolean,
      default: false
    }
  },
  emits: ["scroll"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("scrollbar");
    const visible = ref(false);
    const trackRef = ref();
    const thumbRef = ref();
    const thumbMap = computed(() => {
      if (props.direction === "horizontal") {
        return {
          size: "width",
          direction: "left",
          offset: "offsetWidth",
          client: "clientX"
        };
      }
      return {
        size: "height",
        direction: "top",
        offset: "offsetHeight",
        client: "clientY"
      };
    });
    const offset = ref(0);
    const isDragging = ref(false);
    const mouseOffset = ref(0);
    const thumbStyle = computed(() => {
      var _a2, _b;
      return {
        [thumbMap.value.size]: `${(_b = (_a2 = props.data) == null ? void 0 : _a2.thumbSize) != null ? _b : 0}px`,
        [thumbMap.value.direction]: `${offset.value}px`
      };
    });
    const handleThumbMouseDown = (ev) => {
      ev.preventDefault();
      if (thumbRef.value) {
        mouseOffset.value = ev[thumbMap.value.client] - thumbRef.value.getBoundingClientRect()[thumbMap.value.direction];
        isDragging.value = true;
        on(window, "mousemove", handleMouseMove);
        on(window, "mouseup", handleMouseUp);
        on(window, "contextmenu", handleMouseUp);
      }
    };
    const handleTrackClick = (ev) => {
      var _a2, _b, _c, _d;
      ev.preventDefault();
      if (thumbRef.value) {
        const _offset = getLegalOffset(ev[thumbMap.value.client] > thumbRef.value.getBoundingClientRect()[thumbMap.value.direction] ? offset.value + ((_b = (_a2 = props.data) == null ? void 0 : _a2.thumbSize) != null ? _b : 0) : offset.value - ((_d = (_c = props.data) == null ? void 0 : _c.thumbSize) != null ? _d : 0));
        if (_offset !== offset.value) {
          offset.value = _offset;
          emit("scroll", _offset);
        }
      }
    };
    const getLegalOffset = (offset2) => {
      if (offset2 < 0) {
        return 0;
      }
      if (props.data && offset2 > props.data.max) {
        return props.data.max;
      }
      return offset2;
    };
    const handleMouseMove = (ev) => {
      if (trackRef.value && thumbRef.value) {
        const _offset = getLegalOffset(ev[thumbMap.value.client] - trackRef.value.getBoundingClientRect()[thumbMap.value.direction] - mouseOffset.value);
        if (_offset !== offset.value) {
          offset.value = _offset;
          emit("scroll", _offset);
        }
      }
    };
    const handleMouseUp = () => {
      isDragging.value = false;
      off(window, "mousemove", handleMouseMove);
      off(window, "mouseup", handleMouseUp);
    };
    const setOffset = (_offset) => {
      if (!isDragging.value) {
        _offset = getLegalOffset(_offset);
        if (_offset !== offset.value) {
          offset.value = _offset;
        }
      }
    };
    const thumbCls = computed(() => [
      `${prefixCls}-thumb`,
      `${prefixCls}-thumb-direction-${props.direction}`,
      {
        [`${prefixCls}-thumb-dragging`]: isDragging.value
      }
    ]);
    return {
      visible,
      trackRef,
      thumbRef,
      prefixCls,
      thumbCls,
      thumbStyle,
      handleThumbMouseDown,
      handleTrackClick,
      setOffset
    };
  }
});
function _sfc_render$j(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createBlock(Transition, null, {
    default: withCtx(() => [
      createBaseVNode("div", {
        ref: "trackRef",
        class: normalizeClass([
          `${_ctx.prefixCls}-track`,
          `${_ctx.prefixCls}-track-direction-${_ctx.direction}`
        ]),
        onMousedown: _cache[1] || (_cache[1] = withModifiers((...args) => _ctx.handleTrackClick && _ctx.handleTrackClick(...args), ["self"]))
      }, [
        createBaseVNode("div", {
          ref: "thumbRef",
          class: normalizeClass(_ctx.thumbCls),
          style: normalizeStyle(_ctx.thumbStyle),
          onMousedown: _cache[0] || (_cache[0] = (...args) => _ctx.handleThumbMouseDown && _ctx.handleThumbMouseDown(...args))
        }, [
          createBaseVNode("div", {
            class: normalizeClass(`${_ctx.prefixCls}-thumb-bar`)
          }, null, 2)
        ], 38)
      ], 34)
    ]),
    _: 1
  });
}
var Thumb = /* @__PURE__ */ _export_sfc(_sfc_main$l, [["render", _sfc_render$j]]);
const THUMB_MIN_SIZE = 20;
const TRACK_SIZE = 15;
const _sfc_main$k = defineComponent({
  name: "Scrollbar",
  components: {
    ResizeObserver: ResizeObserver$1,
    Thumb
  },
  inheritAttrs: false,
  props: {
    type: {
      type: String,
      default: "embed"
    },
    outerClass: [String, Object, Array],
    outerStyle: {
      type: [String, Object, Array]
    },
    hide: {
      type: Boolean,
      default: false
    },
    disableHorizontal: {
      type: Boolean,
      default: false
    },
    disableVertical: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    scroll: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("scrollbar");
    const containerRef = ref();
    const horizontalData = ref();
    const verticalData = ref();
    const horizontalThumbRef = ref();
    const verticalThumbRef = ref();
    const _hasHorizontalScrollbar = ref(false);
    const _hasVerticalScrollbar = ref(false);
    const hasHorizontalScrollbar = computed(() => _hasHorizontalScrollbar.value && !props.disableHorizontal);
    const hasVerticalScrollbar = computed(() => _hasVerticalScrollbar.value && !props.disableVertical);
    const isBoth = ref(false);
    const getContainerSize2 = () => {
      var _a2, _b, _c, _d, _e, _f;
      if (containerRef.value) {
        const {
          clientWidth,
          clientHeight,
          offsetWidth,
          offsetHeight,
          scrollWidth,
          scrollHeight,
          scrollTop,
          scrollLeft
        } = containerRef.value;
        _hasHorizontalScrollbar.value = scrollWidth > clientWidth;
        _hasVerticalScrollbar.value = scrollHeight > clientHeight;
        isBoth.value = hasHorizontalScrollbar.value && hasVerticalScrollbar.value;
        const horizontalTrackWidth = props.type === "embed" && isBoth.value ? offsetWidth - TRACK_SIZE : offsetWidth;
        const verticalTrackHeight = props.type === "embed" && isBoth.value ? offsetHeight - TRACK_SIZE : offsetHeight;
        const horizontalThumbWidth = Math.round(horizontalTrackWidth / Math.min(scrollWidth / clientWidth, horizontalTrackWidth / THUMB_MIN_SIZE));
        const maxHorizontalOffset = horizontalTrackWidth - horizontalThumbWidth;
        const horizontalRatio = (scrollWidth - clientWidth) / maxHorizontalOffset;
        const verticalThumbHeight = Math.round(verticalTrackHeight / Math.min(scrollHeight / clientHeight, verticalTrackHeight / THUMB_MIN_SIZE));
        const maxVerticalOffset = verticalTrackHeight - verticalThumbHeight;
        const verticalRatio = (scrollHeight - clientHeight) / maxVerticalOffset;
        horizontalData.value = {
          ratio: horizontalRatio,
          thumbSize: horizontalThumbWidth,
          max: maxHorizontalOffset
        };
        verticalData.value = {
          ratio: verticalRatio,
          thumbSize: verticalThumbHeight,
          max: maxVerticalOffset
        };
        if (scrollTop > 0) {
          const verticalOffset = Math.round(scrollTop / ((_b = (_a2 = verticalData.value) == null ? void 0 : _a2.ratio) != null ? _b : 1));
          (_c = verticalThumbRef.value) == null ? void 0 : _c.setOffset(verticalOffset);
        }
        if (scrollLeft > 0) {
          const horizontalOffset = Math.round(scrollLeft / ((_e = (_d = verticalData.value) == null ? void 0 : _d.ratio) != null ? _e : 1));
          (_f = horizontalThumbRef.value) == null ? void 0 : _f.setOffset(horizontalOffset);
        }
      }
    };
    onMounted(() => {
      getContainerSize2();
    });
    const handleResize = () => {
      getContainerSize2();
    };
    const handleScroll = (ev) => {
      var _a2, _b, _c, _d, _e, _f;
      if (containerRef.value) {
        if (hasHorizontalScrollbar.value && !props.disableHorizontal) {
          const horizontalOffset = Math.round(containerRef.value.scrollLeft / ((_b = (_a2 = horizontalData.value) == null ? void 0 : _a2.ratio) != null ? _b : 1));
          (_c = horizontalThumbRef.value) == null ? void 0 : _c.setOffset(horizontalOffset);
        }
        if (hasVerticalScrollbar.value && !props.disableVertical) {
          const verticalOffset = Math.round(containerRef.value.scrollTop / ((_e = (_d = verticalData.value) == null ? void 0 : _d.ratio) != null ? _e : 1));
          (_f = verticalThumbRef.value) == null ? void 0 : _f.setOffset(verticalOffset);
        }
      }
      emit("scroll", ev);
    };
    const handleHorizontalScroll = (offset) => {
      var _a2, _b;
      if (containerRef.value) {
        containerRef.value.scrollTo({
          left: offset * ((_b = (_a2 = horizontalData.value) == null ? void 0 : _a2.ratio) != null ? _b : 1)
        });
      }
    };
    const handleVerticalScroll = (offset) => {
      var _a2, _b;
      if (containerRef.value) {
        containerRef.value.scrollTo({
          top: offset * ((_b = (_a2 = verticalData.value) == null ? void 0 : _a2.ratio) != null ? _b : 1)
        });
      }
    };
    const style = computed(() => {
      const style2 = {};
      if (props.type === "track") {
        if (hasHorizontalScrollbar.value) {
          style2.paddingBottom = `${TRACK_SIZE}px`;
        }
        if (hasVerticalScrollbar.value) {
          style2.paddingRight = `${TRACK_SIZE}px`;
        }
      }
      return [style2, props.outerStyle];
    });
    const cls = computed(() => [
      `${prefixCls}`,
      `${prefixCls}-type-${props.type}`,
      {
        [`${prefixCls}-both`]: isBoth.value
      },
      props.outerClass
    ]);
    return {
      prefixCls,
      cls,
      style,
      containerRef,
      horizontalThumbRef,
      verticalThumbRef,
      horizontalData,
      verticalData,
      isBoth,
      hasHorizontalScrollbar,
      hasVerticalScrollbar,
      handleResize,
      handleScroll,
      handleHorizontalScroll,
      handleVerticalScroll
    };
  },
  methods: {
    scrollTo(options, y) {
      var _a2, _b;
      if (isObject$1(options)) {
        (_a2 = this.$refs.containerRef) == null ? void 0 : _a2.scrollTo(options);
      } else if (options || y) {
        (_b = this.$refs.containerRef) == null ? void 0 : _b.scrollTo(options, y);
      }
    },
    scrollTop(top) {
      var _a2;
      (_a2 = this.$refs.containerRef) == null ? void 0 : _a2.scrollTo({
        top
      });
    },
    scrollLeft(left2) {
      var _a2;
      (_a2 = this.$refs.containerRef) == null ? void 0 : _a2.scrollTo({
        left: left2
      });
    }
  }
});
function _sfc_render$i(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ResizeObserver = resolveComponent("ResizeObserver");
  const _component_thumb = resolveComponent("thumb");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.style)
  }, [
    createVNode(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
      default: withCtx(() => [
        createBaseVNode("div", mergeProps({
          ref: "containerRef",
          class: `${_ctx.prefixCls}-container`
        }, _ctx.$attrs, {
          onScroll: _cache[0] || (_cache[0] = (...args) => _ctx.handleScroll && _ctx.handleScroll(...args))
        }), [
          createVNode(_component_ResizeObserver, { onResize: _ctx.handleResize }, {
            default: withCtx(() => [
              renderSlot(_ctx.$slots, "default")
            ]),
            _: 3
          }, 8, ["onResize"])
        ], 16)
      ]),
      _: 3
    }, 8, ["onResize"]),
    !_ctx.hide && _ctx.hasHorizontalScrollbar ? (openBlock(), createBlock(_component_thumb, {
      key: 0,
      ref: "horizontalThumbRef",
      data: _ctx.horizontalData,
      direction: "horizontal",
      both: _ctx.isBoth,
      onScroll: _ctx.handleHorizontalScroll
    }, null, 8, ["data", "both", "onScroll"])) : createCommentVNode("v-if", true),
    !_ctx.hide && _ctx.hasVerticalScrollbar ? (openBlock(), createBlock(_component_thumb, {
      key: 1,
      ref: "verticalThumbRef",
      data: _ctx.verticalData,
      direction: "vertical",
      both: _ctx.isBoth,
      onScroll: _ctx.handleVerticalScroll
    }, null, 8, ["data", "both", "onScroll"])) : createCommentVNode("v-if", true)
  ], 6);
}
var _Scrollbar = /* @__PURE__ */ _export_sfc(_sfc_main$k, [["render", _sfc_render$i]]);
const Scrollbar$2 = Object.assign(_Scrollbar, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Scrollbar.name, _Scrollbar);
  }
});
const useComponentRef = (name) => {
  const componentRef = ref();
  const getElement = () => {
    if (isComponentInstance(componentRef.value)) {
      return componentRef.value.$refs[name];
    }
    return componentRef.value;
  };
  const elementRef = ref();
  onMounted(() => {
    elementRef.value = getElement();
  });
  watch([componentRef], () => {
    elementRef.value = getElement();
  });
  return {
    componentRef,
    elementRef
  };
};
var __defProp$8 = Object.defineProperty;
var __getOwnPropSymbols$8 = Object.getOwnPropertySymbols;
var __hasOwnProp$8 = Object.prototype.hasOwnProperty;
var __propIsEnum$8 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$8 = (obj, key, value2) => key in obj ? __defProp$8(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$8 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$8.call(b, prop))
      __defNormalProp$8(a, prop, b[prop]);
  if (__getOwnPropSymbols$8)
    for (var prop of __getOwnPropSymbols$8(b)) {
      if (__propIsEnum$8.call(b, prop))
        __defNormalProp$8(a, prop, b[prop]);
    }
  return a;
};
const useScrollbar = (scrollbar2) => {
  const displayScrollbar = computed(() => Boolean(scrollbar2.value));
  const scrollbarProps = computed(() => {
    if (!scrollbar2.value)
      return void 0;
    return __spreadValues$8({
      type: "embed"
    }, isBoolean$1(scrollbar2.value) ? void 0 : scrollbar2.value);
  });
  return {
    displayScrollbar,
    scrollbarProps
  };
};
const _sfc_main$j = defineComponent({
  name: "SelectDropdown",
  components: {
    ScrollbarComponent: Scrollbar$2,
    Empty,
    Spin
  },
  props: {
    loading: Boolean,
    empty: Boolean,
    virtualList: Boolean,
    bottomOffset: {
      type: Number,
      default: 0
    },
    scrollbar: {
      type: [Boolean, Object],
      default: true
    },
    onScroll: {
      type: [Function, Array]
    },
    onReachBottom: {
      type: [Function, Array]
    },
    showHeaderOnEmpty: {
      type: Boolean,
      default: false
    },
    showFooterOnEmpty: {
      type: Boolean,
      default: false
    }
  },
  emits: ["scroll", "reachBottom"],
  setup(props, { emit, slots }) {
    var _a2, _b, _c;
    const { scrollbar: scrollbar2 } = toRefs(props);
    const prefixCls = getPrefixCls("select-dropdown");
    const configCtx = inject(configProviderInjectionKey, void 0);
    const SelectEmpty = (_c = (_b = configCtx == null ? void 0 : (_a2 = configCtx.slots).empty) == null ? void 0 : _b.call(_a2, { component: "select" })) == null ? void 0 : _c[0];
    const { componentRef: wrapperComRef, elementRef: wrapperRef } = useComponentRef("containerRef");
    const { displayScrollbar, scrollbarProps } = useScrollbar(scrollbar2);
    const handleScroll = (e) => {
      const { scrollTop, scrollHeight, offsetHeight } = e.target;
      const bottom = scrollHeight - (scrollTop + offsetHeight);
      if (bottom <= props.bottomOffset) {
        emit("reachBottom", e);
      }
      emit("scroll", e);
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-has-header`]: Boolean(slots.header),
        [`${prefixCls}-has-footer`]: Boolean(slots.footer)
      }
    ]);
    return {
      prefixCls,
      SelectEmpty,
      cls,
      wrapperRef,
      wrapperComRef,
      handleScroll,
      displayScrollbar,
      scrollbarProps
    };
  }
});
function _sfc_render$h(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_spin = resolveComponent("spin");
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    _ctx.$slots.header && (!_ctx.empty || _ctx.showHeaderOnEmpty) ? (openBlock(), createElementBlock("div", {
      key: 0,
      class: normalizeClass(`${_ctx.prefixCls}-header`)
    }, [
      renderSlot(_ctx.$slots, "header")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.loading ? (openBlock(), createBlock(_component_spin, {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-loading`)
    }, null, 8, ["class"])) : _ctx.empty ? (openBlock(), createElementBlock("div", {
      key: 2,
      class: normalizeClass(`${_ctx.prefixCls}-empty`)
    }, [
      renderSlot(_ctx.$slots, "empty", {}, () => [
        (openBlock(), createBlock(resolveDynamicComponent(_ctx.SelectEmpty ? _ctx.SelectEmpty : "Empty")))
      ])
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.virtualList && !_ctx.loading && !_ctx.empty ? renderSlot(_ctx.$slots, "virtual-list", { key: 3 }) : createCommentVNode("v-if", true),
    !_ctx.virtualList ? withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.displayScrollbar ? "ScrollbarComponent" : "div"), mergeProps({
      key: 4,
      ref: "wrapperComRef",
      class: `${_ctx.prefixCls}-list-wrapper`
    }, _ctx.scrollbarProps, { onScroll: _ctx.handleScroll }), {
      default: withCtx(() => [
        createBaseVNode("ul", {
          class: normalizeClass(`${_ctx.prefixCls}-list`)
        }, [
          renderSlot(_ctx.$slots, "default")
        ], 2)
      ]),
      _: 3
    }, 16, ["class", "onScroll"])), [
      [vShow, !_ctx.loading && !_ctx.empty]
    ]) : createCommentVNode("v-if", true),
    _ctx.$slots.footer && (!_ctx.empty || _ctx.showFooterOnEmpty) ? (openBlock(), createElementBlock("div", {
      key: 5,
      class: normalizeClass(`${_ctx.prefixCls}-footer`)
    }, [
      renderSlot(_ctx.$slots, "footer")
    ], 2)) : createCommentVNode("v-if", true)
  ], 2);
}
var SelectDropdown = /* @__PURE__ */ _export_sfc(_sfc_main$j, [["render", _sfc_render$h]]);
var IconCheck = defineComponent({
  name: "IconCheck",
  render() {
    return createVNode("svg", {
      "aria-hidden": "true",
      "focusable": "false",
      "viewBox": "0 0 1024 1024",
      "width": "200",
      "height": "200",
      "fill": "currentColor"
    }, [createVNode("path", {
      "d": "M877.44815445 206.10060629a64.72691371 64.72691371 0 0 0-95.14856334 4.01306852L380.73381888 685.46812814 235.22771741 533.48933518a64.72691371 64.72691371 0 0 0-92.43003222-1.03563036l-45.82665557 45.82665443a64.72691371 64.72691371 0 0 0-0.90617629 90.61767965l239.61903446 250.10479331a64.72691371 64.72691371 0 0 0 71.19960405 15.14609778 64.33855261 64.33855261 0 0 0 35.08198741-21.23042702l36.24707186-42.71976334 40.5190474-40.77795556-3.36579926-3.49525333 411.40426297-486.74638962a64.72691371 64.72691371 0 0 0-3.88361443-87.64024149l-45.3088404-45.43829334z",
      "p-id": "840"
    }, null)]);
  }
});
const checkboxGroupKey = Symbol("ArcoCheckboxGroup");
var _Checkbox = defineComponent({
  name: "Checkbox",
  components: {
    IconCheck,
    IconHover
  },
  props: {
    modelValue: {
      type: [Boolean, Array],
      default: void 0
    },
    defaultChecked: {
      type: Boolean,
      default: false
    },
    value: {
      type: [String, Number, Boolean]
    },
    disabled: {
      type: Boolean,
      default: false
    },
    indeterminate: {
      type: Boolean,
      default: false
    },
    uninjectGroupContext: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value2) => true,
    "change": (value2, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      disabled,
      modelValue
    } = toRefs(props);
    const prefixCls = getPrefixCls("checkbox");
    const checkboxRef = ref();
    const checkboxGroupCtx = !props.uninjectGroupContext ? inject(checkboxGroupKey, void 0) : void 0;
    const isGroup = (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.name) === "ArcoCheckboxGroup";
    const {
      mergedDisabled: _mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled
    });
    const _checked = ref(props.defaultChecked);
    const computedValue = computed(() => {
      var _a2;
      return isGroup ? checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.computedValue : (_a2 = props.modelValue) != null ? _a2 : _checked.value;
    });
    const computedChecked = computed(() => {
      var _a2;
      return isArray$2(computedValue.value) ? computedValue.value.includes((_a2 = props.value) != null ? _a2 : true) : computedValue.value;
    });
    const mergedDisabled = computed(() => (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.disabled) || (_mergedDisabled == null ? void 0 : _mergedDisabled.value) || !computedChecked.value && (checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.isMaxed));
    const handleClick = (ev) => {
      ev.stopPropagation();
    };
    const handleChange = (e) => {
      var _a2, _b, _c, _d;
      const {
        checked
      } = e.target;
      let newValue = checked;
      if (isArray$2(computedValue.value)) {
        const set2 = new Set(computedValue.value);
        if (checked) {
          set2.add((_a2 = props.value) != null ? _a2 : true);
        } else {
          set2.delete((_b = props.value) != null ? _b : true);
        }
        newValue = Array.from(set2);
      }
      _checked.value = checked;
      if (isGroup && isArray$2(newValue)) {
        checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.handleChange(newValue, e);
      } else {
        emit("update:modelValue", newValue);
        emit("change", newValue, e);
        (_d = (_c = eventHandlers.value) == null ? void 0 : _c.onChange) == null ? void 0 : _d.call(_c, e);
      }
      nextTick(() => {
        if (checkboxRef.value && checkboxRef.value.checked !== computedChecked.value) {
          checkboxRef.value.checked = computedChecked.value;
        }
      });
    };
    const cls = computed(() => [prefixCls, {
      [`${prefixCls}-checked`]: computedChecked.value,
      [`${prefixCls}-indeterminate`]: props.indeterminate,
      [`${prefixCls}-disabled`]: mergedDisabled.value
    }]);
    const handleFocus = (ev) => {
      var _a2, _b;
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onFocus) == null ? void 0 : _b.call(_a2, ev);
    };
    const handleBlur = (ev) => {
      var _a2, _b;
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onBlur) == null ? void 0 : _b.call(_a2, ev);
    };
    watch(modelValue, (value2) => {
      if (isUndefined$1(value2) || isNull$1(value2)) {
        _checked.value = false;
      }
    });
    watch(computedValue, (value2) => {
      var _a2;
      let checked;
      if (isArray$2(value2)) {
        checked = value2.includes((_a2 = props.value) != null ? _a2 : true);
      } else {
        checked = value2;
      }
      if (_checked.value !== checked) {
        _checked.value = checked;
      }
      if (checkboxRef.value && checkboxRef.value.checked !== checked) {
        checkboxRef.value.checked = checked;
      }
    });
    return () => {
      var _a2, _b, _c, _d;
      return createVNode("label", {
        "aria-disabled": mergedDisabled.value,
        "class": cls.value
      }, [createVNode("input", {
        "ref": checkboxRef,
        "type": "checkbox",
        "checked": computedChecked.value,
        "value": props.value,
        "class": `${prefixCls}-target`,
        "disabled": mergedDisabled.value,
        "onClick": handleClick,
        "onChange": handleChange,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }, null), (_d = (_c = (_b = slots.checkbox) != null ? _b : (_a2 = checkboxGroupCtx == null ? void 0 : checkboxGroupCtx.slots) == null ? void 0 : _a2.checkbox) == null ? void 0 : _c({
        checked: computedChecked.value,
        disabled: mergedDisabled.value
      })) != null ? _d : createVNode(IconHover, {
        "class": `${prefixCls}-icon-hover`,
        "disabled": mergedDisabled.value || computedChecked.value
      }, {
        default: () => [createVNode("div", {
          "class": `${prefixCls}-icon`
        }, [computedChecked.value && createVNode(IconCheck, {
          "class": `${prefixCls}-icon-check`
        }, null)])]
      }), slots.default && createVNode("span", {
        "class": `${prefixCls}-label`
      }, [slots.default()])]);
    };
  }
});
var CheckboxGroup = defineComponent({
  name: "CheckboxGroup",
  props: {
    modelValue: {
      type: Array,
      default: void 0
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    max: {
      type: Number
    },
    options: {
      type: Array
    },
    direction: {
      type: String,
      default: "horizontal"
    },
    disabled: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value2) => true,
    "change": (value2, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      disabled
    } = toRefs(props);
    const prefixCls = getPrefixCls("checkbox-group");
    const {
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      disabled
    });
    const _value = ref(props.defaultValue);
    const computedValue = computed(() => isArray$2(props.modelValue) ? props.modelValue : _value.value);
    const isMaxed = computed(() => props.max === void 0 ? false : computedValue.value.length >= props.max);
    const options = computed(() => {
      var _a2;
      return ((_a2 = props.options) != null ? _a2 : []).map((option) => {
        if (isString$1(option) || isNumber$2(option)) {
          return {
            label: option,
            value: option
          };
        }
        return option;
      });
    });
    const handleChange = (value2, e) => {
      var _a2, _b;
      _value.value = value2;
      emit("update:modelValue", value2);
      emit("change", value2, e);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onChange) == null ? void 0 : _b.call(_a2, e);
    };
    provide(checkboxGroupKey, reactive({
      name: "ArcoCheckboxGroup",
      computedValue,
      disabled: mergedDisabled,
      isMaxed,
      slots,
      handleChange
    }));
    const cls = computed(() => [prefixCls, `${prefixCls}-direction-${props.direction}`]);
    watch(() => props.modelValue, (curValue) => {
      if (isArray$2(curValue)) {
        _value.value = [...curValue];
      } else {
        _value.value = [];
      }
    });
    const renderOptions = () => {
      return options.value.map((option) => {
        const checked = computedValue.value.includes(option.value);
        return createVNode(_Checkbox, {
          "key": option.value,
          "value": option.value,
          "disabled": option.disabled || !checked && isMaxed.value,
          "indeterminate": option.indeterminate,
          "modelValue": checked
        }, {
          default: () => [slots.label ? slots.label({
            data: option
          }) : isFunction$1(option.label) ? option.label() : option.label]
        });
      });
    };
    return () => {
      var _a2;
      return createVNode("span", {
        "class": cls.value
      }, [options.value.length > 0 ? renderOptions() : (_a2 = slots.default) == null ? void 0 : _a2.call(slots)]);
    };
  }
});
const Checkbox = Object.assign(_Checkbox, {
  Group: CheckboxGroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Checkbox.name, _Checkbox);
    app.component(componentPrefix + CheckboxGroup.name, CheckboxGroup);
  }
});
const selectInjectionKey = Symbol("ArcoSelectContext");
var __defProp$7 = Object.defineProperty;
var __defProps$3 = Object.defineProperties;
var __getOwnPropDescs$3 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$7 = Object.getOwnPropertySymbols;
var __hasOwnProp$7 = Object.prototype.hasOwnProperty;
var __propIsEnum$7 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$7 = (obj, key, value2) => key in obj ? __defProp$7(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$7 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$7.call(b, prop))
      __defNormalProp$7(a, prop, b[prop]);
  if (__getOwnPropSymbols$7)
    for (var prop of __getOwnPropSymbols$7(b)) {
      if (__propIsEnum$7.call(b, prop))
        __defNormalProp$7(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$3 = (a, b) => __defProps$3(a, __getOwnPropDescs$3(b));
const isGroupOption = (option) => {
  return isObject$1(option) && "isGroup" in option;
};
const isGroupOptionInfo = (option) => {
  return isObject$1(option) && "isGroup" in option;
};
const getValueString = (value2, valueKey = "value") => String(isObject$1(value2) ? value2[valueKey] : value2);
const getKeyFromValue = (value2, valueKey = "value") => {
  if (isObject$1(value2)) {
    return `__arco__option__object__${value2[valueKey]}`;
  }
  if (value2 || isNumber$2(value2) || isString$1(value2) || isBoolean$1(value2)) {
    return `__arco__option__${typeof value2}-${value2}`;
  }
  return "";
};
const hasEmptyStringKey = (optionInfoMap) => {
  return optionInfoMap.has(`__arco__option__string-`);
};
const createOptionInfo = (option, {
  valueKey,
  fieldNames,
  origin,
  index: index2 = -1
}) => {
  var _a2;
  if (isObject$1(option)) {
    const value2 = option[fieldNames.value];
    return {
      raw: option,
      index: index2,
      key: getKeyFromValue(value2, valueKey),
      origin,
      value: value2,
      label: (_a2 = option[fieldNames.label]) != null ? _a2 : getValueString(value2, valueKey),
      render: option[fieldNames.render],
      disabled: Boolean(option[fieldNames.disabled]),
      tagProps: option[fieldNames.tagProps]
    };
  }
  const raw = {
    value: option,
    label: String(option),
    disabled: false
  };
  return __spreadValues$7({
    raw,
    index: index2,
    key: getKeyFromValue(option, valueKey),
    origin
  }, raw);
};
const getOptionInfos = (options, {
  valueKey,
  fieldNames,
  origin,
  optionInfoMap
}) => {
  var _a2;
  const infos = [];
  for (const item of options) {
    if (isGroupOption(item)) {
      const options2 = getOptionInfos((_a2 = item.options) != null ? _a2 : [], {
        valueKey,
        fieldNames,
        origin,
        optionInfoMap
      });
      if (options2.length > 0) {
        infos.push(__spreadProps$3(__spreadValues$7({}, item), {
          key: `__arco__group__${item.label}`,
          options: options2
        }));
      }
    } else {
      const optionInfo = createOptionInfo(item, {
        valueKey,
        fieldNames,
        origin
      });
      infos.push(optionInfo);
      if (!optionInfoMap.get(optionInfo.key)) {
        optionInfoMap.set(optionInfo.key, optionInfo);
      }
    }
  }
  return infos;
};
const getValidOptions = (optionInfos, {
  inputValue,
  filterOption
}) => {
  const travel = (optionInfos2) => {
    var _a2;
    const options = [];
    for (const item of optionInfos2) {
      if (isGroupOptionInfo(item)) {
        const _options = travel((_a2 = item.options) != null ? _a2 : []);
        if (_options.length > 0) {
          options.push(__spreadProps$3(__spreadValues$7({}, item), { options: _options }));
        }
      } else if (isValidOption(item, { inputValue, filterOption })) {
        options.push(item);
      }
    }
    return options;
  };
  return travel(optionInfos);
};
const isValidOption = (optionInfo, {
  inputValue,
  filterOption
}) => {
  if (isFunction$1(filterOption)) {
    return !inputValue || filterOption(inputValue, optionInfo.raw);
  }
  if (filterOption) {
    return optionInfo.label.toLowerCase().includes((inputValue != null ? inputValue : "").toLowerCase());
  }
  return true;
};
const isEqualObject = (obj, other2) => {
  if (!obj || !other2) {
    return false;
  }
  if (obj.length !== other2.length) {
    return false;
  }
  for (const key of Object.keys(obj)) {
    const result = isEqual$2(obj[key], other2[key]);
    if (!result)
      return false;
  }
  return true;
};
const isEqualArray = (arr, other2) => {
  if (!arr || !other2) {
    return false;
  }
  const { length: length2 } = arr;
  if (length2 !== other2.length) {
    return false;
  }
  for (let i = 0; i < length2; i++) {
    const result = isEqual$2(arr[i], other2[i]);
    if (!result)
      return false;
  }
  return true;
};
const isEqual$2 = (a, b) => {
  const type = Object.prototype.toString.call(a);
  if (type !== Object.prototype.toString.call(b)) {
    return false;
  }
  if (type === "[object Object]") {
    return isEqualObject(a, b);
  }
  if (type === "[object Array]") {
    return isEqualArray(a, b);
  }
  if (type === "[object Function]") {
    if (a === b) {
      return true;
    }
    return a.toString() === b.toString();
  }
  return a === b;
};
const _sfc_main$i = defineComponent({
  name: "Option",
  components: {
    Checkbox
  },
  props: {
    value: {
      type: [String, Number, Boolean, Object],
      default: void 0
    },
    label: String,
    disabled: Boolean,
    tagProps: {
      type: Object
    },
    extra: {
      type: Object
    },
    index: {
      type: Number
    },
    internal: Boolean
  },
  setup(props) {
    const { disabled, tagProps: _tagProps, index: index2 } = toRefs(props);
    const prefixCls = getPrefixCls("select-option");
    const selectCtx = inject(selectInjectionKey, void 0);
    const instance = getCurrentInstance();
    const itemRef = ref();
    const tagProps = ref(_tagProps.value);
    watch(_tagProps, (cur, pre) => {
      if (!isEqual$2(cur, pre)) {
        tagProps.value = cur;
      }
    });
    const textContent = ref("");
    const value2 = computed(() => {
      var _a2, _b;
      return (_b = (_a2 = props.value) != null ? _a2 : props.label) != null ? _b : textContent.value;
    });
    const label2 = computed(() => {
      var _a2;
      return (_a2 = props.label) != null ? _a2 : textContent.value;
    });
    const key = computed(() => getKeyFromValue(value2.value, selectCtx == null ? void 0 : selectCtx.valueKey));
    const component2 = computed(() => {
      var _a2;
      return (_a2 = selectCtx == null ? void 0 : selectCtx.component) != null ? _a2 : "li";
    });
    const setTextContent = () => {
      var _a2;
      if (!props.label && itemRef.value) {
        const text2 = (_a2 = itemRef.value.textContent) != null ? _a2 : "";
        if (textContent.value !== text2) {
          textContent.value = text2;
        }
      }
    };
    onMounted(() => setTextContent());
    onUpdated(() => setTextContent());
    const isSelected = computed(() => {
      var _a2;
      return (_a2 = selectCtx == null ? void 0 : selectCtx.valueKeys.includes(key.value)) != null ? _a2 : false;
    });
    const isActive = computed(() => (selectCtx == null ? void 0 : selectCtx.activeKey) === key.value);
    let isValid = ref(true);
    if (!props.internal) {
      const optionInfo = reactive({
        raw: {
          value: value2,
          label: label2,
          disabled,
          tagProps
        },
        ref: itemRef,
        index: index2,
        key,
        origin: "slot",
        value: value2,
        label: label2,
        disabled,
        tagProps
      });
      isValid = computed(() => isValidOption(optionInfo, {
        inputValue: selectCtx == null ? void 0 : selectCtx.inputValue,
        filterOption: selectCtx == null ? void 0 : selectCtx.filterOption
      }));
      if (instance) {
        selectCtx == null ? void 0 : selectCtx.addSlotOptionInfo(instance.uid, optionInfo);
      }
      onBeforeUnmount(() => {
        if (instance) {
          selectCtx == null ? void 0 : selectCtx.removeSlotOptionInfo(instance.uid);
        }
      });
    }
    const handleClick = (ev) => {
      if (!props.disabled) {
        selectCtx == null ? void 0 : selectCtx.onSelect(key.value, ev);
      }
    };
    const handleMouseEnter = () => {
      if (!props.disabled) {
        selectCtx == null ? void 0 : selectCtx.setActiveKey(key.value);
      }
    };
    const handleMouseLeave = () => {
      if (!props.disabled) {
        selectCtx == null ? void 0 : selectCtx.setActiveKey();
      }
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-disabled`]: props.disabled,
        [`${prefixCls}-active`]: isActive.value,
        [`${prefixCls}-multiple`]: selectCtx == null ? void 0 : selectCtx.multiple
      }
    ]);
    return {
      prefixCls,
      cls,
      selectCtx,
      itemRef,
      component: component2,
      isSelected,
      isValid,
      handleClick,
      handleMouseEnter,
      handleMouseLeave
    };
  }
});
function _sfc_render$g(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_checkbox = resolveComponent("checkbox");
  return withDirectives((openBlock(), createBlock(resolveDynamicComponent(_ctx.component), {
    ref: "itemRef",
    class: normalizeClass([_ctx.cls, { [`${_ctx.prefixCls}-has-suffix`]: Boolean(_ctx.$slots.suffix) }]),
    onClick: _ctx.handleClick,
    onMouseenter: _ctx.handleMouseEnter,
    onMouseleave: _ctx.handleMouseLeave
  }, {
    default: withCtx(() => [
      _ctx.$slots.icon ? (openBlock(), createElementBlock("span", {
        key: 0,
        class: normalizeClass(`${_ctx.prefixCls}-icon`)
      }, [
        renderSlot(_ctx.$slots, "icon")
      ], 2)) : createCommentVNode("v-if", true),
      _ctx.selectCtx && _ctx.selectCtx.multiple ? (openBlock(), createBlock(_component_checkbox, {
        key: 1,
        class: normalizeClass(`${_ctx.prefixCls}-checkbox`),
        "model-value": _ctx.isSelected,
        disabled: _ctx.disabled,
        "uninject-group-context": ""
      }, {
        default: withCtx(() => [
          renderSlot(_ctx.$slots, "default", {}, () => [
            createTextVNode(toDisplayString(_ctx.label), 1)
          ])
        ]),
        _: 3
      }, 8, ["class", "model-value", "disabled"])) : (openBlock(), createElementBlock("span", {
        key: 2,
        class: normalizeClass(`${_ctx.prefixCls}-content`)
      }, [
        renderSlot(_ctx.$slots, "default", {}, () => [
          createTextVNode(toDisplayString(_ctx.label), 1)
        ])
      ], 2)),
      _ctx.$slots.suffix ? (openBlock(), createElementBlock("span", {
        key: 3,
        class: normalizeClass(`${_ctx.prefixCls}-suffix`)
      }, [
        renderSlot(_ctx.$slots, "suffix")
      ], 2)) : createCommentVNode("v-if", true)
    ]),
    _: 3
  }, 8, ["class", "onClick", "onMouseenter", "onMouseleave"])), [
    [vShow, _ctx.isValid]
  ]);
}
var Option = /* @__PURE__ */ _export_sfc(_sfc_main$i, [["render", _sfc_render$g]]);
var __defProp$6 = Object.defineProperty;
var __defProps$2 = Object.defineProperties;
var __getOwnPropDescs$2 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$6 = Object.getOwnPropertySymbols;
var __hasOwnProp$6 = Object.prototype.hasOwnProperty;
var __propIsEnum$6 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$6 = (obj, key, value2) => key in obj ? __defProp$6(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$6 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$6.call(b, prop))
      __defNormalProp$6(a, prop, b[prop]);
  if (__getOwnPropSymbols$6)
    for (var prop of __getOwnPropSymbols$6(b)) {
      if (__propIsEnum$6.call(b, prop))
        __defNormalProp$6(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$2 = (a, b) => __defProps$2(a, __getOwnPropDescs$2(b));
const DEFAULT_FIELD_NAMES$2 = {
  value: "value",
  label: "label",
  disabled: "disabled",
  tagProps: "tagProps",
  render: "render"
};
const useOptions = ({
  options,
  extraOptions,
  inputValue,
  filterOption,
  showExtraOptions,
  valueKey,
  fieldNames
}) => {
  const mergedFieldNames = computed(() => __spreadValues$6(__spreadValues$6({}, DEFAULT_FIELD_NAMES$2), fieldNames == null ? void 0 : fieldNames.value));
  const slotOptionInfoMap = reactive(/* @__PURE__ */ new Map());
  const sortedSlotOptionInfos = computed(() => Array.from(slotOptionInfoMap.values()).sort((a, b) => {
    if (isNumber$2(a.index) && isNumber$2(b.index)) {
      return a.index - b.index;
    }
    return 0;
  }));
  const propOptionData = computed(() => {
    var _a2, _b;
    const optionInfoMap2 = /* @__PURE__ */ new Map();
    const optionInfos = getOptionInfos((_a2 = options == null ? void 0 : options.value) != null ? _a2 : [], {
      valueKey: (_b = valueKey == null ? void 0 : valueKey.value) != null ? _b : "value",
      fieldNames: mergedFieldNames.value,
      origin: "options",
      optionInfoMap: optionInfoMap2
    });
    return {
      optionInfos,
      optionInfoMap: optionInfoMap2
    };
  });
  const extraOptionData = computed(() => {
    var _a2, _b;
    const optionInfoMap2 = /* @__PURE__ */ new Map();
    const optionInfos = getOptionInfos((_a2 = extraOptions == null ? void 0 : extraOptions.value) != null ? _a2 : [], {
      valueKey: (_b = valueKey == null ? void 0 : valueKey.value) != null ? _b : "value",
      fieldNames: mergedFieldNames.value,
      origin: "extraOptions",
      optionInfoMap: optionInfoMap2
    });
    return {
      optionInfos,
      optionInfoMap: optionInfoMap2
    };
  });
  const optionInfoMap = reactive(/* @__PURE__ */ new Map());
  watch([
    sortedSlotOptionInfos,
    options != null ? options : ref([]),
    extraOptions != null ? extraOptions : ref([]),
    valueKey != null ? valueKey : ref("value")
  ], () => {
    optionInfoMap.clear();
    sortedSlotOptionInfos.value.forEach((info, index2) => {
      optionInfoMap.set(info.key, __spreadProps$2(__spreadValues$6({}, info), { index: index2 }));
    });
    propOptionData.value.optionInfoMap.forEach((info) => {
      if (!optionInfoMap.has(info.key)) {
        info.index = optionInfoMap.size;
        optionInfoMap.set(info.key, info);
      }
    });
    extraOptionData.value.optionInfoMap.forEach((info) => {
      if (!optionInfoMap.has(info.key)) {
        info.index = optionInfoMap.size;
        optionInfoMap.set(info.key, info);
      }
    });
  }, { immediate: true, deep: true });
  const validOptions = computed(() => {
    var _a2;
    const options2 = getValidOptions(propOptionData.value.optionInfos, {
      inputValue: inputValue == null ? void 0 : inputValue.value,
      filterOption: filterOption == null ? void 0 : filterOption.value
    });
    if ((_a2 = showExtraOptions == null ? void 0 : showExtraOptions.value) != null ? _a2 : true) {
      options2.push(...getValidOptions(extraOptionData.value.optionInfos, {
        inputValue: inputValue == null ? void 0 : inputValue.value,
        filterOption: filterOption == null ? void 0 : filterOption.value
      }));
    }
    return options2;
  });
  const validOptionInfos = computed(() => Array.from(optionInfoMap.values()).filter((optionInfo) => {
    if (optionInfo.origin === "extraOptions" && (showExtraOptions == null ? void 0 : showExtraOptions.value) === false) {
      return false;
    }
    return isValidOption(optionInfo, {
      inputValue: inputValue == null ? void 0 : inputValue.value,
      filterOption: filterOption == null ? void 0 : filterOption.value
    });
  }));
  const enabledOptionKeys = computed(() => validOptionInfos.value.filter((optionInfo) => !optionInfo.disabled).map((info) => info.key));
  const getNextSlotOptionIndex = () => slotOptionInfoMap.size;
  const addSlotOptionInfo = (id2, optionInfo) => {
    slotOptionInfoMap.set(id2, optionInfo);
  };
  const removeSlotOptionInfo = (id2) => {
    slotOptionInfoMap.delete(id2);
  };
  return {
    validOptions,
    optionInfoMap,
    validOptionInfos,
    enabledOptionKeys,
    getNextSlotOptionIndex,
    addSlotOptionInfo,
    removeSlotOptionInfo
  };
};
const KEYBOARD_KEY = {
  ENTER: "Enter",
  ESC: "Escape",
  BACKSPACE: "Backspace",
  TAB: "Tab",
  SPACE: " ",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight"
};
const stringifyCodeKey = (k) => {
  return JSON.stringify({
    key: k.key,
    ctrl: Boolean(k.ctrl),
    shift: Boolean(k.shift),
    alt: Boolean(k.alt),
    meta: Boolean(k.meta)
  });
};
const getKeyDownHandler = (codeKeyMap) => {
  const map2 = {};
  codeKeyMap.forEach((callback, codeKey) => {
    const _codeKey = isString$1(codeKey) ? { key: codeKey } : codeKey;
    map2[stringifyCodeKey(_codeKey)] = callback;
  });
  return (event) => {
    const key = stringifyCodeKey({
      key: event.key,
      ctrl: event.ctrlKey,
      shift: event.shiftKey,
      alt: event.altKey,
      meta: event.metaKey
    });
    const callback = map2[key];
    if (callback) {
      event.stopPropagation();
      callback(event);
    }
  };
};
const useSelect = ({
  multiple,
  options,
  extraOptions,
  inputValue,
  filterOption,
  showExtraOptions,
  component: component2,
  valueKey,
  fieldNames,
  loading,
  popupVisible,
  valueKeys,
  dropdownRef,
  optionRefs,
  virtualListRef,
  onSelect,
  onPopupVisibleChange,
  enterToOpen = true,
  defaultActiveFirstOption
}) => {
  const {
    validOptions,
    optionInfoMap,
    validOptionInfos,
    enabledOptionKeys,
    getNextSlotOptionIndex,
    addSlotOptionInfo,
    removeSlotOptionInfo
  } = useOptions({
    options,
    extraOptions,
    inputValue,
    filterOption,
    showExtraOptions,
    valueKey,
    fieldNames
  });
  const activeKey = ref();
  watch(enabledOptionKeys, (enabledKeys) => {
    if (!activeKey.value || !enabledKeys.includes(activeKey.value)) {
      activeKey.value = enabledKeys[0];
    }
  });
  const setActiveKey = (key) => {
    activeKey.value = key;
  };
  const getNextActiveKey = (direction2) => {
    const _length = enabledOptionKeys.value.length;
    if (_length === 0) {
      return void 0;
    }
    if (!activeKey.value) {
      if (direction2 === "down") {
        return enabledOptionKeys.value[0];
      }
      return enabledOptionKeys.value[_length - 1];
    }
    const activeIndex = enabledOptionKeys.value.indexOf(activeKey.value);
    const nextIndex = (_length + activeIndex + (direction2 === "up" ? -1 : 1)) % _length;
    return enabledOptionKeys.value[nextIndex];
  };
  const scrollIntoView = (key) => {
    var _a2, _b;
    if (virtualListRef == null ? void 0 : virtualListRef.value) {
      virtualListRef.value.scrollTo({ key });
    }
    const optionInfo = optionInfoMap.get(key);
    const wrapperEle = (_a2 = dropdownRef == null ? void 0 : dropdownRef.value) == null ? void 0 : _a2.wrapperRef;
    const optionEle = (_b = optionRefs == null ? void 0 : optionRefs.value[key]) != null ? _b : optionInfo == null ? void 0 : optionInfo.ref;
    if (!wrapperEle || !optionEle) {
      return;
    }
    if (wrapperEle.scrollHeight === wrapperEle.offsetHeight) {
      return;
    }
    const optionRect = getRelativeRect(optionEle, wrapperEle);
    const wrapperScrollTop = wrapperEle.scrollTop;
    if (optionRect.top < 0) {
      wrapperEle.scrollTo(0, wrapperScrollTop + optionRect.top);
    } else if (optionRect.bottom < 0) {
      wrapperEle.scrollTo(0, wrapperScrollTop - optionRect.bottom);
    }
  };
  watch(popupVisible, (visible) => {
    var _a2;
    if (visible) {
      const current = valueKeys.value[valueKeys.value.length - 1];
      let _activeKey = ((_a2 = defaultActiveFirstOption == null ? void 0 : defaultActiveFirstOption.value) != null ? _a2 : true) ? enabledOptionKeys.value[0] : void 0;
      if (enabledOptionKeys.value.includes(current)) {
        _activeKey = current;
      }
      if (_activeKey !== activeKey.value) {
        activeKey.value = _activeKey;
      }
      nextTick(() => {
        if (activeKey.value) {
          scrollIntoView(activeKey.value);
        }
      });
    }
  });
  const handleKeyDown = getKeyDownHandler(/* @__PURE__ */ new Map([
    [
      KEYBOARD_KEY.ENTER,
      (e) => {
        if (!(loading == null ? void 0 : loading.value) && !e.isComposing) {
          if (popupVisible.value) {
            if (activeKey.value) {
              onSelect(activeKey.value, e);
              e.preventDefault();
            }
          } else if (enterToOpen) {
            onPopupVisibleChange(true);
            e.preventDefault();
          }
        }
      }
    ],
    [
      KEYBOARD_KEY.ESC,
      (e) => {
        if (popupVisible.value) {
          onPopupVisibleChange(false);
          e.preventDefault();
        }
      }
    ],
    [
      KEYBOARD_KEY.ARROW_DOWN,
      (e) => {
        if (popupVisible.value) {
          const next = getNextActiveKey("down");
          if (next) {
            activeKey.value = next;
            scrollIntoView(next);
          }
          e.preventDefault();
        }
      }
    ],
    [
      KEYBOARD_KEY.ARROW_UP,
      (e) => {
        if (popupVisible.value) {
          const next = getNextActiveKey("up");
          if (next) {
            activeKey.value = next;
            scrollIntoView(next);
          }
          e.preventDefault();
        }
      }
    ]
  ]));
  provide(selectInjectionKey, reactive({
    multiple,
    valueKey,
    inputValue,
    filterOption,
    component: component2,
    valueKeys,
    activeKey,
    setActiveKey,
    onSelect,
    getNextSlotOptionIndex,
    addSlotOptionInfo,
    removeSlotOptionInfo
  }));
  return {
    validOptions,
    optionInfoMap,
    validOptionInfos,
    enabledOptionKeys,
    activeKey,
    setActiveKey,
    addSlotOptionInfo,
    removeSlotOptionInfo,
    getNextActiveKey,
    scrollIntoView,
    handleKeyDown
  };
};
const useSize = ({
  dataKeys,
  contentRef,
  fixedSize,
  estimatedSize,
  buffer
}) => {
  const firstRangeAverageSize = ref(0);
  const sizeMap = /* @__PURE__ */ new Map();
  const total = computed(() => dataKeys.value.length);
  const start = ref(0);
  const end = computed(() => {
    const _end = start.value + buffer.value * 3;
    if (_end > total.value)
      return total.value;
    return _end;
  });
  const maxStart = computed(() => {
    const max2 = total.value - buffer.value * 3;
    if (max2 < 0)
      return 0;
    return max2;
  });
  const setStart = (index2) => {
    if (index2 < 0) {
      start.value = 0;
    } else if (index2 > maxStart.value) {
      start.value = maxStart.value;
    } else {
      start.value = index2;
    }
  };
  const isFixed = ref(fixedSize.value);
  const _estimatedSize = computed(() => {
    if (estimatedSize.value !== 30) {
      return estimatedSize.value;
    }
    return firstRangeAverageSize.value || estimatedSize.value;
  });
  const setItemSize = (key, size2) => {
    sizeMap.set(key, size2);
  };
  const getItemSize = (index2) => {
    var _a2;
    if (isFixed.value) {
      return _estimatedSize.value;
    }
    const _key = dataKeys.value[index2];
    return (_a2 = sizeMap.get(_key)) != null ? _a2 : _estimatedSize.value;
  };
  const hasItemSize = (key) => {
    return sizeMap.has(key);
  };
  onMounted(() => {
    const firstRangeTotalSize = Array.from(sizeMap.values()).reduce((pre, value2) => pre + value2, 0);
    if (firstRangeTotalSize > 0) {
      firstRangeAverageSize.value = firstRangeTotalSize / sizeMap.size;
    }
  });
  const getScrollOffset = (index2) => {
    if (isFixed.value) {
      return _estimatedSize.value * index2;
    }
    return getOffset(0, index2);
  };
  const getOffset = (start2, end2) => {
    let offset = 0;
    for (let i = start2; i < end2; i++) {
      offset += getItemSize(i);
    }
    return offset;
  };
  const frontPadding = computed(() => {
    if (isFixed.value) {
      return _estimatedSize.value * start.value;
    }
    return getOffset(0, start.value);
  });
  const getOffsetIndex = (scrollOffset) => {
    const isForward = scrollOffset >= frontPadding.value;
    let offset = Math.abs(scrollOffset - frontPadding.value);
    const _start = isForward ? start.value : start.value - 1;
    let offsetIndex = 0;
    while (offset > 0) {
      offset -= getItemSize(_start + offsetIndex);
      isForward ? offsetIndex++ : offsetIndex--;
    }
    return offsetIndex;
  };
  const getStartByScroll = (scrollOffset) => {
    const offsetIndex = getOffsetIndex(scrollOffset);
    const _start = start.value + offsetIndex - buffer.value;
    if (_start < 0)
      return 0;
    if (_start > maxStart.value)
      return maxStart.value;
    return _start;
  };
  const behindPadding = computed(() => {
    if (isFixed.value) {
      return _estimatedSize.value * (total.value - end.value);
    }
    return getOffset(end.value, total.value);
  });
  return {
    frontPadding,
    behindPadding,
    start,
    end,
    getStartByScroll,
    setItemSize,
    hasItemSize,
    setStart,
    getScrollOffset
  };
};
var VirtualListItem = defineComponent({
  name: "VirtualListItem",
  props: {
    hasItemSize: {
      type: Function,
      required: true
    },
    setItemSize: {
      type: Function,
      required: true
    }
  },
  setup(props, {
    slots
  }) {
    var _a2;
    const key = (_a2 = getCurrentInstance()) == null ? void 0 : _a2.vnode.key;
    const itemRef = ref();
    const setItemSize = () => {
      var _a22, _b, _c, _d;
      const ele = (_b = (_a22 = itemRef.value) == null ? void 0 : _a22.$el) != null ? _b : itemRef.value;
      const height = (_d = (_c = ele == null ? void 0 : ele.getBoundingClientRect) == null ? void 0 : _c.call(ele).height) != null ? _d : ele == null ? void 0 : ele.offsetHeight;
      if (height) {
        props.setItemSize(key, height);
      }
    };
    onMounted(() => setItemSize());
    onBeforeUnmount(() => setItemSize());
    return () => {
      var _a22;
      const child = getFirstComponent((_a22 = slots.default) == null ? void 0 : _a22.call(slots));
      if (child) {
        return cloneVNode(child, {
          ref: itemRef
        }, true);
      }
      return null;
    };
  }
});
var __defProp$5 = Object.defineProperty;
var __getOwnPropSymbols$5 = Object.getOwnPropertySymbols;
var __hasOwnProp$5 = Object.prototype.hasOwnProperty;
var __propIsEnum$5 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$5 = (obj, key, value2) => key in obj ? __defProp$5(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$5 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$5.call(b, prop))
      __defNormalProp$5(a, prop, b[prop]);
  if (__getOwnPropSymbols$5)
    for (var prop of __getOwnPropSymbols$5(b)) {
      if (__propIsEnum$5.call(b, prop))
        __defNormalProp$5(a, prop, b[prop]);
    }
  return a;
};
const _sfc_main$h = defineComponent({
  name: "VirtualList",
  components: { VirtualListItem },
  props: {
    height: {
      type: [Number, String],
      default: 200
    },
    data: {
      type: Array,
      default: () => []
    },
    threshold: {
      type: Number,
      default: 0
    },
    itemKey: {
      type: String,
      default: "key"
    },
    fixedSize: {
      type: Boolean,
      default: false
    },
    estimatedSize: {
      type: Number,
      default: 30
    },
    buffer: {
      type: Number,
      default: 10
    },
    component: {
      type: [String, Object],
      default: "div"
    },
    listAttrs: {
      type: Object
    },
    contentAttrs: {
      type: Object
    },
    paddingPosition: {
      type: String,
      default: "content"
    }
  },
  emits: {
    scroll: (ev) => true,
    reachBottom: (ev) => true
  },
  setup(props, { emit }) {
    const { data: data2, itemKey, fixedSize, estimatedSize, buffer, height } = toRefs(props);
    const prefixCls = getPrefixCls("virtual-list");
    const mergedComponent = computed(() => {
      if (isObject$1(props.component)) {
        return __spreadValues$5({
          container: "div",
          list: "div",
          content: "div"
        }, props.component);
      }
      return {
        container: props.component,
        list: "div",
        content: "div"
      };
    });
    const containerRef = ref();
    const contentRef = ref();
    const style = computed(() => {
      return {
        height: isNumber$2(height.value) ? `${height.value}px` : height.value,
        overflow: "auto"
      };
    });
    const dataKeys = computed(() => data2.value.map((item, index2) => {
      var _a2;
      return (_a2 = item[itemKey.value]) != null ? _a2 : index2;
    }));
    const {
      frontPadding,
      behindPadding,
      start,
      end,
      getStartByScroll,
      setItemSize,
      hasItemSize,
      setStart,
      getScrollOffset
    } = useSize({
      dataKeys,
      contentRef,
      fixedSize,
      estimatedSize,
      buffer
    });
    const currentList = computed(() => {
      if (props.threshold && data2.value.length <= props.threshold) {
        return data2.value;
      }
      return data2.value.slice(start.value, end.value);
    });
    const onScroll = (ev) => {
      const { scrollTop, scrollHeight, offsetHeight } = ev.target;
      const _start = getStartByScroll(scrollTop);
      if (_start !== start.value) {
        setStart(_start);
        nextTick(() => {
          scrollTo(scrollTop);
        });
      }
      emit("scroll", ev);
      const bottom = Math.floor(scrollHeight - (scrollTop + offsetHeight));
      if (bottom <= 0) {
        emit("reachBottom", ev);
      }
    };
    const scrollTo = (options) => {
      var _a2, _b;
      if (containerRef.value) {
        if (isNumber$2(options)) {
          containerRef.value.scrollTop = options;
        } else {
          const _index = (_b = options.index) != null ? _b : dataKeys.value.indexOf((_a2 = options.key) != null ? _a2 : "");
          setStart(_index - buffer.value);
          containerRef.value.scrollTop = getScrollOffset(_index);
          nextTick(() => {
            if (containerRef.value) {
              const _scrollTop = getScrollOffset(_index);
              if (_scrollTop !== containerRef.value.scrollTop) {
                containerRef.value.scrollTop = _scrollTop;
              }
            }
          });
        }
      }
    };
    return {
      prefixCls,
      containerRef,
      contentRef,
      frontPadding,
      currentList,
      behindPadding,
      onScroll,
      setItemSize,
      hasItemSize,
      start,
      scrollTo,
      style,
      mergedComponent
    };
  }
});
function _sfc_render$f(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_VirtualListItem = resolveComponent("VirtualListItem");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.mergedComponent.container), {
    ref: "containerRef",
    class: normalizeClass(_ctx.prefixCls),
    style: normalizeStyle(_ctx.style),
    onScroll: _ctx.onScroll
  }, {
    default: withCtx(() => [
      (openBlock(), createBlock(resolveDynamicComponent(_ctx.mergedComponent.list), mergeProps(_ctx.listAttrs, {
        style: _ctx.paddingPosition === "list" ? {
          paddingTop: `${_ctx.frontPadding}px`,
          paddingBottom: `${_ctx.behindPadding}px`
        } : {}
      }), {
        default: withCtx(() => [
          (openBlock(), createBlock(resolveDynamicComponent(_ctx.mergedComponent.content), mergeProps({ ref: "contentRef" }, _ctx.contentAttrs, {
            style: _ctx.paddingPosition === "content" ? {
              paddingTop: `${_ctx.frontPadding}px`,
              paddingBottom: `${_ctx.behindPadding}px`
            } : {}
          }), {
            default: withCtx(() => [
              (openBlock(true), createElementBlock(Fragment, null, renderList(_ctx.currentList, (item, index2) => {
                var _a2;
                return openBlock(), createBlock(_component_VirtualListItem, {
                  key: (_a2 = item[_ctx.itemKey]) != null ? _a2 : _ctx.start + index2,
                  "has-item-size": _ctx.hasItemSize,
                  "set-item-size": _ctx.setItemSize
                }, {
                  default: withCtx(() => [
                    renderSlot(_ctx.$slots, "item", {
                      item,
                      index: _ctx.start + index2
                    })
                  ]),
                  _: 2
                }, 1032, ["has-item-size", "set-item-size"]);
              }), 128))
            ]),
            _: 3
          }, 16, ["style"]))
        ]),
        _: 3
      }, 16, ["style"]))
    ]),
    _: 3
  }, 8, ["class", "style", "onScroll"]);
}
var VirtualList = /* @__PURE__ */ _export_sfc(_sfc_main$h, [["render", _sfc_render$f]]);
const useIndex = ({
  itemRef,
  selector,
  index: index2,
  parentClassName
}) => {
  const _index = ref(-1);
  const computedIndex = computed(() => {
    var _a2;
    return (_a2 = index2 == null ? void 0 : index2.value) != null ? _a2 : _index.value;
  });
  const parent = ref();
  const getParent = () => {
    var _a2, _b, _c;
    let parent2 = (_b = (_a2 = itemRef.value) == null ? void 0 : _a2.parentElement) != null ? _b : void 0;
    if (parentClassName) {
      while (parent2 && !parent2.className.includes(parentClassName)) {
        parent2 = (_c = parent2.parentElement) != null ? _c : void 0;
      }
    }
    return parent2;
  };
  const getIndex = () => {
    if (isUndefined$1(index2 == null ? void 0 : index2.value) && parent.value && itemRef.value) {
      const index22 = Array.from(parent.value.querySelectorAll(selector)).indexOf(itemRef.value);
      if (index22 !== _index.value) {
        _index.value = index22;
      }
    }
  };
  watch(itemRef, () => {
    if (itemRef.value && !parent.value) {
      parent.value = getParent();
    }
  });
  onMounted(() => {
    if (itemRef.value) {
      parent.value = getParent();
    }
    getIndex();
  });
  onUpdated(() => getIndex());
  return {
    computedIndex
  };
};
const _sfc_main$g = defineComponent({
  name: "IconMore",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value2) => {
        return ["butt", "round", "square"].includes(value2);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value2) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value2);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-more`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber$2(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
const _hoisted_1$6 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
const _hoisted_2$5 = /* @__PURE__ */ createBaseVNode("path", {
  d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z",
  fill: "currentColor",
  stroke: "none"
}, null, -1);
const _hoisted_3$5 = /* @__PURE__ */ createBaseVNode("path", { d: "M38 25v-2h2v2h-2ZM23 25v-2h2v2h-2ZM8 25v-2h2v2H8Z" }, null, -1);
const _hoisted_4$1 = [
  _hoisted_2$5,
  _hoisted_3$5
];
function _sfc_render$e(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_4$1, 14, _hoisted_1$6);
}
var _IconMore = /* @__PURE__ */ _export_sfc(_sfc_main$g, [["render", _sfc_render$e]]);
const IconMore = Object.assign(_IconMore, {
  install: (app, options) => {
    var _a2;
    const iconPrefix = (_a2 = options == null ? void 0 : options.iconPrefix) != null ? _a2 : "";
    app.component(iconPrefix + _IconMore.name, _IconMore);
  }
});
const useTrigger = ({
  popupVisible,
  defaultPopupVisible,
  emit
}) => {
  var _a2;
  const _popupVisible = ref((_a2 = defaultPopupVisible == null ? void 0 : defaultPopupVisible.value) != null ? _a2 : false);
  const computedPopupVisible = computed(() => {
    var _a22;
    return (_a22 = popupVisible == null ? void 0 : popupVisible.value) != null ? _a22 : _popupVisible.value;
  });
  const handlePopupVisibleChange = (visible) => {
    if (visible !== computedPopupVisible.value) {
      _popupVisible.value = visible;
      emit("update:popupVisible", visible);
      emit("popupVisibleChange", visible);
    }
  };
  watch(computedPopupVisible, (visible) => {
    if (_popupVisible.value !== visible) {
      _popupVisible.value = visible;
    }
  });
  return {
    computedPopupVisible,
    handlePopupVisibleChange
  };
};
const useInput = ({
  defaultValue,
  modelValue,
  emit,
  eventName = "input",
  updateEventName = "update:modelValue",
  eventHandlers
}) => {
  var _a2;
  const inputRef = ref();
  const _value = ref((_a2 = defaultValue == null ? void 0 : defaultValue.value) != null ? _a2 : "");
  const _focused = ref(false);
  const isComposition = ref(false);
  const compositionValue = ref("");
  let initialValue;
  const computedValue = computed(() => {
    var _a22;
    return (_a22 = modelValue == null ? void 0 : modelValue.value) != null ? _a22 : _value.value;
  });
  const updateValue = (value2, ev) => {
    _value.value = value2;
    emit(updateEventName, value2);
    emit(eventName, value2, ev);
  };
  const handleInput = (ev) => {
    const { value: value2 } = ev.target;
    if (!isComposition.value) {
      updateValue(value2, ev);
      nextTick(() => {
        if (inputRef.value && computedValue.value !== inputRef.value.value) {
          inputRef.value.value = computedValue.value;
        }
      });
    }
  };
  const handleChange = (ev) => {
    if (eventName === "input" && computedValue.value !== initialValue) {
      initialValue = computedValue.value;
      emit("change", computedValue.value, ev);
    }
  };
  const handleComposition = (ev) => {
    var _a22;
    const { value: value2 } = ev.target;
    if (ev.type === "compositionend") {
      isComposition.value = false;
      compositionValue.value = "";
      updateValue(value2, ev);
      nextTick(() => {
        if (inputRef.value && computedValue.value !== inputRef.value.value) {
          inputRef.value.value = computedValue.value;
        }
      });
    } else {
      isComposition.value = true;
      compositionValue.value = computedValue.value + ((_a22 = ev.data) != null ? _a22 : "");
    }
  };
  const handleFocus = (ev) => {
    var _a22, _b;
    _focused.value = true;
    initialValue = computedValue.value;
    emit("focus", ev);
    (_b = (_a22 = eventHandlers == null ? void 0 : eventHandlers.value) == null ? void 0 : _a22.onFocus) == null ? void 0 : _b.call(_a22, ev);
  };
  const handleBlur = (ev) => {
    var _a22, _b;
    _focused.value = false;
    emit("blur", ev);
    (_b = (_a22 = eventHandlers == null ? void 0 : eventHandlers.value) == null ? void 0 : _a22.onBlur) == null ? void 0 : _b.call(_a22, ev);
    handleChange(ev);
  };
  const handleKeyDown = (ev) => {
    const keyCode = ev.key || ev.code;
    if (!isComposition.value && keyCode === Enter.key) {
      emit("pressEnter", ev);
      handleChange(ev);
    }
  };
  const handleMousedown = (ev) => {
    if (inputRef.value && ev.target !== inputRef.value) {
      ev.preventDefault();
      inputRef.value.focus();
    }
  };
  watch(computedValue, (value2) => {
    if (inputRef.value && value2 !== inputRef.value.value) {
      inputRef.value.value = value2;
    }
  });
  return {
    inputRef,
    _value,
    _focused,
    isComposition,
    compositionValue,
    computedValue,
    handleInput,
    handleComposition,
    handleFocus,
    handleBlur,
    handleKeyDown,
    handleMousedown
  };
};
var InputLabel = defineComponent({
  name: "InputLabel",
  inheritAttrs: false,
  props: {
    modelValue: Object,
    inputValue: {
      type: String,
      default: ""
    },
    enabledInput: Boolean,
    formatLabel: Function,
    placeholder: String,
    retainInputValue: Boolean,
    disabled: Boolean,
    baseCls: String,
    size: String,
    error: Boolean,
    focused: Boolean,
    uninjectFormItemContext: Boolean
  },
  emits: ["update:inputValue", "inputValueChange", "focus", "blur"],
  setup(props, {
    attrs,
    emit,
    slots
  }) {
    var _a2;
    const {
      size: size2,
      disabled,
      error,
      inputValue,
      uninjectFormItemContext
    } = toRefs(props);
    const prefixCls = (_a2 = props.baseCls) != null ? _a2 : getPrefixCls("input-label");
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError,
      eventHandlers
    } = useFormItem({
      size: size2,
      disabled,
      error,
      uninject: uninjectFormItemContext == null ? void 0 : uninjectFormItemContext.value
    });
    const {
      mergedSize
    } = useSize$1(_mergedSize);
    const {
      inputRef,
      _focused,
      computedValue: computedInputValue,
      handleInput,
      handleComposition,
      handleFocus,
      handleBlur,
      handleMousedown
    } = useInput({
      modelValue: inputValue,
      emit,
      eventName: "inputValueChange",
      updateEventName: "update:inputValue",
      eventHandlers
    });
    const mergedFocused = computed(() => {
      var _a22;
      return (_a22 = props.focused) != null ? _a22 : _focused.value;
    });
    const showInput = computed(() => props.enabledInput && _focused.value || !props.modelValue);
    const formatLabel = () => {
      var _a22, _b;
      if (props.modelValue) {
        return (_b = (_a22 = props.formatLabel) == null ? void 0 : _a22.call(props, props.modelValue)) != null ? _b : props.modelValue.label;
      }
      return "";
    };
    const mergedPlaceholder = computed(() => {
      if (props.enabledInput && props.modelValue) {
        return formatLabel();
      }
      return props.placeholder;
    });
    const renderLabel = () => {
      var _a22, _b;
      if (props.modelValue) {
        return (_b = (_a22 = slots.default) == null ? void 0 : _a22.call(slots, {
          data: props.modelValue
        })) != null ? _b : formatLabel();
      }
      return null;
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-search`]: props.enabledInput,
      [`${prefixCls}-focus`]: mergedFocused.value,
      [`${prefixCls}-disabled`]: mergedDisabled.value,
      [`${prefixCls}-error`]: mergedError.value
    }]);
    const wrapperAttrs = computed(() => omit$2(attrs, INPUT_EVENTS));
    const inputAttrs = computed(() => pick$2(attrs, INPUT_EVENTS));
    const render = () => createVNode("span", mergeProps(wrapperAttrs.value, {
      "class": cls.value,
      "title": formatLabel(),
      "onMousedown": handleMousedown
    }), [slots.prefix && createVNode("span", {
      "class": `${prefixCls}-prefix`
    }, [slots.prefix()]), createVNode("input", mergeProps(inputAttrs.value, {
      "ref": inputRef,
      "class": [`${prefixCls}-input`, {
        [`${prefixCls}-input-hidden`]: !showInput.value
      }],
      "value": computedInputValue.value,
      "readonly": !props.enabledInput,
      "placeholder": mergedPlaceholder.value,
      "disabled": mergedDisabled.value,
      "onInput": handleInput,
      "onFocus": handleFocus,
      "onBlur": handleBlur,
      "onCompositionstart": handleComposition,
      "onCompositionupdate": handleComposition,
      "onCompositionend": handleComposition
    }), null), createVNode("span", {
      "class": [`${prefixCls}-value`, {
        [`${prefixCls}-value-hidden`]: showInput.value
      }]
    }, [renderLabel()]), slots.suffix && createVNode("span", {
      "class": `${prefixCls}-suffix`
    }, [slots.suffix()])]);
    return {
      inputRef,
      render
    };
  },
  methods: {
    focus() {
      var _a2;
      (_a2 = this.inputRef) == null ? void 0 : _a2.focus();
    },
    blur() {
      var _a2;
      (_a2 = this.inputRef) == null ? void 0 : _a2.blur();
    }
  },
  render() {
    return this.render();
  }
});
var __defProp$4 = Object.defineProperty;
var __getOwnPropSymbols$4 = Object.getOwnPropertySymbols;
var __hasOwnProp$4 = Object.prototype.hasOwnProperty;
var __propIsEnum$4 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$4 = (obj, key, value2) => key in obj ? __defProp$4(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$4 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$4.call(b, prop))
      __defNormalProp$4(a, prop, b[prop]);
  if (__getOwnPropSymbols$4)
    for (var prop of __getOwnPropSymbols$4(b)) {
      if (__propIsEnum$4.call(b, prop))
        __defNormalProp$4(a, prop, b[prop]);
    }
  return a;
};
const getValueData = (value2, fieldNames) => {
  const result = [];
  for (const item of value2) {
    if (isObject$1(item)) {
      result.push({
        raw: item,
        value: item[fieldNames.value],
        label: item[fieldNames.label],
        closable: item[fieldNames.closable],
        tagProps: item[fieldNames.tagProps]
      });
    } else if (value2 || isNumber$2(value2)) {
      const raw = {
        value: item,
        label: String(item),
        closable: true
      };
      result.push(__spreadValues$4({
        raw
      }, raw));
    }
  }
  return result;
};
var __defProp$3 = Object.defineProperty;
var __getOwnPropSymbols$3 = Object.getOwnPropertySymbols;
var __hasOwnProp$3 = Object.prototype.hasOwnProperty;
var __propIsEnum$3 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$3 = (obj, key, value2) => key in obj ? __defProp$3(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$3 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$3.call(b, prop))
      __defNormalProp$3(a, prop, b[prop]);
  if (__getOwnPropSymbols$3)
    for (var prop of __getOwnPropSymbols$3(b)) {
      if (__propIsEnum$3.call(b, prop))
        __defNormalProp$3(a, prop, b[prop]);
    }
  return a;
};
const DEFAULT_FIELD_NAMES$1 = {
  value: "value",
  label: "label",
  closable: "closable",
  tagProps: "tagProps"
};
var _InputTag = defineComponent({
  name: "InputTag",
  inheritAttrs: false,
  props: {
    modelValue: {
      type: Array
    },
    defaultValue: {
      type: Array,
      default: () => []
    },
    inputValue: String,
    defaultInputValue: {
      type: String,
      default: ""
    },
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    readonly: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    retainInputValue: {
      type: [Boolean, Object],
      default: false
    },
    formatTag: {
      type: Function
    },
    uniqueValue: {
      type: Boolean,
      default: false
    },
    fieldNames: {
      type: Object
    },
    baseCls: String,
    focused: Boolean,
    disabledInput: Boolean,
    uninjectFormItemContext: Boolean
  },
  emits: {
    "update:modelValue": (value2) => true,
    "update:inputValue": (inputValue) => true,
    "change": (value2, ev) => true,
    "inputValueChange": (inputValue, ev) => true,
    "pressEnter": (inputValue, ev) => true,
    "remove": (removed, ev) => true,
    "clear": (ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true
  },
  setup(props, {
    emit,
    slots,
    attrs
  }) {
    const {
      size: size2,
      disabled,
      error,
      uninjectFormItemContext,
      modelValue
    } = toRefs(props);
    const prefixCls = props.baseCls || getPrefixCls("input-tag");
    const inputRef = ref();
    const mirrorRef = ref();
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      mergedError,
      feedback,
      eventHandlers
    } = useFormItem({
      size: size2,
      disabled,
      error,
      uninject: uninjectFormItemContext == null ? void 0 : uninjectFormItemContext.value
    });
    const {
      mergedSize
    } = useSize$1(_mergedSize);
    const mergedFieldNames = computed(() => __spreadValues$3(__spreadValues$3({}, DEFAULT_FIELD_NAMES$1), props.fieldNames));
    const _focused = ref(false);
    const _value = ref(props.defaultValue);
    const _inputValue = ref(props.defaultInputValue);
    const isComposition = ref(false);
    const compositionValue = ref("");
    const retainInputValue = computed(() => {
      if (isObject$1(props.retainInputValue)) {
        return __spreadValues$3({
          create: false,
          blur: false
        }, props.retainInputValue);
      }
      return {
        create: props.retainInputValue,
        blur: props.retainInputValue
      };
    });
    const inputStyle = reactive({
      width: "12px"
    });
    const mergedFocused = computed(() => props.focused || _focused.value);
    const updateInputValue = (value2, ev) => {
      _inputValue.value = value2;
      emit("update:inputValue", value2);
      emit("inputValueChange", value2, ev);
    };
    const handleComposition = (ev) => {
      var _a2;
      const {
        value: value2
      } = ev.target;
      if (ev.type === "compositionend") {
        isComposition.value = false;
        compositionValue.value = "";
        updateInputValue(value2, ev);
        nextTick(() => {
          if (inputRef.value && computedInputValue.value !== inputRef.value.value) {
            inputRef.value.value = computedInputValue.value;
          }
        });
      } else {
        isComposition.value = true;
        compositionValue.value = computedInputValue.value + ((_a2 = ev.data) != null ? _a2 : "");
      }
    };
    const computedValue = computed(() => {
      var _a2;
      return (_a2 = props.modelValue) != null ? _a2 : _value.value;
    });
    const computedInputValue = computed(() => {
      var _a2;
      return (_a2 = props.inputValue) != null ? _a2 : _inputValue.value;
    });
    watch(modelValue, (value2) => {
      if (isUndefined$1(value2) || isNull$1(value2)) {
        _value.value = [];
      }
    });
    const handleMousedown = (e) => {
      if (inputRef.value && e.target !== inputRef.value) {
        e.preventDefault();
        inputRef.value.focus();
      }
    };
    const handleInput = (ev) => {
      const {
        value: value2
      } = ev.target;
      if (!isComposition.value) {
        updateInputValue(value2, ev);
        nextTick(() => {
          if (inputRef.value && computedInputValue.value !== inputRef.value.value) {
            inputRef.value.value = computedInputValue.value;
          }
        });
      }
    };
    const valueData = computed(() => getValueData(computedValue.value, mergedFieldNames.value));
    const tags2 = computed(() => {
      if (props.maxTagCount > 0) {
        const invisibleTags = valueData.value.length - props.maxTagCount;
        if (invisibleTags > 0) {
          const result = valueData.value.slice(0, props.maxTagCount);
          const raw = {
            value: "__arco__more",
            label: `+${invisibleTags}...`,
            closable: false
          };
          result.push(__spreadValues$3({
            raw
          }, raw));
          return result;
        }
      }
      return valueData.value;
    });
    const updateValue = (value2, ev) => {
      var _a2, _b;
      _value.value = value2;
      emit("update:modelValue", value2);
      emit("change", value2, ev);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onChange) == null ? void 0 : _b.call(_a2, ev);
    };
    const handleRemove = (value2, index2, e) => {
      var _a2;
      const newValue = (_a2 = computedValue.value) == null ? void 0 : _a2.filter((_, i) => i !== index2);
      updateValue(newValue, e);
      emit("remove", value2, e);
    };
    const handleClear = (e) => {
      const newValue = [];
      updateValue(newValue, e);
      emit("clear", e);
    };
    const showClearBtn = computed(() => !mergedDisabled.value && !props.readonly && props.allowClear && Boolean(computedValue.value.length));
    const handlePressEnter = (e) => {
      var _a2;
      if (computedInputValue.value) {
        e.preventDefault();
        if (props.uniqueValue && ((_a2 = computedValue.value) == null ? void 0 : _a2.includes(computedInputValue.value))) {
          emit("pressEnter", computedInputValue.value, e);
          return;
        }
        const newValue = computedValue.value.concat(computedInputValue.value);
        updateValue(newValue, e);
        emit("pressEnter", computedInputValue.value, e);
        if (!retainInputValue.value.create) {
          updateInputValue("", e);
        }
      }
    };
    const handleFocus = (ev) => {
      var _a2, _b;
      _focused.value = true;
      emit("focus", ev);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onFocus) == null ? void 0 : _b.call(_a2, ev);
    };
    const handleBlur = (ev) => {
      var _a2, _b;
      _focused.value = false;
      if (!retainInputValue.value.blur && computedInputValue.value) {
        updateInputValue("", ev);
      }
      emit("blur", ev);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onBlur) == null ? void 0 : _b.call(_a2, ev);
    };
    const getLastClosableIndex = () => {
      for (let i = valueData.value.length - 1; i >= 0; i--) {
        if (valueData.value[i].closable) {
          return i;
        }
      }
      return -1;
    };
    const handleKeyDown = (e) => {
      if (mergedDisabled.value || props.readonly) {
        return;
      }
      const keyCode = e.key || e.code;
      if (!isComposition.value && computedInputValue.value && keyCode === Enter.key) {
        handlePressEnter(e);
      }
      if (!isComposition.value && tags2.value.length > 0 && !computedInputValue.value && keyCode === Backspace.key) {
        const lastIndex = getLastClosableIndex();
        if (lastIndex >= 0) {
          handleRemove(valueData.value[lastIndex].value, lastIndex, e);
        }
      }
    };
    const setInputWidth = (width) => {
      if (width > 12) {
        inputStyle.width = `${width}px`;
      } else {
        inputStyle.width = "12px";
      }
    };
    onMounted(() => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    });
    const handleResize = () => {
      if (mirrorRef.value) {
        setInputWidth(mirrorRef.value.offsetWidth);
      }
    };
    watch(computedInputValue, (value2) => {
      if (inputRef.value && !isComposition.value && value2 !== inputRef.value.value) {
        inputRef.value.value = value2;
      }
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-disabled`]: mergedDisabled.value,
      [`${prefixCls}-disabled-input`]: props.disabledInput,
      [`${prefixCls}-error`]: mergedError.value,
      [`${prefixCls}-focus`]: mergedFocused.value,
      [`${prefixCls}-readonly`]: props.readonly,
      [`${prefixCls}-has-tag`]: tags2.value.length > 0,
      [`${prefixCls}-has-prefix`]: Boolean(slots.prefix),
      [`${prefixCls}-has-suffix`]: Boolean(slots.suffix) || showClearBtn.value || feedback.value,
      [`${prefixCls}-has-placeholder`]: !computedValue.value.length
    }]);
    const wrapperAttrs = computed(() => omit$2(attrs, INPUT_EVENTS));
    const inputAttrs = computed(() => pick$2(attrs, INPUT_EVENTS));
    const render = () => {
      var _a2;
      return createVNode("span", mergeProps({
        "class": cls.value,
        "onMousedown": handleMousedown
      }, wrapperAttrs.value), [createVNode(ResizeObserver$2, {
        "onResize": handleResize
      }, {
        default: () => [createVNode("span", {
          "ref": mirrorRef,
          "class": `${prefixCls}-mirror`
        }, [tags2.value.length > 0 ? compositionValue.value || computedInputValue.value : compositionValue.value || computedInputValue.value || props.placeholder])]
      }), slots.prefix && createVNode("span", {
        "class": `${prefixCls}-prefix`
      }, [slots.prefix()]), createVNode(TransitionGroup, {
        "tag": "span",
        "name": "input-tag-zoom",
        "class": `${prefixCls}-inner`
      }, {
        default: () => [tags2.value.map((item, index2) => createVNode(Tag, mergeProps({
          "key": `tag-${item.value}`,
          "class": `${prefixCls}-tag`,
          "closable": !mergedDisabled.value && !props.readonly && item.closable,
          "visible": true
        }, item.tagProps, {
          "onClose": (ev) => handleRemove(item.value, index2, ev)
        }), {
          default: () => {
            var _a22, _b, _c, _d;
            return [(_d = (_c = (_a22 = slots.tag) == null ? void 0 : _a22.call(slots, {
              data: item.raw
            })) != null ? _c : (_b = props.formatTag) == null ? void 0 : _b.call(props, item.raw)) != null ? _d : item.label];
          }
        })), createVNode("input", mergeProps(inputAttrs.value, {
          "ref": inputRef,
          "key": "input-tag-input",
          "class": `${prefixCls}-input`,
          "style": inputStyle,
          "placeholder": tags2.value.length === 0 ? props.placeholder : void 0,
          "disabled": mergedDisabled.value,
          "readonly": props.readonly || props.disabledInput,
          "onInput": handleInput,
          "onKeydown": handleKeyDown,
          "onFocus": handleFocus,
          "onBlur": handleBlur,
          "onCompositionstart": handleComposition,
          "onCompositionupdate": handleComposition,
          "onCompositionend": handleComposition
        }), null)]
      }), showClearBtn.value && createVNode(IconHover, {
        "class": `${prefixCls}-clear-btn`,
        "onClick": handleClear,
        "onMousedown": (e) => e.stopPropagation()
      }, {
        default: () => [createVNode(IconClose, null, null)]
      }), (slots.suffix || Boolean(feedback.value)) && createVNode("span", {
        "class": `${prefixCls}-suffix`
      }, [(_a2 = slots.suffix) == null ? void 0 : _a2.call(slots), Boolean(feedback.value) && createVNode(FeedbackIcon, {
        "type": feedback.value
      }, null)])]);
    };
    return {
      inputRef,
      render
    };
  },
  methods: {
    focus() {
      var _a2;
      (_a2 = this.inputRef) == null ? void 0 : _a2.focus();
    },
    blur() {
      var _a2;
      (_a2 = this.inputRef) == null ? void 0 : _a2.blur();
    }
  },
  render() {
    return this.render();
  }
});
const InputTag = Object.assign(_InputTag, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _InputTag.name, _InputTag);
  }
});
var SelectView = defineComponent({
  name: "SelectView",
  props: {
    modelValue: {
      type: Array,
      required: true
    },
    inputValue: String,
    placeholder: String,
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    loading: {
      type: Boolean,
      default: false
    },
    opened: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    bordered: {
      type: Boolean,
      default: true
    },
    multiple: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    allowCreate: {
      type: Boolean,
      default: false
    },
    allowSearch: {
      type: Boolean,
      default: (props) => isArray$2(props.modelValue)
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    retainInputValue: {
      type: Boolean,
      default: false
    }
  },
  emits: ["remove", "clear", "focus", "blur"],
  setup(props, {
    emit,
    slots
  }) {
    const {
      size: size2,
      disabled,
      error
    } = toRefs(props);
    const prefixCls = getPrefixCls("select-view");
    const {
      feedback,
      eventHandlers,
      mergedDisabled,
      mergedSize: _mergedSize,
      mergedError
    } = useFormItem({
      size: size2,
      disabled,
      error
    });
    const {
      mergedSize
    } = useSize$1(_mergedSize);
    const {
      opened
    } = toRefs(props);
    const componentRef = ref();
    const inputRef = computed(() => {
      var _a2;
      return (_a2 = componentRef.value) == null ? void 0 : _a2.inputRef;
    });
    const isEmptyValue = computed(() => props.modelValue.length === 0);
    const enabledInput = computed(() => props.allowSearch || props.allowCreate);
    const showClearBtn = computed(() => props.allowClear && !props.disabled && !isEmptyValue.value);
    const handleFocus = (ev) => {
      var _a2, _b;
      emit("focus", ev);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onFocus) == null ? void 0 : _b.call(_a2, ev);
    };
    const handleBlur = (ev) => {
      var _a2, _b;
      emit("blur", ev);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onBlur) == null ? void 0 : _b.call(_a2, ev);
    };
    const handleRemove = (tag) => {
      emit("remove", tag);
    };
    const handleClear = (ev) => {
      emit("clear", ev);
    };
    const renderIcon = () => {
      var _a2, _b, _c, _d;
      if (props.loading) {
        return (_b = (_a2 = slots["loading-icon"]) == null ? void 0 : _a2.call(slots)) != null ? _b : createVNode(IconLoading, null, null);
      }
      if (props.allowSearch && props.opened) {
        return (_d = (_c = slots["search-icon"]) == null ? void 0 : _c.call(slots)) != null ? _d : createVNode(IconSearch, null, null);
      }
      if (slots["arrow-icon"]) {
        return slots["arrow-icon"]();
      }
      return createVNode(IconDown, {
        "class": `${prefixCls}-arrow-icon`
      }, null);
    };
    const renderSuffix = () => createVNode(Fragment, null, [showClearBtn.value && createVNode(IconHover, {
      "class": `${prefixCls}-clear-btn`,
      "onClick": handleClear,
      "onMousedown": (ev) => ev.stopPropagation()
    }, {
      default: () => [createVNode(IconClose, null, null)]
    }), createVNode("span", {
      "class": `${prefixCls}-icon`
    }, [renderIcon()]), Boolean(feedback.value) && createVNode(FeedbackIcon, {
      "type": feedback.value
    }, null)]);
    watch(opened, (opened2) => {
      if (!opened2 && inputRef.value && inputRef.value.isSameNode(document.activeElement)) {
        inputRef.value.blur();
      }
    });
    const cls = computed(() => [`${prefixCls}-${props.multiple ? "multiple" : "single"}`, {
      [`${prefixCls}-opened`]: props.opened,
      [`${prefixCls}-borderless`]: !props.bordered
    }]);
    const render = () => {
      if (props.multiple) {
        return createVNode(InputTag, {
          "ref": componentRef,
          "baseCls": prefixCls,
          "class": cls.value,
          "modelValue": props.modelValue,
          "inputValue": props.inputValue,
          "focused": props.opened,
          "placeholder": props.placeholder,
          "disabled": mergedDisabled.value,
          "size": mergedSize.value,
          "error": mergedError.value,
          "maxTagCount": props.maxTagCount,
          "disabledInput": !props.allowSearch && !props.allowCreate,
          "retainInputValue": true,
          "uninjectFormItemContext": true,
          "onRemove": handleRemove,
          "onFocus": handleFocus,
          "onBlur": handleBlur
        }, {
          prefix: slots.prefix,
          suffix: renderSuffix,
          tag: slots.label
        });
      }
      return createVNode(InputLabel, {
        "ref": componentRef,
        "baseCls": prefixCls,
        "class": cls.value,
        "modelValue": props.modelValue[0],
        "inputValue": props.inputValue,
        "focused": props.opened,
        "placeholder": props.placeholder,
        "disabled": mergedDisabled.value,
        "size": mergedSize.value,
        "error": mergedError.value,
        "enabledInput": enabledInput.value,
        "uninjectFormItemContext": true,
        "onFocus": handleFocus,
        "onBlur": handleBlur
      }, {
        default: slots.label,
        prefix: slots.prefix,
        suffix: renderSuffix
      });
    };
    return {
      inputRef,
      handleFocus,
      handleBlur,
      render
    };
  },
  methods: {
    focus() {
      if (this.inputRef) {
        this.inputRef.focus();
      }
    },
    blur() {
      if (this.inputRef) {
        this.inputRef.blur();
      }
    }
  },
  render() {
    return this.render();
  }
});
const _sfc_main$f = defineComponent({
  name: "Optgroup",
  props: {
    label: {
      type: String
    }
  },
  setup() {
    const prefixCls = getPrefixCls("select-group");
    return {
      prefixCls
    };
  }
});
function _sfc_render$d(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock(Fragment, null, [
    createBaseVNode("li", {
      class: normalizeClass(`${_ctx.prefixCls}-title`)
    }, [
      renderSlot(_ctx.$slots, "label", {}, () => [
        createTextVNode(toDisplayString(_ctx.label), 1)
      ])
    ], 2),
    renderSlot(_ctx.$slots, "default")
  ], 64);
}
var Optgroup = /* @__PURE__ */ _export_sfc(_sfc_main$f, [["render", _sfc_render$d]]);
const target = typeof window === "undefined" ? global : window;
function debounce$2(callback, delay) {
  let timer2 = 0;
  return (...args) => {
    if (timer2) {
      target.clearTimeout(timer2);
    }
    timer2 = target.setTimeout(() => {
      timer2 = 0;
      callback(...args);
    }, delay);
  };
}
var __defProp$2 = Object.defineProperty;
var __defProps$1 = Object.defineProperties;
var __getOwnPropDescs$1 = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$2 = Object.getOwnPropertySymbols;
var __hasOwnProp$2 = Object.prototype.hasOwnProperty;
var __propIsEnum$2 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$2 = (obj, key, value2) => key in obj ? __defProp$2(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$2 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$2.call(b, prop))
      __defNormalProp$2(a, prop, b[prop]);
  if (__getOwnPropSymbols$2)
    for (var prop of __getOwnPropSymbols$2(b)) {
      if (__propIsEnum$2.call(b, prop))
        __defNormalProp$2(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps$1 = (a, b) => __defProps$1(a, __getOwnPropDescs$1(b));
function _isSlot$1(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
const DEFAULT_FIELD_NAMES = {
  value: "value",
  label: "label",
  disabled: "disabled",
  tagProps: "tagProps",
  render: "render"
};
var _Select = defineComponent({
  name: "Select",
  components: {
    Trigger,
    SelectView
  },
  inheritAttrs: false,
  props: {
    multiple: {
      type: Boolean,
      default: false
    },
    modelValue: {
      type: [String, Number, Boolean, Object, Array],
      default: void 0
    },
    defaultValue: {
      type: [String, Number, Boolean, Object, Array],
      default: (props) => isUndefined$1(props.multiple) ? "" : []
    },
    inputValue: {
      type: String
    },
    defaultInputValue: {
      type: String,
      default: ""
    },
    size: {
      type: String
    },
    placeholder: String,
    loading: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    allowSearch: {
      type: [Boolean, Object],
      default: (props) => Boolean(props.multiple)
    },
    allowCreate: {
      type: Boolean,
      default: false
    },
    maxTagCount: {
      type: Number,
      default: 0
    },
    popupContainer: {
      type: [String, Object]
    },
    bordered: {
      type: Boolean,
      default: true
    },
    defaultActiveFirstOption: {
      type: Boolean,
      default: true
    },
    popupVisible: {
      type: Boolean,
      default: void 0
    },
    defaultPopupVisible: {
      type: Boolean,
      default: false
    },
    unmountOnClose: {
      type: Boolean,
      default: false
    },
    filterOption: {
      type: [Boolean, Function],
      default: true
    },
    options: {
      type: Array,
      default: () => []
    },
    virtualListProps: {
      type: Object
    },
    triggerProps: {
      type: Object
    },
    formatLabel: {
      type: Function
    },
    fallbackOption: {
      type: [Boolean, Function],
      default: true
    },
    showExtraOptions: {
      type: Boolean,
      default: true
    },
    valueKey: {
      type: String,
      default: "value"
    },
    searchDelay: {
      type: Number,
      default: 500
    },
    limit: {
      type: Number,
      default: 0
    },
    fieldNames: {
      type: Object
    },
    scrollbar: {
      type: [Boolean, Object],
      default: true
    },
    showHeaderOnEmpty: {
      type: Boolean,
      default: false
    },
    showFooterOnEmpty: {
      type: Boolean,
      default: false
    }
  },
  emits: {
    "update:modelValue": (value2) => true,
    "update:inputValue": (inputValue) => true,
    "update:popupVisible": (visible) => true,
    "change": (value2) => true,
    "inputValueChange": (inputValue) => true,
    "popupVisibleChange": (visible) => true,
    "clear": (ev) => true,
    "remove": (removed) => true,
    "search": (inputValue) => true,
    "dropdownScroll": (ev) => true,
    "dropdownReachBottom": (ev) => true,
    "exceedLimit": (value2, ev) => true
  },
  setup(props, {
    slots,
    emit,
    attrs
  }) {
    const {
      size: size2,
      disabled,
      error,
      options,
      filterOption,
      valueKey,
      multiple,
      popupVisible,
      showExtraOptions,
      modelValue,
      fieldNames,
      loading,
      defaultActiveFirstOption
    } = toRefs(props);
    const prefixCls = getPrefixCls("select");
    const {
      mergedSize,
      mergedDisabled,
      mergedError,
      eventHandlers
    } = useFormItem({
      size: size2,
      disabled,
      error
    });
    const component2 = computed(() => props.virtualListProps ? "div" : "li");
    const retainInputValue = computed(() => isObject$1(props.allowSearch) && Boolean(props.allowSearch.retainInputValue));
    computed(() => {
      if (isFunction$1(props.formatLabel)) {
        return (data2) => {
          const optionInfo = optionInfoMap.get(data2.value);
          return props.formatLabel(optionInfo);
        };
      }
      return void 0;
    });
    const dropdownRef = ref();
    const optionRefs = ref({});
    const virtualListRef = ref();
    const {
      computedPopupVisible,
      handlePopupVisibleChange
    } = useTrigger({
      popupVisible,
      emit
    });
    const _value = ref(props.defaultValue);
    const computedValueObjects = computed(() => {
      var _a2;
      const mergedValue = (_a2 = props.modelValue) != null ? _a2 : _value.value;
      const valueArray = isArray$2(mergedValue) ? mergedValue : mergedValue || isNumber$2(mergedValue) || isString$1(mergedValue) || isBoolean$1(mergedValue) ? [mergedValue] : [];
      return valueArray.map((value2) => ({
        value: value2,
        key: getKeyFromValue(value2, props.valueKey)
      }));
    });
    watch(modelValue, (value2) => {
      if (isUndefined$1(value2) || isNull$1(value2)) {
        _value.value = multiple.value ? [] : value2;
      }
    });
    const computedValueKeys = computed(() => computedValueObjects.value.map((obj) => obj.key));
    const mergedFieldNames = computed(() => __spreadValues$2(__spreadValues$2({}, DEFAULT_FIELD_NAMES), fieldNames == null ? void 0 : fieldNames.value));
    const _selectedOption = ref();
    const getRawOptionFromValueKeys = (valueKeys) => {
      const optionMap = {};
      valueKeys.forEach((key) => {
        optionMap[key] = optionInfoMap.get(key);
      });
      return optionMap;
    };
    const updateSelectedOption = (valueKeys) => {
      _selectedOption.value = getRawOptionFromValueKeys(valueKeys);
    };
    const getFallBackOption = (value2) => {
      if (isFunction$1(props.fallbackOption)) {
        return props.fallbackOption(value2);
      }
      return {
        [mergedFieldNames.value.value]: value2,
        [mergedFieldNames.value.label]: String(isObject$1(value2) ? value2[valueKey == null ? void 0 : valueKey.value] : value2)
      };
    };
    const getExtraValueData = () => {
      const valueArray = [];
      const keyArray = [];
      if (props.allowCreate || props.fallbackOption) {
        for (const item of computedValueObjects.value) {
          if (!keyArray.includes(item.key) && item.value !== "") {
            const optionInfo = optionInfoMap.get(item.key);
            if (!optionInfo || optionInfo.origin === "extraOptions") {
              valueArray.push(item);
              keyArray.push(item.key);
            }
          }
        }
      }
      if (props.allowCreate && computedInputValue.value) {
        const key = getKeyFromValue(computedInputValue.value);
        if (!keyArray.includes(key)) {
          const optionInfo = optionInfoMap.get(key);
          if (!optionInfo || optionInfo.origin === "extraOptions") {
            valueArray.push({
              value: computedInputValue.value,
              key
            });
          }
        }
      }
      return valueArray;
    };
    const extraValueObjects = ref([]);
    const extraOptions = computed(() => extraValueObjects.value.map((obj) => {
      var _a2;
      let optionInfo = getFallBackOption(obj.value);
      const extraOptionRawInfo = (_a2 = _selectedOption.value) == null ? void 0 : _a2[obj.key];
      if (!isUndefined$1(extraOptionRawInfo) && !isEmptyObject(extraOptionRawInfo)) {
        optionInfo = __spreadValues$2(__spreadValues$2({}, optionInfo), extraOptionRawInfo);
      }
      return optionInfo;
    }));
    nextTick(() => {
      watchEffect(() => {
        var _a2;
        const valueData = getExtraValueData();
        if (valueData.length !== extraValueObjects.value.length) {
          extraValueObjects.value = valueData;
        } else if (valueData.length > 0) {
          for (let i = 0; i < valueData.length; i++) {
            if (valueData[i].key !== ((_a2 = extraValueObjects.value[i]) == null ? void 0 : _a2.key)) {
              extraValueObjects.value = valueData;
              break;
            }
          }
        }
      });
    });
    const _inputValue = ref("");
    const computedInputValue = computed(() => {
      var _a2;
      return (_a2 = props.inputValue) != null ? _a2 : _inputValue.value;
    });
    watch(computedPopupVisible, (visible) => {
      if (!visible && !retainInputValue.value && computedInputValue.value) {
        updateInputValue("");
      }
    });
    const getValueFromValueKeys = (valueKeys) => {
      var _a2, _b;
      if (!props.multiple) {
        return (_b = (_a2 = optionInfoMap.get(valueKeys[0])) == null ? void 0 : _a2.value) != null ? _b : hasEmptyStringKey(optionInfoMap) ? void 0 : "";
      }
      return valueKeys.map((key) => {
        var _a22, _b2;
        return (_b2 = (_a22 = optionInfoMap.get(key)) == null ? void 0 : _a22.value) != null ? _b2 : "";
      });
    };
    const updateValue = (valueKeys) => {
      var _a2, _b;
      const value2 = getValueFromValueKeys(valueKeys);
      _value.value = value2;
      emit("update:modelValue", value2);
      emit("change", value2);
      (_b = (_a2 = eventHandlers.value) == null ? void 0 : _a2.onChange) == null ? void 0 : _b.call(_a2);
      updateSelectedOption(valueKeys);
    };
    const updateInputValue = (inputValue) => {
      _inputValue.value = inputValue;
      emit("update:inputValue", inputValue);
      emit("inputValueChange", inputValue);
    };
    const handleSelect = (key, ev) => {
      if (props.multiple) {
        if (!computedValueKeys.value.includes(key)) {
          if (enabledOptionKeys.value.includes(key)) {
            if (props.limit > 0 && computedValueKeys.value.length >= props.limit) {
              const info = optionInfoMap.get(key);
              emit("exceedLimit", info == null ? void 0 : info.value, ev);
            } else {
              const valueKeys = computedValueKeys.value.concat(key);
              updateValue(valueKeys);
            }
          }
        } else {
          const valueKeys = computedValueKeys.value.filter((_key) => _key !== key);
          updateValue(valueKeys);
        }
        if (!retainInputValue.value) {
          updateInputValue("");
        }
      } else {
        if (key !== computedValueKeys.value[0]) {
          updateValue([key]);
        }
        if (retainInputValue.value) {
          const optionInfo = optionInfoMap.get(key);
          if (optionInfo) {
            updateInputValue(optionInfo.label);
          }
        }
        handlePopupVisibleChange(false);
      }
    };
    const handleSearch = debounce$2((value2) => {
      emit("search", value2);
    }, props.searchDelay);
    const handleInputValueChange = (inputValue) => {
      if (inputValue !== computedInputValue.value) {
        if (!computedPopupVisible.value) {
          handlePopupVisibleChange(true);
        }
        updateInputValue(inputValue);
        if (props.allowSearch) {
          handleSearch(inputValue);
        }
      }
    };
    const handleRemove = (key) => {
      const optionInfo = optionInfoMap.get(key);
      const newKeys = computedValueKeys.value.filter((_key) => _key !== key);
      updateValue(newKeys);
      emit("remove", optionInfo == null ? void 0 : optionInfo.value);
    };
    const handleClear = (e) => {
      e == null ? void 0 : e.stopPropagation();
      const newKeys = computedValueKeys.value.filter((key) => {
        var _a2;
        return (_a2 = optionInfoMap.get(key)) == null ? void 0 : _a2.disabled;
      });
      updateValue(newKeys);
      updateInputValue("");
      emit("clear", e);
    };
    const handleDropdownScroll = (e) => {
      emit("dropdownScroll", e);
    };
    const handleDropdownReachBottom = (e) => {
      emit("dropdownReachBottom", e);
    };
    const {
      validOptions,
      optionInfoMap,
      validOptionInfos,
      enabledOptionKeys,
      handleKeyDown
    } = useSelect({
      multiple,
      options,
      extraOptions,
      inputValue: computedInputValue,
      filterOption,
      showExtraOptions,
      component: component2,
      valueKey,
      fieldNames,
      loading,
      popupVisible: computedPopupVisible,
      valueKeys: computedValueKeys,
      dropdownRef,
      optionRefs,
      virtualListRef,
      defaultActiveFirstOption,
      onSelect: handleSelect,
      onPopupVisibleChange: handlePopupVisibleChange
    });
    const selectViewValue = computed(() => {
      var _a2;
      const result = [];
      for (const item of computedValueObjects.value) {
        const optionInfo = optionInfoMap.get(item.key);
        if (optionInfo) {
          result.push(__spreadProps$1(__spreadValues$2({}, optionInfo), {
            value: item.key,
            label: (_a2 = optionInfo == null ? void 0 : optionInfo.label) != null ? _a2 : String(isObject$1(item.value) ? item.value[valueKey == null ? void 0 : valueKey.value] : item.value),
            closable: !(optionInfo == null ? void 0 : optionInfo.disabled),
            tagProps: optionInfo == null ? void 0 : optionInfo.tagProps
          }));
        }
      }
      return result;
    });
    const getOptionContentFunc = (optionInfo) => {
      if (isFunction$1(slots.option)) {
        const optionSlot = slots.option;
        return () => optionSlot({
          data: optionInfo.raw
        });
      }
      if (isFunction$1(optionInfo.render)) {
        return optionInfo.render;
      }
      return () => optionInfo.label;
    };
    const renderOption = (optionInfo) => {
      if (isGroupOptionInfo(optionInfo)) {
        let _slot;
        return createVNode(Optgroup, {
          "key": optionInfo.key,
          "label": optionInfo.label
        }, _isSlot$1(_slot = optionInfo.options.map((child) => renderOption(child))) ? _slot : {
          default: () => [_slot]
        });
      }
      if (!isValidOption(optionInfo, {
        inputValue: computedInputValue.value,
        filterOption: filterOption == null ? void 0 : filterOption.value
      })) {
        return null;
      }
      return createVNode(Option, {
        "ref": (ref2) => {
          if (ref2 == null ? void 0 : ref2.$el) {
            optionRefs.value[optionInfo.key] = ref2.$el;
          }
        },
        "key": optionInfo.key,
        "value": optionInfo.value,
        "label": optionInfo.label,
        "disabled": optionInfo.disabled,
        "internal": true
      }, {
        default: getOptionContentFunc(optionInfo)
      });
    };
    const renderDropDown = () => {
      return createVNode(SelectDropdown, {
        "ref": dropdownRef,
        "loading": props.loading,
        "empty": validOptionInfos.value.length === 0,
        "virtualList": Boolean(props.virtualListProps),
        "scrollbar": props.scrollbar,
        "showHeaderOnEmpty": props.showHeaderOnEmpty,
        "showFooterOnEmpty": props.showFooterOnEmpty,
        "onScroll": handleDropdownScroll,
        "onReachBottom": handleDropdownReachBottom
      }, {
        "default": () => {
          var _a2, _b;
          return [...(_b = (_a2 = slots.default) == null ? void 0 : _a2.call(slots)) != null ? _b : [], ...validOptions.value.map(renderOption)];
        },
        "virtual-list": () => createVNode(VirtualList, mergeProps(props.virtualListProps, {
          "ref": virtualListRef,
          "data": validOptions.value
        }), {
          item: ({
            item
          }) => renderOption(item)
        }),
        "empty": slots.empty,
        "header": slots.header,
        "footer": slots.footer
      });
    };
    const renderLabel = ({
      data: data2
    }) => {
      var _a2, _b, _c, _d;
      if ((slots.label || isFunction$1(props.formatLabel)) && data2) {
        const optionInfo = optionInfoMap.get(data2.value);
        if (optionInfo == null ? void 0 : optionInfo.raw) {
          return (_c = (_a2 = slots.label) == null ? void 0 : _a2.call(slots, {
            data: optionInfo.raw
          })) != null ? _c : (_b = props.formatLabel) == null ? void 0 : _b.call(props, optionInfo.raw);
        }
      }
      return (_d = data2 == null ? void 0 : data2.label) != null ? _d : "";
    };
    return () => createVNode(Trigger, mergeProps({
      "trigger": "click",
      "position": "bl",
      "popupOffset": 4,
      "animationName": "slide-dynamic-origin",
      "hideEmpty": true,
      "preventFocus": true,
      "autoFitPopupWidth": true,
      "autoFitTransformOrigin": true,
      "disabled": mergedDisabled.value,
      "popupVisible": computedPopupVisible.value,
      "unmountOnClose": props.unmountOnClose,
      "clickToClose": !(props.allowSearch || props.allowCreate),
      "popupContainer": props.popupContainer,
      "onPopupVisibleChange": handlePopupVisibleChange
    }, props.triggerProps), {
      default: () => {
        var _a2, _b;
        return [(_b = (_a2 = slots.trigger) == null ? void 0 : _a2.call(slots)) != null ? _b : createVNode(SelectView, mergeProps({
          "class": prefixCls,
          "modelValue": selectViewValue.value,
          "inputValue": computedInputValue.value,
          "multiple": props.multiple,
          "disabled": mergedDisabled.value,
          "error": mergedError.value,
          "loading": props.loading,
          "allowClear": props.allowClear,
          "allowCreate": props.allowCreate,
          "allowSearch": Boolean(props.allowSearch),
          "opened": computedPopupVisible.value,
          "maxTagCount": props.maxTagCount,
          "placeholder": props.placeholder,
          "bordered": props.bordered,
          "size": mergedSize.value,
          "onInputValueChange": handleInputValueChange,
          "onRemove": handleRemove,
          "onClear": handleClear,
          "onKeydown": handleKeyDown
        }, attrs), {
          "label": renderLabel,
          "prefix": slots.prefix,
          "arrow-icon": slots["arrow-icon"],
          "loading-icon": slots["loading-icon"],
          "search-icon": slots["search-icon"]
        })];
      },
      content: renderDropDown
    });
  }
});
const Select = Object.assign(_Select, {
  Option,
  OptGroup: Optgroup,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Select.name, _Select);
    app.component(componentPrefix + Option.name, Option);
    app.component(componentPrefix + Optgroup.name, Optgroup);
  }
});
const _sfc_main$e = defineComponent({
  name: "IconLeft",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value2) => {
        return ["butt", "round", "square"].includes(value2);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value2) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value2);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-left`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber$2(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
const _hoisted_1$5 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
const _hoisted_2$4 = /* @__PURE__ */ createBaseVNode("path", { d: "M32 8.4 16.444 23.956 32 39.513" }, null, -1);
const _hoisted_3$4 = [
  _hoisted_2$4
];
function _sfc_render$c(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_3$4, 14, _hoisted_1$5);
}
var _IconLeft = /* @__PURE__ */ _export_sfc(_sfc_main$e, [["render", _sfc_render$c]]);
const IconLeft = Object.assign(_IconLeft, {
  install: (app, options) => {
    var _a2;
    const iconPrefix = (_a2 = options == null ? void 0 : options.iconPrefix) != null ? _a2 : "";
    app.component(iconPrefix + _IconLeft.name, _IconLeft);
  }
});
const cardInjectionKey = Symbol("ArcoCard");
var _Card = defineComponent({
  name: "Card",
  components: {
    Spin
  },
  props: {
    bordered: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    hoverable: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    headerStyle: {
      type: Object,
      default: () => ({})
    },
    bodyStyle: {
      type: Object,
      default: () => ({})
    },
    title: {
      type: String
    },
    extra: {
      type: String
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("card");
    const {
      size: size2
    } = toRefs(props);
    const {
      mergedSize: _mergedSize
    } = useSize$1(size2);
    const mergedSize = computed(() => {
      if (_mergedSize.value === "small" || _mergedSize.value === "mini") {
        return "small";
      }
      return "medium";
    });
    const renderActions = (vns) => {
      const actions = getAllElements$1(vns);
      return createVNode("div", {
        "class": `${prefixCls}-actions`
      }, [createVNode("div", {
        "class": `${prefixCls}-actions-right`
      }, [actions.map((action, index2) => createVNode("span", {
        "key": `action-${index2}`,
        "class": `${prefixCls}-actions-item`
      }, [action]))])]);
    };
    const cardContext = reactive({
      hasMeta: false,
      hasGrid: false,
      slots,
      renderActions
    });
    provide(cardInjectionKey, cardContext);
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-loading`]: props.loading,
      [`${prefixCls}-bordered`]: props.bordered,
      [`${prefixCls}-hoverable`]: props.hoverable,
      [`${prefixCls}-contain-grid`]: cardContext.hasGrid
    }]);
    return () => {
      var _a2, _b, _c, _d, _e, _f, _g;
      const hasTitle = Boolean((_a2 = slots.title) != null ? _a2 : props.title);
      const hasExtra = Boolean((_b = slots.extra) != null ? _b : props.extra);
      return createVNode("div", {
        "class": cls.value
      }, [(hasTitle || hasExtra) && createVNode("div", {
        "class": [`${prefixCls}-header`, {
          [`${prefixCls}-header-no-title`]: !hasTitle
        }],
        "style": props.headerStyle
      }, [hasTitle && createVNode("div", {
        "class": `${prefixCls}-header-title`
      }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasExtra && createVNode("div", {
        "class": `${prefixCls}-header-extra`
      }, [(_f = (_e = slots.extra) == null ? void 0 : _e.call(slots)) != null ? _f : props.extra])]), slots.cover && createVNode("div", {
        "class": `${prefixCls}-cover`
      }, [slots.cover()]), createVNode("div", {
        "class": `${prefixCls}-body`,
        "style": props.bodyStyle
      }, [props.loading ? createVNode(Spin, null, null) : (_g = slots.default) == null ? void 0 : _g.call(slots), slots.actions && !cardContext.hasMeta && renderActions(slots.actions())])]);
    };
  }
});
var CardMeta = defineComponent({
  name: "CardMeta",
  props: {
    title: {
      type: String
    },
    description: {
      type: String
    }
  },
  setup(props, {
    slots
  }) {
    const prefixCls = getPrefixCls("card-meta");
    const context = inject(cardInjectionKey);
    onMounted(() => {
      if (context) {
        context.hasMeta = true;
      }
    });
    return () => {
      var _a2, _b, _c, _d, _e, _f;
      const hasTitle = Boolean((_a2 = slots.title) != null ? _a2 : props.title);
      const hasDesc = Boolean((_b = slots.description) != null ? _b : props.description);
      return createVNode("div", {
        "class": prefixCls
      }, [(hasTitle || hasDesc) && createVNode("div", {
        "class": `${prefixCls}-content`
      }, [hasTitle && createVNode("div", {
        "class": `${prefixCls}-title`
      }, [(_d = (_c = slots.title) == null ? void 0 : _c.call(slots)) != null ? _d : props.title]), hasDesc && createVNode("div", {
        "class": `${prefixCls}-description`
      }, [(_f = (_e = slots.description) == null ? void 0 : _e.call(slots)) != null ? _f : props.description])]), (slots.avatar || (context == null ? void 0 : context.slots.actions)) && createVNode("div", {
        "class": [`${prefixCls}-footer `, {
          [`${prefixCls}-footer-only-actions`]: !slots.avatar
        }]
      }, [slots.avatar && createVNode("div", {
        "class": `${prefixCls}-avatar`
      }, [slots.avatar()]), context && context.slots.actions && context.renderActions(context.slots.actions())])]);
    };
  }
});
const _sfc_main$d = defineComponent({
  name: "CardGrid",
  props: {
    hoverable: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("card-grid");
    const context = inject(cardInjectionKey);
    onMounted(() => {
      if (context) {
        context.hasGrid = true;
      }
    });
    const cls = computed(() => {
      return [
        prefixCls,
        {
          [`${prefixCls}-hoverable`]: props.hoverable
        }
      ];
    });
    return {
      cls
    };
  }
});
function _sfc_render$b(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.cls)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 2);
}
var CardGrid = /* @__PURE__ */ _export_sfc(_sfc_main$d, [["render", _sfc_render$b]]);
const Card = Object.assign(_Card, {
  Meta: CardMeta,
  Grid: CardGrid,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Card.name, _Card);
    app.component(componentPrefix + CardMeta.name, CardMeta);
    app.component(componentPrefix + CardGrid.name, CardGrid);
  }
});
const _sfc_main$c = defineComponent({
  name: "IconUp",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value2) => {
        return ["butt", "round", "square"].includes(value2);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value2) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value2);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-up`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber$2(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
const _hoisted_1$4 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
const _hoisted_2$3 = /* @__PURE__ */ createBaseVNode("path", { d: "M39.6 30.557 24.043 15 8.487 30.557" }, null, -1);
const _hoisted_3$3 = [
  _hoisted_2$3
];
function _sfc_render$a(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_3$3, 14, _hoisted_1$4);
}
var _IconUp = /* @__PURE__ */ _export_sfc(_sfc_main$c, [["render", _sfc_render$a]]);
const IconUp = Object.assign(_IconUp, {
  install: (app, options) => {
    var _a2;
    const iconPrefix = (_a2 = options == null ? void 0 : options.iconPrefix) != null ? _a2 : "";
    app.component(iconPrefix + _IconUp.name, _IconUp);
  }
});
function resolveItemData(cols, props) {
  var _a2, _b;
  const originSpan = (_a2 = props.span) != null ? _a2 : 1;
  const originOffset = (_b = props.offset) != null ? _b : 0;
  const offset = Math.min(originOffset, cols);
  const span = Math.min(offset > 0 ? originSpan + originOffset : originSpan, cols);
  return {
    span,
    offset,
    suffix: "suffix" in props ? props.suffix !== false : false
  };
}
function setItemVisible({
  cols,
  collapsed,
  collapsedRows,
  itemDataList
}) {
  let overflow = false;
  let displayIndexList = [];
  function isOverflow(span) {
    return Math.ceil(span / cols) > collapsedRows;
  }
  if (collapsed) {
    let spanSum = 0;
    for (let i = 0; i < itemDataList.length; i++) {
      if (itemDataList[i].suffix) {
        spanSum += itemDataList[i].span;
        displayIndexList.push(i);
      }
    }
    if (!isOverflow(spanSum)) {
      let current = 0;
      while (current < itemDataList.length) {
        const item = itemDataList[current];
        if (!item.suffix) {
          spanSum += item.span;
          if (isOverflow(spanSum)) {
            break;
          }
          displayIndexList.push(current);
        }
        current++;
      }
    }
    overflow = itemDataList.some((item, index2) => !item.suffix && !displayIndexList.includes(index2));
  } else {
    displayIndexList = itemDataList.map((_, index2) => index2);
  }
  return {
    overflow,
    displayIndexList
  };
}
const _sfc_main$b = defineComponent({
  name: "Grid",
  props: {
    cols: {
      type: [Number, Object],
      default: 24
    },
    rowGap: {
      type: [Number, Object],
      default: 0
    },
    colGap: {
      type: [Number, Object],
      default: 0
    },
    collapsed: {
      type: Boolean,
      default: false
    },
    collapsedRows: {
      type: Number,
      default: 1
    }
  },
  setup(props) {
    const {
      cols: propCols,
      rowGap: propRowGap,
      colGap: propColGap,
      collapsedRows,
      collapsed
    } = toRefs(props);
    const cols = useResponsiveState(propCols, 24);
    const colGap = useResponsiveState(propColGap, 0);
    const rowGap = useResponsiveState(propRowGap, 0);
    const prefixCls = getPrefixCls("grid");
    const classNames = computed(() => [prefixCls]);
    const style = computed(() => [
      {
        "gap": `${rowGap.value}px ${colGap.value}px`,
        "grid-template-columns": `repeat(${cols.value}, minmax(0px, 1fr))`
      }
    ]);
    const itemDataMap = reactive(/* @__PURE__ */ new Map());
    const itemDataList = computed(() => {
      const list = [];
      for (const [index2, itemData] of itemDataMap.entries()) {
        list[index2] = itemData;
      }
      return list;
    });
    const gridContext = reactive({
      overflow: false,
      displayIndexList: [],
      cols: cols.value,
      colGap: colGap.value
    });
    watchEffect(() => {
      gridContext.cols = cols.value;
      gridContext.colGap = colGap.value;
    });
    watchEffect(() => {
      const displayInfo = setItemVisible({
        cols: cols.value,
        collapsed: collapsed.value,
        collapsedRows: collapsedRows.value,
        itemDataList: itemDataList.value
      });
      gridContext.overflow = displayInfo.overflow;
      gridContext.displayIndexList = displayInfo.displayIndexList;
    });
    provide(GridContextInjectionKey, gridContext);
    provide(GridDataCollectorInjectionKey, {
      collectItemData(index2, itemData) {
        itemDataMap.set(index2, itemData);
      },
      removeItemData(index2) {
        itemDataMap.delete(index2);
      }
    });
    return {
      classNames,
      style
    };
  }
});
function _sfc_render$9(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default")
  ], 6);
}
var _Grid = /* @__PURE__ */ _export_sfc(_sfc_main$b, [["render", _sfc_render$9]]);
var __defProp$1 = Object.defineProperty;
var __defProps = Object.defineProperties;
var __getOwnPropDescs = Object.getOwnPropertyDescriptors;
var __getOwnPropSymbols$1 = Object.getOwnPropertySymbols;
var __hasOwnProp$1 = Object.prototype.hasOwnProperty;
var __propIsEnum$1 = Object.prototype.propertyIsEnumerable;
var __defNormalProp$1 = (obj, key, value2) => key in obj ? __defProp$1(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues$1 = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp$1.call(b, prop))
      __defNormalProp$1(a, prop, b[prop]);
  if (__getOwnPropSymbols$1)
    for (var prop of __getOwnPropSymbols$1(b)) {
      if (__propIsEnum$1.call(b, prop))
        __defNormalProp$1(a, prop, b[prop]);
    }
  return a;
};
var __spreadProps = (a, b) => __defProps(a, __getOwnPropDescs(b));
const _sfc_main$a = defineComponent({
  name: "GridItem",
  props: {
    span: {
      type: [Number, Object],
      default: 1
    },
    offset: {
      type: [Number, Object],
      default: 0
    },
    suffix: {
      type: Boolean,
      default: false
    }
  },
  setup(props) {
    const prefixCls = getPrefixCls("grid-item");
    const domRef = ref();
    const { computedIndex } = useIndex({
      itemRef: domRef,
      selector: `.${prefixCls}`
    });
    const gridContext = inject(GridContextInjectionKey, {
      overflow: false,
      displayIndexList: [],
      cols: 24,
      colGap: 0
    });
    const gridDataCollector = inject(GridDataCollectorInjectionKey);
    const visible = computed(() => {
      var _a2;
      return (_a2 = gridContext == null ? void 0 : gridContext.displayIndexList) == null ? void 0 : _a2.includes(computedIndex.value);
    });
    const { span: propSpan, offset: propOffset } = toRefs(props);
    const rSpan = useResponsiveState(propSpan, 1);
    const rOffset = useResponsiveState(propOffset, 0);
    const itemData = computed(() => resolveItemData(gridContext.cols, __spreadProps(__spreadValues$1({}, props), {
      span: rSpan.value,
      offset: rOffset.value
    })));
    const classNames = computed(() => [prefixCls]);
    const offsetStyle = computed(() => {
      const { offset, span } = itemData.value;
      const { colGap } = gridContext;
      if (offset > 0) {
        const oneSpan = `(100% - ${colGap * (span - 1)}px) / ${span}`;
        return {
          "margin-left": `calc((${oneSpan} * ${offset}) + ${colGap * offset}px)`
        };
      }
      return {};
    });
    const columnStart = computed(() => {
      const { suffix, span } = itemData.value;
      const { cols } = gridContext;
      if (suffix) {
        return `${cols - span + 1}`;
      }
      return `span ${span}`;
    });
    const style = computed(() => {
      const { span } = itemData.value;
      if (domRef.value) {
        return [
          {
            "grid-column": `${columnStart.value} / span ${span}`
          },
          offsetStyle.value,
          !visible.value || span === 0 ? { display: "none" } : {}
        ];
      }
      return [];
    });
    watchEffect(() => {
      if (computedIndex.value !== -1) {
        gridDataCollector == null ? void 0 : gridDataCollector.collectItemData(computedIndex.value, itemData.value);
      }
    });
    onUnmounted(() => {
      if (computedIndex.value !== -1) {
        gridDataCollector == null ? void 0 : gridDataCollector.removeItemData(computedIndex.value);
      }
    });
    return {
      classNames,
      style,
      domRef,
      overflow: computed(() => gridContext.overflow)
    };
  }
});
function _sfc_render$8(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", {
    ref: "domRef",
    class: normalizeClass(_ctx.classNames),
    style: normalizeStyle(_ctx.style)
  }, [
    renderSlot(_ctx.$slots, "default", { overflow: _ctx.overflow })
  ], 6);
}
var GridItem = /* @__PURE__ */ _export_sfc(_sfc_main$a, [["render", _sfc_render$8]]);
const Grid = Object.assign(_Grid, {
  Row,
  Col,
  Item: GridItem,
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + Row.name, Row);
    app.component(componentPrefix + Col.name, Col);
    app.component(componentPrefix + _Grid.name, _Grid);
    app.component(componentPrefix + GridItem.name, GridItem);
  }
});
function strip(num, precision) {
  if (precision === void 0) {
    precision = 15;
  }
  return +parseFloat(Number(num).toPrecision(precision));
}
function digitLength(num) {
  var eSplit = num.toString().split(/[eE]/);
  var len = (eSplit[0].split(".")[1] || "").length - +(eSplit[1] || 0);
  return len > 0 ? len : 0;
}
function float2Fixed(num) {
  if (num.toString().indexOf("e") === -1) {
    return Number(num.toString().replace(".", ""));
  }
  var dLen = digitLength(num);
  return dLen > 0 ? strip(Number(num) * Math.pow(10, dLen)) : Number(num);
}
function checkBoundary(num) {
  if (_boundaryCheckingState) {
    if (num > Number.MAX_SAFE_INTEGER || num < Number.MIN_SAFE_INTEGER) {
      console.warn(num + " is beyond boundary when transfer to integer, the results may not be accurate");
    }
  }
}
function createOperation(operation) {
  return function() {
    var nums = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      nums[_i] = arguments[_i];
    }
    var first = nums[0], others = nums.slice(1);
    return others.reduce(function(prev, next) {
      return operation(prev, next);
    }, first);
  };
}
var times = createOperation(function(num1, num2) {
  var num1Changed = float2Fixed(num1);
  var num2Changed = float2Fixed(num2);
  var baseNum = digitLength(num1) + digitLength(num2);
  var leftValue = num1Changed * num2Changed;
  checkBoundary(leftValue);
  return leftValue / Math.pow(10, baseNum);
});
var plus = createOperation(function(num1, num2) {
  var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
  return (times(num1, baseNum) + times(num2, baseNum)) / baseNum;
});
var minus = createOperation(function(num1, num2) {
  var baseNum = Math.pow(10, Math.max(digitLength(num1), digitLength(num2)));
  return (times(num1, baseNum) - times(num2, baseNum)) / baseNum;
});
var divide = createOperation(function(num1, num2) {
  var num1Changed = float2Fixed(num1);
  var num2Changed = float2Fixed(num2);
  checkBoundary(num1Changed);
  checkBoundary(num2Changed);
  return times(num1Changed / num2Changed, strip(Math.pow(10, digitLength(num2) - digitLength(num1))));
});
function round$1(num, decimal) {
  var base = Math.pow(10, decimal);
  var result = divide(Math.round(Math.abs(times(num, base))), base);
  if (num < 0 && result !== 0) {
    result = times(result, -1);
  }
  return result;
}
var _boundaryCheckingState = true;
function enableBoundaryChecking(flag) {
  if (flag === void 0) {
    flag = true;
  }
  _boundaryCheckingState = flag;
}
var index$2 = {
  strip,
  plus,
  minus,
  times,
  divide,
  round: round$1,
  digitLength,
  float2Fixed,
  enableBoundaryChecking
};
const _sfc_main$9 = defineComponent({
  name: "IconPlus",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value2) => {
        return ["butt", "round", "square"].includes(value2);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value2) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value2);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-plus`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber$2(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
const _hoisted_1$3 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
const _hoisted_2$2 = /* @__PURE__ */ createBaseVNode("path", { d: "M5 24h38M24 5v38" }, null, -1);
const _hoisted_3$2 = [
  _hoisted_2$2
];
function _sfc_render$7(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_3$2, 14, _hoisted_1$3);
}
var _IconPlus = /* @__PURE__ */ _export_sfc(_sfc_main$9, [["render", _sfc_render$7]]);
const IconPlus = Object.assign(_IconPlus, {
  install: (app, options) => {
    var _a2;
    const iconPrefix = (_a2 = options == null ? void 0 : options.iconPrefix) != null ? _a2 : "";
    app.component(iconPrefix + _IconPlus.name, _IconPlus);
  }
});
const _sfc_main$8 = defineComponent({
  name: "IconMinus",
  props: {
    size: {
      type: [Number, String]
    },
    strokeWidth: {
      type: Number,
      default: 4
    },
    strokeLinecap: {
      type: String,
      default: "butt",
      validator: (value2) => {
        return ["butt", "round", "square"].includes(value2);
      }
    },
    strokeLinejoin: {
      type: String,
      default: "miter",
      validator: (value2) => {
        return ["arcs", "bevel", "miter", "miter-clip", "round"].includes(value2);
      }
    },
    rotate: Number,
    spin: Boolean
  },
  emits: {
    click: (ev) => true
  },
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("icon");
    const cls = computed(() => [prefixCls, `${prefixCls}-minus`, { [`${prefixCls}-spin`]: props.spin }]);
    const innerStyle = computed(() => {
      const styles = {};
      if (props.size) {
        styles.fontSize = isNumber$2(props.size) ? `${props.size}px` : props.size;
      }
      if (props.rotate) {
        styles.transform = `rotate(${props.rotate}deg)`;
      }
      return styles;
    });
    const onClick = (ev) => {
      emit("click", ev);
    };
    return {
      cls,
      innerStyle,
      onClick
    };
  }
});
const _hoisted_1$2 = ["stroke-width", "stroke-linecap", "stroke-linejoin"];
const _hoisted_2$1 = /* @__PURE__ */ createBaseVNode("path", { d: "M5 24h38" }, null, -1);
const _hoisted_3$1 = [
  _hoisted_2$1
];
function _sfc_render$6(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("svg", {
    viewBox: "0 0 48 48",
    fill: "none",
    xmlns: "http://www.w3.org/2000/svg",
    stroke: "currentColor",
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.innerStyle),
    "stroke-width": _ctx.strokeWidth,
    "stroke-linecap": _ctx.strokeLinecap,
    "stroke-linejoin": _ctx.strokeLinejoin,
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.onClick && _ctx.onClick(...args))
  }, _hoisted_3$1, 14, _hoisted_1$2);
}
var _IconMinus = /* @__PURE__ */ _export_sfc(_sfc_main$8, [["render", _sfc_render$6]]);
const IconMinus = Object.assign(_IconMinus, {
  install: (app, options) => {
    var _a2;
    const iconPrefix = (_a2 = options == null ? void 0 : options.iconPrefix) != null ? _a2 : "";
    app.component(iconPrefix + _IconMinus.name, _IconMinus);
  }
});
var __defProp = Object.defineProperty;
var __getOwnPropSymbols = Object.getOwnPropertySymbols;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __propIsEnum = Object.prototype.propertyIsEnumerable;
var __defNormalProp = (obj, key, value2) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value: value2 }) : obj[key] = value2;
var __spreadValues = (a, b) => {
  for (var prop in b || (b = {}))
    if (__hasOwnProp.call(b, prop))
      __defNormalProp(a, prop, b[prop]);
  if (__getOwnPropSymbols)
    for (var prop of __getOwnPropSymbols(b)) {
      if (__propIsEnum.call(b, prop))
        __defNormalProp(a, prop, b[prop]);
    }
  return a;
};
const FIRST_DELAY = 800;
const SPEED = 150;
index$2.enableBoundaryChecking(false);
var _InputNumber = defineComponent({
  name: "InputNumber",
  props: {
    modelValue: Number,
    defaultValue: Number,
    mode: {
      type: String,
      default: "embed"
    },
    precision: Number,
    step: {
      type: Number,
      default: 1
    },
    disabled: {
      type: Boolean,
      default: false
    },
    error: {
      type: Boolean,
      default: false
    },
    max: {
      type: Number,
      default: Infinity
    },
    min: {
      type: Number,
      default: -Infinity
    },
    formatter: {
      type: Function
    },
    parser: {
      type: Function
    },
    placeholder: String,
    hideButton: {
      type: Boolean,
      default: false
    },
    size: {
      type: String
    },
    allowClear: {
      type: Boolean,
      default: false
    },
    modelEvent: {
      type: String,
      default: "change"
    },
    readOnly: {
      type: Boolean,
      default: false
    },
    inputAttrs: {
      type: Object
    }
  },
  emits: {
    "update:modelValue": (value2) => true,
    "change": (value2, ev) => true,
    "focus": (ev) => true,
    "blur": (ev) => true,
    "clear": (ev) => true,
    "input": (value2, inputValue, ev) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    var _a2;
    const {
      size: size2,
      disabled
    } = toRefs(props);
    const prefixCls = getPrefixCls("input-number");
    const inputRef = ref();
    const {
      mergedSize: _mergedSize,
      mergedDisabled,
      eventHandlers
    } = useFormItem({
      size: size2,
      disabled
    });
    const {
      mergedSize
    } = useSize$1(_mergedSize);
    const mergedPrecision = computed(() => {
      if (isNumber$2(props.precision)) {
        const decimal = `${props.step}`.split(".")[1];
        const stepPrecision = decimal && decimal.length || 0;
        return Math.max(stepPrecision, props.precision);
      }
      return void 0;
    });
    const getStringValue = (number2) => {
      var _a22, _b;
      if (!isNumber$2(number2)) {
        return "";
      }
      const numString = mergedPrecision.value ? number2.toFixed(mergedPrecision.value) : String(number2);
      return (_b = (_a22 = props.formatter) == null ? void 0 : _a22.call(props, numString)) != null ? _b : numString;
    };
    const _value = ref(getStringValue((_a2 = props.modelValue) != null ? _a2 : props.defaultValue));
    const valueNumber = computed(() => {
      var _a22, _b;
      if (!_value.value) {
        return void 0;
      }
      const number2 = Number((_b = (_a22 = props.parser) == null ? void 0 : _a22.call(props, _value.value)) != null ? _b : _value.value);
      return Number.isNaN(number2) ? void 0 : number2;
    });
    const isMin = ref(isNumber$2(valueNumber.value) && valueNumber.value <= props.min);
    const isMax = ref(isNumber$2(valueNumber.value) && valueNumber.value >= props.max);
    let repeatTimer = 0;
    const clearRepeatTimer = () => {
      if (repeatTimer) {
        window.clearTimeout(repeatTimer);
        repeatTimer = 0;
      }
    };
    const getLegalValue = (value2) => {
      if (isUndefined$1(value2)) {
        return void 0;
      }
      if (isNumber$2(props.min) && value2 < props.min) {
        value2 = props.min;
      }
      if (isNumber$2(props.max) && value2 > props.max) {
        value2 = props.max;
      }
      return isNumber$2(mergedPrecision.value) ? index$2.round(value2, mergedPrecision.value) : value2;
    };
    const updateNumberStatus = (number2) => {
      let _isMin = false;
      let _isMax = false;
      if (isNumber$2(number2)) {
        if (number2 <= props.min) {
          _isMin = true;
        }
        if (number2 >= props.max) {
          _isMax = true;
        }
      }
      if (isMax.value !== _isMax) {
        isMax.value = _isMax;
      }
      if (isMin.value !== _isMin) {
        isMin.value = _isMin;
      }
    };
    const handleExceedRange = () => {
      const finalValue = getLegalValue(valueNumber.value);
      const stringValue = getStringValue(finalValue);
      if (finalValue !== valueNumber.value || _value.value !== stringValue) {
        _value.value = stringValue;
      }
      emit("update:modelValue", finalValue);
    };
    watch(() => props.min, (newVal) => {
      const _isMin = isNumber$2(valueNumber.value) && valueNumber.value <= newVal;
      if (isMin.value !== _isMin) {
        isMin.value = _isMin;
      }
      const isExceedMinValue = isNumber$2(valueNumber.value) && valueNumber.value < newVal;
      if (isExceedMinValue) {
        handleExceedRange();
      }
    });
    watch(() => props.max, (newVal) => {
      const _isMax = isNumber$2(valueNumber.value) && valueNumber.value >= newVal;
      if (isMax.value !== _isMax) {
        isMax.value = _isMax;
      }
      const isExceedMaxValue = isNumber$2(valueNumber.value) && valueNumber.value > newVal;
      if (isExceedMaxValue) {
        handleExceedRange();
      }
    });
    const nextStep = (method, event) => {
      if (mergedDisabled.value || method === "plus" && isMax.value || method === "minus" && isMin.value) {
        return;
      }
      let nextValue;
      if (isNumber$2(valueNumber.value)) {
        nextValue = getLegalValue(index$2[method](valueNumber.value, props.step));
      } else {
        nextValue = props.min === -Infinity ? 0 : props.min;
      }
      _value.value = getStringValue(nextValue);
      updateNumberStatus(nextValue);
      emit("update:modelValue", nextValue);
      emit("change", nextValue, event);
    };
    const handleStepButton = (event, method, needRepeat = false) => {
      var _a22;
      event.preventDefault();
      (_a22 = inputRef.value) == null ? void 0 : _a22.focus();
      nextStep(method, event);
      if (needRepeat) {
        repeatTimer = window.setTimeout(() => event.target.dispatchEvent(event), repeatTimer ? SPEED : FIRST_DELAY);
      }
    };
    const handleInput = (value2, ev) => {
      var _a22, _b, _c, _d;
      value2 = value2.trim().replace(//g, ".");
      value2 = (_b = (_a22 = props.parser) == null ? void 0 : _a22.call(props, value2)) != null ? _b : value2;
      if (isNumber$2(Number(value2)) || /^(\.|-)$/.test(value2)) {
        _value.value = (_d = (_c = props.formatter) == null ? void 0 : _c.call(props, value2)) != null ? _d : value2;
        updateNumberStatus(valueNumber.value);
        if (props.modelEvent === "input") {
          emit("update:modelValue", valueNumber.value);
        }
        emit("input", valueNumber.value, _value.value, ev);
      }
    };
    const handleFocus = (ev) => {
      emit("focus", ev);
    };
    const handleChange = (value2, ev) => {
      const finalValue = getLegalValue(valueNumber.value);
      const stringValue = getStringValue(finalValue);
      if (finalValue !== valueNumber.value || _value.value !== stringValue) {
        _value.value = stringValue;
        updateNumberStatus(finalValue);
      }
      nextTick(() => {
        if (isNumber$2(props.modelValue) && props.modelValue !== finalValue) {
          _value.value = getStringValue(props.modelValue);
          updateNumberStatus(props.modelValue);
        }
      });
      emit("update:modelValue", finalValue);
      emit("change", finalValue, ev);
    };
    const handleBlur = (ev) => {
      emit("blur", ev);
    };
    const handleClear = (ev) => {
      var _a22, _b;
      _value.value = "";
      emit("update:modelValue", void 0);
      emit("change", void 0, ev);
      (_b = (_a22 = eventHandlers.value) == null ? void 0 : _a22.onChange) == null ? void 0 : _b.call(_a22, ev);
      emit("clear", ev);
    };
    const onKeyDown = getKeyDownHandler(/* @__PURE__ */ new Map([[KEYBOARD_KEY.ARROW_UP, (ev) => {
      ev.preventDefault();
      !props.readOnly && nextStep("plus", ev);
    }], [KEYBOARD_KEY.ARROW_DOWN, (ev) => {
      ev.preventDefault();
      !props.readOnly && nextStep("minus", ev);
    }]]));
    watch(() => props.modelValue, (value2) => {
      if (value2 !== valueNumber.value) {
        _value.value = getStringValue(value2);
        updateNumberStatus(value2);
      }
    });
    const renderSuffix = () => {
      var _a22, _b, _c;
      if (props.readOnly) {
        return null;
      }
      return createVNode(Fragment, null, [(_a22 = slots.suffix) == null ? void 0 : _a22.call(slots), createVNode("div", {
        "class": `${prefixCls}-step`
      }, [createVNode("button", {
        "class": [`${prefixCls}-step-button`, {
          [`${prefixCls}-step-button-disabled`]: mergedDisabled.value || isMax.value
        }],
        "type": "button",
        "tabindex": "-1",
        "disabled": mergedDisabled.value || isMax.value,
        "onMousedown": (e) => handleStepButton(e, "plus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, [slots.plus ? (_b = slots.plus) == null ? void 0 : _b.call(slots) : createVNode(IconUp, null, null)]), createVNode("button", {
        "class": [`${prefixCls}-step-button`, {
          [`${prefixCls}-step-button-disabled`]: mergedDisabled.value || isMin.value
        }],
        "type": "button",
        "tabindex": "-1",
        "disabled": mergedDisabled.value || isMin.value,
        "onMousedown": (e) => handleStepButton(e, "minus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, [slots.minus ? (_c = slots.minus) == null ? void 0 : _c.call(slots) : createVNode(IconDown, null, null)])])]);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-mode-${props.mode}`, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-readonly`]: props.readOnly
    }]);
    const renderPrependButton = () => {
      return createVNode(Button, {
        "size": mergedSize.value,
        "tabindex": "-1",
        "class": `${prefixCls}-step-button`,
        "disabled": mergedDisabled.value || isMin.value,
        "onMousedown": (ev) => handleStepButton(ev, "minus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, {
        icon: () => createVNode(IconMinus, null, null)
      });
    };
    const renderAppendButton = () => {
      return createVNode(Button, {
        "size": mergedSize.value,
        "tabindex": "-1",
        "class": `${prefixCls}-step-button`,
        "disabled": mergedDisabled.value || isMax.value,
        "onMousedown": (ev) => handleStepButton(ev, "plus", true),
        "onMouseup": clearRepeatTimer,
        "onMouseleave": clearRepeatTimer
      }, {
        icon: () => createVNode(IconPlus, null, null)
      });
    };
    const render = () => {
      const _slots = props.mode === "embed" ? {
        prepend: slots.prepend,
        prefix: slots.prefix,
        suffix: props.hideButton ? slots.suffix : renderSuffix,
        append: slots.append
      } : {
        prepend: props.hideButton ? slots.prepend : renderPrependButton,
        prefix: slots.prefix,
        suffix: slots.suffix,
        append: props.hideButton ? slots.append : renderAppendButton
      };
      return createVNode(Input, {
        "key": `__arco__${props.mode}`,
        "ref": inputRef,
        "class": cls.value,
        "type": "text",
        "allowClear": props.allowClear,
        "size": mergedSize.value,
        "modelValue": _value.value,
        "placeholder": props.placeholder,
        "disabled": mergedDisabled.value,
        "readonly": props.readOnly,
        "error": props.error,
        "inputAttrs": __spreadValues({
          "role": "spinbutton",
          "aria-valuemax": props.max,
          "aria-valuemin": props.min,
          "aria-valuenow": _value.value
        }, props.inputAttrs),
        "onInput": handleInput,
        "onFocus": handleFocus,
        "onBlur": handleBlur,
        "onClear": handleClear,
        "onChange": handleChange,
        "onKeydown": onKeyDown
      }, _slots);
    };
    return {
      inputRef,
      render
    };
  },
  methods: {
    focus() {
      var _a2;
      (_a2 = this.inputRef) == null ? void 0 : _a2.focus();
    },
    blur() {
      var _a2;
      (_a2 = this.inputRef) == null ? void 0 : _a2.blur();
    }
  },
  render() {
    return this.render();
  }
});
const InputNumber = Object.assign(_InputNumber, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _InputNumber.name, _InputNumber);
  }
});
const _sfc_main$7 = defineComponent({
  name: "Pager",
  props: {
    pageNumber: {
      type: Number
    },
    current: {
      type: Number
    },
    disabled: {
      type: Boolean,
      default: false
    },
    style: {
      type: Object
    },
    activeStyle: {
      type: Object
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-item");
    const isActive = computed(() => props.current === props.pageNumber);
    const handleClick = (e) => {
      if (!props.disabled) {
        emit("click", props.pageNumber, e);
      }
    };
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-active`]: isActive.value
      }
    ]);
    const mergedStyle = computed(() => {
      return isActive.value ? props.activeStyle : props.style;
    });
    return {
      prefixCls,
      cls,
      mergedStyle,
      handleClick
    };
  }
});
function _sfc_render$5(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.cls),
    style: normalizeStyle(_ctx.mergedStyle),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", { page: _ctx.pageNumber }, () => [
      createTextVNode(toDisplayString(_ctx.pageNumber), 1)
    ])
  ], 6);
}
var Pager = /* @__PURE__ */ _export_sfc(_sfc_main$7, [["render", _sfc_render$5]]);
const getLegalPage = (page, { min: min2, max: max2 }) => {
  if (page < min2) {
    return min2;
  }
  if (page > max2) {
    return max2;
  }
  return page;
};
const _sfc_main$6 = defineComponent({
  name: "StepPager",
  components: {
    IconLeft,
    IconRight
  },
  props: {
    pages: {
      type: Number,
      required: true
    },
    current: {
      type: Number,
      required: true
    },
    type: {
      type: String,
      required: true
    },
    disabled: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: false
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-item");
    const isNext = props.type === "next";
    const mergedDisabled = computed(() => {
      if (props.disabled) {
        return props.disabled;
      }
      if (!props.pages) {
        return true;
      }
      if (isNext && props.current === props.pages) {
        return true;
      }
      return !isNext && props.current <= 1;
    });
    const nextPage = computed(() => getLegalPage(props.current + (isNext ? 1 : -1), {
      min: 1,
      max: props.pages
    }));
    const handleClick = (e) => {
      if (!mergedDisabled.value) {
        emit("click", nextPage.value);
      }
    };
    const cls = computed(() => [
      prefixCls,
      `${prefixCls}-${props.type}`,
      {
        [`${prefixCls}-disabled`]: mergedDisabled.value
      }
    ]);
    return {
      prefixCls,
      cls,
      isNext,
      handleClick
    };
  }
});
function _sfc_render$4(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_right = resolveComponent("icon-right");
  const _component_icon_left = resolveComponent("icon-left");
  return openBlock(), createBlock(resolveDynamicComponent(_ctx.simple ? "span" : "li"), {
    class: normalizeClass(_ctx.cls),
    onClick: _ctx.handleClick
  }, {
    default: withCtx(() => [
      renderSlot(_ctx.$slots, "default", {
        type: _ctx.isNext ? "next" : "previous"
      }, () => [
        _ctx.isNext ? (openBlock(), createBlock(_component_icon_right, { key: 0 })) : (openBlock(), createBlock(_component_icon_left, { key: 1 }))
      ])
    ]),
    _: 3
  }, 8, ["class", "onClick"]);
}
var StepPager = /* @__PURE__ */ _export_sfc(_sfc_main$6, [["render", _sfc_render$4]]);
const _sfc_main$5 = defineComponent({
  name: "EllipsisPager",
  components: {
    IconMore
  },
  props: {
    current: {
      type: Number,
      required: true
    },
    step: {
      type: Number,
      default: 5
    },
    pages: {
      type: Number,
      required: true
    }
  },
  emits: ["click"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-item");
    const nextPage = computed(() => getLegalPage(props.current + props.step, {
      min: 1,
      max: props.pages
    }));
    const handleClick = (e) => {
      emit("click", nextPage.value);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-ellipsis`]);
    return {
      prefixCls,
      cls,
      handleClick
    };
  }
});
function _sfc_render$3(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_icon_more = resolveComponent("icon-more");
  return openBlock(), createElementBlock("li", {
    class: normalizeClass(_ctx.cls),
    onClick: _cache[0] || (_cache[0] = (...args) => _ctx.handleClick && _ctx.handleClick(...args))
  }, [
    renderSlot(_ctx.$slots, "default", {}, () => [
      createVNode(_component_icon_more)
    ])
  ], 2);
}
var EllipsisPager = /* @__PURE__ */ _export_sfc(_sfc_main$5, [["render", _sfc_render$3]]);
const _sfc_main$4 = defineComponent({
  name: "PageJumper",
  components: {
    InputNumber
  },
  props: {
    current: {
      type: Number,
      required: true
    },
    simple: {
      type: Boolean,
      default: false
    },
    disabled: {
      type: Boolean,
      default: false
    },
    pages: {
      type: Number,
      required: true
    },
    size: {
      type: String
    },
    onChange: {
      type: Function
    }
  },
  emits: ["change"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-jumper");
    const { t } = useI18n();
    const inputValue = ref(props.simple ? props.current : void 0);
    const handleFormatter = (value2) => {
      const parseIntVal = parseInt(value2.toString(), 10);
      return Number.isNaN(parseIntVal) ? void 0 : String(parseIntVal);
    };
    const handleChange = (value2) => {
      emit("change", inputValue.value);
      nextTick(() => {
        if (!props.simple) {
          inputValue.value = void 0;
        }
      });
    };
    watch(() => props.current, (value2) => {
      if (props.simple && value2 !== inputValue.value) {
        inputValue.value = value2;
      }
    });
    const cls = computed(() => [
      prefixCls,
      {
        [`${prefixCls}-simple`]: props.simple
      }
    ]);
    return {
      prefixCls,
      cls,
      t,
      inputValue,
      handleChange,
      handleFormatter
    };
  }
});
function _sfc_render$2(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_input_number = resolveComponent("input-number");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.cls)
  }, [
    !_ctx.simple ? (openBlock(), createElementBlock("span", {
      key: 0,
      class: normalizeClass([`${_ctx.prefixCls}-prepend`, `${_ctx.prefixCls}-text-goto`])
    }, [
      renderSlot(_ctx.$slots, "jumper-prepend", {}, () => [
        createTextVNode(toDisplayString(_ctx.t("pagination.goto")), 1)
      ])
    ], 2)) : createCommentVNode("v-if", true),
    createVNode(_component_input_number, {
      modelValue: _ctx.inputValue,
      "onUpdate:modelValue": _cache[0] || (_cache[0] = ($event) => _ctx.inputValue = $event),
      class: normalizeClass(`${_ctx.prefixCls}-input`),
      min: 1,
      max: _ctx.pages,
      size: _ctx.size,
      disabled: _ctx.disabled,
      "hide-button": "",
      formatter: _ctx.handleFormatter,
      onChange: _ctx.handleChange
    }, null, 8, ["modelValue", "class", "max", "size", "disabled", "formatter", "onChange"]),
    _ctx.$slots["jumper-append"] ? (openBlock(), createElementBlock("span", {
      key: 1,
      class: normalizeClass(`${_ctx.prefixCls}-append`)
    }, [
      renderSlot(_ctx.$slots, "jumper-append")
    ], 2)) : createCommentVNode("v-if", true),
    _ctx.simple ? (openBlock(), createElementBlock(Fragment, { key: 2 }, [
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-separator`)
      }, "/", 2),
      createBaseVNode("span", {
        class: normalizeClass(`${_ctx.prefixCls}-total-page`)
      }, toDisplayString(_ctx.pages), 3)
    ], 64)) : createCommentVNode("v-if", true)
  ], 2);
}
var PageJumper = /* @__PURE__ */ _export_sfc(_sfc_main$4, [["render", _sfc_render$2]]);
const _sfc_main$3 = defineComponent({
  name: "PageOptions",
  components: {
    ArcoSelect: Select
  },
  props: {
    sizeOptions: {
      type: Array,
      required: true
    },
    pageSize: Number,
    disabled: Boolean,
    size: {
      type: String
    },
    onChange: {
      type: Function
    },
    selectProps: {
      type: Object
    }
  },
  emits: ["change"],
  setup(props, { emit }) {
    const prefixCls = getPrefixCls("pagination-options");
    const { t } = useI18n();
    const options = computed(() => props.sizeOptions.map((value2) => ({
      value: value2,
      label: `${value2} ${t("pagination.countPerPage")}`
    })));
    const handleChange = (value2) => {
      emit("change", value2);
    };
    return {
      prefixCls,
      options,
      handleChange
    };
  }
});
function _sfc_render$1(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_arco_select = resolveComponent("arco-select");
  return openBlock(), createElementBlock("span", {
    class: normalizeClass(_ctx.prefixCls)
  }, [
    createVNode(_component_arco_select, mergeProps({
      "model-value": _ctx.pageSize,
      options: _ctx.options,
      size: _ctx.size,
      disabled: _ctx.disabled
    }, _ctx.selectProps, { onChange: _ctx.handleChange }), null, 16, ["model-value", "options", "size", "disabled", "onChange"])
  ], 2);
}
var PageOptions = /* @__PURE__ */ _export_sfc(_sfc_main$3, [["render", _sfc_render$1]]);
var _Pagination = defineComponent({
  name: "Pagination",
  props: {
    total: {
      type: Number,
      required: true
    },
    current: Number,
    defaultCurrent: {
      type: Number,
      default: 1
    },
    pageSize: Number,
    defaultPageSize: {
      type: Number,
      default: 10
    },
    disabled: {
      type: Boolean,
      default: false
    },
    hideOnSinglePage: {
      type: Boolean,
      default: false
    },
    simple: {
      type: Boolean,
      default: false
    },
    showTotal: {
      type: Boolean,
      default: false
    },
    showMore: {
      type: Boolean,
      default: false
    },
    showJumper: {
      type: Boolean,
      default: false
    },
    showPageSize: {
      type: Boolean,
      default: false
    },
    pageSizeOptions: {
      type: Array,
      default: () => [10, 20, 30, 40, 50]
    },
    pageSizeProps: {
      type: Object
    },
    size: {
      type: String
    },
    pageItemStyle: {
      type: Object
    },
    activePageItemStyle: {
      type: Object
    },
    baseSize: {
      type: Number,
      default: 6
    },
    bufferSize: {
      type: Number,
      default: 2
    },
    autoAdjust: {
      type: Boolean,
      default: true
    }
  },
  emits: {
    "update:current": (current) => true,
    "update:pageSize": (pageSize) => true,
    "change": (current) => true,
    "pageSizeChange": (pageSize) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const prefixCls = getPrefixCls("pagination");
    const {
      t
    } = useI18n();
    const {
      disabled,
      pageItemStyle,
      activePageItemStyle,
      size: size2
    } = toRefs(props);
    const {
      mergedSize
    } = useSize$1(size2);
    const _current = ref(props.defaultCurrent);
    const _pageSize = ref(props.defaultPageSize);
    const computedCurrent = computed(() => {
      var _a2;
      return (_a2 = props.current) != null ? _a2 : _current.value;
    });
    const computedPageSize = computed(() => {
      var _a2;
      return (_a2 = props.pageSize) != null ? _a2 : _pageSize.value;
    });
    const pages = computed(() => Math.ceil(props.total / computedPageSize.value));
    const handleClick = (page) => {
      if (page !== computedCurrent.value && isNumber$2(page) && !props.disabled) {
        _current.value = page;
        emit("update:current", page);
        emit("change", page);
      }
    };
    const handlePageSizeChange = (pageSize) => {
      _pageSize.value = pageSize;
      emit("update:pageSize", pageSize);
      emit("pageSizeChange", pageSize);
    };
    const pagerProps = reactive({
      current: computedCurrent,
      pages,
      disabled,
      style: pageItemStyle,
      activeStyle: activePageItemStyle,
      onClick: handleClick
    });
    const getPageItemElement = (type, props2 = {}) => {
      if (type === "more") {
        return createVNode(EllipsisPager, mergeProps(props2, pagerProps), {
          default: slots["page-item-ellipsis"]
        });
      }
      if (type === "previous") {
        return createVNode(StepPager, mergeProps({
          "type": "previous"
        }, props2, pagerProps), {
          default: slots["page-item-step"]
        });
      }
      if (type === "next") {
        return createVNode(StepPager, mergeProps({
          "type": "next"
        }, props2, pagerProps), {
          default: slots["page-item-step"]
        });
      }
      return createVNode(Pager, mergeProps(props2, pagerProps), {
        default: slots["page-item"]
      });
    };
    const pageList = computed(() => {
      const pageList2 = [];
      if (pages.value < props.baseSize + props.bufferSize * 2) {
        for (let i = 1; i <= pages.value; i++) {
          pageList2.push(getPageItemElement("page", {
            key: i,
            pageNumber: i
          }));
        }
      } else {
        let left2 = 1;
        let right2 = pages.value;
        let hasLeftEllipsis = false;
        let hasRightEllipsis = false;
        if (computedCurrent.value > 2 + props.bufferSize) {
          hasLeftEllipsis = true;
          left2 = Math.min(computedCurrent.value - props.bufferSize, pages.value - 2 * props.bufferSize);
        }
        if (computedCurrent.value < pages.value - (props.bufferSize + 1)) {
          hasRightEllipsis = true;
          right2 = Math.max(computedCurrent.value + props.bufferSize, 2 * props.bufferSize + 1);
        }
        if (hasLeftEllipsis) {
          pageList2.push(getPageItemElement("page", {
            key: 1,
            pageNumber: 1
          }));
          pageList2.push(getPageItemElement("more", {
            key: "left-ellipsis-pager",
            step: -(props.bufferSize * 2 + 1)
          }));
        }
        for (let i = left2; i <= right2; i++) {
          pageList2.push(getPageItemElement("page", {
            key: i,
            pageNumber: i
          }));
        }
        if (hasRightEllipsis) {
          pageList2.push(getPageItemElement("more", {
            key: "right-ellipsis-pager",
            step: props.bufferSize * 2 + 1
          }));
          pageList2.push(getPageItemElement("page", {
            key: pages.value,
            pageNumber: pages.value
          }));
        }
      }
      return pageList2;
    });
    const renderPager = () => {
      if (props.simple) {
        return createVNode("span", {
          "class": `${prefixCls}-simple`
        }, [getPageItemElement("previous", {
          simple: true
        }), createVNode(PageJumper, {
          "disabled": props.disabled,
          "current": computedCurrent.value,
          "size": mergedSize.value,
          "pages": pages.value,
          "simple": true,
          "onChange": handleClick
        }, null), getPageItemElement("next", {
          simple: true
        })]);
      }
      return createVNode("ul", {
        "class": `${prefixCls}-list`
      }, [getPageItemElement("previous", {
        simple: true
      }), pageList.value, props.showMore && getPageItemElement("more", {
        key: "more",
        step: props.bufferSize * 2 + 1
      }), getPageItemElement("next", {
        simple: true
      })]);
    };
    watch(computedPageSize, (curPageSize, prePageSize) => {
      if (props.autoAdjust && curPageSize !== prePageSize && computedCurrent.value > 1) {
        const index2 = prePageSize * (computedCurrent.value - 1) + 1;
        const newPage = Math.ceil(index2 / curPageSize);
        if (newPage !== computedCurrent.value) {
          _current.value = newPage;
          emit("update:current", newPage);
          emit("change", newPage);
        }
      }
    });
    watch(pages, (curPages, prePages) => {
      if (props.autoAdjust && curPages !== prePages && computedCurrent.value > 1 && computedCurrent.value > curPages) {
        _current.value = curPages;
        emit("update:current", curPages);
        emit("change", curPages);
      }
    });
    const cls = computed(() => [prefixCls, `${prefixCls}-size-${mergedSize.value}`, {
      [`${prefixCls}-simple`]: props.simple,
      [`${prefixCls}-disabled`]: props.disabled
    }]);
    return () => {
      var _a2, _b;
      if (props.hideOnSinglePage && pages.value <= 1) {
        return null;
      }
      return createVNode("div", {
        "class": cls.value
      }, [props.showTotal && createVNode("span", {
        "class": `${prefixCls}-total`
      }, [(_b = (_a2 = slots.total) == null ? void 0 : _a2.call(slots, {
        total: props.total
      })) != null ? _b : t("pagination.total", props.total)]), renderPager(), props.showPageSize && createVNode(PageOptions, {
        "disabled": props.disabled,
        "sizeOptions": props.pageSizeOptions,
        "pageSize": computedPageSize.value,
        "size": mergedSize.value,
        "onChange": handlePageSizeChange,
        "selectProps": props.pageSizeProps
      }, null), !props.simple && props.showJumper && createVNode(PageJumper, {
        "disabled": props.disabled,
        "current": computedCurrent.value,
        "pages": pages.value,
        "size": mergedSize.value,
        "onChange": handleClick
      }, {
        "jumper-prepend": slots["jumper-prepend"],
        "jumper-append": slots["jumper-append"]
      })]);
    };
  }
});
const Pagination = Object.assign(_Pagination, {
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _Pagination.name, _Pagination);
  }
});
const usePagination = (props, { emit }) => {
  var _a2, _b;
  const _current = ref(isObject$1(props.paginationProps) ? (_a2 = props.paginationProps.defaultCurrent) != null ? _a2 : 1 : 1);
  const _pageSize = ref(isObject$1(props.paginationProps) ? (_b = props.paginationProps.defaultPageSize) != null ? _b : 10 : 10);
  const current = computed(() => {
    var _a22;
    return isObject$1(props.paginationProps) ? (_a22 = props.paginationProps.current) != null ? _a22 : _current.value : _current.value;
  });
  const pageSize = computed(() => {
    var _a22;
    return isObject$1(props.paginationProps) ? (_a22 = props.paginationProps.pageSize) != null ? _a22 : _pageSize.value : _pageSize.value;
  });
  const handlePageChange = (page) => {
    _current.value = page;
    emit("pageChange", page);
  };
  const handlePageSizeChange = (pageSize2) => {
    _pageSize.value = pageSize2;
    emit("pageSizeChange", pageSize2);
  };
  return {
    current,
    pageSize,
    handlePageChange,
    handlePageSizeChange
  };
};
function _isSlot(s) {
  return typeof s === "function" || Object.prototype.toString.call(s) === "[object Object]" && !isVNode(s);
}
var _List = defineComponent({
  name: "List",
  props: {
    data: {
      type: Array
    },
    size: {
      type: String,
      default: "medium"
    },
    bordered: {
      type: Boolean,
      default: true
    },
    split: {
      type: Boolean,
      default: true
    },
    loading: {
      type: Boolean,
      default: false
    },
    hoverable: {
      type: Boolean,
      default: false
    },
    paginationProps: {
      type: Object
    },
    gridProps: {
      type: Object
    },
    maxHeight: {
      type: [String, Number],
      default: 0
    },
    bottomOffset: {
      type: Number,
      default: 0
    },
    virtualListProps: {
      type: Object
    },
    scrollbar: {
      type: [Object, Boolean],
      default: true
    }
  },
  emits: {
    scroll: () => true,
    reachBottom: () => true,
    pageChange: (page) => true,
    pageSizeChange: (pageSize) => true
  },
  setup(props, {
    emit,
    slots
  }) {
    const {
      scrollbar: scrollbar2
    } = toRefs(props);
    const prefixCls = getPrefixCls("list");
    const configCtx = inject(configProviderInjectionKey, void 0);
    const {
      componentRef,
      elementRef: listRef
    } = useComponentRef("containerRef");
    const isVirtualList = computed(() => props.virtualListProps);
    const {
      displayScrollbar,
      scrollbarProps
    } = useScrollbar(scrollbar2);
    let preScrollTop = 0;
    const handleScroll = (e) => {
      const {
        scrollTop,
        scrollHeight,
        offsetHeight
      } = e.target;
      const bottom = Math.floor(scrollHeight - (scrollTop + offsetHeight));
      if (scrollTop > preScrollTop && bottom <= props.bottomOffset) {
        emit("reachBottom");
      }
      emit("scroll");
      preScrollTop = scrollTop;
    };
    onMounted(() => {
      if (listRef.value) {
        const {
          scrollTop,
          scrollHeight,
          offsetHeight
        } = listRef.value;
        if (scrollHeight <= scrollTop + offsetHeight) {
          emit("reachBottom");
        }
      }
    });
    const {
      current,
      pageSize,
      handlePageChange,
      handlePageSizeChange
    } = usePagination(props, {
      emit
    });
    const getCurrentPageItems = (data2) => {
      if (!props.paginationProps) {
        return data2;
      }
      if (props.paginationProps && data2.length > pageSize.value) {
        const startIndex = (current.value - 1) * pageSize.value;
        return data2.slice(startIndex, startIndex + pageSize.value);
      }
      return data2;
    };
    const renderGridItems = (data2) => {
      let _slot2;
      if (!props.gridProps) {
        return null;
      }
      const currentPageItems = getCurrentPageItems(data2);
      if (props.gridProps.span) {
        const items = [];
        const rowSize = 24 / props.gridProps.span;
        for (let i = 0; i < currentPageItems.length; i += rowSize) {
          let _slot;
          const nextIndex = i + rowSize;
          const rowIndex = Math.floor(i / rowSize);
          items.push(createVNode(Grid.Row, {
            "key": rowIndex,
            "class": `${prefixCls}-row`,
            "gutter": props.gridProps.gutter
          }, _isSlot(_slot = currentPageItems.slice(i, nextIndex).map((item, index2) => {
            var _a2;
            return createVNode(Grid.Col, {
              "key": `${rowIndex}-${index2}`,
              "class": `${prefixCls}-col`,
              "span": (_a2 = props.gridProps) == null ? void 0 : _a2.span
            }, {
              default: () => {
                var _a22;
                return [isVNode(item) ? item : (_a22 = slots.item) == null ? void 0 : _a22.call(slots, {
                  item,
                  index: index2
                })];
              }
            });
          })) ? _slot : {
            default: () => [_slot]
          }));
        }
        return items;
      }
      return createVNode(Grid.Row, {
        "class": `${prefixCls}-row`,
        "gutter": props.gridProps.gutter
      }, _isSlot(_slot2 = currentPageItems.map((item, index2) => createVNode(Grid.Col, mergeProps({
        "key": index2,
        "class": `${prefixCls}-col`
      }, omit$2(props.gridProps, ["gutter"])), {
        default: () => {
          var _a2;
          return [isVNode(item) ? item : (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
            item,
            index: index2
          })];
        }
      }))) ? _slot2 : {
        default: () => [_slot2]
      });
    };
    const renderListItems = (data2) => {
      const currentPageItems = getCurrentPageItems(data2);
      return currentPageItems.map((item, index2) => {
        var _a2;
        return isVNode(item) ? item : (_a2 = slots.item) == null ? void 0 : _a2.call(slots, {
          item,
          index: index2
        });
      });
    };
    const renderItems = () => {
      const data2 = slots.default ? getAllElements$1(slots.default()) : props.data;
      if (data2 && data2.length > 0) {
        return props.gridProps ? renderGridItems(data2) : renderListItems(data2);
      }
      return renderEmpty();
    };
    const renderPagination = () => {
      if (!props.paginationProps) {
        return null;
      }
      const paginationProps = omit$2(props.paginationProps, ["current", "pageSize", "defaultCurrent", "defaultPageSize"]);
      return createVNode(Pagination, mergeProps({
        "class": `${prefixCls}-pagination`
      }, paginationProps, {
        "current": current.value,
        "pageSize": pageSize.value,
        "onChange": handlePageChange,
        "onPageSizeChange": handlePageSizeChange
      }), null);
    };
    const cls = computed(() => [prefixCls, `${prefixCls}-${props.size}`, {
      [`${prefixCls}-bordered`]: props.bordered,
      [`${prefixCls}-split`]: props.split,
      [`${prefixCls}-hover`]: props.hoverable
    }]);
    const contentStyle = computed(() => {
      if (props.maxHeight) {
        const maxHeight = isNumber$2(props.maxHeight) ? `${props.maxHeight}px` : props.maxHeight;
        return {
          maxHeight,
          overflowY: "auto"
        };
      }
      return void 0;
    });
    const contentCls = computed(() => [`${prefixCls}-content`, {
      [`${prefixCls}-virtual`]: isVirtualList.value
    }]);
    const virtualListRef = ref();
    const renderVirtualList = () => {
      var _a2;
      const currentPageItems = getCurrentPageItems((_a2 = props.data) != null ? _a2 : []);
      return currentPageItems.length ? createVNode(VirtualList, mergeProps({
        "ref": virtualListRef,
        "class": contentCls.value,
        "data": currentPageItems
      }, props.virtualListProps, {
        "onScroll": handleScroll
      }), {
        item: ({
          item,
          index: index2
        }) => {
          var _a22;
          return (_a22 = slots.item) == null ? void 0 : _a22.call(slots, {
            item,
            index: index2
          });
        }
      }) : renderEmpty();
    };
    const renderScrollLoading = () => {
      if (slots["scroll-loading"]) {
        return createVNode("div", {
          "class": [`${prefixCls}-item`, `${prefixCls}-scroll-loading`]
        }, [slots["scroll-loading"]()]);
      }
      return null;
    };
    const renderEmpty = () => {
      var _a2, _b, _c, _d, _e;
      if (slots["scroll-loading"]) {
        return null;
      }
      return (_e = (_d = (_a2 = slots.empty) == null ? void 0 : _a2.call(slots)) != null ? _d : (_c = configCtx == null ? void 0 : (_b = configCtx.slots).empty) == null ? void 0 : _c.call(_b, {
        component: "list"
      })) != null ? _e : createVNode(Empty, null, null);
    };
    const render = () => {
      const Component2 = displayScrollbar.value ? Scrollbar$2 : "div";
      return createVNode("div", {
        "class": `${prefixCls}-wrapper`
      }, [createVNode(Spin, {
        "class": `${prefixCls}-spin`,
        "loading": props.loading
      }, {
        default: () => [createVNode(Component2, mergeProps({
          "ref": componentRef,
          "class": cls.value,
          "style": contentStyle.value
        }, scrollbarProps.value, {
          "onScroll": handleScroll
        }), {
          default: () => [createVNode("div", {
            "class": `${prefixCls}-content-wrapper`
          }, [slots.header && createVNode("div", {
            "class": `${prefixCls}-header`
          }, [slots.header()]), isVirtualList.value && !props.gridProps ? createVNode(Fragment, null, [renderVirtualList(), renderScrollLoading()]) : createVNode("div", {
            "role": "list",
            "class": contentCls.value
          }, [renderItems(), renderScrollLoading()]), slots.footer && createVNode("div", {
            "class": `${prefixCls}-footer`
          }, [slots.footer()])])]
        }), renderPagination()]
      })]);
    };
    return {
      virtualListRef,
      render
    };
  },
  methods: {
    scrollIntoView(options) {
      if (this.virtualListRef) {
        this.virtualListRef.scrollTo(options);
      }
    }
  },
  render() {
    return this.render();
  }
});
const List$1 = Object.assign(_List, {
  Item: Object.assign(ListItem, {
    Meta: ListItemMeta
  }),
  install: (app, options) => {
    setGlobalConfig(app, options);
    const componentPrefix = getComponentPrefix(options);
    app.component(componentPrefix + _List.name, _List);
    app.component(componentPrefix + ListItem.name, ListItem);
    app.component(componentPrefix + ListItemMeta.name, ListItemMeta);
  }
});
var extendStatics$1 = function(d, b) {
  extendStatics$1 = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (Object.prototype.hasOwnProperty.call(b10, p))
        d2[p] = b10[p];
  };
  return extendStatics$1(d, b);
};
function __extends$1(d, b) {
  if (typeof b !== "function" && b !== null)
    throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
  extendStatics$1(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign$1 = function() {
  __assign$1 = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign$1.apply(this, arguments);
};
function __rest(s, e) {
  var t = {};
  for (var p in s)
    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
      t[p] = s[p];
  if (s != null && typeof Object.getOwnPropertySymbols === "function")
    for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
      if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
        t[p[i]] = s[p[i]];
    }
  return t;
}
function __awaiter(thisArg, _arguments, P, generator) {
  function adopt(value2) {
    return value2 instanceof P ? value2 : new P(function(resolve) {
      resolve(value2);
    });
  }
  return new (P || (P = Promise))(function(resolve, reject) {
    function fulfilled(value2) {
      try {
        step(generator.next(value2));
      } catch (e) {
        reject(e);
      }
    }
    function rejected(value2) {
      try {
        step(generator["throw"](value2));
      } catch (e) {
        reject(e);
      }
    }
    function step(result) {
      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);
    }
    step((generator = generator.apply(thisArg, _arguments || [])).next());
  });
}
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}
function __values(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m)
    return m.call(o);
  if (o && typeof o.length === "number")
    return {
      next: function() {
        if (o && i >= o.length)
          o = void 0;
        return { value: o && o[i++], done: !o };
      }
    };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
}
function __read(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m)
    return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done)
      ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"]))
        m.call(i);
    } finally {
      if (e)
        throw e.error;
    }
  }
  return ar;
}
function __spreadArrays() {
  for (var s = 0, i = 0, il = arguments.length; i < il; i++)
    s += arguments[i].length;
  for (var r = Array(s), k = 0, i = 0; i < il; i++)
    for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)
      r[k] = a[j];
  return r;
}
function __spreadArray$1(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
}
var isArrayLike = function(value2) {
  return value2 !== null && typeof value2 !== "function" && isFinite(value2.length);
};
var contains = function(arr, value2) {
  if (!isArrayLike(arr)) {
    return false;
  }
  return arr.indexOf(value2) > -1;
};
var filter = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value2 = arr[index2];
    if (func(value2, index2)) {
      result.push(value2);
    }
  }
  return result;
};
var difference = function(arr, values2) {
  if (values2 === void 0) {
    values2 = [];
  }
  return filter(arr, function(value2) {
    return !contains(values2, value2);
  });
};
var toString$3 = {}.toString;
var isType$1 = function(value2, type) {
  return toString$3.call(value2) === "[object " + type + "]";
};
const isFunction = function(value2) {
  return isType$1(value2, "Function");
};
var isNil = function(value2) {
  return value2 === null || value2 === void 0;
};
const isArray$1 = function(value2) {
  return Array.isArray ? Array.isArray(value2) : isType$1(value2, "Array");
};
const isObject = function(value2) {
  var type = typeof value2;
  return value2 !== null && type === "object" || type === "function";
};
function each$1(elements, func) {
  if (!elements) {
    return;
  }
  var rst;
  if (isArray$1(elements)) {
    for (var i = 0, len = elements.length; i < len; i++) {
      rst = func(elements[i], i);
      if (rst === false) {
        break;
      }
    }
  } else if (isObject(elements)) {
    for (var k in elements) {
      if (elements.hasOwnProperty(k)) {
        rst = func(elements[k], k);
        if (rst === false) {
          break;
        }
      }
    }
  }
}
var keys = Object.keys ? function(obj) {
  return Object.keys(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value2, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(key);
    }
  });
  return result;
};
function isMatch(obj, attrs) {
  var _keys = keys(attrs);
  var length2 = _keys.length;
  if (isNil(obj))
    return !length2;
  for (var i = 0; i < length2; i += 1) {
    var key = _keys[i];
    if (attrs[key] !== obj[key] || !(key in obj)) {
      return false;
    }
  }
  return true;
}
var isObjectLike$1 = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject$1 = function(value2) {
  if (!isObjectLike$1(value2) || !isType$1(value2, "Object")) {
    return false;
  }
  if (Object.getPrototypeOf(value2) === null) {
    return true;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
function find$1(arr, predicate) {
  if (!isArray$1(arr))
    return null;
  var _predicate;
  if (isFunction(predicate)) {
    _predicate = predicate;
  }
  if (isPlainObject$1(predicate)) {
    _predicate = function(a) {
      return isMatch(a, predicate);
    };
  }
  if (_predicate) {
    for (var i = 0; i < arr.length; i += 1) {
      if (_predicate(arr[i])) {
        return arr[i];
      }
    }
  }
  return null;
}
function findIndex(arr, predicate, fromIndex) {
  if (fromIndex === void 0) {
    fromIndex = 0;
  }
  for (var i = fromIndex; i < arr.length; i++) {
    if (predicate(arr[i], i)) {
      return i;
    }
  }
  return -1;
}
var firstValue = function(data2, name) {
  var rst = null;
  for (var i = 0; i < data2.length; i++) {
    var obj = data2[i];
    var value2 = obj[name];
    if (!isNil(value2)) {
      if (isArray$1(value2)) {
        rst = value2[0];
      } else {
        rst = value2;
      }
      break;
    }
  }
  return rst;
};
var flatten = function(arr) {
  if (!isArray$1(arr)) {
    return [];
  }
  var rst = [];
  for (var i = 0; i < arr.length; i++) {
    rst = rst.concat(arr[i]);
  }
  return rst;
};
const max$2 = function(arr) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.max(prev, curr);
  }, arr[0]);
};
const min$2 = function(arr) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  return arr.reduce(function(prev, curr) {
    return Math.min(prev, curr);
  }, arr[0]);
};
var getRange = function(values2) {
  var filterValues = values2.filter(function(v) {
    return !isNaN(v);
  });
  if (!filterValues.length) {
    return {
      min: 0,
      max: 0
    };
  }
  if (isArray$1(values2[0])) {
    var tmp = [];
    for (var i = 0; i < values2.length; i++) {
      tmp = tmp.concat(values2[i]);
    }
    filterValues = tmp;
  }
  var max2 = max$2(filterValues);
  var min2 = min$2(filterValues);
  return {
    min: min2,
    max: max2
  };
};
var splice = Array.prototype.splice;
var pullAt = function pullAt2(arr, indexes) {
  if (!isArrayLike(arr)) {
    return [];
  }
  var length2 = arr ? indexes.length : 0;
  var last2 = length2 - 1;
  while (length2--) {
    var previous = void 0;
    var index2 = indexes[length2];
    if (length2 === last2 || index2 !== previous) {
      previous = index2;
      splice.call(arr, index2, 1);
    }
  }
  return arr;
};
var reduce = function(arr, fn, init) {
  if (!isArray$1(arr) && !isPlainObject$1(arr)) {
    return arr;
  }
  var result = init;
  each$1(arr, function(data2, i) {
    result = fn(result, data2, i);
  });
  return result;
};
var remove = function(arr, predicate) {
  var result = [];
  if (!isArrayLike(arr)) {
    return result;
  }
  var i = -1;
  var indexes = [];
  var length2 = arr.length;
  while (++i < length2) {
    var value2 = arr[i];
    if (predicate(value2, i, arr)) {
      result.push(value2);
      indexes.push(i);
    }
  }
  pullAt(arr, indexes);
  return result;
};
const isString = function(str) {
  return isType$1(str, "String");
};
function sortBy(arr, key) {
  var comparer;
  if (isFunction(key)) {
    comparer = function(a, b) {
      return key(a) - key(b);
    };
  } else {
    var keys_1 = [];
    if (isString(key)) {
      keys_1.push(key);
    } else if (isArray$1(key)) {
      keys_1 = key;
    }
    comparer = function(a, b) {
      for (var i = 0; i < keys_1.length; i += 1) {
        var prop = keys_1[i];
        if (a[prop] > b[prop]) {
          return 1;
        }
        if (a[prop] < b[prop]) {
          return -1;
        }
      }
      return 0;
    };
  }
  arr.sort(comparer);
  return arr;
}
function uniq$2(arr, cache2) {
  if (cache2 === void 0) {
    cache2 = /* @__PURE__ */ new Map();
  }
  var r = [];
  if (Array.isArray(arr)) {
    for (var i = 0, len = arr.length; i < len; i++) {
      var item = arr[i];
      if (!cache2.has(item)) {
        r.push(item);
        cache2.set(item, true);
      }
    }
  }
  return r;
}
const valuesOfKey = function(data2, name) {
  var rst = [];
  var tmpMap = {};
  for (var i = 0; i < data2.length; i++) {
    var obj = data2[i];
    var value2 = obj[name];
    if (!isNil(value2)) {
      if (!isArray$1(value2)) {
        value2 = [value2];
      }
      for (var j = 0; j < value2.length; j++) {
        var val = value2[j];
        if (!tmpMap[val]) {
          rst.push(val);
          tmpMap[val] = true;
        }
      }
    }
  }
  return rst;
};
function head(o) {
  if (isArrayLike(o)) {
    return o[0];
  }
  return void 0;
}
function last(o) {
  if (isArrayLike(o)) {
    var arr = o;
    return arr[arr.length - 1];
  }
  return void 0;
}
var every = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (!func(arr[i], i))
      return false;
  }
  return true;
};
var some = function(arr, func) {
  for (var i = 0; i < arr.length; i++) {
    if (func(arr[i], i))
      return true;
  }
  return false;
};
var hasOwnProperty$2 = Object.prototype.hasOwnProperty;
function groupBy(data2, condition) {
  if (!condition || !isArray$1(data2)) {
    return {};
  }
  var result = {};
  var predicate = isFunction(condition) ? condition : function(item2) {
    return item2[condition];
  };
  var key;
  for (var i = 0; i < data2.length; i++) {
    var item = data2[i];
    key = predicate(item);
    if (hasOwnProperty$2.call(result, key)) {
      result[key].push(item);
    } else {
      result[key] = [item];
    }
  }
  return result;
}
function groupToMap(data2, condition) {
  if (!condition) {
    return {
      0: data2
    };
  }
  if (!isFunction(condition)) {
    var paramscondition_1 = isArray$1(condition) ? condition : condition.replace(/\s+/g, "").split("*");
    condition = function(row) {
      var unique = "_";
      for (var i = 0, l = paramscondition_1.length; i < l; i++) {
        unique += row[paramscondition_1[i]] && row[paramscondition_1[i]].toString();
      }
      return unique;
    };
  }
  return groupBy(data2, condition);
}
const group$1 = function(data2, condition) {
  if (!condition) {
    return [data2];
  }
  var groups = groupToMap(data2, condition);
  var array2 = [];
  for (var i in groups) {
    array2.push(groups[i]);
  }
  return array2;
};
var clamp = function(a, min2, max2) {
  if (a < min2) {
    return min2;
  } else if (a > max2) {
    return max2;
  }
  return a;
};
var fixedBase = function(v, base) {
  var str = base.toString();
  var index2 = str.indexOf(".");
  if (index2 === -1) {
    return Math.round(v);
  }
  var length2 = str.substr(index2 + 1).length;
  if (length2 > 20) {
    length2 = 20;
  }
  return parseFloat(v.toFixed(length2));
};
var isNumber$1 = function(value2) {
  return isType$1(value2, "Number");
};
var PRECISION = 1e-5;
function isNumberEqual$1(a, b, precision) {
  if (precision === void 0) {
    precision = PRECISION;
  }
  return Math.abs(a - b) < precision;
}
const maxBy = function(arr, fn) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  var maxItem;
  var max2 = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v > max2) {
      maxItem = item;
      max2 = v;
    }
  }
  return maxItem;
};
const minBy = function(arr, fn) {
  if (!isArray$1(arr)) {
    return void 0;
  }
  var minItem;
  var min2 = Infinity;
  for (var i = 0; i < arr.length; i++) {
    var item = arr[i];
    var v = isFunction(fn) ? fn(item) : item[fn];
    if (v < min2) {
      minItem = item;
      min2 = v;
    }
  }
  return minItem;
};
var mod$1 = function(n, m) {
  return (n % m + m) % m;
};
var RADIAN = Math.PI / 180;
var toRadian = function(degree) {
  return RADIAN * degree;
};
const has = function(obj, key) {
  return obj.hasOwnProperty(key);
};
var values = Object.values ? function(obj) {
  return Object.values(obj);
} : function(obj) {
  var result = [];
  each$1(obj, function(value2, key) {
    if (!(isFunction(obj) && key === "prototype")) {
      result.push(value2);
    }
  });
  return result;
};
const toString$2 = function(value2) {
  if (isNil(value2))
    return "";
  return value2.toString();
};
var lowerCase = function(str) {
  return toString$2(str).toLowerCase();
};
function substitute(str, o) {
  if (!str || !o) {
    return str;
  }
  return str.replace(/\\?\{([^{}]+)\}/g, function(match, name) {
    if (match.charAt(0) === "\\") {
      return match.slice(1);
    }
    return o[name] === void 0 ? "" : o[name];
  });
}
var upperFirst = function(value2) {
  var str = toString$2(value2);
  return str.charAt(0).toUpperCase() + str.substring(1);
};
var toString$1 = {}.toString;
var getType = function(value2) {
  return toString$1.call(value2).replace(/^\[object /, "").replace(/]$/, "");
};
var isBoolean = function(value2) {
  return isType$1(value2, "Boolean");
};
var isDate = function(value2) {
  return isType$1(value2, "Date");
};
var isNull = function(value2) {
  return value2 === null;
};
var objectProto = Object.prototype;
var isPrototype = function(value2) {
  var Ctor = value2 && value2.constructor;
  var proto = typeof Ctor === "function" && Ctor.prototype || objectProto;
  return value2 === proto;
};
var isUndefined = function(value2) {
  return value2 === void 0;
};
var isElement = function(o) {
  return o instanceof Element || o instanceof HTMLDocument;
};
function requestAnimationFrame(fn) {
  var method = window.requestAnimationFrame || window.webkitRequestAnimationFrame || // @ts-ignore
  window.mozRequestAnimationFrame || // @ts-ignore
  window.msRequestAnimationFrame || function(f) {
    return setTimeout(f, 16);
  };
  return method(fn);
}
function cancelAnimationFrame(handler) {
  var method = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || // @ts-ignore
  window.mozCancelAnimationFrame || // @ts-ignore
  window.msCancelAnimationFrame || clearTimeout;
  method(handler);
}
function _mix(dist, obj) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key) && key !== "constructor" && obj[key] !== void 0) {
      dist[key] = obj[key];
    }
  }
}
function mix(dist, src1, src2, src3) {
  if (src1)
    _mix(dist, src1);
  if (src2)
    _mix(dist, src2);
  if (src3)
    _mix(dist, src3);
  return dist;
}
var clone = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return obj;
  }
  var rst;
  if (isArray$1(obj)) {
    rst = [];
    for (var i = 0, l = obj.length; i < l; i++) {
      if (typeof obj[i] === "object" && obj[i] != null) {
        rst[i] = clone(obj[i]);
      } else {
        rst[i] = obj[i];
      }
    }
  } else {
    rst = {};
    for (var k in obj) {
      if (typeof obj[k] === "object" && obj[k] != null) {
        rst[k] = clone(obj[k]);
      } else {
        rst[k] = obj[k];
      }
    }
  }
  return rst;
};
function debounce$1(func, wait, immediate) {
  var timeout2;
  return function() {
    var context = this, args = arguments;
    var later = function() {
      timeout2 = null;
      if (!immediate) {
        func.apply(context, args);
      }
    };
    var callNow = immediate && !timeout2;
    clearTimeout(timeout2);
    timeout2 = setTimeout(later, wait);
    if (callNow) {
      func.apply(context, args);
    }
  };
}
const memoize = function(f, resolver) {
  if (!isFunction(f)) {
    throw new TypeError("Expected a function");
  }
  var memoized = function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var key = resolver ? resolver.apply(this, args) : args[0];
    var cache2 = memoized.cache;
    if (cache2.has(key)) {
      return cache2.get(key);
    }
    var result = f.apply(this, args);
    cache2.set(key, result);
    return result;
  };
  memoized.cache = /* @__PURE__ */ new Map();
  return memoized;
};
var MAX_MIX_LEVEL$1 = 5;
function _deepMix(dist, src2, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL$1;
  for (var key in src2) {
    if (src2.hasOwnProperty(key)) {
      var value2 = src2[key];
      if (value2 !== null && isPlainObject$1(value2)) {
        if (!isPlainObject$1(dist[key])) {
          dist[key] = {};
        }
        if (level < maxLevel) {
          _deepMix(dist[key], value2, level + 1, maxLevel);
        } else {
          dist[key] = src2[key];
        }
      } else if (isArray$1(value2)) {
        dist[key] = [];
        dist[key] = dist[key].concat(value2);
      } else if (value2 !== void 0) {
        dist[key] = value2;
      }
    }
  }
}
var deepMix = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    _deepMix(rst, args[i]);
  }
  return rst;
};
var indexOf = function(arr, obj) {
  if (!isArrayLike(arr)) {
    return -1;
  }
  var m = Array.prototype.indexOf;
  if (m) {
    return m.call(arr, obj);
  }
  var index2 = -1;
  for (var i = 0; i < arr.length; i++) {
    if (arr[i] === obj) {
      index2 = i;
      break;
    }
  }
  return index2;
};
var hasOwnProperty$1 = Object.prototype.hasOwnProperty;
function isEmpty(value2) {
  if (isNil(value2)) {
    return true;
  }
  if (isArrayLike(value2)) {
    return !value2.length;
  }
  var type = getType(value2);
  if (type === "Map" || type === "Set") {
    return !value2.size;
  }
  if (isPrototype(value2)) {
    return !Object.keys(value2).length;
  }
  for (var key in value2) {
    if (hasOwnProperty$1.call(value2, key)) {
      return false;
    }
  }
  return true;
}
var isEqual$1 = function(value2, other2) {
  if (value2 === other2) {
    return true;
  }
  if (!value2 || !other2) {
    return false;
  }
  if (isString(value2) || isString(other2)) {
    return false;
  }
  if (isArrayLike(value2) || isArrayLike(other2)) {
    if (value2.length !== other2.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < value2.length; i++) {
      rst = isEqual$1(value2[i], other2[i]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  if (isObjectLike$1(value2) || isObjectLike$1(other2)) {
    var valueKeys = Object.keys(value2);
    var otherKeys = Object.keys(other2);
    if (valueKeys.length !== otherKeys.length) {
      return false;
    }
    var rst = true;
    for (var i = 0; i < valueKeys.length; i++) {
      rst = isEqual$1(value2[valueKeys[i]], other2[valueKeys[i]]);
      if (!rst) {
        break;
      }
    }
    return rst;
  }
  return false;
};
var map$2 = function(arr, func) {
  if (!isArrayLike(arr)) {
    return arr;
  }
  var result = [];
  for (var index2 = 0; index2 < arr.length; index2++) {
    var value2 = arr[index2];
    result.push(func(value2, index2));
  }
  return result;
};
var identity = function(v) {
  return v;
};
const mapValues = function(object2, func) {
  if (func === void 0) {
    func = identity;
  }
  var r = {};
  if (isObject(object2) && !isNil(object2)) {
    Object.keys(object2).forEach(function(key) {
      r[key] = func(object2[key], key);
    });
  }
  return r;
};
const get = function(obj, key, defaultValue) {
  var p = 0;
  var keyArr = isString(key) ? key.split(".") : key;
  while (obj && p < keyArr.length) {
    obj = obj[keyArr[p++]];
  }
  return obj === void 0 || p < keyArr.length ? defaultValue : obj;
};
const set = function(obj, path2, value2) {
  var o = obj;
  var keyArr = isString(path2) ? path2.split(".") : path2;
  keyArr.forEach(function(key, idx) {
    if (idx < keyArr.length - 1) {
      if (!isObject(o[key])) {
        o[key] = isNumber$1(keyArr[idx + 1]) ? [] : {};
      }
      o = o[key];
    } else {
      o[key] = value2;
    }
  });
  return obj;
};
var hasOwnProperty = Object.prototype.hasOwnProperty;
const pick$1 = function(object2, keys2) {
  if (object2 === null || !isPlainObject$1(object2)) {
    return {};
  }
  var result = {};
  each$1(keys2, function(key) {
    if (hasOwnProperty.call(object2, key)) {
      result[key] = object2[key];
    }
  });
  return result;
};
const omit$1 = function(obj, keys2) {
  return reduce(obj, function(r, curr, key) {
    if (!keys2.includes(key)) {
      r[key] = curr;
    }
    return r;
  }, {});
};
const throttle = function(func, wait, options) {
  var timeout2, context, args, result;
  var previous = 0;
  if (!options)
    options = {};
  var later = function() {
    previous = options.leading === false ? 0 : Date.now();
    timeout2 = null;
    result = func.apply(context, args);
    if (!timeout2)
      context = args = null;
  };
  var throttled = function() {
    var now2 = Date.now();
    if (!previous && options.leading === false)
      previous = now2;
    var remaining = wait - (now2 - previous);
    context = this;
    args = arguments;
    if (remaining <= 0 || remaining > wait) {
      if (timeout2) {
        clearTimeout(timeout2);
        timeout2 = null;
      }
      previous = now2;
      result = func.apply(context, args);
      if (!timeout2)
        context = args = null;
    } else if (!timeout2 && options.trailing !== false) {
      timeout2 = setTimeout(later, remaining);
    }
    return result;
  };
  throttled.cancel = function() {
    clearTimeout(timeout2);
    previous = 0;
    timeout2 = context = args = null;
  };
  return throttled;
};
const toArray = function(value2) {
  return isArrayLike(value2) ? Array.prototype.slice.call(value2) : [];
};
var map$1 = {};
const uniqueId = function(prefix) {
  prefix = prefix || "g";
  if (!map$1[prefix]) {
    map$1[prefix] = 1;
  } else {
    map$1[prefix] += 1;
  }
  return prefix + map$1[prefix];
};
const noop = function() {
};
function size(o) {
  if (isNil(o)) {
    return 0;
  }
  if (isArrayLike(o)) {
    return o.length;
  }
  return Object.keys(o).length;
}
var ctx$2;
const measureTextWidth$1 = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  if (!ctx$2) {
    ctx$2 = document.createElement("canvas").getContext("2d");
  }
  ctx$2.font = [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ");
  return ctx$2.measureText(isString(text2) ? text2 : "").width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArrays([text2], values(font)).join("");
});
const getEllipsisText$1 = function(text2, maxWidth, font, str) {
  if (str === void 0) {
    str = "...";
  }
  var STEP = 16;
  var PLACEHOLDER_WIDTH = measureTextWidth$1(str, font);
  var leftText = !isString(text2) ? toString$2(text2) : text2;
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth$1(text2, font) <= maxWidth) {
    return text2;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth$1(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth$1(currentText, font);
    if (currentWidth + PLACEHOLDER_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "" + r.join("") + str;
};
var default_1 = (
  /** @class */
  function() {
    function default_12() {
      this.map = {};
    }
    default_12.prototype.has = function(key) {
      return this.map[key] !== void 0;
    };
    default_12.prototype.get = function(key, def) {
      var v = this.map[key];
      return v === void 0 ? def : v;
    };
    default_12.prototype.set = function(key, value2) {
      this.map[key] = value2;
    };
    default_12.prototype.clear = function() {
      this.map = {};
    };
    default_12.prototype.delete = function(key) {
      delete this.map[key];
    };
    default_12.prototype.size = function() {
      return Object.keys(this.map).length;
    };
    return default_12;
  }()
);
var LAYER;
(function(LAYER2) {
  LAYER2["FORE"] = "fore";
  LAYER2["MID"] = "mid";
  LAYER2["BG"] = "bg";
})(LAYER || (LAYER = {}));
var DIRECTION;
(function(DIRECTION2) {
  DIRECTION2["TOP"] = "top";
  DIRECTION2["TOP_LEFT"] = "top-left";
  DIRECTION2["TOP_RIGHT"] = "top-right";
  DIRECTION2["RIGHT"] = "right";
  DIRECTION2["RIGHT_TOP"] = "right-top";
  DIRECTION2["RIGHT_BOTTOM"] = "right-bottom";
  DIRECTION2["LEFT"] = "left";
  DIRECTION2["LEFT_TOP"] = "left-top";
  DIRECTION2["LEFT_BOTTOM"] = "left-bottom";
  DIRECTION2["BOTTOM"] = "bottom";
  DIRECTION2["BOTTOM_LEFT"] = "bottom-left";
  DIRECTION2["BOTTOM_RIGHT"] = "bottom-right";
  DIRECTION2["RADIUS"] = "radius";
  DIRECTION2["CIRCLE"] = "circle";
  DIRECTION2["NONE"] = "none";
})(DIRECTION || (DIRECTION = {}));
var COMPONENT_TYPE;
(function(COMPONENT_TYPE2) {
  COMPONENT_TYPE2["AXIS"] = "axis";
  COMPONENT_TYPE2["GRID"] = "grid";
  COMPONENT_TYPE2["LEGEND"] = "legend";
  COMPONENT_TYPE2["TOOLTIP"] = "tooltip";
  COMPONENT_TYPE2["ANNOTATION"] = "annotation";
  COMPONENT_TYPE2["SLIDER"] = "slider";
  COMPONENT_TYPE2["SCROLLBAR"] = "scrollbar";
  COMPONENT_TYPE2["OTHER"] = "other";
})(COMPONENT_TYPE || (COMPONENT_TYPE = {}));
var GROUP_Z_INDEX = {
  FORE: 3,
  MID: 2,
  BG: 1
};
var VIEW_LIFE_CIRCLE;
(function(VIEW_LIFE_CIRCLE2) {
  VIEW_LIFE_CIRCLE2["BEFORE_RENDER"] = "beforerender";
  VIEW_LIFE_CIRCLE2["AFTER_RENDER"] = "afterrender";
  VIEW_LIFE_CIRCLE2["BEFORE_PAINT"] = "beforepaint";
  VIEW_LIFE_CIRCLE2["AFTER_PAINT"] = "afterpaint";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_DATA"] = "beforechangedata";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_DATA"] = "afterchangedata";
  VIEW_LIFE_CIRCLE2["BEFORE_CLEAR"] = "beforeclear";
  VIEW_LIFE_CIRCLE2["AFTER_CLEAR"] = "afterclear";
  VIEW_LIFE_CIRCLE2["BEFORE_DESTROY"] = "beforedestroy";
  VIEW_LIFE_CIRCLE2["BEFORE_CHANGE_SIZE"] = "beforechangesize";
  VIEW_LIFE_CIRCLE2["AFTER_CHANGE_SIZE"] = "afterchangesize";
})(VIEW_LIFE_CIRCLE || (VIEW_LIFE_CIRCLE = {}));
var GEOMETRY_LIFE_CIRCLE;
(function(GEOMETRY_LIFE_CIRCLE2) {
  GEOMETRY_LIFE_CIRCLE2["BEFORE_DRAW_ANIMATE"] = "beforeanimate";
  GEOMETRY_LIFE_CIRCLE2["AFTER_DRAW_ANIMATE"] = "afteranimate";
  GEOMETRY_LIFE_CIRCLE2["BEFORE_RENDER_LABEL"] = "beforerenderlabel";
  GEOMETRY_LIFE_CIRCLE2["AFTER_RENDER_LABEL"] = "afterrenderlabel";
})(GEOMETRY_LIFE_CIRCLE || (GEOMETRY_LIFE_CIRCLE = {}));
var PLOT_EVENTS;
(function(PLOT_EVENTS2) {
  PLOT_EVENTS2["MOUSE_ENTER"] = "plot:mouseenter";
  PLOT_EVENTS2["MOUSE_DOWN"] = "plot:mousedown";
  PLOT_EVENTS2["MOUSE_MOVE"] = "plot:mousemove";
  PLOT_EVENTS2["MOUSE_UP"] = "plot:mouseup";
  PLOT_EVENTS2["MOUSE_LEAVE"] = "plot:mouseleave";
  PLOT_EVENTS2["TOUCH_START"] = "plot:touchstart";
  PLOT_EVENTS2["TOUCH_MOVE"] = "plot:touchmove";
  PLOT_EVENTS2["TOUCH_END"] = "plot:touchend";
  PLOT_EVENTS2["TOUCH_CANCEL"] = "plot:touchcancel";
  PLOT_EVENTS2["CLICK"] = "plot:click";
  PLOT_EVENTS2["DBLCLICK"] = "plot:dblclick";
  PLOT_EVENTS2["CONTEXTMENU"] = "plot:contextmenu";
  PLOT_EVENTS2["LEAVE"] = "plot:leave";
  PLOT_EVENTS2["ENTER"] = "plot:enter";
})(PLOT_EVENTS || (PLOT_EVENTS = {}));
var ELEMENT_STATE;
(function(ELEMENT_STATE2) {
  ELEMENT_STATE2["ACTIVE"] = "active";
  ELEMENT_STATE2["INACTIVE"] = "inactive";
  ELEMENT_STATE2["SELECTED"] = "selected";
  ELEMENT_STATE2["DEFAULT"] = "default";
})(ELEMENT_STATE || (ELEMENT_STATE = {}));
var GROUP_ATTRS = ["color", "shape", "size"];
var FIELD_ORIGIN = "_origin";
var MIN_CHART_WIDTH = 1;
var MIN_CHART_HEIGHT = 1;
var COMPONENT_MAX_VIEW_PERCENTAGE = 0.25;
var ENGINES = {};
function getEngine(name) {
  var G = ENGINES[name];
  if (!G) {
    throw new Error("G engine '".concat(name, "' is not exist, please register it at first."));
  }
  return G;
}
function registerEngine(name, engine) {
  ENGINES[name] = engine;
}
function addEventListener(target2, eventType, callback) {
  if (target2) {
    if (typeof target2.addEventListener === "function") {
      target2.addEventListener(eventType, callback, false);
      return {
        remove: function() {
          target2.removeEventListener(eventType, callback, false);
        }
      };
    }
    if (typeof target2.attachEvent === "function") {
      target2.attachEvent("on" + eventType, callback);
      return {
        remove: function() {
          target2.detachEvent("on" + eventType, callback);
        }
      };
    }
  }
}
var TABLE;
var TABLE_TR;
var FRAGMENT_REG;
var CONTAINERS;
function initConstants() {
  TABLE = document.createElement("table");
  TABLE_TR = document.createElement("tr");
  FRAGMENT_REG = /^\s*<(\w+|!)[^>]*>/;
  CONTAINERS = {
    tr: document.createElement("tbody"),
    tbody: TABLE,
    thead: TABLE,
    tfoot: TABLE,
    td: TABLE_TR,
    th: TABLE_TR,
    "*": document.createElement("div")
  };
}
function createDom$1(str) {
  if (!TABLE) {
    initConstants();
  }
  var name = FRAGMENT_REG.test(str) && RegExp.$1;
  if (!name || !(name in CONTAINERS)) {
    name = "*";
  }
  var container = CONTAINERS[name];
  str = typeof str === "string" ? str.replace(/(^\s*)|(\s*$)/g, "") : str;
  container.innerHTML = "" + str;
  var dom = container.childNodes[0];
  if (dom && container.contains(dom)) {
    container.removeChild(dom);
  }
  return dom;
}
function getStyle$1(dom, name, defaultValue) {
  var v;
  try {
    v = window.getComputedStyle ? window.getComputedStyle(dom, null)[name] : dom.style[name];
  } catch (e) {
  } finally {
    v = v === void 0 ? defaultValue : v;
  }
  return v;
}
function getHeight$1(el, defaultValue) {
  var height = getStyle$1(el, "height", defaultValue);
  if (height === "auto") {
    height = el.offsetHeight;
  }
  return parseFloat(height);
}
function getOuterHeight(el, defaultValue) {
  var height = getHeight$1(el, defaultValue);
  var bTop = parseFloat(getStyle$1(el, "borderTopWidth")) || 0;
  var pTop = parseFloat(getStyle$1(el, "paddingTop")) || 0;
  var pBottom = parseFloat(getStyle$1(el, "paddingBottom")) || 0;
  var bBottom = parseFloat(getStyle$1(el, "borderBottomWidth")) || 0;
  var mTop = parseFloat(getStyle$1(el, "marginTop")) || 0;
  var mBottom = parseFloat(getStyle$1(el, "marginBottom")) || 0;
  return height + bTop + bBottom + pTop + pBottom + mTop + mBottom;
}
function getHeight(el, defaultValue) {
  var width = getStyle$1(el, "width", defaultValue);
  if (width === "auto") {
    width = el.offsetWidth;
  }
  return parseFloat(width);
}
function getOuterWidth(el, defaultValue) {
  var width = getHeight(el, defaultValue);
  var bLeft = parseFloat(getStyle$1(el, "borderLeftWidth")) || 0;
  var pLeft = parseFloat(getStyle$1(el, "paddingLeft")) || 0;
  var pRight = parseFloat(getStyle$1(el, "paddingRight")) || 0;
  var bRight = parseFloat(getStyle$1(el, "borderRightWidth")) || 0;
  var mRight = parseFloat(getStyle$1(el, "marginRight")) || 0;
  var mLeft = parseFloat(getStyle$1(el, "marginLeft")) || 0;
  return width + bLeft + bRight + pLeft + pRight + mLeft + mRight;
}
function modifyCSS(dom, css) {
  if (dom) {
    for (var key in css) {
      if (css.hasOwnProperty(key)) {
        dom.style[key] = css[key];
      }
    }
  }
  return dom;
}
function getElementSize(ele) {
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function isNumber(v) {
  return typeof v === "number" && !isNaN(v);
}
function getChartSize(ele, autoFit, width, height) {
  var w = width;
  var h = height;
  if (autoFit) {
    var size2 = getElementSize(ele);
    w = size2.width ? size2.width : w;
    h = size2.height ? size2.height : h;
  }
  return {
    width: Math.max(isNumber(w) ? w : MIN_CHART_WIDTH, MIN_CHART_WIDTH),
    height: Math.max(isNumber(h) ? h : MIN_CHART_HEIGHT, MIN_CHART_HEIGHT)
  };
}
function removeDom(dom) {
  var parent = dom.parentNode;
  if (parent) {
    parent.removeChild(dom);
  }
}
var WILDCARD$1 = "*";
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2() {
      this._events = {};
    }
    EventEmitter2.prototype.on = function(evt, callback, once) {
      if (!this._events[evt]) {
        this._events[evt] = [];
      }
      this._events[evt].push({
        callback,
        once: !!once
      });
      return this;
    };
    EventEmitter2.prototype.once = function(evt, callback) {
      return this.on(evt, callback, true);
    };
    EventEmitter2.prototype.emit = function(evt) {
      var _this = this;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var events = this._events[evt] || [];
      var wildcardEvents = this._events[WILDCARD$1] || [];
      var doEmit = function(es) {
        var length2 = es.length;
        for (var i = 0; i < length2; i++) {
          if (!es[i]) {
            continue;
          }
          var _a2 = es[i], callback = _a2.callback, once = _a2.once;
          if (once) {
            es.splice(i, 1);
            if (es.length === 0) {
              delete _this._events[evt];
            }
            length2--;
            i--;
          }
          callback.apply(_this, args);
        }
      };
      doEmit(events);
      doEmit(wildcardEvents);
    };
    EventEmitter2.prototype.off = function(evt, callback) {
      if (!evt) {
        this._events = {};
      } else {
        if (!callback) {
          delete this._events[evt];
        } else {
          var events = this._events[evt] || [];
          var length_1 = events.length;
          for (var i = 0; i < length_1; i++) {
            if (events[i].callback === callback) {
              events.splice(i, 1);
              length_1--;
              i--;
            }
          }
          if (events.length === 0) {
            delete this._events[evt];
          }
        }
      }
      return this;
    };
    EventEmitter2.prototype.getEvents = function() {
      return this._events;
    };
    return EventEmitter2;
  }()
);
var Base$1 = (
  /** @class */
  function(_super) {
    __extends$1(Base2, _super);
    function Base2(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var _a2 = cfg.visible, visible = _a2 === void 0 ? true : _a2;
      _this.visible = visible;
      return _this;
    }
    Base2.prototype.show = function() {
      var visible = this.visible;
      if (!visible) {
        this.changeVisible(true);
      }
    };
    Base2.prototype.hide = function() {
      var visible = this.visible;
      if (visible) {
        this.changeVisible(false);
      }
    };
    Base2.prototype.destroy = function() {
      this.off();
      this.destroyed = true;
    };
    Base2.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.visible = visible;
    };
    return Base2;
  }(EventEmitter)
);
var SPACES$1 = "	\n\v\f\r \u2028\u2029";
var PATH_COMMAND$1 = new RegExp("([a-z])[" + SPACES$1 + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*)+)", "ig");
var PATH_VALUES$1 = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES$1 + "]*,?[" + SPACES$1 + "]*", "ig");
var parsePathString$1 = function(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND$1, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES$1, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b, params[0]]);
    }
    if (name === "r") {
      data2.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return pathString;
  });
  return data2;
};
var catmullRomToBezier = function(crp, z) {
  var d = [];
  for (var i = 0, iLen = crp.length; iLen - 2 * !z > i; i += 2) {
    var p = [
      {
        x: +crp[i - 2],
        y: +crp[i - 1]
      },
      {
        x: +crp[i],
        y: +crp[i + 1]
      },
      {
        x: +crp[i + 2],
        y: +crp[i + 3]
      },
      {
        x: +crp[i + 4],
        y: +crp[i + 5]
      }
    ];
    if (z) {
      if (!i) {
        p[0] = {
          x: +crp[iLen - 2],
          y: +crp[iLen - 1]
        };
      } else if (iLen - 4 === i) {
        p[3] = {
          x: +crp[0],
          y: +crp[1]
        };
      } else if (iLen - 2 === i) {
        p[2] = {
          x: +crp[0],
          y: +crp[1]
        };
        p[3] = {
          x: +crp[2],
          y: +crp[3]
        };
      }
    } else {
      if (iLen - 4 === i) {
        p[3] = p[2];
      } else if (!i) {
        p[0] = {
          x: +crp[i],
          y: +crp[i + 1]
        };
      }
    }
    d.push([
      "C",
      (-p[0].x + 6 * p[1].x + p[2].x) / 6,
      (-p[0].y + 6 * p[1].y + p[2].y) / 6,
      (p[1].x + 6 * p[2].x - p[3].x) / 6,
      (p[1].y + 6 * p[2].y - p[3].y) / 6,
      p[2].x,
      p[2].y
    ]);
  }
  return d;
};
var ellipsePath = function(x, y, rx, ry, a) {
  var res = [];
  if (a === null && ry === null) {
    ry = rx;
  }
  x = +x;
  y = +y;
  rx = +rx;
  ry = +ry;
  if (a !== null) {
    var rad = Math.PI / 180;
    var x1 = x + rx * Math.cos(-ry * rad);
    var x2 = x + rx * Math.cos(-a * rad);
    var y1 = y + rx * Math.sin(-ry * rad);
    var y2 = y + rx * Math.sin(-a * rad);
    res = [
      ["M", x1, y1],
      ["A", rx, rx, 0, +(a - ry > 180), 0, x2, y2]
    ];
  } else {
    res = [["M", x, y], ["m", 0, -ry], ["a", rx, ry, 0, 1, 1, 0, 2 * ry], ["a", rx, ry, 0, 1, 1, 0, -2 * ry], ["z"]];
  }
  return res;
};
var pathToAbsolute$1 = function(pathArray) {
  pathArray = parsePathString$1(pathArray);
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var pa0;
  var dots;
  if (pathArray[0][0] === "M") {
    x = +pathArray[0][1];
    y = +pathArray[0][2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  var crz = pathArray.length === 3 && pathArray[0][0] === "M" && pathArray[1][0].toUpperCase() === "R" && pathArray[2][0].toUpperCase() === "Z";
  for (var r = void 0, pa = void 0, i = start, ii = pathArray.length; i < ii; i++) {
    res.push(r = []);
    pa = pathArray[i];
    pa0 = pa[0];
    if (pa0 !== pa0.toUpperCase()) {
      r[0] = pa0.toUpperCase();
      switch (r[0]) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "R":
          dots = [x, y].concat(pa.slice(1));
          for (var j = 2, jj = dots.length; j < jj; j++) {
            dots[j] = +dots[j] + x;
            dots[++j] = +dots[j] + y;
          }
          res.pop();
          res = res.concat(catmullRomToBezier(dots, crz));
          break;
        case "O":
          res.pop();
          dots = ellipsePath(x, y, pa[1], pa[2]);
          dots.push(dots[0]);
          res = res.concat(dots);
          break;
        case "U":
          res.pop();
          res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
          r = ["U"].concat(res[res.length - 1].slice(-2));
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else if (pa0 === "R") {
      dots = [x, y].concat(pa.slice(1));
      res.pop();
      res = res.concat(catmullRomToBezier(dots, crz));
      r = ["R"].concat(pa.slice(-2));
    } else if (pa0 === "O") {
      res.pop();
      dots = ellipsePath(x, y, pa[1], pa[2]);
      dots.push(dots[0]);
      res = res.concat(dots);
    } else if (pa0 === "U") {
      res.pop();
      res = res.concat(ellipsePath(x, y, pa[1], pa[2], pa[3]));
      r = ["U"].concat(res[res.length - 1].slice(-2));
    } else {
      for (var k = 0, kk = pa.length; k < kk; k++) {
        r[k] = pa[k];
      }
    }
    pa0 = pa0.toUpperCase();
    if (pa0 !== "O") {
      switch (r[0]) {
        case "Z":
          x = +mx;
          y = +my;
          break;
        case "H":
          x = r[1];
          break;
        case "V":
          y = r[1];
          break;
        case "M":
          mx = r[r.length - 2];
          my = r[r.length - 1];
          break;
        default:
          x = r[r.length - 2];
          y = r[r.length - 1];
      }
    }
  }
  return res;
};
var l2c = function(x1, y1, x2, y2) {
  return [x1, y1, x2, y2, x2, y2];
};
var q2c = function(x1, y1, ax, ay, x2, y2) {
  var _13 = 1 / 3;
  var _23 = 2 / 3;
  return [_13 * x1 + _23 * ax, _13 * y1 + _23 * ay, _13 * x2 + _23 * ax, _13 * y2 + _23 * ay, x2, y2];
};
var a2c = function(x1, y1, rx, ry, angle2, large_arc_flag, sweep_flag, x2, y2, recursive) {
  if (rx === ry) {
    rx += 1;
  }
  var _120 = Math.PI * 120 / 180;
  var rad = Math.PI / 180 * (+angle2 || 0);
  var res = [];
  var xy;
  var f1;
  var f2;
  var cx;
  var cy;
  var rotate2 = function(x3, y3, rad2) {
    var X = x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
    var Y = x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
    return {
      x: X,
      y: Y
    };
  };
  if (!recursive) {
    xy = rotate2(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate2(x2, y2, -rad);
    x2 = xy.x;
    y2 = xy.y;
    if (x1 === x2 && y1 === y2) {
      x2 += 1;
      y2 += 1;
    }
    var x = (x1 - x2) / 2;
    var y = (y1 - y2) / 2;
    var h = x * x / (rx * rx) + y * y / (ry * ry);
    if (h > 1) {
      h = Math.sqrt(h);
      rx = h * rx;
      ry = h * ry;
    }
    var rx2 = rx * rx;
    var ry2 = ry * ry;
    var k = (large_arc_flag === sweep_flag ? -1 : 1) * Math.sqrt(Math.abs((rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)));
    cx = k * rx * y / ry + (x1 + x2) / 2;
    cy = k * -ry * x / rx + (y1 + y2) / 2;
    f1 = Math.asin(((y1 - cy) / ry).toFixed(9));
    f2 = Math.asin(((y2 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? Math.PI - f1 : f1;
    f2 = x2 < cx ? Math.PI - f2 : f2;
    f1 < 0 && (f1 = Math.PI * 2 + f1);
    f2 < 0 && (f2 = Math.PI * 2 + f2);
    if (sweep_flag && f1 > f2) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweep_flag && f2 > f1) {
      f2 = f2 - Math.PI * 2;
    }
  } else {
    f1 = recursive[0];
    f2 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f2 - f1;
  if (Math.abs(df) > _120) {
    var f2old = f2;
    var x2old = x2;
    var y2old = y2;
    f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
    x2 = cx + rx * Math.cos(f2);
    y2 = cy + ry * Math.sin(f2);
    res = a2c(x2, y2, rx, ry, angle2, 0, sweep_flag, x2old, y2old, [f2, f2old, cx, cy]);
  }
  df = f2 - f1;
  var c1 = Math.cos(f1);
  var s1 = Math.sin(f1);
  var c2 = Math.cos(f2);
  var s2 = Math.sin(f2);
  var t = Math.tan(df / 4);
  var hx = 4 / 3 * rx * t;
  var hy = 4 / 3 * ry * t;
  var m1 = [x1, y1];
  var m2 = [x1 + hx * s1, y1 - hy * c1];
  var m3 = [x2 + hx * s2, y2 - hy * c2];
  var m4 = [x2, y2];
  m2[0] = 2 * m1[0] - m2[0];
  m2[1] = 2 * m1[1] - m2[1];
  if (recursive) {
    return [m2, m3, m4].concat(res);
  }
  res = [m2, m3, m4].concat(res).join().split(",");
  var newres = [];
  for (var i = 0, ii = res.length; i < ii; i++) {
    newres[i] = i % 2 ? rotate2(res[i - 1], res[i], rad).y : rotate2(res[i], res[i + 1], rad).x;
  }
  return newres;
};
var pathToCurve = function(path2, path22) {
  var p = pathToAbsolute$1(path2);
  var p2 = path22 && pathToAbsolute$1(path22);
  var attrs = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var attrs2 = {
    x: 0,
    y: 0,
    bx: 0,
    by: 0,
    X: 0,
    Y: 0,
    qx: null,
    qy: null
  };
  var pcoms1 = [];
  var pcoms2 = [];
  var pfirst = "";
  var pcom = "";
  var ii;
  var processPath = function(path3, d, pcom2) {
    var nx;
    var ny;
    if (!path3) {
      return ["C", d.x, d.y, d.x, d.y, d.x, d.y];
    }
    !(path3[0] in {
      T: 1,
      Q: 1
    }) && (d.qx = d.qy = null);
    switch (path3[0]) {
      case "M":
        d.X = path3[1];
        d.Y = path3[2];
        break;
      case "A":
        path3 = ["C"].concat(a2c.apply(0, [d.x, d.y].concat(path3.slice(1))));
        break;
      case "S":
        if (pcom2 === "C" || pcom2 === "S") {
          nx = d.x * 2 - d.bx;
          ny = d.y * 2 - d.by;
        } else {
          nx = d.x;
          ny = d.y;
        }
        path3 = ["C", nx, ny].concat(path3.slice(1));
        break;
      case "T":
        if (pcom2 === "Q" || pcom2 === "T") {
          d.qx = d.x * 2 - d.qx;
          d.qy = d.y * 2 - d.qy;
        } else {
          d.qx = d.x;
          d.qy = d.y;
        }
        path3 = ["C"].concat(q2c(d.x, d.y, d.qx, d.qy, path3[1], path3[2]));
        break;
      case "Q":
        d.qx = path3[1];
        d.qy = path3[2];
        path3 = ["C"].concat(q2c(d.x, d.y, path3[1], path3[2], path3[3], path3[4]));
        break;
      case "L":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], path3[2]));
        break;
      case "H":
        path3 = ["C"].concat(l2c(d.x, d.y, path3[1], d.y));
        break;
      case "V":
        path3 = ["C"].concat(l2c(d.x, d.y, d.x, path3[1]));
        break;
      case "Z":
        path3 = ["C"].concat(l2c(d.x, d.y, d.X, d.Y));
        break;
    }
    return path3;
  };
  var fixArc = function(pp, i2) {
    if (pp[i2].length > 7) {
      pp[i2].shift();
      var pi2 = pp[i2];
      while (pi2.length) {
        pcoms1[i2] = "A";
        p2 && (pcoms2[i2] = "A");
        pp.splice(i2++, 0, ["C"].concat(pi2.splice(0, 6)));
      }
      pp.splice(i2, 1);
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  var fixM = function(path1, path23, a1, a2, i2) {
    if (path1 && path23 && path1[i2][0] === "M" && path23[i2][0] !== "M") {
      path23.splice(i2, 0, ["M", a2.x, a2.y]);
      a1.bx = 0;
      a1.by = 0;
      a1.x = path1[i2][1];
      a1.y = path1[i2][2];
      ii = Math.max(p.length, p2 && p2.length || 0);
    }
  };
  ii = Math.max(p.length, p2 && p2.length || 0);
  for (var i = 0; i < ii; i++) {
    p[i] && (pfirst = p[i][0]);
    if (pfirst !== "C") {
      pcoms1[i] = pfirst;
      i && (pcom = pcoms1[i - 1]);
    }
    p[i] = processPath(p[i], attrs, pcom);
    if (pcoms1[i] !== "A" && pfirst === "C")
      pcoms1[i] = "C";
    fixArc(p, i);
    if (p2) {
      p2[i] && (pfirst = p2[i][0]);
      if (pfirst !== "C") {
        pcoms2[i] = pfirst;
        i && (pcom = pcoms2[i - 1]);
      }
      p2[i] = processPath(p2[i], attrs2, pcom);
      if (pcoms2[i] !== "A" && pfirst === "C") {
        pcoms2[i] = "C";
      }
      fixArc(p2, i);
    }
    fixM(p, p2, attrs, attrs2, i);
    fixM(p2, p, attrs2, attrs, i);
    var seg = p[i];
    var seg2 = p2 && p2[i];
    var seglen = seg.length;
    var seg2len = p2 && seg2.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = parseFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = parseFloat(seg[seglen - 3]) || attrs.y;
    attrs2.bx = p2 && (parseFloat(seg2[seg2len - 4]) || attrs2.x);
    attrs2.by = p2 && (parseFloat(seg2[seg2len - 3]) || attrs2.y);
    attrs2.x = p2 && seg2[seg2len - 2];
    attrs2.y = p2 && seg2[seg2len - 1];
  }
  return p2 ? [p, p2] : p;
};
var p2s = /,?([a-z]),?/gi;
var parsePathArray = function(path2) {
  return path2.join(",").replace(p2s, "$1");
};
var base3 = function(t, p1, p2, p3, p4) {
  var t1 = -3 * p1 + 9 * p2 - 9 * p3 + 3 * p4;
  var t2 = t * t1 + 6 * p1 - 12 * p2 + 6 * p3;
  return t * t2 - 3 * p1 + 3 * p2;
};
var bezlen = function(x1, y1, x2, y2, x3, y3, x4, y4, z) {
  if (z === null) {
    z = 1;
  }
  z = z > 1 ? 1 : z < 0 ? 0 : z;
  var z2 = z / 2;
  var n = 12;
  var Tvalues = [
    -0.1252,
    0.1252,
    -0.3678,
    0.3678,
    -0.5873,
    0.5873,
    -0.7699,
    0.7699,
    -0.9041,
    0.9041,
    -0.9816,
    0.9816
  ];
  var Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472];
  var sum = 0;
  for (var i = 0; i < n; i++) {
    var ct = z2 * Tvalues[i] + z2;
    var xbase = base3(ct, x1, x2, x3, x4);
    var ybase = base3(ct, y1, y2, y3, y4);
    var comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i] * Math.sqrt(comb);
  }
  return z2 * sum;
};
var curveDim = function(x0, y0, x1, y1, x2, y2, x3, y3) {
  var tvalues = [];
  var bounds = [[], []];
  var a;
  var b;
  var c;
  var t;
  for (var i = 0; i < 2; ++i) {
    if (i === 0) {
      b = 6 * x0 - 12 * x1 + 6 * x2;
      a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;
      c = 3 * x1 - 3 * x0;
    } else {
      b = 6 * y0 - 12 * y1 + 6 * y2;
      a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;
      c = 3 * y1 - 3 * y0;
    }
    if (Math.abs(a) < 1e-12) {
      if (Math.abs(b) < 1e-12) {
        continue;
      }
      t = -c / b;
      if (t > 0 && t < 1) {
        tvalues.push(t);
      }
      continue;
    }
    var b2ac = b * b - 4 * c * a;
    var sqrtb2ac = Math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    var t1 = (-b + sqrtb2ac) / (2 * a);
    if (t1 > 0 && t1 < 1) {
      tvalues.push(t1);
    }
    var t2 = (-b - sqrtb2ac) / (2 * a);
    if (t2 > 0 && t2 < 1) {
      tvalues.push(t2);
    }
  }
  var j = tvalues.length;
  var jlen = j;
  var mt;
  while (j--) {
    t = tvalues[j];
    mt = 1 - t;
    bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;
    bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x3;
  bounds[1][jlen + 1] = y3;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    min: {
      x: Math.min.apply(0, bounds[0]),
      y: Math.min.apply(0, bounds[1])
    },
    max: {
      x: Math.max.apply(0, bounds[0]),
      y: Math.max.apply(0, bounds[1])
    }
  };
};
var intersect$1 = function(x1, y1, x2, y2, x3, y3, x4, y4) {
  if (Math.max(x1, x2) < Math.min(x3, x4) || Math.min(x1, x2) > Math.max(x3, x4) || Math.max(y1, y2) < Math.min(y3, y4) || Math.min(y1, y2) > Math.max(y3, y4)) {
    return;
  }
  var nx = (x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4);
  var ny = (x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4);
  var denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);
  if (!denominator) {
    return;
  }
  var px = nx / denominator;
  var py = ny / denominator;
  var px2 = +px.toFixed(2);
  var py2 = +py.toFixed(2);
  if (px2 < +Math.min(x1, x2).toFixed(2) || px2 > +Math.max(x1, x2).toFixed(2) || px2 < +Math.min(x3, x4).toFixed(2) || px2 > +Math.max(x3, x4).toFixed(2) || py2 < +Math.min(y1, y2).toFixed(2) || py2 > +Math.max(y1, y2).toFixed(2) || py2 < +Math.min(y3, y4).toFixed(2) || py2 > +Math.max(y3, y4).toFixed(2)) {
    return;
  }
  return {
    x: px,
    y: py
  };
};
var isPointInsideBBox = function(bbox, x, y) {
  return x >= bbox.x && x <= bbox.x + bbox.width && y >= bbox.y && y <= bbox.y + bbox.height;
};
var rectPath = function(x, y, w, h, r) {
  if (r) {
    return [
      ["M", +x + +r, y],
      ["l", w - r * 2, 0],
      ["a", r, r, 0, 0, 1, r, r],
      ["l", 0, h - r * 2],
      ["a", r, r, 0, 0, 1, -r, r],
      ["l", r * 2 - w, 0],
      ["a", r, r, 0, 0, 1, -r, -r],
      ["l", 0, r * 2 - h],
      ["a", r, r, 0, 0, 1, r, -r],
      ["z"]
    ];
  }
  var res = [["M", x, y], ["l", w, 0], ["l", 0, h], ["l", -w, 0], ["z"]];
  res.parsePathArray = parsePathArray;
  return res;
};
var box = function(x, y, width, height) {
  if (x === null) {
    x = y = width = height = 0;
  }
  if (y === null) {
    y = x.y;
    width = x.width;
    height = x.height;
    x = x.x;
  }
  return {
    x,
    y,
    width,
    w: width,
    height,
    h: height,
    x2: x + width,
    y2: y + height,
    cx: x + width / 2,
    cy: y + height / 2,
    r1: Math.min(width, height) / 2,
    r2: Math.max(width, height) / 2,
    r0: Math.sqrt(width * width + height * height) / 2,
    path: rectPath(x, y, width, height),
    vb: [x, y, width, height].join(" ")
  };
};
var isBBoxIntersect = function(bbox1, bbox2) {
  bbox1 = box(bbox1);
  bbox2 = box(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
};
var bezierBBox = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y) {
  if (!isArray$1(p1x)) {
    p1x = [p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y];
  }
  var bbox = curveDim.apply(null, p1x);
  return box(bbox.min.x, bbox.min.y, bbox.max.x - bbox.min.x, bbox.max.y - bbox.min.y);
};
var findDotsAtSegment = function(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t) {
  var t1 = 1 - t;
  var t13 = Math.pow(t1, 3);
  var t12 = Math.pow(t1, 2);
  var t2 = t * t;
  var t3 = t2 * t;
  var x = t13 * p1x + t12 * 3 * t * c1x + t1 * 3 * t * t * c2x + t3 * p2x;
  var y = t13 * p1y + t12 * 3 * t * c1y + t1 * 3 * t * t * c2y + t3 * p2y;
  var mx = p1x + 2 * t * (c1x - p1x) + t2 * (c2x - 2 * c1x + p1x);
  var my = p1y + 2 * t * (c1y - p1y) + t2 * (c2y - 2 * c1y + p1y);
  var nx = c1x + 2 * t * (c2x - c1x) + t2 * (p2x - 2 * c2x + c1x);
  var ny = c1y + 2 * t * (c2y - c1y) + t2 * (p2y - 2 * c2y + c1y);
  var ax = t1 * p1x + t * c1x;
  var ay = t1 * p1y + t * c1y;
  var cx = t1 * c2x + t * p2x;
  var cy = t1 * c2y + t * p2y;
  var alpha = 90 - Math.atan2(mx - nx, my - ny) * 180 / Math.PI;
  return {
    x,
    y,
    m: {
      x: mx,
      y: my
    },
    n: {
      x: nx,
      y: ny
    },
    start: {
      x: ax,
      y: ay
    },
    end: {
      x: cx,
      y: cy
    },
    alpha
  };
};
var interHelper = function(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1);
  var bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen.apply(0, bez1);
  var l2 = bezlen.apply(0, bez2);
  var n1 = ~~(l1 / 8);
  var n2 = ~~(l2 / 8);
  var dots1 = [];
  var dots2 = [];
  var xy = {};
  var res = justCount ? 0 : [];
  for (var i = 0; i < n1 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez1.concat(i / n1));
    dots1.push({
      x: d.x,
      y: d.y,
      t: i / n1
    });
  }
  for (var i = 0; i < n2 + 1; i++) {
    var d = findDotsAtSegment.apply(0, bez2.concat(i / n2));
    dots2.push({
      x: d.x,
      y: d.y,
      t: i / n2
    });
  }
  for (var i = 0; i < n1; i++) {
    for (var j = 0; j < n2; j++) {
      var di = dots1[i];
      var di1 = dots1[i + 1];
      var dj = dots2[j];
      var dj1 = dots2[j + 1];
      var ci = Math.abs(di1.x - di.x) < 1e-3 ? "y" : "x";
      var cj = Math.abs(dj1.x - dj.x) < 1e-3 ? "y" : "x";
      var is = intersect$1(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y);
      if (is) {
        if (xy[is.x.toFixed(4)] === is.y.toFixed(4)) {
          continue;
        }
        xy[is.x.toFixed(4)] = is.y.toFixed(4);
        var t1 = di.t + Math.abs((is[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t);
        var t2 = dj.t + Math.abs((is[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t2 >= 0 && t2 <= 1) {
          if (justCount) {
            res += 1;
          } else {
            res.push({
              x: is.x,
              y: is.y,
              t1,
              t2
            });
          }
        }
      }
    }
  }
  return res;
};
var interPathHelper = function(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1;
  var y1;
  var x2;
  var y2;
  var x1m;
  var y1m;
  var x2m;
  var y2m;
  var bez1;
  var bez2;
  var res = justCount ? 0 : [];
  for (var i = 0, ii = path1.length; i < ii; i++) {
    var pi2 = path1[i];
    if (pi2[0] === "M") {
      x1 = x1m = pi2[1];
      y1 = y1m = pi2[2];
    } else {
      if (pi2[0] === "C") {
        bez1 = [x1, y1].concat(pi2.slice(1));
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j = 0, jj = path2.length; j < jj; j++) {
        var pj = path2[j];
        if (pj[0] === "M") {
          x2 = x2m = pj[1];
          y2 = y2m = pj[2];
        } else {
          if (pj[0] === "C") {
            bez2 = [x2, y2].concat(pj.slice(1));
            x2 = bez2[6];
            y2 = bez2[7];
          } else {
            bez2 = [x2, y2, x2, y2, x2m, y2m, x2m, y2m];
            x2 = x2m;
            y2 = y2m;
          }
          var intr = interHelper(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k = 0, kk = intr.length; k < kk; k++) {
              intr[k].segment1 = i;
              intr[k].segment2 = j;
              intr[k].bez1 = bez1;
              intr[k].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
};
var intersection = function(path1, path2) {
  return interPathHelper(path1, path2);
};
function decasteljau(points2, t) {
  var left2 = [];
  var right2 = [];
  function recurse(points3, t2) {
    if (points3.length === 1) {
      left2.push(points3[0]);
      right2.push(points3[0]);
    } else {
      var middlePoints = [];
      for (var i = 0; i < points3.length - 1; i++) {
        if (i === 0) {
          left2.push(points3[0]);
        }
        if (i === points3.length - 2) {
          right2.push(points3[i + 1]);
        }
        middlePoints[i] = [
          (1 - t2) * points3[i][0] + t2 * points3[i + 1][0],
          (1 - t2) * points3[i][1] + t2 * points3[i + 1][1]
        ];
      }
      recurse(middlePoints, t2);
    }
  }
  if (points2.length) {
    recurse(points2, t);
  }
  return { left: left2, right: right2.reverse() };
}
function splitCurve(start, end, count2) {
  var points2 = [[start[1], start[2]]];
  count2 = count2 || 2;
  var segments = [];
  if (end[0] === "A") {
    points2.push(end[6]);
    points2.push(end[7]);
  } else if (end[0] === "C") {
    points2.push([end[1], end[2]]);
    points2.push([end[3], end[4]]);
    points2.push([end[5], end[6]]);
  } else if (end[0] === "S" || end[0] === "Q") {
    points2.push([end[1], end[2]]);
    points2.push([end[3], end[4]]);
  } else {
    points2.push([end[1], end[2]]);
  }
  var leftSegments = points2;
  var t = 1 / count2;
  for (var i = 0; i < count2 - 1; i++) {
    var rt = t / (1 - t * i);
    var split = decasteljau(leftSegments, rt);
    segments.push(split.left);
    leftSegments = split.right;
  }
  segments.push(leftSegments);
  var result = segments.map(function(segment) {
    var cmd = [];
    if (segment.length === 4) {
      cmd.push("C");
      cmd = cmd.concat(segment[2]);
    }
    if (segment.length >= 3) {
      if (segment.length === 3) {
        cmd.push("Q");
      }
      cmd = cmd.concat(segment[1]);
    }
    if (segment.length === 2) {
      cmd.push("L");
    }
    cmd = cmd.concat(segment[segment.length - 1]);
    return cmd;
  });
  return result;
}
var splitSegment = function(start, end, count2) {
  if (count2 === 1) {
    return [[].concat(start)];
  }
  var segments = [];
  if (end[0] === "L" || end[0] === "C" || end[0] === "Q") {
    segments = segments.concat(splitCurve(start, end, count2));
  } else {
    var temp = [].concat(start);
    if (temp[0] === "M") {
      temp[0] = "L";
    }
    for (var i = 0; i <= count2 - 1; i++) {
      segments.push(temp);
    }
  }
  return segments;
};
var fillPath = function(source, target2) {
  if (source.length === 1) {
    return source;
  }
  var sourceLen = source.length - 1;
  var targetLen = target2.length - 1;
  var ratio = sourceLen / targetLen;
  var segmentsToFill = [];
  if (source.length === 1 && source[0][0] === "M") {
    for (var i = 0; i < targetLen - sourceLen; i++) {
      source.push(source[0]);
    }
    return source;
  }
  for (var i = 0; i < targetLen; i++) {
    var index2 = Math.floor(ratio * i);
    segmentsToFill[index2] = (segmentsToFill[index2] || 0) + 1;
  }
  var filled = segmentsToFill.reduce(function(filled2, count2, i2) {
    if (i2 === sourceLen) {
      return filled2.concat(source[sourceLen]);
    }
    return filled2.concat(splitSegment(source[i2], source[i2 + 1], count2));
  }, []);
  filled.unshift(source[0]);
  if (target2[targetLen] === "Z" || target2[targetLen] === "z") {
    filled.push("Z");
  }
  return filled;
};
var isEqual = function(obj1, obj2) {
  if (obj1.length !== obj2.length) {
    return false;
  }
  var result = true;
  each$1(obj1, function(item, i) {
    if (item !== obj2[i]) {
      result = false;
      return false;
    }
  });
  return result;
};
function getMinDiff(del, add2, modify) {
  var type = null;
  var min2 = modify;
  if (add2 < min2) {
    min2 = add2;
    type = "add";
  }
  if (del < min2) {
    min2 = del;
    type = "del";
  }
  return {
    type,
    min: min2
  };
}
var levenshteinDistance = function(source, target2) {
  var sourceLen = source.length;
  var targetLen = target2.length;
  var sourceSegment;
  var targetSegment;
  var temp = 0;
  if (sourceLen === 0 || targetLen === 0) {
    return null;
  }
  var dist = [];
  for (var i = 0; i <= sourceLen; i++) {
    dist[i] = [];
    dist[i][0] = { min: i };
  }
  for (var j = 0; j <= targetLen; j++) {
    dist[0][j] = { min: j };
  }
  for (var i = 1; i <= sourceLen; i++) {
    sourceSegment = source[i - 1];
    for (var j = 1; j <= targetLen; j++) {
      targetSegment = target2[j - 1];
      if (isEqual(sourceSegment, targetSegment)) {
        temp = 0;
      } else {
        temp = 1;
      }
      var del = dist[i - 1][j].min + 1;
      var add2 = dist[i][j - 1].min + 1;
      var modify = dist[i - 1][j - 1].min + temp;
      dist[i][j] = getMinDiff(del, add2, modify);
    }
  }
  return dist;
};
var fillPathByDiff = function(source, target2) {
  var diffMatrix = levenshteinDistance(source, target2);
  var sourceLen = source.length;
  var targetLen = target2.length;
  var changes = [];
  var index2 = 1;
  var minPos = 1;
  if (diffMatrix[sourceLen][targetLen].min !== sourceLen) {
    for (var i = 1; i <= sourceLen; i++) {
      var min2 = diffMatrix[i][i].min;
      minPos = i;
      for (var j = index2; j <= targetLen; j++) {
        if (diffMatrix[i][j].min < min2) {
          min2 = diffMatrix[i][j].min;
          minPos = j;
        }
      }
      index2 = minPos;
      if (diffMatrix[i][index2].type) {
        changes.push({ index: i - 1, type: diffMatrix[i][index2].type });
      }
    }
    for (var i = changes.length - 1; i >= 0; i--) {
      index2 = changes[i].index;
      if (changes[i].type === "add") {
        source.splice(index2, 0, [].concat(source[index2]));
      } else {
        source.splice(index2, 1);
      }
    }
  }
  sourceLen = source.length;
  var diff2 = targetLen - sourceLen;
  if (sourceLen < targetLen) {
    for (var i = 0; i < diff2; i++) {
      if (source[sourceLen - 1][0] === "z" || source[sourceLen - 1][0] === "Z") {
        source.splice(sourceLen - 2, 0, source[sourceLen - 2]);
      } else {
        source.push(source[sourceLen - 1]);
      }
      sourceLen += 1;
    }
  }
  return source;
};
function _splitPoints(points2, former, count2) {
  var result = [].concat(points2);
  var index2;
  var t = 1 / (count2 + 1);
  var formerEnd = _getSegmentPoints(former)[0];
  for (var i = 1; i <= count2; i++) {
    t *= i;
    index2 = Math.floor(points2.length * t);
    if (index2 === 0) {
      result.unshift([formerEnd[0] * t + points2[index2][0] * (1 - t), formerEnd[1] * t + points2[index2][1] * (1 - t)]);
    } else {
      result.splice(index2, 0, [
        formerEnd[0] * t + points2[index2][0] * (1 - t),
        formerEnd[1] * t + points2[index2][1] * (1 - t)
      ]);
    }
  }
  return result;
}
function _getSegmentPoints(segment) {
  var points2 = [];
  switch (segment[0]) {
    case "M":
      points2.push([segment[1], segment[2]]);
      break;
    case "L":
      points2.push([segment[1], segment[2]]);
      break;
    case "A":
      points2.push([segment[6], segment[7]]);
      break;
    case "Q":
      points2.push([segment[3], segment[4]]);
      points2.push([segment[1], segment[2]]);
      break;
    case "T":
      points2.push([segment[1], segment[2]]);
      break;
    case "C":
      points2.push([segment[5], segment[6]]);
      points2.push([segment[1], segment[2]]);
      points2.push([segment[3], segment[4]]);
      break;
    case "S":
      points2.push([segment[3], segment[4]]);
      points2.push([segment[1], segment[2]]);
      break;
    case "H":
      points2.push([segment[1], segment[1]]);
      break;
    case "V":
      points2.push([segment[1], segment[1]]);
      break;
  }
  return points2;
}
var formatPath = function(fromPath, toPath) {
  if (fromPath.length <= 1) {
    return fromPath;
  }
  var points2;
  for (var i = 0; i < toPath.length; i++) {
    if (fromPath[i][0] !== toPath[i][0]) {
      points2 = _getSegmentPoints(fromPath[i]);
      switch (toPath[i][0]) {
        case "M":
          fromPath[i] = ["M"].concat(points2[0]);
          break;
        case "L":
          fromPath[i] = ["L"].concat(points2[0]);
          break;
        case "A":
          fromPath[i] = [].concat(toPath[i]);
          fromPath[i][6] = points2[0][0];
          fromPath[i][7] = points2[0][1];
          break;
        case "Q":
          if (points2.length < 2) {
            if (i > 0) {
              points2 = _splitPoints(points2, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["Q"].concat(points2.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "T":
          fromPath[i] = ["T"].concat(points2[0]);
          break;
        case "C":
          if (points2.length < 3) {
            if (i > 0) {
              points2 = _splitPoints(points2, fromPath[i - 1], 2);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["C"].concat(points2.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        case "S":
          if (points2.length < 2) {
            if (i > 0) {
              points2 = _splitPoints(points2, fromPath[i - 1], 1);
            } else {
              fromPath[i] = toPath[i];
              break;
            }
          }
          fromPath[i] = ["S"].concat(points2.reduce(function(arr, i2) {
            return arr.concat(i2);
          }, []));
          break;
        default:
          fromPath[i] = toPath[i];
      }
    }
  }
  return fromPath;
};
const PathUtil$1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  catmullRomToBezier,
  fillPath,
  fillPathByDiff,
  formatPath,
  intersection,
  parsePathArray,
  parsePathString: parsePathString$1,
  pathToAbsolute: pathToAbsolute$1,
  pathToCurve,
  rectPath
}, Symbol.toStringTag, { value: "Module" }));
var GraphEvent = (
  /** @class */
  function() {
    function GraphEvent2(type, event) {
      this.bubbles = true;
      this.target = null;
      this.currentTarget = null;
      this.delegateTarget = null;
      this.delegateObject = null;
      this.defaultPrevented = false;
      this.propagationStopped = false;
      this.shape = null;
      this.fromShape = null;
      this.toShape = null;
      this.propagationPath = [];
      this.type = type;
      this.name = type;
      this.originalEvent = event;
      this.timeStamp = event.timeStamp;
    }
    GraphEvent2.prototype.preventDefault = function() {
      this.defaultPrevented = true;
      if (this.originalEvent.preventDefault) {
        this.originalEvent.preventDefault();
      }
    };
    GraphEvent2.prototype.stopPropagation = function() {
      this.propagationStopped = true;
    };
    GraphEvent2.prototype.toString = function() {
      var type = this.type;
      return "[Event (type=" + type + ")]";
    };
    GraphEvent2.prototype.save = function() {
    };
    GraphEvent2.prototype.restore = function() {
    };
    return GraphEvent2;
  }()
);
function removeFromArray(arr, obj) {
  var index2 = arr.indexOf(obj);
  if (index2 !== -1) {
    arr.splice(index2, 1);
  }
}
var isBrowser = typeof window !== "undefined" && typeof window.document !== "undefined";
function isParent(container, shape) {
  if (container.isCanvas()) {
    return true;
  }
  var parent = shape.getParent();
  var isParent2 = false;
  while (parent) {
    if (parent === container) {
      isParent2 = true;
      break;
    }
    parent = parent.getParent();
  }
  return isParent2;
}
function isAllowCapture(element) {
  return element.cfg.visible && element.cfg.capture;
}
var Base = (
  /** @class */
  function(_super) {
    __extends$1(Base2, _super);
    function Base2(cfg) {
      var _this = _super.call(this) || this;
      _this.destroyed = false;
      var defaultCfg = _this.getDefaultCfg();
      _this.cfg = mix(defaultCfg, cfg);
      return _this;
    }
    Base2.prototype.getDefaultCfg = function() {
      return {};
    };
    Base2.prototype.get = function(name) {
      return this.cfg[name];
    };
    Base2.prototype.set = function(name, value2) {
      this.cfg[name] = value2;
    };
    Base2.prototype.destroy = function() {
      this.cfg = {
        destroyed: true
      };
      this.off();
      this.destroyed = true;
    };
    return Base2;
  }(EventEmitter)
);
var __spreadArray = function(to, from, pack2) {
  if (pack2 || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var BrowserInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BrowserInfo2(name, version2, os) {
      this.name = name;
      this.version = version2;
      this.os = os;
      this.type = "browser";
    }
    return BrowserInfo2;
  }()
);
var NodeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function NodeInfo2(version2) {
      this.version = version2;
      this.type = "node";
      this.name = "node";
      this.os = process.platform;
    }
    return NodeInfo2;
  }()
);
var SearchBotDeviceInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function SearchBotDeviceInfo2(name, version2, os, bot) {
      this.name = name;
      this.version = version2;
      this.os = os;
      this.bot = bot;
      this.type = "bot-device";
    }
    return SearchBotDeviceInfo2;
  }()
);
var BotInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function BotInfo2() {
      this.type = "bot";
      this.bot = true;
      this.name = "bot";
      this.version = null;
      this.os = null;
    }
    return BotInfo2;
  }()
);
var ReactNativeInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function ReactNativeInfo2() {
      this.type = "react-native";
      this.name = "react-native";
      this.version = null;
      this.os = null;
    }
    return ReactNativeInfo2;
  }()
);
var SEARCHBOX_UA_REGEX = /alexa|bot|crawl(er|ing)|facebookexternalhit|feedburner|google web preview|nagios|postrank|pingdom|slurp|spider|yahoo!|yandex/;
var SEARCHBOT_OS_REGEX = /(nuhk|curl|Googlebot|Yammybot|Openbot|Slurp|MSNBot|Ask\ Jeeves\/Teoma|ia_archiver)/;
var REQUIRED_VERSION_PARTS = 3;
var userAgentRules = [
  ["aol", /AOLShield\/([0-9\._]+)/],
  ["edge", /Edge\/([0-9\._]+)/],
  ["edge-ios", /EdgiOS\/([0-9\._]+)/],
  ["yandexbrowser", /YaBrowser\/([0-9\._]+)/],
  ["kakaotalk", /KAKAOTALK\s([0-9\.]+)/],
  ["samsung", /SamsungBrowser\/([0-9\.]+)/],
  ["silk", /\bSilk\/([0-9._-]+)\b/],
  ["miui", /MiuiBrowser\/([0-9\.]+)$/],
  ["beaker", /BeakerBrowser\/([0-9\.]+)/],
  ["edge-chromium", /EdgA?\/([0-9\.]+)/],
  [
    "chromium-webview",
    /(?!Chrom.*OPR)wv\).*Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/
  ],
  ["chrome", /(?!Chrom.*OPR)Chrom(?:e|ium)\/([0-9\.]+)(:?\s|$)/],
  ["phantomjs", /PhantomJS\/([0-9\.]+)(:?\s|$)/],
  ["crios", /CriOS\/([0-9\.]+)(:?\s|$)/],
  ["firefox", /Firefox\/([0-9\.]+)(?:\s|$)/],
  ["fxios", /FxiOS\/([0-9\.]+)/],
  ["opera-mini", /Opera Mini.*Version\/([0-9\.]+)/],
  ["opera", /Opera\/([0-9\.]+)(?:\s|$)/],
  ["opera", /OPR\/([0-9\.]+)(:?\s|$)/],
  ["pie", /^Microsoft Pocket Internet Explorer\/(\d+\.\d+)$/],
  ["pie", /^Mozilla\/\d\.\d+\s\(compatible;\s(?:MSP?IE|MSInternet Explorer) (\d+\.\d+);.*Windows CE.*\)$/],
  ["netfront", /^Mozilla\/\d\.\d+.*NetFront\/(\d.\d)/],
  ["ie", /Trident\/7\.0.*rv\:([0-9\.]+).*\).*Gecko$/],
  ["ie", /MSIE\s([0-9\.]+);.*Trident\/[4-7].0/],
  ["ie", /MSIE\s(7\.0)/],
  ["bb10", /BB10;\sTouch.*Version\/([0-9\.]+)/],
  ["android", /Android\s([0-9\.]+)/],
  ["ios", /Version\/([0-9\._]+).*Mobile.*Safari.*/],
  ["safari", /Version\/([0-9\._]+).*Safari/],
  ["facebook", /FB[AS]V\/([0-9\.]+)/],
  ["instagram", /Instagram\s([0-9\.]+)/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Mobile/],
  ["ios-webview", /AppleWebKit\/([0-9\.]+).*Gecko\)$/],
  ["curl", /^curl\/([0-9\.]+)$/],
  ["searchbot", SEARCHBOX_UA_REGEX]
];
var operatingSystemRules = [
  ["iOS", /iP(hone|od|ad)/],
  ["Android OS", /Android/],
  ["BlackBerry OS", /BlackBerry|BB10/],
  ["Windows Mobile", /IEMobile/],
  ["Amazon OS", /Kindle/],
  ["Windows 3.11", /Win16/],
  ["Windows 95", /(Windows 95)|(Win95)|(Windows_95)/],
  ["Windows 98", /(Windows 98)|(Win98)/],
  ["Windows 2000", /(Windows NT 5.0)|(Windows 2000)/],
  ["Windows XP", /(Windows NT 5.1)|(Windows XP)/],
  ["Windows Server 2003", /(Windows NT 5.2)/],
  ["Windows Vista", /(Windows NT 6.0)/],
  ["Windows 7", /(Windows NT 6.1)/],
  ["Windows 8", /(Windows NT 6.2)/],
  ["Windows 8.1", /(Windows NT 6.3)/],
  ["Windows 10", /(Windows NT 10.0)/],
  ["Windows ME", /Windows ME/],
  ["Windows CE", /Windows CE|WinCE|Microsoft Pocket Internet Explorer/],
  ["Open BSD", /OpenBSD/],
  ["Sun OS", /SunOS/],
  ["Chrome OS", /CrOS/],
  ["Linux", /(Linux)|(X11)/],
  ["Mac OS", /(Mac_PowerPC)|(Macintosh)/],
  ["QNX", /QNX/],
  ["BeOS", /BeOS/],
  ["OS/2", /OS\/2/]
];
function detect(userAgent) {
  if (!!userAgent) {
    return parseUserAgent(userAgent);
  }
  if (typeof document === "undefined" && typeof navigator !== "undefined" && navigator.product === "ReactNative") {
    return new ReactNativeInfo();
  }
  if (typeof navigator !== "undefined") {
    return parseUserAgent(navigator.userAgent);
  }
  return getNodeVersion();
}
function matchUserAgent(ua) {
  return ua !== "" && userAgentRules.reduce(function(matched, _a2) {
    var browser2 = _a2[0], regex = _a2[1];
    if (matched) {
      return matched;
    }
    var uaMatch = regex.exec(ua);
    return !!uaMatch && [browser2, uaMatch];
  }, false);
}
function parseUserAgent(ua) {
  var matchedRule = matchUserAgent(ua);
  if (!matchedRule) {
    return null;
  }
  var name = matchedRule[0], match = matchedRule[1];
  if (name === "searchbot") {
    return new BotInfo();
  }
  var versionParts = match[1] && match[1].split(".").join("_").split("_").slice(0, 3);
  if (versionParts) {
    if (versionParts.length < REQUIRED_VERSION_PARTS) {
      versionParts = __spreadArray(__spreadArray([], versionParts, true), createVersionParts(REQUIRED_VERSION_PARTS - versionParts.length), true);
    }
  } else {
    versionParts = [];
  }
  var version2 = versionParts.join(".");
  var os = detectOS(ua);
  var searchBotMatch = SEARCHBOT_OS_REGEX.exec(ua);
  if (searchBotMatch && searchBotMatch[1]) {
    return new SearchBotDeviceInfo(name, version2, os, searchBotMatch[1]);
  }
  return new BrowserInfo(name, version2, os);
}
function detectOS(ua) {
  for (var ii = 0, count2 = operatingSystemRules.length; ii < count2; ii++) {
    var _a2 = operatingSystemRules[ii], os = _a2[0], regex = _a2[1];
    var match = regex.exec(ua);
    if (match) {
      return os;
    }
  }
  return null;
}
function getNodeVersion() {
  var isNode = typeof process !== "undefined" && process.version;
  return isNode ? new NodeInfo(process.version.slice(1)) : null;
}
function createVersionParts(count2) {
  var output2 = [];
  for (var ii = 0; ii < count2; ii++) {
    output2.push("0");
  }
  return output2;
}
var ARRAY_TYPE = typeof Float32Array !== "undefined" ? Float32Array : Array;
if (!Math.hypot)
  Math.hypot = function() {
    var y = 0, i = arguments.length;
    while (i--) {
      y += arguments[i] * arguments[i];
    }
    return Math.sqrt(y);
  };
function invert$1(out, a) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
function multiply(out, a, b) {
  var a00 = a[0], a01 = a[1], a02 = a[2];
  var a10 = a[3], a11 = a[4], a12 = a[5];
  var a20 = a[6], a21 = a[7], a22 = a[8];
  var b00 = b[0], b01 = b[1], b02 = b[2];
  var b10 = b[3], b11 = b[4], b12 = b[5];
  var b20 = b[6], b21 = b[7], b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function fromTranslation(out, v) {
  out[0] = 1;
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = 1;
  out[5] = 0;
  out[6] = v[0];
  out[7] = v[1];
  out[8] = 1;
  return out;
}
function fromRotation(out, rad) {
  var s = Math.sin(rad), c = Math.cos(rad);
  out[0] = c;
  out[1] = s;
  out[2] = 0;
  out[3] = -s;
  out[4] = c;
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function fromScaling(out, v) {
  out[0] = v[0];
  out[1] = 0;
  out[2] = 0;
  out[3] = 0;
  out[4] = v[1];
  out[5] = 0;
  out[6] = 0;
  out[7] = 0;
  out[8] = 1;
  return out;
}
function create$1() {
  var out = new ARRAY_TYPE(3);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
    out[2] = 0;
  }
  return out;
}
function transformMat3$1(out, a, m) {
  var x = a[0], y = a[1], z = a[2];
  out[0] = x * m[0] + y * m[3] + z * m[6];
  out[1] = x * m[1] + y * m[4] + z * m[7];
  out[2] = x * m[2] + y * m[5] + z * m[8];
  return out;
}
(function() {
  var vec = create$1();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 3;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      vec[2] = a[i + 2];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
      a[i + 2] = vec[2];
    }
    return a;
  };
})();
function create() {
  var out = new ARRAY_TYPE(2);
  if (ARRAY_TYPE != Float32Array) {
    out[0] = 0;
    out[1] = 0;
  }
  return out;
}
function add(out, a, b) {
  out[0] = a[0] + b[0];
  out[1] = a[1] + b[1];
  return out;
}
function subtract(out, a, b) {
  out[0] = a[0] - b[0];
  out[1] = a[1] - b[1];
  return out;
}
function min$1(out, a, b) {
  out[0] = Math.min(a[0], b[0]);
  out[1] = Math.min(a[1], b[1]);
  return out;
}
function max$1(out, a, b) {
  out[0] = Math.max(a[0], b[0]);
  out[1] = Math.max(a[1], b[1]);
  return out;
}
function scale$3(out, a, b) {
  out[0] = a[0] * b;
  out[1] = a[1] * b;
  return out;
}
function distance$6(a, b) {
  var x = b[0] - a[0], y = b[1] - a[1];
  return Math.hypot(x, y);
}
function length(a) {
  var x = a[0], y = a[1];
  return Math.hypot(x, y);
}
function normalize(out, a) {
  var x = a[0], y = a[1];
  var len = x * x + y * y;
  if (len > 0) {
    len = 1 / Math.sqrt(len);
  }
  out[0] = a[0] * len;
  out[1] = a[1] * len;
  return out;
}
function dot$2(a, b) {
  return a[0] * b[0] + a[1] * b[1];
}
function transformMat3(out, a, m) {
  var x = a[0], y = a[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function angle$1(a, b) {
  var x1 = a[0], y1 = a[1], x2 = b[0], y2 = b[1], mag = Math.sqrt(x1 * x1 + y1 * y1) * Math.sqrt(x2 * x2 + y2 * y2), cosine = mag && (x1 * x2 + y1 * y2) / mag;
  return Math.acos(Math.min(Math.max(cosine, -1), 1));
}
function exactEquals(a, b) {
  return a[0] === b[0] && a[1] === b[1];
}
var sub = subtract;
(function() {
  var vec = create();
  return function(a, stride, offset, count2, fn, arg) {
    var i, l;
    if (!stride) {
      stride = 2;
    }
    if (!offset) {
      offset = 0;
    }
    if (count2) {
      l = Math.min(count2 * stride + offset, a.length);
    } else {
      l = a.length;
    }
    for (i = offset; i < l; i += stride) {
      vec[0] = a[i];
      vec[1] = a[i + 1];
      fn(vec, vec, arg);
      a[i] = vec[0];
      a[i + 1] = vec[1];
    }
    return a;
  };
})();
function leftTranslate(out, a, v) {
  var transMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromTranslation(transMat, v);
  return multiply(out, transMat, a);
}
function leftRotate(out, a, rad) {
  var rotateMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromRotation(rotateMat, rad);
  return multiply(out, rotateMat, a);
}
function leftScale(out, a, v) {
  var scaleMat = [0, 0, 0, 0, 0, 0, 0, 0, 0];
  fromScaling(scaleMat, v);
  return multiply(out, scaleMat, a);
}
function leftMultiply(out, a, a1) {
  return multiply(out, a1, a);
}
function transform$6(m, actions) {
  var matrix = m ? [].concat(m) : [1, 0, 0, 0, 1, 0, 0, 0, 1];
  for (var i = 0, len = actions.length; i < len; i++) {
    var action = actions[i];
    switch (action[0]) {
      case "t":
        leftTranslate(matrix, matrix, [action[1], action[2]]);
        break;
      case "s":
        leftScale(matrix, matrix, [action[1], action[2]]);
        break;
      case "r":
        leftRotate(matrix, matrix, action[1]);
        break;
      case "m":
        leftMultiply(matrix, matrix, action[1]);
        break;
    }
  }
  return matrix;
}
function direction(v1, v2) {
  return v1[0] * v2[1] - v2[0] * v1[1];
}
function angleTo(v1, v2, direct) {
  var ang = angle$1(v1, v2);
  var angleLargeThanPI = direction(v1, v2) >= 0;
  if (direct) {
    if (angleLargeThanPI) {
      return Math.PI * 2 - ang;
    }
    return ang;
  }
  if (angleLargeThanPI) {
    return ang;
  }
  return Math.PI * 2 - ang;
}
function multiplyMatrix(a, b) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b00 = b[0];
  var b01 = b[1];
  var b02 = b[2];
  var b10 = b[3];
  var b11 = b[4];
  var b12 = b[5];
  var b20 = b[6];
  var b21 = b[7];
  var b22 = b[8];
  out[0] = b00 * a00 + b01 * a10 + b02 * a20;
  out[1] = b00 * a01 + b01 * a11 + b02 * a21;
  out[2] = b00 * a02 + b01 * a12 + b02 * a22;
  out[3] = b10 * a00 + b11 * a10 + b12 * a20;
  out[4] = b10 * a01 + b11 * a11 + b12 * a21;
  out[5] = b10 * a02 + b11 * a12 + b12 * a22;
  out[6] = b20 * a00 + b21 * a10 + b22 * a20;
  out[7] = b20 * a01 + b21 * a11 + b22 * a21;
  out[8] = b20 * a02 + b21 * a12 + b22 * a22;
  return out;
}
function multiplyVec2$1(m, v) {
  var out = [];
  var x = v[0];
  var y = v[1];
  out[0] = m[0] * x + m[3] * y + m[6];
  out[1] = m[1] * x + m[4] * y + m[7];
  return out;
}
function invert(a) {
  var out = [];
  var a00 = a[0];
  var a01 = a[1];
  var a02 = a[2];
  var a10 = a[3];
  var a11 = a[4];
  var a12 = a[5];
  var a20 = a[6];
  var a21 = a[7];
  var a22 = a[8];
  var b01 = a22 * a11 - a12 * a21;
  var b11 = -a22 * a10 + a12 * a20;
  var b21 = a21 * a10 - a11 * a20;
  var det = a00 * b01 + a01 * b11 + a02 * b21;
  if (!det) {
    return null;
  }
  det = 1 / det;
  out[0] = b01 * det;
  out[1] = (-a22 * a01 + a02 * a21) * det;
  out[2] = (a12 * a01 - a02 * a11) * det;
  out[3] = b11 * det;
  out[4] = (a22 * a00 - a02 * a20) * det;
  out[5] = (-a12 * a00 + a02 * a10) * det;
  out[6] = b21 * det;
  out[7] = (-a21 * a00 + a01 * a20) * det;
  out[8] = (a11 * a00 - a01 * a10) * det;
  return out;
}
var transform$5 = transform$6;
var MATRIX = "matrix";
var CLONE_CFGS = ["zIndex", "capture", "visible", "type"];
var RESERVED_PORPS = ["repeat"];
var DELEGATION_SPLIT = ":";
var WILDCARD = "*";
function _cloneArrayAttr(arr) {
  var result = [];
  for (var i = 0; i < arr.length; i++) {
    if (isArray$1(arr[i])) {
      result.push([].concat(arr[i]));
    } else {
      result.push(arr[i]);
    }
  }
  return result;
}
function getFormatFromAttrs(toAttrs, shape) {
  var fromAttrs = {};
  var attrs = shape.attrs;
  for (var k in toAttrs) {
    fromAttrs[k] = attrs[k];
  }
  return fromAttrs;
}
function getFormatToAttrs(props, shape) {
  var toAttrs = {};
  var attrs = shape.attr();
  each$1(props, function(v, k) {
    if (RESERVED_PORPS.indexOf(k) === -1 && !isEqual$1(attrs[k], v)) {
      toAttrs[k] = v;
    }
  });
  return toAttrs;
}
function checkExistedAttrs(animations, animation2) {
  if (animation2.onFrame) {
    return animations;
  }
  var startTime = animation2.startTime, delay = animation2.delay, duration = animation2.duration;
  var hasOwnProperty2 = Object.prototype.hasOwnProperty;
  each$1(animations, function(item) {
    if (startTime + delay < item.startTime + item.delay + item.duration && duration > item.delay) {
      each$1(animation2.toAttrs, function(v, k) {
        if (hasOwnProperty2.call(item.toAttrs, k)) {
          delete item.toAttrs[k];
          delete item.fromAttrs[k];
        }
      });
    }
  });
  return animations;
}
var Element$2 = (
  /** @class */
  function(_super) {
    __extends$1(Element2, _super);
    function Element2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.attrs = {};
      var attrs = _this.getDefaultAttrs();
      mix(attrs, cfg.attrs);
      _this.attrs = attrs;
      _this.initAttrs(attrs);
      _this.initAnimate();
      return _this;
    }
    Element2.prototype.getDefaultCfg = function() {
      return {
        visible: true,
        capture: true,
        zIndex: 0
      };
    };
    Element2.prototype.getDefaultAttrs = function() {
      return {
        matrix: this.getDefaultMatrix(),
        opacity: 1
      };
    };
    Element2.prototype.onCanvasChange = function(changeType) {
    };
    Element2.prototype.initAttrs = function(attrs) {
    };
    Element2.prototype.initAnimate = function() {
      this.set("animable", true);
      this.set("animating", false);
    };
    Element2.prototype.isGroup = function() {
      return false;
    };
    Element2.prototype.getParent = function() {
      return this.get("parent");
    };
    Element2.prototype.getCanvas = function() {
      return this.get("canvas");
    };
    Element2.prototype.attr = function() {
      var _a2;
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var name = args[0], value2 = args[1];
      if (!name)
        return this.attrs;
      if (isObject(name)) {
        for (var k in name) {
          this.setAttr(k, name[k]);
        }
        this.afterAttrsChange(name);
        return this;
      }
      if (args.length === 2) {
        this.setAttr(name, value2);
        this.afterAttrsChange((_a2 = {}, _a2[name] = value2, _a2));
        return this;
      }
      return this.attrs[name];
    };
    Element2.prototype.isClipped = function(refX, refY) {
      var clip = this.getClip();
      return clip && !clip.isHit(refX, refY);
    };
    Element2.prototype.setAttr = function(name, value2) {
      var originValue = this.attrs[name];
      if (originValue !== value2) {
        this.attrs[name] = value2;
        this.onAttrChange(name, value2, originValue);
      }
    };
    Element2.prototype.onAttrChange = function(name, value2, originValue) {
      if (name === "matrix") {
        this.set("totalMatrix", null);
      }
    };
    Element2.prototype.afterAttrsChange = function(targetAttrs) {
      if (this.cfg.isClipShape) {
        var applyTo = this.cfg.applyTo;
        if (applyTo) {
          applyTo.onCanvasChange("clip");
        }
      } else {
        this.onCanvasChange("attr");
      }
    };
    Element2.prototype.show = function() {
      this.set("visible", true);
      this.onCanvasChange("show");
      return this;
    };
    Element2.prototype.hide = function() {
      this.set("visible", false);
      this.onCanvasChange("hide");
      return this;
    };
    Element2.prototype.setZIndex = function(zIndex) {
      this.set("zIndex", zIndex);
      var parent = this.getParent();
      if (parent) {
        parent.sort();
      }
      return this;
    };
    Element2.prototype.toFront = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      this.get("el");
      var index2 = children.indexOf(this);
      children.splice(index2, 1);
      children.push(this);
      this.onCanvasChange("zIndex");
    };
    Element2.prototype.toBack = function() {
      var parent = this.getParent();
      if (!parent) {
        return;
      }
      var children = parent.getChildren();
      this.get("el");
      var index2 = children.indexOf(this);
      children.splice(index2, 1);
      children.unshift(this);
      this.onCanvasChange("zIndex");
    };
    Element2.prototype.remove = function(destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      var parent = this.getParent();
      if (parent) {
        removeFromArray(parent.getChildren(), this);
        if (!parent.get("clearing")) {
          this.onCanvasChange("remove");
        }
      } else {
        this.onCanvasChange("remove");
      }
      if (destroy) {
        this.destroy();
      }
    };
    Element2.prototype.resetMatrix = function() {
      this.attr(MATRIX, this.getDefaultMatrix());
      this.onCanvasChange("matrix");
    };
    Element2.prototype.getMatrix = function() {
      return this.attr(MATRIX);
    };
    Element2.prototype.setMatrix = function(m) {
      this.attr(MATRIX, m);
      this.onCanvasChange("matrix");
    };
    Element2.prototype.getTotalMatrix = function() {
      var totalMatrix = this.cfg.totalMatrix;
      if (!totalMatrix) {
        var currentMatrix = this.attr("matrix");
        var parentMatrix = this.cfg.parentMatrix;
        if (parentMatrix && currentMatrix) {
          totalMatrix = multiplyMatrix(parentMatrix, currentMatrix);
        } else {
          totalMatrix = currentMatrix || parentMatrix;
        }
        this.set("totalMatrix", totalMatrix);
      }
      return totalMatrix;
    };
    Element2.prototype.applyMatrix = function(matrix) {
      var currentMatrix = this.attr("matrix");
      var totalMatrix = null;
      if (matrix && currentMatrix) {
        totalMatrix = multiplyMatrix(matrix, currentMatrix);
      } else {
        totalMatrix = currentMatrix || matrix;
      }
      this.set("totalMatrix", totalMatrix);
      this.set("parentMatrix", matrix);
    };
    Element2.prototype.getDefaultMatrix = function() {
      return null;
    };
    Element2.prototype.applyToMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        return multiplyVec2$1(matrix, v);
      }
      return v;
    };
    Element2.prototype.invertFromMatrix = function(v) {
      var matrix = this.attr("matrix");
      if (matrix) {
        var invertMatrix = invert(matrix);
        if (invertMatrix) {
          return multiplyVec2$1(invertMatrix, v);
        }
      }
      return v;
    };
    Element2.prototype.setClip = function(clipCfg) {
      var canvas = this.getCanvas();
      var clipShape = null;
      if (clipCfg) {
        var ShapeBase2 = this.getShapeBase();
        var shapeType = upperFirst(clipCfg.type);
        var Cons = ShapeBase2[shapeType];
        if (Cons) {
          clipShape = new Cons({
            type: clipCfg.type,
            isClipShape: true,
            applyTo: this,
            attrs: clipCfg.attrs,
            canvas
          });
        }
      }
      this.set("clipShape", clipShape);
      this.onCanvasChange("clip");
      return clipShape;
    };
    Element2.prototype.getClip = function() {
      var clipShape = this.cfg.clipShape;
      if (!clipShape) {
        return null;
      }
      return clipShape;
    };
    Element2.prototype.clone = function() {
      var _this = this;
      var originAttrs = this.attrs;
      var attrs = {};
      each$1(originAttrs, function(i, k) {
        if (isArray$1(originAttrs[k])) {
          attrs[k] = _cloneArrayAttr(originAttrs[k]);
        } else {
          attrs[k] = originAttrs[k];
        }
      });
      var cons = this.constructor;
      var clone2 = new cons({ attrs });
      each$1(CLONE_CFGS, function(cfgName) {
        clone2.set(cfgName, _this.get(cfgName));
      });
      return clone2;
    };
    Element2.prototype.destroy = function() {
      var destroyed = this.destroyed;
      if (destroyed) {
        return;
      }
      this.attrs = {};
      _super.prototype.destroy.call(this);
    };
    Element2.prototype.isAnimatePaused = function() {
      return this.get("_pause").isPaused;
    };
    Element2.prototype.animate = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (!this.get("timeline") && !this.get("canvas")) {
        return;
      }
      this.set("animating", true);
      var timeline = this.get("timeline");
      if (!timeline) {
        timeline = this.get("canvas").get("timeline");
        this.set("timeline", timeline);
      }
      var animations = this.get("animations") || [];
      if (!timeline.timer) {
        timeline.initTimer();
      }
      var toAttrs = args[0], duration = args[1], _a2 = args[2], easing = _a2 === void 0 ? "easeLinear" : _a2, _b = args[3], callback = _b === void 0 ? noop : _b, _c = args[4], delay = _c === void 0 ? 0 : _c;
      var onFrame;
      var repeat;
      var pauseCallback;
      var resumeCallback;
      var animateCfg;
      if (isFunction(toAttrs)) {
        onFrame = toAttrs;
        toAttrs = {};
      } else if (isObject(toAttrs) && toAttrs.onFrame) {
        onFrame = toAttrs.onFrame;
        repeat = toAttrs.repeat;
      }
      if (isObject(duration)) {
        animateCfg = duration;
        duration = animateCfg.duration;
        easing = animateCfg.easing || "easeLinear";
        delay = animateCfg.delay || 0;
        repeat = animateCfg.repeat || repeat || false;
        callback = animateCfg.callback || noop;
        pauseCallback = animateCfg.pauseCallback || noop;
        resumeCallback = animateCfg.resumeCallback || noop;
      } else {
        if (isNumber$1(callback)) {
          delay = callback;
          callback = null;
        }
        if (isFunction(easing)) {
          callback = easing;
          easing = "easeLinear";
        } else {
          easing = easing || "easeLinear";
        }
      }
      var formatToAttrs = getFormatToAttrs(toAttrs, this);
      var animation2 = {
        fromAttrs: getFormatFromAttrs(formatToAttrs, this),
        toAttrs: formatToAttrs,
        duration,
        easing,
        repeat,
        callback,
        pauseCallback,
        resumeCallback,
        delay,
        startTime: timeline.getTime(),
        id: uniqueId(),
        onFrame,
        pathFormatted: false
      };
      if (animations.length > 0) {
        animations = checkExistedAttrs(animations, animation2);
      } else {
        timeline.addAnimator(this);
      }
      animations.push(animation2);
      this.set("animations", animations);
      this.set("_pause", { isPaused: false });
    };
    Element2.prototype.stopAnimate = function(toEnd) {
      var _this = this;
      if (toEnd === void 0) {
        toEnd = true;
      }
      var animations = this.get("animations");
      each$1(animations, function(animation2) {
        if (toEnd) {
          if (animation2.onFrame) {
            _this.attr(animation2.onFrame(1));
          } else {
            _this.attr(animation2.toAttrs);
          }
        }
        if (animation2.callback) {
          animation2.callback();
        }
      });
      this.set("animating", false);
      this.set("animations", []);
    };
    Element2.prototype.pauseAnimate = function() {
      var timeline = this.get("timeline");
      var animations = this.get("animations");
      var pauseTime = timeline.getTime();
      each$1(animations, function(animation2) {
        animation2._paused = true;
        animation2._pauseTime = pauseTime;
        if (animation2.pauseCallback) {
          animation2.pauseCallback();
        }
      });
      this.set("_pause", {
        isPaused: true,
        pauseTime
      });
      return this;
    };
    Element2.prototype.resumeAnimate = function() {
      var timeline = this.get("timeline");
      var current = timeline.getTime();
      var animations = this.get("animations");
      var pauseTime = this.get("_pause").pauseTime;
      each$1(animations, function(animation2) {
        animation2.startTime = animation2.startTime + (current - pauseTime);
        animation2._paused = false;
        animation2._pauseTime = null;
        if (animation2.resumeCallback) {
          animation2.resumeCallback();
        }
      });
      this.set("_pause", {
        isPaused: false
      });
      this.set("animations", animations);
      return this;
    };
    Element2.prototype.emitDelegation = function(type, eventObj) {
      var _this = this;
      var paths = eventObj.propagationPath;
      this.getEvents();
      var relativeShape;
      if (type === "mouseenter") {
        relativeShape = eventObj.fromShape;
      } else if (type === "mouseleave") {
        relativeShape = eventObj.toShape;
      }
      var _loop_1 = function(i2) {
        var element = paths[i2];
        var name_1 = element.get("name");
        if (name_1) {
          if (
            //  element  Group  Canvas  isParent
            (element.isGroup() || element.isCanvas && element.isCanvas()) && relativeShape && isParent(element, relativeShape)
          ) {
            return "break";
          }
          if (isArray$1(name_1)) {
            each$1(name_1, function(subName) {
              _this.emitDelegateEvent(element, subName, eventObj);
            });
          } else {
            this_1.emitDelegateEvent(element, name_1, eventObj);
          }
        }
      };
      var this_1 = this;
      for (var i = 0; i < paths.length; i++) {
        var state_1 = _loop_1(i);
        if (state_1 === "break")
          break;
      }
    };
    Element2.prototype.emitDelegateEvent = function(element, name, eventObj) {
      var events = this.getEvents();
      var eventName = name + DELEGATION_SPLIT + eventObj.type;
      if (events[eventName] || events[WILDCARD]) {
        eventObj.name = eventName;
        eventObj.currentTarget = element;
        eventObj.delegateTarget = this;
        eventObj.delegateObject = element.get("delegateObject");
        this.emit(eventName, eventObj);
      }
    };
    Element2.prototype.translate = function(translateX, translateY) {
      if (translateX === void 0) {
        translateX = 0;
      }
      if (translateY === void 0) {
        translateY = 0;
      }
      var matrix = this.getMatrix();
      var newMatrix = transform$5(matrix, [["t", translateX, translateY]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element2.prototype.move = function(targetX, targetY) {
      var x = this.attr("x") || 0;
      var y = this.attr("y") || 0;
      this.translate(targetX - x, targetY - y);
      return this;
    };
    Element2.prototype.moveTo = function(targetX, targetY) {
      return this.move(targetX, targetY);
    };
    Element2.prototype.scale = function(ratioX, ratioY) {
      var matrix = this.getMatrix();
      var newMatrix = transform$5(matrix, [["s", ratioX, ratioY || ratioX]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element2.prototype.rotate = function(radian) {
      var matrix = this.getMatrix();
      var newMatrix = transform$5(matrix, [["r", radian]]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element2.prototype.rotateAtStart = function(rotate2) {
      var _a2 = this.attr(), x = _a2.x, y = _a2.y;
      var matrix = this.getMatrix();
      var newMatrix = transform$5(matrix, [
        ["t", -x, -y],
        ["r", rotate2],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    Element2.prototype.rotateAtPoint = function(x, y, rotate2) {
      var matrix = this.getMatrix();
      var newMatrix = transform$5(matrix, [
        ["t", -x, -y],
        ["r", rotate2],
        ["t", x, y]
      ]);
      this.setMatrix(newMatrix);
      return this;
    };
    return Element2;
  }(Base)
);
var SHAPE_MAP = {};
var INDEX = "_INDEX";
function setCanvas(element, canvas) {
  element.set("canvas", canvas);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setCanvas(child, canvas);
      });
    }
  }
}
function setTimeline(element, timeline) {
  element.set("timeline", timeline);
  if (element.isGroup()) {
    var children = element.get("children");
    if (children.length) {
      children.forEach(function(child) {
        setTimeline(child, timeline);
      });
    }
  }
}
function removeChild(container, element, destroy) {
  if (destroy === void 0) {
    destroy = true;
  }
  if (destroy) {
    element.destroy();
  } else {
    element.set("parent", null);
    element.set("canvas", null);
  }
  removeFromArray(container.getChildren(), element);
}
function getComparer(compare2) {
  return function(left2, right2) {
    var result = compare2(left2, right2);
    return result === 0 ? left2[INDEX] - right2[INDEX] : result;
  };
}
var Container = (
  /** @class */
  function(_super) {
    __extends$1(Container2, _super);
    function Container2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Container2.prototype.isCanvas = function() {
      return false;
    };
    Container2.prototype.getBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY2 = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each$1(children, function(child) {
          var box3 = child.getBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min$2(xArr);
        maxX = max$2(xArr);
        minY = min$2(yArr);
        maxY2 = max$2(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY2 = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
      return box2;
    };
    Container2.prototype.getCanvasBBox = function() {
      var minX = Infinity;
      var maxX = -Infinity;
      var minY = Infinity;
      var maxY2 = -Infinity;
      var xArr = [];
      var yArr = [];
      var children = this.getChildren().filter(function(child) {
        return child.get("visible") && (!child.isGroup() || child.isGroup() && child.getChildren().length > 0);
      });
      if (children.length > 0) {
        each$1(children, function(child) {
          var box3 = child.getCanvasBBox();
          xArr.push(box3.minX, box3.maxX);
          yArr.push(box3.minY, box3.maxY);
        });
        minX = min$2(xArr);
        maxX = max$2(xArr);
        minY = min$2(yArr);
        maxY2 = max$2(yArr);
      } else {
        minX = 0;
        maxX = 0;
        minY = 0;
        maxY2 = 0;
      }
      var box2 = {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
      return box2;
    };
    Container2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["children"] = [];
      return cfg;
    };
    Container2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name === "matrix") {
        var totalMatrix = this.getTotalMatrix();
        this._applyChildrenMarix(totalMatrix);
      }
    };
    Container2.prototype.applyMatrix = function(matrix) {
      var preTotalMatrix = this.getTotalMatrix();
      _super.prototype.applyMatrix.call(this, matrix);
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix === preTotalMatrix) {
        return;
      }
      this._applyChildrenMarix(totalMatrix);
    };
    Container2.prototype._applyChildrenMarix = function(totalMatrix) {
      var children = this.getChildren();
      each$1(children, function(child) {
        child.applyMatrix(totalMatrix);
      });
    };
    Container2.prototype.addShape = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var type = args[0];
      var cfg = args[1];
      if (isObject(type)) {
        cfg = type;
      } else {
        cfg["type"] = type;
      }
      var shapeType = SHAPE_MAP[cfg.type];
      if (!shapeType) {
        shapeType = upperFirst(cfg.type);
        SHAPE_MAP[cfg.type] = shapeType;
      }
      var ShapeBase2 = this.getShapeBase();
      var shape = new ShapeBase2[shapeType](cfg);
      this.add(shape);
      return shape;
    };
    Container2.prototype.addGroup = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      var groupClass = args[0], cfg = args[1];
      var group2;
      if (isFunction(groupClass)) {
        if (cfg) {
          group2 = new groupClass(cfg);
        } else {
          group2 = new groupClass({
            // canvas,
            parent: this
          });
        }
      } else {
        var tmpCfg = groupClass || {};
        var TmpGroupClass = this.getGroupBase();
        group2 = new TmpGroupClass(tmpCfg);
      }
      this.add(group2);
      return group2;
    };
    Container2.prototype.getCanvas = function() {
      var canvas;
      if (this.isCanvas()) {
        canvas = this;
      } else {
        canvas = this.get("canvas");
      }
      return canvas;
    };
    Container2.prototype.getShape = function(x, y, ev) {
      if (!isAllowCapture(this)) {
        return null;
      }
      var children = this.getChildren();
      var shape;
      if (!this.isCanvas()) {
        var v = [x, y, 1];
        v = this.invertFromMatrix(v);
        if (!this.isClipped(v[0], v[1])) {
          shape = this._findShape(children, v[0], v[1], ev);
        }
      } else {
        shape = this._findShape(children, x, y, ev);
      }
      return shape;
    };
    Container2.prototype._findShape = function(children, x, y, ev) {
      var shape = null;
      for (var i = children.length - 1; i >= 0; i--) {
        var child = children[i];
        if (isAllowCapture(child)) {
          if (child.isGroup()) {
            shape = child.getShape(x, y, ev);
          } else if (child.isHit(x, y)) {
            shape = child;
          }
        }
        if (shape) {
          break;
        }
      }
      return shape;
    };
    Container2.prototype.add = function(element) {
      var canvas = this.getCanvas();
      var children = this.getChildren();
      var timeline = this.get("timeline");
      var preParent = element.getParent();
      if (preParent) {
        removeChild(preParent, element, false);
      }
      element.set("parent", this);
      if (canvas) {
        setCanvas(element, canvas);
      }
      if (timeline) {
        setTimeline(element, timeline);
      }
      children.push(element);
      element.onCanvasChange("add");
      this._applyElementMatrix(element);
    };
    Container2.prototype._applyElementMatrix = function(element) {
      var totalMatrix = this.getTotalMatrix();
      if (totalMatrix) {
        element.applyMatrix(totalMatrix);
      }
    };
    Container2.prototype.getChildren = function() {
      return this.get("children");
    };
    Container2.prototype.sort = function() {
      var children = this.getChildren();
      each$1(children, function(child, index2) {
        child[INDEX] = index2;
        return child;
      });
      children.sort(getComparer(function(obj1, obj2) {
        return obj1.get("zIndex") - obj2.get("zIndex");
      }));
      this.onCanvasChange("sort");
    };
    Container2.prototype.clear = function() {
      this.set("clearing", true);
      if (this.destroyed) {
        return;
      }
      var children = this.getChildren();
      for (var i = children.length - 1; i >= 0; i--) {
        children[i].destroy();
      }
      this.set("children", []);
      this.onCanvasChange("clear");
      this.set("clearing", false);
    };
    Container2.prototype.destroy = function() {
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      _super.prototype.destroy.call(this);
    };
    Container2.prototype.getFirst = function() {
      return this.getChildByIndex(0);
    };
    Container2.prototype.getLast = function() {
      var children = this.getChildren();
      return this.getChildByIndex(children.length - 1);
    };
    Container2.prototype.getChildByIndex = function(index2) {
      var children = this.getChildren();
      return children[index2];
    };
    Container2.prototype.getCount = function() {
      var children = this.getChildren();
      return children.length;
    };
    Container2.prototype.contain = function(element) {
      var children = this.getChildren();
      return children.indexOf(element) > -1;
    };
    Container2.prototype.removeChild = function(element, destroy) {
      if (destroy === void 0) {
        destroy = true;
      }
      if (this.contain(element)) {
        element.remove(destroy);
      }
    };
    Container2.prototype.findAll = function(fn) {
      var rst = [];
      var children = this.getChildren();
      each$1(children, function(element) {
        if (fn(element)) {
          rst.push(element);
        }
        if (element.isGroup()) {
          rst = rst.concat(element.findAll(fn));
        }
      });
      return rst;
    };
    Container2.prototype.find = function(fn) {
      var rst = null;
      var children = this.getChildren();
      each$1(children, function(element) {
        if (fn(element)) {
          rst = element;
        } else if (element.isGroup()) {
          rst = element.find(fn);
        }
        if (rst) {
          return false;
        }
      });
      return rst;
    };
    Container2.prototype.findById = function(id2) {
      return this.find(function(element) {
        return element.get("id") === id2;
      });
    };
    Container2.prototype.findByClassName = function(className) {
      return this.find(function(element) {
        return element.get("className") === className;
      });
    };
    Container2.prototype.findAllByName = function(name) {
      return this.findAll(function(element) {
        return element.get("name") === name;
      });
    };
    return Container2;
  }(Element$2)
);
var frame = 0, timeout = 0, interval$1 = 0, pokeDelay = 1e3, taskHead, taskTail, clockLast = 0, clockNow = 0, clockSkew = 0, clock = typeof performance === "object" && performance.now ? performance : Date, setFrame = typeof window === "object" && window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : function(f) {
  setTimeout(f, 17);
};
function now() {
  return clockNow || (setFrame(clearNow), clockNow = clock.now() + clockSkew);
}
function clearNow() {
  clockNow = 0;
}
function Timer() {
  this._call = this._time = this._next = null;
}
Timer.prototype = timer.prototype = {
  constructor: Timer,
  restart: function(callback, delay, time) {
    if (typeof callback !== "function")
      throw new TypeError("callback is not a function");
    time = (time == null ? now() : +time) + (delay == null ? 0 : +delay);
    if (!this._next && taskTail !== this) {
      if (taskTail)
        taskTail._next = this;
      else
        taskHead = this;
      taskTail = this;
    }
    this._call = callback;
    this._time = time;
    sleep();
  },
  stop: function() {
    if (this._call) {
      this._call = null;
      this._time = Infinity;
      sleep();
    }
  }
};
function timer(callback, delay, time) {
  var t = new Timer();
  t.restart(callback, delay, time);
  return t;
}
function timerFlush() {
  now();
  ++frame;
  var t = taskHead, e;
  while (t) {
    if ((e = clockNow - t._time) >= 0)
      t._call.call(null, e);
    t = t._next;
  }
  --frame;
}
function wake() {
  clockNow = (clockLast = clock.now()) + clockSkew;
  frame = timeout = 0;
  try {
    timerFlush();
  } finally {
    frame = 0;
    nap();
    clockNow = 0;
  }
}
function poke() {
  var now2 = clock.now(), delay = now2 - clockLast;
  if (delay > pokeDelay)
    clockSkew -= delay, clockLast = now2;
}
function nap() {
  var t0, t1 = taskHead, t2, time = Infinity;
  while (t1) {
    if (t1._call) {
      if (time > t1._time)
        time = t1._time;
      t0 = t1, t1 = t1._next;
    } else {
      t2 = t1._next, t1._next = null;
      t1 = t0 ? t0._next = t2 : taskHead = t2;
    }
  }
  taskTail = t0;
  sleep(time);
}
function sleep(time) {
  if (frame)
    return;
  if (timeout)
    timeout = clearTimeout(timeout);
  var delay = time - clockNow;
  if (delay > 24) {
    if (time < Infinity)
      timeout = setTimeout(wake, time - clock.now() - clockSkew);
    if (interval$1)
      interval$1 = clearInterval(interval$1);
  } else {
    if (!interval$1)
      clockLast = clock.now(), interval$1 = setInterval(poke, pokeDelay);
    frame = 1, setFrame(wake);
  }
}
function define(constructor, factory, prototype) {
  constructor.prototype = factory.prototype = prototype;
  prototype.constructor = constructor;
}
function extend(parent, definition) {
  var prototype = Object.create(parent.prototype);
  for (var key in definition)
    prototype[key] = definition[key];
  return prototype;
}
function Color$1() {
}
var darker = 0.7;
var brighter = 1 / darker;
var reI = "\\s*([+-]?\\d+)\\s*", reN = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)\\s*", reP = "\\s*([+-]?\\d*\\.?\\d+(?:[eE][+-]?\\d+)?)%\\s*", reHex = /^#([0-9a-f]{3,8})$/, reRgbInteger = new RegExp("^rgb\\(" + [reI, reI, reI] + "\\)$"), reRgbPercent = new RegExp("^rgb\\(" + [reP, reP, reP] + "\\)$"), reRgbaInteger = new RegExp("^rgba\\(" + [reI, reI, reI, reN] + "\\)$"), reRgbaPercent = new RegExp("^rgba\\(" + [reP, reP, reP, reN] + "\\)$"), reHslPercent = new RegExp("^hsl\\(" + [reN, reP, reP] + "\\)$"), reHslaPercent = new RegExp("^hsla\\(" + [reN, reP, reP, reN] + "\\)$");
var named = {
  aliceblue: 15792383,
  antiquewhite: 16444375,
  aqua: 65535,
  aquamarine: 8388564,
  azure: 15794175,
  beige: 16119260,
  bisque: 16770244,
  black: 0,
  blanchedalmond: 16772045,
  blue: 255,
  blueviolet: 9055202,
  brown: 10824234,
  burlywood: 14596231,
  cadetblue: 6266528,
  chartreuse: 8388352,
  chocolate: 13789470,
  coral: 16744272,
  cornflowerblue: 6591981,
  cornsilk: 16775388,
  crimson: 14423100,
  cyan: 65535,
  darkblue: 139,
  darkcyan: 35723,
  darkgoldenrod: 12092939,
  darkgray: 11119017,
  darkgreen: 25600,
  darkgrey: 11119017,
  darkkhaki: 12433259,
  darkmagenta: 9109643,
  darkolivegreen: 5597999,
  darkorange: 16747520,
  darkorchid: 10040012,
  darkred: 9109504,
  darksalmon: 15308410,
  darkseagreen: 9419919,
  darkslateblue: 4734347,
  darkslategray: 3100495,
  darkslategrey: 3100495,
  darkturquoise: 52945,
  darkviolet: 9699539,
  deeppink: 16716947,
  deepskyblue: 49151,
  dimgray: 6908265,
  dimgrey: 6908265,
  dodgerblue: 2003199,
  firebrick: 11674146,
  floralwhite: 16775920,
  forestgreen: 2263842,
  fuchsia: 16711935,
  gainsboro: 14474460,
  ghostwhite: 16316671,
  gold: 16766720,
  goldenrod: 14329120,
  gray: 8421504,
  green: 32768,
  greenyellow: 11403055,
  grey: 8421504,
  honeydew: 15794160,
  hotpink: 16738740,
  indianred: 13458524,
  indigo: 4915330,
  ivory: 16777200,
  khaki: 15787660,
  lavender: 15132410,
  lavenderblush: 16773365,
  lawngreen: 8190976,
  lemonchiffon: 16775885,
  lightblue: 11393254,
  lightcoral: 15761536,
  lightcyan: 14745599,
  lightgoldenrodyellow: 16448210,
  lightgray: 13882323,
  lightgreen: 9498256,
  lightgrey: 13882323,
  lightpink: 16758465,
  lightsalmon: 16752762,
  lightseagreen: 2142890,
  lightskyblue: 8900346,
  lightslategray: 7833753,
  lightslategrey: 7833753,
  lightsteelblue: 11584734,
  lightyellow: 16777184,
  lime: 65280,
  limegreen: 3329330,
  linen: 16445670,
  magenta: 16711935,
  maroon: 8388608,
  mediumaquamarine: 6737322,
  mediumblue: 205,
  mediumorchid: 12211667,
  mediumpurple: 9662683,
  mediumseagreen: 3978097,
  mediumslateblue: 8087790,
  mediumspringgreen: 64154,
  mediumturquoise: 4772300,
  mediumvioletred: 13047173,
  midnightblue: 1644912,
  mintcream: 16121850,
  mistyrose: 16770273,
  moccasin: 16770229,
  navajowhite: 16768685,
  navy: 128,
  oldlace: 16643558,
  olive: 8421376,
  olivedrab: 7048739,
  orange: 16753920,
  orangered: 16729344,
  orchid: 14315734,
  palegoldenrod: 15657130,
  palegreen: 10025880,
  paleturquoise: 11529966,
  palevioletred: 14381203,
  papayawhip: 16773077,
  peachpuff: 16767673,
  peru: 13468991,
  pink: 16761035,
  plum: 14524637,
  powderblue: 11591910,
  purple: 8388736,
  rebeccapurple: 6697881,
  red: 16711680,
  rosybrown: 12357519,
  royalblue: 4286945,
  saddlebrown: 9127187,
  salmon: 16416882,
  sandybrown: 16032864,
  seagreen: 3050327,
  seashell: 16774638,
  sienna: 10506797,
  silver: 12632256,
  skyblue: 8900331,
  slateblue: 6970061,
  slategray: 7372944,
  slategrey: 7372944,
  snow: 16775930,
  springgreen: 65407,
  steelblue: 4620980,
  tan: 13808780,
  teal: 32896,
  thistle: 14204888,
  tomato: 16737095,
  turquoise: 4251856,
  violet: 15631086,
  wheat: 16113331,
  white: 16777215,
  whitesmoke: 16119285,
  yellow: 16776960,
  yellowgreen: 10145074
};
define(Color$1, color$1, {
  copy: function(channels) {
    return Object.assign(new this.constructor(), this, channels);
  },
  displayable: function() {
    return this.rgb().displayable();
  },
  hex: color_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: color_formatHex,
  formatHsl: color_formatHsl,
  formatRgb: color_formatRgb,
  toString: color_formatRgb
});
function color_formatHex() {
  return this.rgb().formatHex();
}
function color_formatHsl() {
  return hslConvert(this).formatHsl();
}
function color_formatRgb() {
  return this.rgb().formatRgb();
}
function color$1(format2) {
  var m, l;
  format2 = (format2 + "").trim().toLowerCase();
  return (m = reHex.exec(format2)) ? (l = m[1].length, m = parseInt(m[1], 16), l === 6 ? rgbn(m) : l === 3 ? new Rgb(m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, (m & 15) << 4 | m & 15, 1) : l === 8 ? rgba(m >> 24 & 255, m >> 16 & 255, m >> 8 & 255, (m & 255) / 255) : l === 4 ? rgba(m >> 12 & 15 | m >> 8 & 240, m >> 8 & 15 | m >> 4 & 240, m >> 4 & 15 | m & 240, ((m & 15) << 4 | m & 15) / 255) : null) : (m = reRgbInteger.exec(format2)) ? new Rgb(m[1], m[2], m[3], 1) : (m = reRgbPercent.exec(format2)) ? new Rgb(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, 1) : (m = reRgbaInteger.exec(format2)) ? rgba(m[1], m[2], m[3], m[4]) : (m = reRgbaPercent.exec(format2)) ? rgba(m[1] * 255 / 100, m[2] * 255 / 100, m[3] * 255 / 100, m[4]) : (m = reHslPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, 1) : (m = reHslaPercent.exec(format2)) ? hsla(m[1], m[2] / 100, m[3] / 100, m[4]) : named.hasOwnProperty(format2) ? rgbn(named[format2]) : format2 === "transparent" ? new Rgb(NaN, NaN, NaN, 0) : null;
}
function rgbn(n) {
  return new Rgb(n >> 16 & 255, n >> 8 & 255, n & 255, 1);
}
function rgba(r, g, b, a) {
  if (a <= 0)
    r = g = b = NaN;
  return new Rgb(r, g, b, a);
}
function rgbConvert(o) {
  if (!(o instanceof Color$1))
    o = color$1(o);
  if (!o)
    return new Rgb();
  o = o.rgb();
  return new Rgb(o.r, o.g, o.b, o.opacity);
}
function rgb$1(r, g, b, opacity) {
  return arguments.length === 1 ? rgbConvert(r) : new Rgb(r, g, b, opacity == null ? 1 : opacity);
}
function Rgb(r, g, b, opacity) {
  this.r = +r;
  this.g = +g;
  this.b = +b;
  this.opacity = +opacity;
}
define(Rgb, rgb$1, extend(Color$1, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Rgb(this.r * k, this.g * k, this.b * k, this.opacity);
  },
  rgb: function() {
    return this;
  },
  displayable: function() {
    return -0.5 <= this.r && this.r < 255.5 && (-0.5 <= this.g && this.g < 255.5) && (-0.5 <= this.b && this.b < 255.5) && (0 <= this.opacity && this.opacity <= 1);
  },
  hex: rgb_formatHex,
  // Deprecated! Use color.formatHex.
  formatHex: rgb_formatHex,
  formatRgb: rgb_formatRgb,
  toString: rgb_formatRgb
}));
function rgb_formatHex() {
  return "#" + hex(this.r) + hex(this.g) + hex(this.b);
}
function rgb_formatRgb() {
  var a = this.opacity;
  a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
  return (a === 1 ? "rgb(" : "rgba(") + Math.max(0, Math.min(255, Math.round(this.r) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.g) || 0)) + ", " + Math.max(0, Math.min(255, Math.round(this.b) || 0)) + (a === 1 ? ")" : ", " + a + ")");
}
function hex(value2) {
  value2 = Math.max(0, Math.min(255, Math.round(value2) || 0));
  return (value2 < 16 ? "0" : "") + value2.toString(16);
}
function hsla(h, s, l, a) {
  if (a <= 0)
    h = s = l = NaN;
  else if (l <= 0 || l >= 1)
    h = s = NaN;
  else if (s <= 0)
    h = NaN;
  return new Hsl(h, s, l, a);
}
function hslConvert(o) {
  if (o instanceof Hsl)
    return new Hsl(o.h, o.s, o.l, o.opacity);
  if (!(o instanceof Color$1))
    o = color$1(o);
  if (!o)
    return new Hsl();
  if (o instanceof Hsl)
    return o;
  o = o.rgb();
  var r = o.r / 255, g = o.g / 255, b = o.b / 255, min2 = Math.min(r, g, b), max2 = Math.max(r, g, b), h = NaN, s = max2 - min2, l = (max2 + min2) / 2;
  if (s) {
    if (r === max2)
      h = (g - b) / s + (g < b) * 6;
    else if (g === max2)
      h = (b - r) / s + 2;
    else
      h = (r - g) / s + 4;
    s /= l < 0.5 ? max2 + min2 : 2 - max2 - min2;
    h *= 60;
  } else {
    s = l > 0 && l < 1 ? 0 : h;
  }
  return new Hsl(h, s, l, o.opacity);
}
function hsl(h, s, l, opacity) {
  return arguments.length === 1 ? hslConvert(h) : new Hsl(h, s, l, opacity == null ? 1 : opacity);
}
function Hsl(h, s, l, opacity) {
  this.h = +h;
  this.s = +s;
  this.l = +l;
  this.opacity = +opacity;
}
define(Hsl, hsl, extend(Color$1, {
  brighter: function(k) {
    k = k == null ? brighter : Math.pow(brighter, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  darker: function(k) {
    k = k == null ? darker : Math.pow(darker, k);
    return new Hsl(this.h, this.s, this.l * k, this.opacity);
  },
  rgb: function() {
    var h = this.h % 360 + (this.h < 0) * 360, s = isNaN(h) || isNaN(this.s) ? 0 : this.s, l = this.l, m2 = l + (l < 0.5 ? l : 1 - l) * s, m1 = 2 * l - m2;
    return new Rgb(
      hsl2rgb(h >= 240 ? h - 240 : h + 120, m1, m2),
      hsl2rgb(h, m1, m2),
      hsl2rgb(h < 120 ? h + 240 : h - 120, m1, m2),
      this.opacity
    );
  },
  displayable: function() {
    return (0 <= this.s && this.s <= 1 || isNaN(this.s)) && (0 <= this.l && this.l <= 1) && (0 <= this.opacity && this.opacity <= 1);
  },
  formatHsl: function() {
    var a = this.opacity;
    a = isNaN(a) ? 1 : Math.max(0, Math.min(1, a));
    return (a === 1 ? "hsl(" : "hsla(") + (this.h || 0) + ", " + (this.s || 0) * 100 + "%, " + (this.l || 0) * 100 + "%" + (a === 1 ? ")" : ", " + a + ")");
  }
}));
function hsl2rgb(h, m1, m2) {
  return (h < 60 ? m1 + (m2 - m1) * h / 60 : h < 180 ? m2 : h < 240 ? m1 + (m2 - m1) * (240 - h) / 60 : m1) * 255;
}
function constant$3(x) {
  return function() {
    return x;
  };
}
function linear$3(a, d) {
  return function(t) {
    return a + t * d;
  };
}
function exponential$1(a, b, y) {
  return a = Math.pow(a, y), b = Math.pow(b, y) - a, y = 1 / y, function(t) {
    return Math.pow(a + t * b, y);
  };
}
function gamma(y) {
  return (y = +y) === 1 ? nogamma : function(a, b) {
    return b - a ? exponential$1(a, b, y) : constant$3(isNaN(a) ? b : a);
  };
}
function nogamma(a, b) {
  var d = b - a;
  return d ? linear$3(a, d) : constant$3(isNaN(a) ? b : a);
}
const rgb = function rgbGamma(y) {
  var color2 = gamma(y);
  function rgb2(start, end) {
    var r = color2((start = rgb$1(start)).r, (end = rgb$1(end)).r), g = color2(start.g, end.g), b = color2(start.b, end.b), opacity = nogamma(start.opacity, end.opacity);
    return function(t) {
      start.r = r(t);
      start.g = g(t);
      start.b = b(t);
      start.opacity = opacity(t);
      return start + "";
    };
  }
  rgb2.gamma = rgbGamma;
  return rgb2;
}(1);
function numberArray(a, b) {
  if (!b)
    b = [];
  var n = a ? Math.min(b.length, a.length) : 0, c = b.slice(), i;
  return function(t) {
    for (i = 0; i < n; ++i)
      c[i] = a[i] * (1 - t) + b[i] * t;
    return c;
  };
}
function isNumberArray(x) {
  return ArrayBuffer.isView(x) && !(x instanceof DataView);
}
function interpolateArray(a, b) {
  return (isNumberArray(b) ? numberArray : genericArray)(a, b);
}
function genericArray(a, b) {
  var nb = b ? b.length : 0, na = a ? Math.min(nb, a.length) : 0, x = new Array(na), c = new Array(nb), i;
  for (i = 0; i < na; ++i)
    x[i] = interpolate(a[i], b[i]);
  for (; i < nb; ++i)
    c[i] = b[i];
  return function(t) {
    for (i = 0; i < na; ++i)
      c[i] = x[i](t);
    return c;
  };
}
function date(a, b) {
  var d = /* @__PURE__ */ new Date();
  return a = +a, b = +b, function(t) {
    return d.setTime(a * (1 - t) + b * t), d;
  };
}
function number(a, b) {
  return a = +a, b = +b, function(t) {
    return a * (1 - t) + b * t;
  };
}
function object$1(a, b) {
  var i = {}, c = {}, k;
  if (a === null || typeof a !== "object")
    a = {};
  if (b === null || typeof b !== "object")
    b = {};
  for (k in b) {
    if (k in a) {
      i[k] = interpolate(a[k], b[k]);
    } else {
      c[k] = b[k];
    }
  }
  return function(t) {
    for (k in i)
      c[k] = i[k](t);
    return c;
  };
}
var reA = /[-+]?(?:\d+\.?\d*|\.?\d+)(?:[eE][-+]?\d+)?/g, reB = new RegExp(reA.source, "g");
function zero(b) {
  return function() {
    return b;
  };
}
function one(b) {
  return function(t) {
    return b(t) + "";
  };
}
function string(a, b) {
  var bi = reA.lastIndex = reB.lastIndex = 0, am, bm, bs, i = -1, s = [], q = [];
  a = a + "", b = b + "";
  while ((am = reA.exec(a)) && (bm = reB.exec(b))) {
    if ((bs = bm.index) > bi) {
      bs = b.slice(bi, bs);
      if (s[i])
        s[i] += bs;
      else
        s[++i] = bs;
    }
    if ((am = am[0]) === (bm = bm[0])) {
      if (s[i])
        s[i] += bm;
      else
        s[++i] = bm;
    } else {
      s[++i] = null;
      q.push({ i, x: number(am, bm) });
    }
    bi = reB.lastIndex;
  }
  if (bi < b.length) {
    bs = b.slice(bi);
    if (s[i])
      s[i] += bs;
    else
      s[++i] = bs;
  }
  return s.length < 2 ? q[0] ? one(q[0].x) : zero(b) : (b = q.length, function(t) {
    for (var i2 = 0, o; i2 < b; ++i2)
      s[(o = q[i2]).i] = o.x(t);
    return s.join("");
  });
}
function interpolate(a, b) {
  var t = typeof b, c;
  return b == null || t === "boolean" ? constant$3(b) : (t === "number" ? number : t === "string" ? (c = color$1(b)) ? (b = c, rgb) : string : b instanceof color$1 ? rgb : b instanceof Date ? date : isNumberArray(b) ? numberArray : Array.isArray(b) ? genericArray : typeof b.valueOf !== "function" && typeof b.toString !== "function" || isNaN(b) ? object$1 : number)(a, b);
}
function linear$2(t) {
  return +t;
}
function quadIn(t) {
  return t * t;
}
function quadOut(t) {
  return t * (2 - t);
}
function quadInOut(t) {
  return ((t *= 2) <= 1 ? t * t : --t * (2 - t) + 1) / 2;
}
function cubicIn(t) {
  return t * t * t;
}
function cubicOut(t) {
  return --t * t * t + 1;
}
function cubicInOut(t) {
  return ((t *= 2) <= 1 ? t * t * t : (t -= 2) * t * t + 2) / 2;
}
var exponent = 3;
var polyIn = function custom(e) {
  e = +e;
  function polyIn2(t) {
    return Math.pow(t, e);
  }
  polyIn2.exponent = custom;
  return polyIn2;
}(exponent);
var polyOut = function custom2(e) {
  e = +e;
  function polyOut2(t) {
    return 1 - Math.pow(1 - t, e);
  }
  polyOut2.exponent = custom2;
  return polyOut2;
}(exponent);
var polyInOut = function custom3(e) {
  e = +e;
  function polyInOut2(t) {
    return ((t *= 2) <= 1 ? Math.pow(t, e) : 2 - Math.pow(2 - t, e)) / 2;
  }
  polyInOut2.exponent = custom3;
  return polyInOut2;
}(exponent);
var pi = Math.PI, halfPi = pi / 2;
function sinIn(t) {
  return +t === 1 ? 1 : 1 - Math.cos(t * halfPi);
}
function sinOut(t) {
  return Math.sin(t * halfPi);
}
function sinInOut(t) {
  return (1 - Math.cos(pi * t)) / 2;
}
function tpmt(x) {
  return (Math.pow(2, -10 * x) - 9765625e-10) * 1.0009775171065494;
}
function expIn(t) {
  return tpmt(1 - +t);
}
function expOut(t) {
  return 1 - tpmt(t);
}
function expInOut(t) {
  return ((t *= 2) <= 1 ? tpmt(1 - t) : 2 - tpmt(t - 1)) / 2;
}
function circleIn(t) {
  return 1 - Math.sqrt(1 - t * t);
}
function circleOut(t) {
  return Math.sqrt(1 - --t * t);
}
function circleInOut(t) {
  return ((t *= 2) <= 1 ? 1 - Math.sqrt(1 - t * t) : Math.sqrt(1 - (t -= 2) * t) + 1) / 2;
}
var b1 = 4 / 11, b2 = 6 / 11, b3 = 8 / 11, b4 = 3 / 4, b5 = 9 / 11, b6 = 10 / 11, b7 = 15 / 16, b8 = 21 / 22, b9 = 63 / 64, b0 = 1 / b1 / b1;
function bounceIn(t) {
  return 1 - bounceOut(1 - t);
}
function bounceOut(t) {
  return (t = +t) < b1 ? b0 * t * t : t < b3 ? b0 * (t -= b2) * t + b4 : t < b6 ? b0 * (t -= b5) * t + b7 : b0 * (t -= b8) * t + b9;
}
function bounceInOut(t) {
  return ((t *= 2) <= 1 ? 1 - bounceOut(1 - t) : bounceOut(t - 1) + 1) / 2;
}
var overshoot = 1.70158;
var backIn = function custom4(s) {
  s = +s;
  function backIn2(t) {
    return (t = +t) * t * (s * (t - 1) + t);
  }
  backIn2.overshoot = custom4;
  return backIn2;
}(overshoot);
var backOut = function custom5(s) {
  s = +s;
  function backOut2(t) {
    return --t * t * ((t + 1) * s + t) + 1;
  }
  backOut2.overshoot = custom5;
  return backOut2;
}(overshoot);
var backInOut = function custom6(s) {
  s = +s;
  function backInOut2(t) {
    return ((t *= 2) < 1 ? t * t * ((s + 1) * t - s) : (t -= 2) * t * ((s + 1) * t + s) + 2) / 2;
  }
  backInOut2.overshoot = custom6;
  return backInOut2;
}(overshoot);
var tau = 2 * Math.PI, amplitude = 1, period = 0.3;
var elasticIn = function custom7(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticIn2(t) {
    return a * tpmt(- --t) * Math.sin((s - t) / p);
  }
  elasticIn2.amplitude = function(a2) {
    return custom7(a2, p * tau);
  };
  elasticIn2.period = function(p2) {
    return custom7(a, p2);
  };
  return elasticIn2;
}(amplitude, period);
var elasticOut = function custom8(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticOut2(t) {
    return 1 - a * tpmt(t = +t) * Math.sin((t + s) / p);
  }
  elasticOut2.amplitude = function(a2) {
    return custom8(a2, p * tau);
  };
  elasticOut2.period = function(p2) {
    return custom8(a, p2);
  };
  return elasticOut2;
}(amplitude, period);
var elasticInOut = function custom9(a, p) {
  var s = Math.asin(1 / (a = Math.max(1, a))) * (p /= tau);
  function elasticInOut2(t) {
    return ((t = t * 2 - 1) < 0 ? a * tpmt(-t) * Math.sin((s - t) / p) : 2 - a * tpmt(t) * Math.sin((s + t) / p)) / 2;
  }
  elasticInOut2.amplitude = function(a2) {
    return custom9(a2, p * tau);
  };
  elasticInOut2.period = function(p2) {
    return custom9(a, p2);
  };
  return elasticInOut2;
}(amplitude, period);
const d3Ease = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  easeBack: backInOut,
  easeBackIn: backIn,
  easeBackInOut: backInOut,
  easeBackOut: backOut,
  easeBounce: bounceOut,
  easeBounceIn: bounceIn,
  easeBounceInOut: bounceInOut,
  easeBounceOut: bounceOut,
  easeCircle: circleInOut,
  easeCircleIn: circleIn,
  easeCircleInOut: circleInOut,
  easeCircleOut: circleOut,
  easeCubic: cubicInOut,
  easeCubicIn: cubicIn,
  easeCubicInOut: cubicInOut,
  easeCubicOut: cubicOut,
  easeElastic: elasticOut,
  easeElasticIn: elasticIn,
  easeElasticInOut: elasticInOut,
  easeElasticOut: elasticOut,
  easeExp: expInOut,
  easeExpIn: expIn,
  easeExpInOut: expInOut,
  easeExpOut: expOut,
  easeLinear: linear$2,
  easePoly: polyInOut,
  easePolyIn: polyIn,
  easePolyInOut: polyInOut,
  easePolyOut: polyOut,
  easeQuad: quadInOut,
  easeQuadIn: quadIn,
  easeQuadInOut: quadInOut,
  easeQuadOut: quadOut,
  easeSin: sinInOut,
  easeSinIn: sinIn,
  easeSinInOut: sinInOut,
  easeSinOut: sinOut
}, Symbol.toStringTag, { value: "Module" }));
var EASING_MAP = {};
function getEasing(type) {
  return EASING_MAP[type.toLowerCase()] || d3Ease[type];
}
function registerEasing(type, easeFn) {
  EASING_MAP[type.toLowerCase()] = easeFn;
}
var isColorProp = function(prop) {
  return ["fill", "stroke", "fillStyle", "strokeStyle"].includes(prop);
};
var isGradientColor$1 = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var IDENTITY_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function _update(shape, animation2, ratio) {
  var cProps = {};
  var fromAttrs = animation2.fromAttrs, toAttrs = animation2.toAttrs;
  if (shape.destroyed) {
    return;
  }
  var interf;
  for (var k in toAttrs) {
    if (!isEqual$1(fromAttrs[k], toAttrs[k])) {
      if (k === "path") {
        var toPath = toAttrs[k];
        var fromPath = fromAttrs[k];
        if (toPath.length > fromPath.length) {
          toPath = parsePathString$1(toAttrs[k]);
          fromPath = parsePathString$1(fromAttrs[k]);
          fromPath = fillPathByDiff(fromPath, toPath);
          fromPath = formatPath(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
        } else if (!animation2.pathFormatted) {
          toPath = parsePathString$1(toAttrs[k]);
          fromPath = parsePathString$1(fromAttrs[k]);
          fromPath = formatPath(fromPath, toPath);
          animation2.fromAttrs.path = fromPath;
          animation2.toAttrs.path = toPath;
          animation2.pathFormatted = true;
        }
        cProps[k] = [];
        for (var i = 0; i < toPath.length; i++) {
          var toPathPoint = toPath[i];
          var fromPathPoint = fromPath[i];
          var cPathPoint = [];
          for (var j = 0; j < toPathPoint.length; j++) {
            if (isNumber$1(toPathPoint[j]) && fromPathPoint && isNumber$1(fromPathPoint[j])) {
              interf = interpolate(fromPathPoint[j], toPathPoint[j]);
              cPathPoint.push(interf(ratio));
            } else {
              cPathPoint.push(toPathPoint[j]);
            }
          }
          cProps[k].push(cPathPoint);
        }
      } else if (k === "matrix") {
        var matrixFn = interpolateArray(fromAttrs[k] || IDENTITY_MATRIX, toAttrs[k] || IDENTITY_MATRIX);
        var currentMatrix = matrixFn(ratio);
        cProps[k] = currentMatrix;
      } else if (isColorProp(k) && isGradientColor$1(toAttrs[k])) {
        cProps[k] = toAttrs[k];
      } else if (!isFunction(toAttrs[k])) {
        interf = interpolate(fromAttrs[k], toAttrs[k]);
        cProps[k] = interf(ratio);
      }
    }
  }
  shape.attr(cProps);
}
function update(shape, animation2, elapsed) {
  var startTime = animation2.startTime, delay = animation2.delay;
  if (elapsed < startTime + delay || animation2._paused) {
    return false;
  }
  var ratio;
  var duration = animation2.duration;
  var easing = animation2.easing;
  var easeFn = getEasing(easing);
  elapsed = elapsed - startTime - animation2.delay;
  if (animation2.repeat) {
    ratio = elapsed % duration / duration;
    ratio = easeFn(ratio);
  } else {
    ratio = elapsed / duration;
    if (ratio < 1) {
      ratio = easeFn(ratio);
    } else {
      if (animation2.onFrame) {
        shape.attr(animation2.onFrame(1));
      } else {
        shape.attr(animation2.toAttrs);
      }
      return true;
    }
  }
  if (animation2.onFrame) {
    var attrs = animation2.onFrame(ratio);
    shape.attr(attrs);
  } else {
    _update(shape, animation2, ratio);
  }
  return false;
}
var Timeline = (
  /** @class */
  function() {
    function Timeline2(canvas) {
      this.animators = [];
      this.current = 0;
      this.timer = null;
      this.canvas = canvas;
    }
    Timeline2.prototype.initTimer = function() {
      var _this = this;
      var isFinished = false;
      var shape;
      var animations;
      var animation2;
      this.timer = timer(function(elapsed) {
        _this.current = elapsed;
        if (_this.animators.length > 0) {
          for (var i = _this.animators.length - 1; i >= 0; i--) {
            shape = _this.animators[i];
            if (shape.destroyed) {
              _this.removeAnimator(i);
              continue;
            }
            if (!shape.isAnimatePaused()) {
              animations = shape.get("animations");
              for (var j = animations.length - 1; j >= 0; j--) {
                animation2 = animations[j];
                isFinished = update(shape, animation2, elapsed);
                if (isFinished) {
                  animations.splice(j, 1);
                  isFinished = false;
                  if (animation2.callback) {
                    animation2.callback();
                  }
                }
              }
            }
            if (animations.length === 0) {
              _this.removeAnimator(i);
            }
          }
          var autoDraw = _this.canvas.get("autoDraw");
          if (!autoDraw) {
            _this.canvas.draw();
          }
        }
      });
    };
    Timeline2.prototype.addAnimator = function(shape) {
      this.animators.push(shape);
    };
    Timeline2.prototype.removeAnimator = function(index2) {
      this.animators.splice(index2, 1);
    };
    Timeline2.prototype.isAnimating = function() {
      return !!this.animators.length;
    };
    Timeline2.prototype.stop = function() {
      if (this.timer) {
        this.timer.stop();
      }
    };
    Timeline2.prototype.stopAllAnimations = function(toEnd) {
      if (toEnd === void 0) {
        toEnd = true;
      }
      this.animators.forEach(function(animator) {
        animator.stopAnimate(toEnd);
      });
      this.animators = [];
      this.canvas.draw();
    };
    Timeline2.prototype.getTime = function() {
      return this.current;
    };
    return Timeline2;
  }()
);
var CLICK_OFFSET = 40;
var LEFT_BTN_CODE = 0;
var EVENTS$2 = [
  "mousedown",
  "mouseup",
  "dblclick",
  "mouseout",
  "mouseover",
  "mousemove",
  "mouseleave",
  "mouseenter",
  "touchstart",
  "touchmove",
  "touchend",
  "dragenter",
  "dragover",
  "dragleave",
  "drop",
  "contextmenu",
  "mousewheel"
];
function emitTargetEvent(target2, type, eventObj) {
  eventObj.name = type;
  eventObj.target = target2;
  eventObj.currentTarget = target2;
  eventObj.delegateTarget = target2;
  target2.emit(type, eventObj);
}
function bubbleEvent(container, type, eventObj) {
  if (eventObj.bubbles) {
    var relativeShape = void 0;
    var isOverEvent = false;
    if (type === "mouseenter") {
      relativeShape = eventObj.fromShape;
      isOverEvent = true;
    } else if (type === "mouseleave") {
      isOverEvent = true;
      relativeShape = eventObj.toShape;
    }
    if (container.isCanvas() && isOverEvent) {
      return;
    }
    if (relativeShape && isParent(container, relativeShape)) {
      eventObj.bubbles = false;
      return;
    }
    eventObj.name = type;
    eventObj.currentTarget = container;
    eventObj.delegateTarget = container;
    container.emit(type, eventObj);
  }
}
var EventController = (
  /** @class */
  function() {
    function EventController2(cfg) {
      var _this = this;
      this.draggingShape = null;
      this.dragging = false;
      this.currentShape = null;
      this.mousedownShape = null;
      this.mousedownPoint = null;
      this._eventCallback = function(ev) {
        var type = ev.type;
        _this._triggerEvent(type, ev);
      };
      this._onDocumentMove = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging || _this.currentShape) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.dragging) {
              _this._emitEvent("drag", ev, pointInfo, _this.draggingShape);
            }
          }
        }
      };
      this._onDocumentMouseUp = function(ev) {
        var canvas = _this.canvas;
        var el = canvas.get("el");
        if (el !== ev.target) {
          if (_this.dragging) {
            var pointInfo = _this._getPointInfo(ev);
            if (_this.draggingShape) {
              _this._emitEvent("drop", ev, pointInfo, null);
            }
            _this._emitEvent("dragend", ev, pointInfo, _this.draggingShape);
            _this._afterDrag(_this.draggingShape, pointInfo, ev);
          }
        }
      };
      this.canvas = cfg.canvas;
    }
    EventController2.prototype.init = function() {
      this._bindEvents();
    };
    EventController2.prototype._bindEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each$1(EVENTS$2, function(eventName) {
        el.addEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.addEventListener("mousemove", this._onDocumentMove);
        document.addEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._clearEvents = function() {
      var _this = this;
      var el = this.canvas.get("el");
      each$1(EVENTS$2, function(eventName) {
        el.removeEventListener(eventName, _this._eventCallback);
      });
      if (document) {
        document.removeEventListener("mousemove", this._onDocumentMove);
        document.removeEventListener("mouseup", this._onDocumentMouseUp);
      }
    };
    EventController2.prototype._getEventObj = function(type, event, point2, target2, fromShape, toShape) {
      var eventObj = new GraphEvent(type, event);
      eventObj.fromShape = fromShape;
      eventObj.toShape = toShape;
      eventObj.x = point2.x;
      eventObj.y = point2.y;
      eventObj.clientX = point2.clientX;
      eventObj.clientY = point2.clientY;
      eventObj.propagationPath.push(target2);
      return eventObj;
    };
    EventController2.prototype._getShape = function(point2, ev) {
      return this.canvas.getShape(point2.x, point2.y, ev);
    };
    EventController2.prototype._getPointInfo = function(ev) {
      var canvas = this.canvas;
      var clientPoint = canvas.getClientByEvent(ev);
      var point2 = canvas.getPointByEvent(ev);
      return {
        x: point2.x,
        y: point2.y,
        clientX: clientPoint.x,
        clientY: clientPoint.y
      };
    };
    EventController2.prototype._triggerEvent = function(type, ev) {
      var pointInfo = this._getPointInfo(ev);
      var shape = this._getShape(pointInfo, ev);
      var method = this["_on" + type];
      var leaveCanvas = false;
      if (method) {
        method.call(this, pointInfo, shape, ev);
      } else {
        var preShape = this.currentShape;
        if (type === "mouseenter" || type === "dragenter" || type === "mouseover") {
          this._emitEvent(type, ev, pointInfo, null, null, shape);
          if (shape) {
            this._emitEvent(type, ev, pointInfo, shape, null, shape);
          }
          if (type === "mouseenter" && this.draggingShape) {
            this._emitEvent("dragenter", ev, pointInfo, null);
          }
        } else if (type === "mouseleave" || type === "dragleave" || type === "mouseout") {
          leaveCanvas = true;
          if (preShape) {
            this._emitEvent(type, ev, pointInfo, preShape, preShape, null);
          }
          this._emitEvent(type, ev, pointInfo, null, preShape, null);
          if (type === "mouseleave" && this.draggingShape) {
            this._emitEvent("dragleave", ev, pointInfo, null);
          }
        } else {
          this._emitEvent(type, ev, pointInfo, shape, null, null);
        }
      }
      if (!leaveCanvas) {
        this.currentShape = shape;
      }
      if (shape && !shape.get("destroyed")) {
        var canvas = this.canvas;
        var el = canvas.get("el");
        el.style.cursor = shape.attr("cursor") || canvas.get("cursor");
      }
    };
    EventController2.prototype._onmousedown = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        this.mousedownShape = shape;
        this.mousedownPoint = pointInfo;
        this.mousedownTimeStamp = event.timeStamp;
      }
      this._emitEvent("mousedown", event, pointInfo, shape, null, null);
    };
    EventController2.prototype._emitMouseoverEvents = function(event, pointInfo, fromShape, toShape) {
      var el = this.canvas.get("el");
      if (fromShape !== toShape) {
        if (fromShape) {
          this._emitEvent("mouseout", event, pointInfo, fromShape, fromShape, toShape);
          this._emitEvent("mouseleave", event, pointInfo, fromShape, fromShape, toShape);
          if (!toShape || toShape.get("destroyed")) {
            el.style.cursor = this.canvas.get("cursor");
          }
        }
        if (toShape) {
          this._emitEvent("mouseover", event, pointInfo, toShape, fromShape, toShape);
          this._emitEvent("mouseenter", event, pointInfo, toShape, fromShape, toShape);
        }
      }
    };
    EventController2.prototype._emitDragoverEvents = function(event, pointInfo, fromShape, toShape, isCanvasEmit) {
      if (toShape) {
        if (toShape !== fromShape) {
          if (fromShape) {
            this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
          }
          this._emitEvent("dragenter", event, pointInfo, toShape, fromShape, toShape);
        }
        if (!isCanvasEmit) {
          this._emitEvent("dragover", event, pointInfo, toShape);
        }
      } else if (fromShape) {
        this._emitEvent("dragleave", event, pointInfo, fromShape, fromShape, toShape);
      }
      if (isCanvasEmit) {
        this._emitEvent("dragover", event, pointInfo, toShape);
      }
    };
    EventController2.prototype._afterDrag = function(draggingShape, pointInfo, event) {
      if (draggingShape) {
        draggingShape.set("capture", true);
        this.draggingShape = null;
      }
      this.dragging = false;
      var shape = this._getShape(pointInfo, event);
      if (shape !== draggingShape) {
        this._emitMouseoverEvents(event, pointInfo, draggingShape, shape);
      }
      this.currentShape = shape;
    };
    EventController2.prototype._onmouseup = function(pointInfo, shape, event) {
      if (event.button === LEFT_BTN_CODE) {
        var draggingShape = this.draggingShape;
        if (this.dragging) {
          if (draggingShape) {
            this._emitEvent("drop", event, pointInfo, shape);
          }
          this._emitEvent("dragend", event, pointInfo, draggingShape);
          this._afterDrag(draggingShape, pointInfo, event);
        } else {
          this._emitEvent("mouseup", event, pointInfo, shape);
          if (shape === this.mousedownShape) {
            this._emitEvent("click", event, pointInfo, shape);
          }
          this.mousedownShape = null;
          this.mousedownPoint = null;
        }
      }
    };
    EventController2.prototype._ondragover = function(pointInfo, shape, event) {
      event.preventDefault();
      var preShape = this.currentShape;
      this._emitDragoverEvents(event, pointInfo, preShape, shape, true);
    };
    EventController2.prototype._onmousemove = function(pointInfo, shape, event) {
      var canvas = this.canvas;
      var preShape = this.currentShape;
      var draggingShape = this.draggingShape;
      if (this.dragging) {
        if (draggingShape) {
          this._emitDragoverEvents(event, pointInfo, preShape, shape, false);
        }
        this._emitEvent("drag", event, pointInfo, draggingShape);
      } else {
        var mousedownPoint = this.mousedownPoint;
        if (mousedownPoint) {
          var mousedownShape = this.mousedownShape;
          var now2 = event.timeStamp;
          var timeWindow = now2 - this.mousedownTimeStamp;
          var dx = mousedownPoint.clientX - pointInfo.clientX;
          var dy = mousedownPoint.clientY - pointInfo.clientY;
          var dist = dx * dx + dy * dy;
          if (timeWindow > 120 || dist > CLICK_OFFSET) {
            if (mousedownShape && mousedownShape.get("draggable")) {
              draggingShape = this.mousedownShape;
              draggingShape.set("capture", false);
              this.draggingShape = draggingShape;
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, draggingShape);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else if (!mousedownShape && canvas.get("draggable")) {
              this.dragging = true;
              this._emitEvent("dragstart", event, pointInfo, null);
              this.mousedownShape = null;
              this.mousedownPoint = null;
            } else {
              this._emitMouseoverEvents(event, pointInfo, preShape, shape);
              this._emitEvent("mousemove", event, pointInfo, shape);
            }
          } else {
            this._emitMouseoverEvents(event, pointInfo, preShape, shape);
            this._emitEvent("mousemove", event, pointInfo, shape);
          }
        } else {
          this._emitMouseoverEvents(event, pointInfo, preShape, shape);
          this._emitEvent("mousemove", event, pointInfo, shape);
        }
      }
    };
    EventController2.prototype._emitEvent = function(type, event, pointInfo, shape, fromShape, toShape) {
      var eventObj = this._getEventObj(type, event, pointInfo, shape, fromShape, toShape);
      if (shape) {
        eventObj.shape = shape;
        emitTargetEvent(shape, type, eventObj);
        var parent_1 = shape.getParent();
        while (parent_1) {
          parent_1.emitDelegation(type, eventObj);
          if (!eventObj.propagationStopped) {
            bubbleEvent(parent_1, type, eventObj);
          }
          eventObj.propagationPath.push(parent_1);
          parent_1 = parent_1.getParent();
        }
      } else {
        var canvas = this.canvas;
        emitTargetEvent(canvas, type, eventObj);
      }
    };
    EventController2.prototype.destroy = function() {
      this._clearEvents();
      this.canvas = null;
      this.currentShape = null;
      this.draggingShape = null;
      this.mousedownPoint = null;
      this.mousedownShape = null;
      this.mousedownTimeStamp = null;
    };
    return EventController2;
  }()
);
var PX_SUFFIX = "px";
var browser = detect();
var isFirefox = browser && browser.name === "firefox";
var Canvas$2 = (
  /** @class */
  function(_super) {
    __extends$1(Canvas2, _super);
    function Canvas2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initContainer();
      _this.initDom();
      _this.initEvents();
      _this.initTimeline();
      return _this;
    }
    Canvas2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["cursor"] = "default";
      cfg["supportCSSTransform"] = false;
      return cfg;
    };
    Canvas2.prototype.initContainer = function() {
      var container = this.get("container");
      if (isString(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
    };
    Canvas2.prototype.initDom = function() {
      var el = this.createDom();
      this.set("el", el);
      var container = this.get("container");
      container.appendChild(el);
      this.setDOMSize(this.get("width"), this.get("height"));
    };
    Canvas2.prototype.initEvents = function() {
      var eventController = new EventController({
        canvas: this
      });
      eventController.init();
      this.set("eventController", eventController);
    };
    Canvas2.prototype.initTimeline = function() {
      var timeline = new Timeline(this);
      this.set("timeline", timeline);
    };
    Canvas2.prototype.setDOMSize = function(width, height) {
      var el = this.get("el");
      if (isBrowser) {
        el.style.width = width + PX_SUFFIX;
        el.style.height = height + PX_SUFFIX;
      }
    };
    Canvas2.prototype.changeSize = function(width, height) {
      this.setDOMSize(width, height);
      this.set("width", width);
      this.set("height", height);
      this.onCanvasChange("changeSize");
    };
    Canvas2.prototype.getRenderer = function() {
      return this.get("renderer");
    };
    Canvas2.prototype.getCursor = function() {
      return this.get("cursor");
    };
    Canvas2.prototype.setCursor = function(cursor) {
      this.set("cursor", cursor);
      var el = this.get("el");
      if (isBrowser && el) {
        el.style.cursor = cursor;
      }
    };
    Canvas2.prototype.getPointByEvent = function(ev) {
      var supportCSSTransform = this.get("supportCSSTransform");
      if (supportCSSTransform) {
        if (isFirefox && !isNil(ev.layerX) && ev.layerX !== ev.offsetX) {
          return {
            x: ev.layerX,
            y: ev.layerY
          };
        }
        if (!isNil(ev.offsetX)) {
          return {
            x: ev.offsetX,
            y: ev.offsetY
          };
        }
      }
      var _a2 = this.getClientByEvent(ev), clientX = _a2.x, clientY = _a2.y;
      return this.getPointByClient(clientX, clientY);
    };
    Canvas2.prototype.getClientByEvent = function(ev) {
      var clientInfo = ev;
      if (ev.touches) {
        if (ev.type === "touchend") {
          clientInfo = ev.changedTouches[0];
        } else {
          clientInfo = ev.touches[0];
        }
      }
      return {
        x: clientInfo.clientX,
        y: clientInfo.clientY
      };
    };
    Canvas2.prototype.getPointByClient = function(clientX, clientY) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: clientX - bbox.left,
        y: clientY - bbox.top
      };
    };
    Canvas2.prototype.getClientByPoint = function(x, y) {
      var el = this.get("el");
      var bbox = el.getBoundingClientRect();
      return {
        x: x + bbox.left,
        y: y + bbox.top
      };
    };
    Canvas2.prototype.draw = function() {
    };
    Canvas2.prototype.removeDom = function() {
      var el = this.get("el");
      el.parentNode.removeChild(el);
    };
    Canvas2.prototype.clearEvents = function() {
      var eventController = this.get("eventController");
      eventController.destroy();
    };
    Canvas2.prototype.isCanvas = function() {
      return true;
    };
    Canvas2.prototype.getParent = function() {
      return null;
    };
    Canvas2.prototype.destroy = function() {
      var timeline = this.get("timeline");
      if (this.get("destroyed")) {
        return;
      }
      this.clear();
      if (timeline) {
        timeline.stop();
      }
      this.clearEvents();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    return Canvas2;
  }(Container)
);
var AbstractGroup = (
  /** @class */
  function(_super) {
    __extends$1(AbstractGroup2, _super);
    function AbstractGroup2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AbstractGroup2.prototype.isGroup = function() {
      return true;
    };
    AbstractGroup2.prototype.isEntityGroup = function() {
      return false;
    };
    AbstractGroup2.prototype.clone = function() {
      var clone2 = _super.prototype.clone.call(this);
      var children = this.getChildren();
      for (var i = 0; i < children.length; i++) {
        var child = children[i];
        clone2.add(child.clone());
      }
      return clone2;
    };
    return AbstractGroup2;
  }(Container)
);
var AbstractShape = (
  /** @class */
  function(_super) {
    __extends$1(AbstractShape2, _super);
    function AbstractShape2(cfg) {
      return _super.call(this, cfg) || this;
    }
    AbstractShape2.prototype._isInBBox = function(refX, refY) {
      var bbox = this.getBBox();
      return bbox.minX <= refX && bbox.maxX >= refX && bbox.minY <= refY && bbox.maxY >= refY;
    };
    AbstractShape2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      this.clearCacheBBox();
    };
    AbstractShape2.prototype.getBBox = function() {
      var bbox = this.cfg.bbox;
      if (!bbox) {
        bbox = this.calculateBBox();
        this.set("bbox", bbox);
      }
      return bbox;
    };
    AbstractShape2.prototype.getCanvasBBox = function() {
      var canvasBBox = this.cfg.canvasBBox;
      if (!canvasBBox) {
        canvasBBox = this.calculateCanvasBBox();
        this.set("canvasBBox", canvasBBox);
      }
      return canvasBBox;
    };
    AbstractShape2.prototype.applyMatrix = function(matrix) {
      _super.prototype.applyMatrix.call(this, matrix);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.calculateCanvasBBox = function() {
      var bbox = this.getBBox();
      var totalMatrix = this.getTotalMatrix();
      var minX = bbox.minX, minY = bbox.minY, maxX = bbox.maxX, maxY2 = bbox.maxY;
      if (totalMatrix) {
        var topLeft = multiplyVec2$1(totalMatrix, [bbox.minX, bbox.minY]);
        var topRight = multiplyVec2$1(totalMatrix, [bbox.maxX, bbox.minY]);
        var bottomLeft = multiplyVec2$1(totalMatrix, [bbox.minX, bbox.maxY]);
        var bottomRight = multiplyVec2$1(totalMatrix, [bbox.maxX, bbox.maxY]);
        minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
        minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
        maxY2 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
      }
      var attrs = this.attrs;
      if (attrs.shadowColor) {
        var _a2 = attrs.shadowBlur, shadowBlur = _a2 === void 0 ? 0 : _a2, _b = attrs.shadowOffsetX, shadowOffsetX = _b === void 0 ? 0 : _b, _c = attrs.shadowOffsetY, shadowOffsetY = _c === void 0 ? 0 : _c;
        var shadowLeft = minX - shadowBlur + shadowOffsetX;
        var shadowRight = maxX + shadowBlur + shadowOffsetX;
        var shadowTop = minY - shadowBlur + shadowOffsetY;
        var shadowBottom = maxY2 + shadowBlur + shadowOffsetY;
        minX = Math.min(minX, shadowLeft);
        maxX = Math.max(maxX, shadowRight);
        minY = Math.min(minY, shadowTop);
        maxY2 = Math.max(maxY2, shadowBottom);
      }
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
    };
    AbstractShape2.prototype.clearCacheBBox = function() {
      this.set("bbox", null);
      this.set("canvasBBox", null);
    };
    AbstractShape2.prototype.isClipShape = function() {
      return this.get("isClipShape");
    };
    AbstractShape2.prototype.isInShape = function(refX, refY) {
      return false;
    };
    AbstractShape2.prototype.isOnlyHitBox = function() {
      return false;
    };
    AbstractShape2.prototype.isHit = function(x, y) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      var vec = [x, y, 1];
      vec = this.invertFromMatrix(vec);
      var refX = vec[0], refY = vec[1];
      var inBBox = this._isInBBox(refX, refY);
      if (this.isOnlyHitBox()) {
        return inBBox;
      }
      if (inBBox && !this.isClipped(refX, refY)) {
        if (this.isInShape(refX, refY)) {
          return true;
        }
        if (startArrowShape && startArrowShape.isHit(refX, refY)) {
          return true;
        }
        if (endArrowShape && endArrowShape.isHit(refX, refY)) {
          return true;
        }
      }
      return false;
    };
    return AbstractShape2;
  }(Element$2)
);
var cache$1 = /* @__PURE__ */ new Map();
function register(type, method) {
  cache$1.set(type, method);
}
function getMethod(type) {
  return cache$1.get(type);
}
function rect$1(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height;
  return {
    x,
    y,
    width,
    height
  };
}
function circle$1(shape) {
  var _a2 = shape.attr(), x = _a2.x, y = _a2.y, r = _a2.r;
  return {
    x: x - r,
    y: y - r,
    width: r * 2,
    height: r * 2
  };
}
function distance$5(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function isNumberEqual(v1, v2) {
  return Math.abs(v1 - v2) < 1e-3;
}
function getBBoxByArray(xArr, yArr) {
  var minX = min$2(xArr);
  var minY = min$2(yArr);
  var maxX = max$2(xArr);
  var maxY2 = max$2(yArr);
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function piMod(angle2) {
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
const LineUtil = {
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {object} 
   */
  box: function(x1, y1, x2, y2) {
    return getBBoxByArray([x1, x2], [y1, y2]);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  length: function(x1, y1, x2, y2) {
    return distance$5(x1, y1, x2, y2);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} t 
   * @return {object}  x, y 
   */
  pointAt: function(x1, y1, x2, y2, t) {
    return {
      x: (1 - t) * x1 + t * x2,
      y: (1 - t) * y1 + t * y2
    };
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointDistance: function(x1, y1, x2, y2, x, y) {
    var cross = (x2 - x1) * (x - x1) + (y2 - y1) * (y - y1);
    if (cross < 0) {
      return distance$5(x1, y1, x, y);
    }
    var lengthSquare = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
    if (cross > lengthSquare) {
      return distance$5(x2, y2, x, y);
    }
    return this.pointToLine(x1, y1, x2, y2, x, y);
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @param {number} x   x
   * @param {number} y   y
   * @return {number} 
   */
  pointToLine: function(x1, y1, x2, y2, x, y) {
    var d = [x2 - x1, y2 - y1];
    if (exactEquals(d, [0, 0])) {
      return Math.sqrt((x - x1) * (x - x1) + (y - y1) * (y - y1));
    }
    var u = [-d[1], d[0]];
    normalize(u, u);
    var a = [x - x1, y - y1];
    return Math.abs(dot$2(a, u));
  },
  /**
   * 
   * @param {number} x1  x
   * @param {number} y1  y
   * @param {number} x2  x
   * @param {number} y2  y
   * @return {number} 
   */
  tangentAngle: function(x1, y1, x2, y2) {
    return Math.atan2(y2 - y1, x2 - x1);
  }
};
var EPSILON = 1e-4;
function nearestPoint(xArr, yArr, x, y, tCallback, length2) {
  var t;
  var d = Infinity;
  var v0 = [x, y];
  var segNum = 20;
  if (length2 && length2 > 200) {
    segNum = length2 / 10;
  }
  var increaseRate = 1 / segNum;
  var interval2 = increaseRate / 10;
  for (var i = 0; i <= segNum; i++) {
    var _t = i * increaseRate;
    var v1 = [tCallback.apply(null, xArr.concat([_t])), tCallback.apply(null, yArr.concat([_t]))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (d1 < d) {
      t = _t;
      d = d1;
    }
  }
  if (t === 0) {
    return {
      x: xArr[0],
      y: yArr[0]
    };
  }
  if (t === 1) {
    var count2 = xArr.length;
    return {
      x: xArr[count2 - 1],
      y: yArr[count2 - 1]
    };
  }
  d = Infinity;
  for (var i = 0; i < 32; i++) {
    if (interval2 < EPSILON) {
      break;
    }
    var prev = t - interval2;
    var next = t + interval2;
    var v1 = [tCallback.apply(null, xArr.concat([prev])), tCallback.apply(null, yArr.concat([prev]))];
    var d1 = distance$5(v0[0], v0[1], v1[0], v1[1]);
    if (prev >= 0 && d1 < d) {
      t = prev;
      d = d1;
    } else {
      var v2 = [tCallback.apply(null, xArr.concat([next])), tCallback.apply(null, yArr.concat([next]))];
      var d2 = distance$5(v0[0], v0[1], v2[0], v2[1]);
      if (next <= 1 && d2 < d) {
        t = next;
        d = d2;
      } else {
        interval2 *= 0.5;
      }
    }
  }
  return {
    x: tCallback.apply(null, xArr.concat([t])),
    y: tCallback.apply(null, yArr.concat([t]))
  };
}
function snapLength(xArr, yArr) {
  var totalLength = 0;
  var count2 = xArr.length;
  for (var i = 0; i < count2; i++) {
    var x = xArr[i];
    var y = yArr[i];
    var nextX = xArr[(i + 1) % count2];
    var nextY = yArr[(i + 1) % count2];
    totalLength += distance$5(x, y, nextX, nextY);
  }
  return totalLength / 2;
}
function quadraticAt(p0, p1, p2, t) {
  var onet = 1 - t;
  return onet * onet * p0 + 2 * t * onet * p1 + t * t * p2;
}
function extrema$1(p0, p1, p2) {
  var a = p0 + p2 - 2 * p1;
  if (isNumberEqual(a, 0)) {
    return [0.5];
  }
  var rst = (p0 - p1) / a;
  if (rst <= 1 && rst >= 0) {
    return [rst];
  }
  return [];
}
function derivativeAt$1(p0, p1, p2, t) {
  return 2 * (1 - t) * (p1 - p0) + 2 * t * (p2 - p1);
}
function divideQuadratic(x1, y1, x2, y2, x3, y3, t) {
  var xt = quadraticAt(x1, x2, x3, t);
  var yt = quadraticAt(y1, y2, y3, t);
  var controlPoint1 = LineUtil.pointAt(x1, y1, x2, y2, t);
  var controlPoint2 = LineUtil.pointAt(x2, y2, x3, y3, t);
  return [
    [x1, y1, controlPoint1.x, controlPoint1.y, xt, yt],
    [xt, yt, controlPoint2.x, controlPoint2.y, x3, y3]
  ];
}
function quadraticLength(x1, y1, x2, y2, x3, y3, iterationCount) {
  if (iterationCount === 0) {
    return (distance$5(x1, y1, x2, y2) + distance$5(x2, y2, x3, y3) + distance$5(x1, y1, x3, y3)) / 2;
  }
  var quadratics = divideQuadratic(x1, y1, x2, y2, x3, y3, 0.5);
  var left2 = quadratics[0];
  var right2 = quadratics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return quadraticLength.apply(null, left2) + quadraticLength.apply(null, right2);
}
const QuadUtil = {
  box: function(x1, y1, x2, y2, x3, y3) {
    var xExtrema2 = extrema$1(x1, x2, x3)[0];
    var yExtrema2 = extrema$1(y1, y2, y3)[0];
    var xArr = [x1, x3];
    var yArr = [y1, y3];
    if (xExtrema2 !== void 0) {
      xArr.push(quadraticAt(x1, x2, x3, xExtrema2));
    }
    if (yExtrema2 !== void 0) {
      yArr.push(quadraticAt(y1, y2, y3, yExtrema2));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3) {
    return quadraticLength(x1, y1, x2, y2, x3, y3, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    return nearestPoint([x1, x2, x3], [y1, y2, y3], x0, y0, quadraticAt);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x0, y0) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x0, y0);
    return distance$5(point2.x, point2.y, x0, y0);
  },
  interpolationAt: quadraticAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, t) {
    return {
      x: quadraticAt(x1, x2, x3, t),
      y: quadraticAt(y1, y2, y3, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, t) {
    return divideQuadratic(x1, y1, x2, y2, x3, y3, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, t) {
    var dx = derivativeAt$1(x1, x2, x3, t);
    var dy = derivativeAt$1(y1, y2, y3, t);
    var angle2 = Math.atan2(dy, dx);
    return piMod(angle2);
  }
};
function cubicAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return onet * onet * onet * p0 + 3 * p1 * t * onet * onet + 3 * p2 * t * t * onet + p3 * t * t * t;
}
function derivativeAt(p0, p1, p2, p3, t) {
  var onet = 1 - t;
  return 3 * (onet * onet * (p1 - p0) + 2 * onet * t * (p2 - p1) + t * t * (p3 - p2));
}
function extrema(p0, p1, p2, p3) {
  var a = -3 * p0 + 9 * p1 - 9 * p2 + 3 * p3;
  var b = 6 * p0 - 12 * p1 + 6 * p2;
  var c = 3 * p1 - 3 * p0;
  var extremas = [];
  var t1;
  var t2;
  var discSqrt;
  if (isNumberEqual(a, 0)) {
    if (!isNumberEqual(b, 0)) {
      t1 = -c / b;
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
    }
  } else {
    var disc = b * b - 4 * a * c;
    if (isNumberEqual(disc, 0)) {
      extremas.push(-b / (2 * a));
    } else if (disc > 0) {
      discSqrt = Math.sqrt(disc);
      t1 = (-b + discSqrt) / (2 * a);
      t2 = (-b - discSqrt) / (2 * a);
      if (t1 >= 0 && t1 <= 1) {
        extremas.push(t1);
      }
      if (t2 >= 0 && t2 <= 1) {
        extremas.push(t2);
      }
    }
  }
  return extremas;
}
function divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t) {
  var xt = cubicAt(x1, x2, x3, x4, t);
  var yt = cubicAt(y1, y2, y3, y4, t);
  var c1 = LineUtil.pointAt(x1, y1, x2, y2, t);
  var c2 = LineUtil.pointAt(x2, y2, x3, y3, t);
  var c3 = LineUtil.pointAt(x3, y3, x4, y4, t);
  var c12 = LineUtil.pointAt(c1.x, c1.y, c2.x, c2.y, t);
  var c23 = LineUtil.pointAt(c2.x, c2.y, c3.x, c3.y, t);
  return [
    [x1, y1, c1.x, c1.y, c12.x, c12.y, xt, yt],
    [xt, yt, c23.x, c23.y, c3.x, c3.y, x4, y4]
  ];
}
function cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, iterationCount) {
  if (iterationCount === 0) {
    return snapLength([x1, x2, x3, x4], [y1, y2, y3, y4]);
  }
  var cubics = divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, 0.5);
  var left2 = cubics[0];
  var right2 = cubics[1];
  left2.push(iterationCount - 1);
  right2.push(iterationCount - 1);
  return cubicLength.apply(null, left2) + cubicLength.apply(null, right2);
}
const CubicUtil = {
  extrema,
  box: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    var xArr = [x1, x4];
    var yArr = [y1, y4];
    var xExtrema2 = extrema(x1, x2, x3, x4);
    var yExtrema2 = extrema(y1, y2, y3, y4);
    for (var i = 0; i < xExtrema2.length; i++) {
      xArr.push(cubicAt(x1, x2, x3, x4, xExtrema2[i]));
    }
    for (var i = 0; i < yExtrema2.length; i++) {
      yArr.push(cubicAt(y1, y2, y3, y4, yExtrema2[i]));
    }
    return getBBoxByArray(xArr, yArr);
  },
  length: function(x1, y1, x2, y2, x3, y3, x4, y4) {
    return cubicLength(x1, y1, x2, y2, x3, y3, x4, y4, 3);
  },
  nearestPoint: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
    return nearestPoint([x1, x2, x3, x4], [y1, y2, y3, y4], x0, y0, cubicAt, length2);
  },
  pointDistance: function(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2) {
    var point2 = this.nearestPoint(x1, y1, x2, y2, x3, y3, x4, y4, x0, y0, length2);
    return distance$5(point2.x, point2.y, x0, y0);
  },
  interpolationAt: cubicAt,
  pointAt: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return {
      x: cubicAt(x1, x2, x3, x4, t),
      y: cubicAt(y1, y2, y3, y4, t)
    };
  },
  divide: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    return divideCubic(x1, y1, x2, y2, x3, y3, x4, y4, t);
  },
  tangentAngle: function(x1, y1, x2, y2, x3, y3, x4, y4, t) {
    var dx = derivativeAt(x1, x2, x3, x4, t);
    var dy = derivativeAt(y1, y2, y3, y4, t);
    return piMod(Math.atan2(dy, dx));
  }
};
function copysign(v1, v2) {
  var absv = Math.abs(v1);
  return v2 > 0 ? absv : absv * -1;
}
const ellipse$1 = {
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {object} 
   */
  box: function(x, y, rx, ry) {
    return {
      x: x - rx,
      y: y - ry,
      width: rx * 2,
      height: ry * 2
    };
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @return {number} 
   */
  length: function(x, y, rx, ry) {
    return Math.PI * (3 * (rx + ry) - Math.sqrt((3 * rx + ry) * (rx + 3 * ry)));
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {object} 
   */
  nearestPoint: function(x, y, rx, ry, x0, y0) {
    var a = rx;
    var b = ry;
    if (a === 0 || b === 0) {
      return {
        x,
        y
      };
    }
    var relativeX = x0 - x;
    var relativeY = y0 - y;
    var px = Math.abs(relativeX);
    var py = Math.abs(relativeY);
    var squareA = a * a;
    var squareB = b * b;
    var t = Math.PI / 4;
    var nearestX;
    var nearestY;
    for (var i = 0; i < 4; i++) {
      nearestX = a * Math.cos(t);
      nearestY = b * Math.sin(t);
      var ex = (squareA - squareB) * Math.pow(Math.cos(t), 3) / a;
      var ey = (squareB - squareA) * Math.pow(Math.sin(t), 3) / b;
      var rx1 = nearestX - ex;
      var ry1 = nearestY - ey;
      var qx = px - ex;
      var qy = py - ey;
      var r = Math.hypot(ry1, rx1);
      var q = Math.hypot(qy, qx);
      var delta_c = r * Math.asin((rx1 * qy - ry1 * qx) / (r * q));
      var delta_t = delta_c / Math.sqrt(squareA + squareB - nearestX * nearestX - nearestY * nearestY);
      t += delta_t;
      t = Math.min(Math.PI / 2, Math.max(0, t));
    }
    return {
      x: x + copysign(nearestX, relativeX),
      y: y + copysign(nearestY, relativeY)
    };
  },
  /**
   * 
   * @param {number} x   x
   * @param {number} y   y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} x0   x
   * @param {number} y0   y
   * @return {number} 
   */
  pointDistance: function(x, y, rx, ry, x0, y0) {
    var nearestPoint2 = this.nearestPoint(x, y, rx, ry, x0, y0);
    return distance$5(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t x 0
   * @return {object} 
   */
  pointAt: function(x, y, rx, ry, t) {
    var angle2 = 2 * Math.PI * t;
    return {
      x: x + rx * Math.cos(angle2),
      y: y + ry * Math.sin(angle2)
    };
  },
  /**
   * 
   * @param {number} x  x
   * @param {number} y  y
   * @param {number} rx  x 
   * @param {number} ry  y 
   * @param {number} t  0 - 1 x 0 0-1  null
   * @return {number}  0 - 2PI 
   */
  tangentAngle: function(x, y, rx, ry, t) {
    var angle2 = 2 * Math.PI * t;
    var tangentAngle = Math.atan2(ry * Math.cos(angle2), -rx * Math.sin(angle2));
    return piMod(tangentAngle);
  }
};
function derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.cos(xRotation) * Math.sin(angle2) - ry * Math.sin(xRotation) * Math.cos(angle2);
}
function derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2) {
  return -1 * rx * Math.sin(xRotation) * Math.sin(angle2) + ry * Math.cos(xRotation) * Math.cos(angle2);
}
function xExtrema(rx, ry, xRotation) {
  return Math.atan(-ry / rx * Math.tan(xRotation));
}
function yExtrema(rx, ry, xRotation) {
  return Math.atan(ry / (rx * Math.tan(xRotation)));
}
function xAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.cos(xRotation) * Math.cos(angle2) - ry * Math.sin(xRotation) * Math.sin(angle2) + cx;
}
function yAt(cx, cy, rx, ry, xRotation, angle2) {
  return rx * Math.sin(xRotation) * Math.cos(angle2) + ry * Math.cos(xRotation) * Math.sin(angle2) + cy;
}
function getAngle$2(rx, ry, x0, y0) {
  var angle2 = Math.atan2(y0 * rx, x0 * ry);
  return (angle2 + Math.PI * 2) % (Math.PI * 2);
}
function getPoint(rx, ry, angle2) {
  return {
    x: rx * Math.cos(angle2),
    y: ry * Math.sin(angle2)
  };
}
function rotate$1(x, y, angle2) {
  var cos2 = Math.cos(angle2);
  var sin2 = Math.sin(angle2);
  return [x * cos2 - y * sin2, x * sin2 + y * cos2];
}
const EllipseArcUtil = {
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @return {object} 
   */
  box: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
    var xDim = xExtrema(rx, ry, xRotation);
    var minX = Infinity;
    var maxX = -Infinity;
    var xs = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var xAngle = xDim + i;
      if (startAngle < endAngle) {
        if (startAngle < xAngle && xAngle < endAngle) {
          xs.push(xAngle);
        }
      } else {
        if (endAngle < xAngle && xAngle < startAngle) {
          xs.push(xAngle);
        }
      }
    }
    for (var i = 0; i < xs.length; i++) {
      var x = xAt(cx, cy, rx, ry, xRotation, xs[i]);
      if (x < minX) {
        minX = x;
      }
      if (x > maxX) {
        maxX = x;
      }
    }
    var yDim = yExtrema(rx, ry, xRotation);
    var minY = Infinity;
    var maxY2 = -Infinity;
    var ys = [startAngle, endAngle];
    for (var i = -Math.PI * 2; i <= Math.PI * 2; i += Math.PI) {
      var yAngle = yDim + i;
      if (startAngle < endAngle) {
        if (startAngle < yAngle && yAngle < endAngle) {
          ys.push(yAngle);
        }
      } else {
        if (endAngle < yAngle && yAngle < startAngle) {
          ys.push(yAngle);
        }
      }
    }
    for (var i = 0; i < ys.length; i++) {
      var y = yAt(cx, cy, rx, ry, xRotation, ys[i]);
      if (y < minY) {
        minY = y;
      }
      if (y > maxY2) {
        maxY2 = y;
      }
    }
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  },
  /**
   * 
   *  rx, ry, startAngle, endAngle 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   */
  length: function(cx, cy, rx, ry, xRotation, startAngle, endAngle) {
  },
  /**
   * 
   * @param {number} cx          x
   * @param {number} cy          y
   * @param {number} rx         x 
   * @param {number} ry         y 
   * @param {number} xRotation  
   * @param {number} startAngle 
   * @param {number} endAngle   
   * @param {number} x0          x
   * @param {number} y0          y
   * @return {object} 
   */
  nearestPoint: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var relativeVector = rotate$1(x0 - cx, y0 - cy, -xRotation);
    var x1 = relativeVector[0], y1 = relativeVector[1];
    var relativePoint = ellipse$1.nearestPoint(0, 0, rx, ry, x1, y1);
    var angle2 = getAngle$2(rx, ry, relativePoint.x, relativePoint.y);
    if (angle2 < startAngle) {
      relativePoint = getPoint(rx, ry, startAngle);
    } else if (angle2 > endAngle) {
      relativePoint = getPoint(rx, ry, endAngle);
    }
    var vector = rotate$1(relativePoint.x, relativePoint.y, xRotation);
    return {
      x: vector[0] + cx,
      y: vector[1] + cy
    };
  },
  pointDistance: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, x0, y0) {
    var nearestPoint2 = this.nearestPoint(cx, cy, rx, ry, x0, y0);
    return distance$5(nearestPoint2.x, nearestPoint2.y, x0, y0);
  },
  pointAt: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle2 = (endAngle - startAngle) * t + startAngle;
    return {
      x: xAt(cx, cy, rx, ry, xRotation, angle2),
      y: yAt(cx, cy, rx, ry, xRotation, angle2)
    };
  },
  tangentAngle: function(cx, cy, rx, ry, xRotation, startAngle, endAngle, t) {
    var angle2 = (endAngle - startAngle) * t + startAngle;
    var dx = derivativeXAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    var dy = derivativeYAt(cx, cy, rx, ry, xRotation, startAngle, endAngle, angle2);
    return piMod(Math.atan2(dy, dx));
  }
};
function analyzePoints(points2) {
  var totalLength = 0;
  var segments = [];
  for (var i = 0; i < points2.length - 1; i++) {
    var from = points2[i];
    var to = points2[i + 1];
    var length_1 = distance$5(from[0], from[1], to[0], to[1]);
    var seg = {
      from,
      to,
      length: length_1
    };
    segments.push(seg);
    totalLength += length_1;
  }
  return { segments, totalLength };
}
function lengthOfSegment(points2) {
  if (points2.length < 2) {
    return 0;
  }
  var totalLength = 0;
  for (var i = 0; i < points2.length - 1; i++) {
    var from = points2[i];
    var to = points2[i + 1];
    totalLength += distance$5(from[0], from[1], to[0], to[1]);
  }
  return totalLength;
}
function pointAtSegments(points2, t) {
  if (t > 1 || t < 0 || points2.length < 2) {
    return null;
  }
  var _a2 = analyzePoints(points2), segments = _a2.segments, totalLength = _a2.totalLength;
  if (totalLength === 0) {
    return {
      x: points2[0][0],
      y: points2[0][1]
    };
  }
  var startRatio = 0;
  var point2 = null;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      var localRatio = (t - startRatio) / currentRatio;
      point2 = LineUtil.pointAt(from[0], from[1], to[0], to[1], localRatio);
      break;
    }
    startRatio += currentRatio;
  }
  return point2;
}
function angleAtSegments(points2, t) {
  if (t > 1 || t < 0 || points2.length < 2) {
    return 0;
  }
  var _a2 = analyzePoints(points2), segments = _a2.segments, totalLength = _a2.totalLength;
  var startRatio = 0;
  var angle2 = 0;
  for (var i = 0; i < segments.length; i++) {
    var seg = segments[i];
    var from = seg.from, to = seg.to;
    var currentRatio = seg.length / totalLength;
    if (t >= startRatio && t <= startRatio + currentRatio) {
      angle2 = Math.atan2(to[1] - from[1], to[0] - from[0]);
      break;
    }
    startRatio += currentRatio;
  }
  return angle2;
}
function distanceAtSegment(points2, x, y) {
  var minDistance = Infinity;
  for (var i = 0; i < points2.length - 1; i++) {
    var point2 = points2[i];
    var nextPoint = points2[i + 1];
    var distance_1 = LineUtil.pointDistance(point2[0], point2[1], nextPoint[0], nextPoint[1], x, y);
    if (distance_1 < minDistance) {
      minDistance = distance_1;
    }
  }
  return minDistance;
}
const PolylineUtil = {
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  box: function(points2) {
    var xArr = [];
    var yArr = [];
    for (var i = 0; i < points2.length; i++) {
      var point2 = points2[i];
      xArr.push(point2[0]);
      yArr.push(point2[1]);
    }
    return getBBoxByArray(xArr, yArr);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @return {object} 
   */
  length: function(points2) {
    return lengthOfSegment(points2);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  pointAt: function(points2, t) {
    return pointAtSegments(points2, t);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} x  x
   * @param {number} y  y
   * @return {number} 
   */
  pointDistance: function(points2, x, y) {
    return distanceAtSegment(points2, x, y);
  },
  /**
   * 
   * @param {array} points  [x,y] 
   * @param {number} t 
   * @return {object} 
   */
  tangentAngle: function(points2, t) {
    return angleAtSegments(points2, t);
  }
};
function mergeBBox(bbox1, bbox2) {
  if (!bbox1 || !bbox2) {
    return bbox1 || bbox2;
  }
  return {
    minX: Math.min(bbox1.minX, bbox2.minX),
    minY: Math.min(bbox1.minY, bbox2.minY),
    maxX: Math.max(bbox1.maxX, bbox2.maxX),
    maxY: Math.max(bbox1.maxY, bbox2.maxY)
  };
}
function mergeArrowBBox(shape, bbox) {
  var startArrowShape = shape.get("startArrowShape");
  var endArrowShape = shape.get("endArrowShape");
  var startArrowBBox = null;
  var endArrowBBox = null;
  if (startArrowShape) {
    startArrowBBox = startArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, startArrowBBox);
  }
  if (endArrowShape) {
    endArrowBBox = endArrowShape.getCanvasBBox();
    bbox = mergeBBox(bbox, endArrowBBox);
  }
  return bbox;
}
function polyline(shape) {
  var attrs = shape.attr();
  var points2 = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  var _a2 = getBBoxByArray(xArr, yArr), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function polygon$1(shape) {
  var attrs = shape.attr();
  var points2 = attrs.points;
  var xArr = [];
  var yArr = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    xArr.push(point2[0]);
    yArr.push(point2[1]);
  }
  return getBBoxByArray(xArr, yArr);
}
var offScreenCtx = null;
function getOffScreenContext() {
  if (!offScreenCtx) {
    var canvas = document.createElement("canvas");
    canvas.width = 1;
    canvas.height = 1;
    offScreenCtx = canvas.getContext("2d");
  }
  return offScreenCtx;
}
function getTextHeight(text2, fontSize, lineHeight) {
  var lineCount = 1;
  if (isString(text2)) {
    lineCount = text2.split("\n").length;
  }
  if (lineCount > 1) {
    var spaceingY = getLineSpaceing(fontSize, lineHeight);
    return fontSize * lineCount + spaceingY * (lineCount - 1);
  }
  return fontSize;
}
function getLineSpaceing(fontSize, lineHeight) {
  return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
}
function getTextWidth(text2, font) {
  var context = getOffScreenContext();
  var width = 0;
  if (isNil(text2) || text2 === "") {
    return width;
  }
  context.save();
  context.font = font;
  if (isString(text2) && text2.includes("\n")) {
    var textArr = text2.split("\n");
    each$1(textArr, function(subText) {
      var measureWidth = context.measureText(subText).width;
      if (width < measureWidth) {
        width = measureWidth;
      }
    });
  } else {
    width = context.measureText(text2).width;
  }
  context.restore();
  return width;
}
function assembleFont(attrs) {
  var fontSize = attrs.fontSize, fontFamily = attrs.fontFamily, fontWeight = attrs.fontWeight, fontStyle = attrs.fontStyle, fontVariant = attrs.fontVariant;
  return [fontStyle, fontVariant, fontWeight, fontSize + "px", fontFamily].join(" ").trim();
}
function text(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, text2 = attrs.text, fontSize = attrs.fontSize, lineHeight = attrs.lineHeight;
  var font = attrs.font;
  if (!font) {
    font = assembleFont(attrs);
  }
  var width = getTextWidth(text2, font);
  var bbox;
  if (!width) {
    bbox = {
      x,
      y,
      width: 0,
      height: 0
    };
  } else {
    var textAlign = attrs.textAlign, textBaseline = attrs.textBaseline;
    var height = getTextHeight(text2, fontSize, lineHeight);
    var point2 = {
      x,
      y: y - height
    };
    if (textAlign) {
      if (textAlign === "end" || textAlign === "right") {
        point2.x -= width;
      } else if (textAlign === "center") {
        point2.x -= width / 2;
      }
    }
    if (textBaseline) {
      if (textBaseline === "top") {
        point2.y += height;
      } else if (textBaseline === "middle") {
        point2.y += height / 2;
      }
    }
    bbox = {
      x: point2.x,
      y: point2.y,
      width,
      height
    };
  }
  return bbox;
}
var regexTags = /[MLHVQTCSAZ]([^MLHVQTCSAZ]*)/ig;
var regexDot = /[^\s\,]+/ig;
function parsePath(p) {
  var path2 = p || [];
  if (isArray$1(path2)) {
    return path2;
  }
  if (isString(path2)) {
    path2 = path2.match(regexTags);
    each$1(path2, function(item, index2) {
      item = item.match(regexDot);
      if (item[0].length > 1) {
        var tag = item[0].charAt(0);
        item.splice(1, 0, item[0].substr(1));
        item[0] = tag;
      }
      each$1(item, function(sub2, i) {
        if (!isNaN(sub2)) {
          item[i] = +sub2;
        }
      });
      path2[index2] = item;
    });
    return path2;
  }
}
function smoothBezier$2(points2, smooth, isLoop, constraint) {
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min2;
  var max2;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    min2 = constraint[0], max2 = constraint[1];
    for (var i = 0, l = points2.length; i < l; i += 1) {
      var point2 = points2[i];
      min2 = min$1([0, 0], min2, point2);
      max2 = max$1([0, 0], max2, point2);
    }
  }
  for (var i = 0, len = points2.length; i < len; i += 1) {
    var point2 = points2[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      var prevIdx = [i ? i - 1 : len - 1, i - 1][isLoop ? 0 : 1];
      prevPoint = points2[prevIdx];
      nextPoint = points2[isLoop ? (i + 1) % len : i + 1];
      var v = [0, 0];
      v = sub(v, nextPoint, prevPoint);
      v = scale$3(v, v, smooth);
      var d0 = distance$6(point2, prevPoint);
      var d1 = distance$6(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$3([0, 0], v, -d0);
      var v2 = scale$3([0, 0], v, d1);
      cp1 = add([0, 0], point2, v1);
      nextCp0 = add([0, 0], point2, v2);
      nextCp0 = min$1([0, 0], nextCp0, max$1([0, 0], nextPoint, point2));
      nextCp0 = max$1([0, 0], nextCp0, min$1([0, 0], nextPoint, point2));
      v1 = sub([0, 0], nextCp0, point2);
      v1 = scale$3([0, 0], v1, -d0 / d1);
      cp1 = add([0, 0], point2, v1);
      cp1 = min$1([0, 0], cp1, max$1([0, 0], prevPoint, point2));
      cp1 = max$1([0, 0], cp1, min$1([0, 0], prevPoint, point2));
      v2 = sub([0, 0], point2, cp1);
      v2 = scale$3([0, 0], v2, d1 / d0);
      nextCp0 = add([0, 0], point2, v2);
      if (hasConstraint) {
        cp1 = max$1([0, 0], cp1, min2);
        cp1 = min$1([0, 0], cp1, max2);
        nextCp0 = max$1([0, 0], nextCp0, min2);
        nextCp0 = min$1([0, 0], nextCp0, max2);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
}
function catmullRom2Bezier(crp, z, constraint) {
  if (z === void 0) {
    z = false;
  }
  if (constraint === void 0) {
    constraint = [
      [0, 0],
      [1, 1]
    ];
  }
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier$2(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i += 1) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
var SPACES = "	\n\v\f\r \u2028\u2029";
var PATH_COMMAND = new RegExp("([a-z])[" + SPACES + ",]*((-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?[" + SPACES + "]*,?[" + SPACES + "]*)+)", "ig");
var PATH_VALUES = new RegExp("(-?\\d*\\.?\\d*(?:e[\\-+]?\\d+)?)[" + SPACES + "]*,?[" + SPACES + "]*", "ig");
function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  if (isArray$1(pathString)) {
    return pathString;
  }
  var paramCounts = {
    a: 7,
    c: 6,
    o: 2,
    h: 1,
    l: 2,
    m: 2,
    r: 4,
    q: 4,
    s: 4,
    t: 2,
    v: 1,
    u: 3,
    z: 0
  };
  var data2 = [];
  String(pathString).replace(PATH_COMMAND, function(a, b, c) {
    var params = [];
    var name = b.toLowerCase();
    c.replace(PATH_VALUES, function(a2, b10) {
      b10 && params.push(+b10);
    });
    if (name === "m" && params.length > 2) {
      data2.push([b].concat(params.splice(0, 2)));
      name = "l";
      b = b === "m" ? "l" : "L";
    }
    if (name === "o" && params.length === 1) {
      data2.push([b, params[0]]);
    }
    if (name === "r") {
      data2.push([b].concat(params));
    } else {
      while (params.length >= paramCounts[name]) {
        data2.push([b].concat(params.splice(0, paramCounts[name])));
        if (!paramCounts[name]) {
          break;
        }
      }
    }
    return "";
  });
  return data2;
}
var REGEX_MD = /[a-z]/;
function toSymmetry$1(p, c) {
  return [
    c[0] + (c[0] - p[0]),
    c[1] + (c[1] - p[1])
  ];
}
function pathToAbsolute(pathString) {
  var pathArray = parsePathString(pathString);
  if (!pathArray || !pathArray.length) {
    return [
      ["M", 0, 0]
    ];
  }
  var needProcess = false;
  for (var i = 0; i < pathArray.length; i++) {
    var cmd = pathArray[i][0];
    if (REGEX_MD.test(cmd) || ["V", "H", "T", "S"].indexOf(cmd) >= 0) {
      needProcess = true;
      break;
    }
  }
  if (!needProcess) {
    return pathArray;
  }
  var res = [];
  var x = 0;
  var y = 0;
  var mx = 0;
  var my = 0;
  var start = 0;
  var first = pathArray[0];
  if (first[0] === "M" || first[0] === "m") {
    x = +first[1];
    y = +first[2];
    mx = x;
    my = y;
    start++;
    res[0] = ["M", x, y];
  }
  for (var i = start, ii = pathArray.length; i < ii; i++) {
    var pa = pathArray[i];
    var preParams = res[i - 1];
    var r = [];
    var cmd = pa[0];
    var upCmd = cmd.toUpperCase();
    if (cmd !== upCmd) {
      r[0] = upCmd;
      switch (upCmd) {
        case "A":
          r[1] = pa[1];
          r[2] = pa[2];
          r[3] = pa[3];
          r[4] = pa[4];
          r[5] = pa[5];
          r[6] = +pa[6] + x;
          r[7] = +pa[7] + y;
          break;
        case "V":
          r[1] = +pa[1] + y;
          break;
        case "H":
          r[1] = +pa[1] + x;
          break;
        case "M":
          mx = +pa[1] + x;
          my = +pa[2] + y;
          r[1] = mx;
          r[2] = my;
          break;
        default:
          for (var j = 1, jj = pa.length; j < jj; j++) {
            r[j] = +pa[j] + (j % 2 ? x : y);
          }
      }
    } else {
      r = pathArray[i];
    }
    switch (upCmd) {
      case "Z":
        x = +mx;
        y = +my;
        break;
      case "H":
        x = r[1];
        r = ["L", x, y];
        break;
      case "V":
        y = r[1];
        r = ["L", x, y];
        break;
      case "T":
        x = r[1];
        y = r[2];
        var symetricT = toSymmetry$1([preParams[1], preParams[2]], [preParams[3], preParams[4]]);
        r = ["Q", symetricT[0], symetricT[1], x, y];
        break;
      case "S":
        x = r[r.length - 2];
        y = r[r.length - 1];
        var length_1 = preParams.length;
        var symetricS = toSymmetry$1([preParams[length_1 - 4], preParams[length_1 - 3]], [preParams[length_1 - 2], preParams[length_1 - 1]]);
        r = ["C", symetricS[0], symetricS[1], r[1], r[2], x, y];
        break;
      case "M":
        mx = r[r.length - 2];
        my = r[r.length - 1];
        break;
      default:
        x = r[r.length - 2];
        y = r[r.length - 1];
    }
    res.push(r);
  }
  return res;
}
function vMag$1(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio$1(u, v) {
  return vMag$1(u) * vMag$1(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag$1(u) * vMag$1(v)) : 1;
}
function vAngle$1(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio$1(u, v));
}
function isSamePoint$1(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
function getArcParams$1(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle$1([1, 0], u);
  var dTheta = vAngle$1(u, v);
  if (vRatio$1(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio$1(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint$1(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint$1(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
function toSymmetry(point2, center2) {
  return [center2[0] + (center2[0] - point2[0]), center2[1] + (center2[1] - point2[1])];
}
function getSegments(path2) {
  path2 = parsePath(path2);
  var segments = [];
  var currentPoint = null;
  var nextParams = null;
  var startMovePoint = null;
  var lastStartMovePointIndex = 0;
  var count2 = path2.length;
  for (var i = 0; i < count2; i++) {
    var params = path2[i];
    nextParams = path2[i + 1];
    var command = params[0];
    var segment = {
      command,
      prePoint: currentPoint,
      params,
      startTangent: null,
      endTangent: null
    };
    switch (command) {
      case "M":
        startMovePoint = [params[1], params[2]];
        lastStartMovePointIndex = i;
        break;
      case "A":
        var arcParams = getArcParams$1(currentPoint, params);
        segment["arcParams"] = arcParams;
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
      nextParams = path2[lastStartMovePointIndex + 1];
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
    if (nextParams && nextParams[0] === "Z") {
      nextParams = path2[lastStartMovePointIndex];
      if (segments[lastStartMovePointIndex]) {
        segments[lastStartMovePointIndex].prePoint = currentPoint;
      }
    }
    segment["currentPoint"] = currentPoint;
    if (segments[lastStartMovePointIndex] && isSamePoint$1(currentPoint, segments[lastStartMovePointIndex].currentPoint)) {
      segments[lastStartMovePointIndex].prePoint = segment.prePoint;
    }
    var nextPoint = nextParams ? [nextParams[nextParams.length - 2], nextParams[nextParams.length - 1]] : null;
    segment["nextPoint"] = nextPoint;
    var prePoint = segment.prePoint;
    if (["L", "H", "V"].includes(command)) {
      segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
      segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
    } else if (command === "Q") {
      var cp = [params[1], params[2]];
      segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
      segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
    } else if (command === "T") {
      var preSegment = segments[i - 1];
      var cp = toSymmetry(preSegment.currentPoint, prePoint);
      if (preSegment.command === "Q") {
        segment.command = "Q";
        segment.startTangent = [prePoint[0] - cp[0], prePoint[1] - cp[1]];
        segment.endTangent = [currentPoint[0] - cp[0], currentPoint[1] - cp[1]];
      } else {
        segment.command = "TL";
        segment.startTangent = [prePoint[0] - currentPoint[0], prePoint[1] - currentPoint[1]];
        segment.endTangent = [currentPoint[0] - prePoint[0], currentPoint[1] - prePoint[1]];
      }
    } else if (command === "C") {
      var cp1 = [params[1], params[2]];
      var cp2 = [params[3], params[4]];
      segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
      segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      if (segment.startTangent[0] === 0 && segment.startTangent[1] === 0) {
        segment.startTangent = [cp1[0] - cp2[0], cp1[1] - cp2[1]];
      }
      if (segment.endTangent[0] === 0 && segment.endTangent[1] === 0) {
        segment.endTangent = [cp2[0] - cp1[0], cp2[1] - cp1[1]];
      }
    } else if (command === "S") {
      var preSegment = segments[i - 1];
      var cp1 = toSymmetry(preSegment.currentPoint, prePoint);
      var cp2 = [params[1], params[2]];
      if (preSegment.command === "C") {
        segment.command = "C";
        segment.startTangent = [prePoint[0] - cp1[0], prePoint[1] - cp1[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      } else {
        segment.command = "SQ";
        segment.startTangent = [prePoint[0] - cp2[0], prePoint[1] - cp2[1]];
        segment.endTangent = [currentPoint[0] - cp2[0], currentPoint[1] - cp2[1]];
      }
    } else if (command === "A") {
      var d = 1e-3;
      var _a2 = segment["arcParams"] || {}, _b = _a2.cx, cx = _b === void 0 ? 0 : _b, _c = _a2.cy, cy = _c === void 0 ? 0 : _c, _d = _a2.rx, rx = _d === void 0 ? 0 : _d, _e = _a2.ry, ry = _e === void 0 ? 0 : _e, _f = _a2.sweepFlag, sweepFlag = _f === void 0 ? 0 : _f, _g = _a2.startAngle, startAngle = _g === void 0 ? 0 : _g, _h = _a2.endAngle, endAngle = _h === void 0 ? 0 : _h;
      if (sweepFlag === 0) {
        d *= -1;
      }
      var dx1 = rx * Math.cos(startAngle - d) + cx;
      var dy1 = ry * Math.sin(startAngle - d) + cy;
      segment.startTangent = [dx1 - startMovePoint[0], dy1 - startMovePoint[1]];
      var dx2 = rx * Math.cos(startAngle + endAngle + d) + cx;
      var dy2 = ry * Math.sin(startAngle + endAngle - d) + cy;
      segment.endTangent = [prePoint[0] - dx2, prePoint[1] - dy2];
    }
    segments.push(segment);
  }
  return segments;
}
var isBetween$2 = function(value2, min2, max2) {
  return value2 >= min2 && value2 <= max2;
};
function getLineIntersect(p0, p1, p2, p3) {
  var tolerance2 = 1e-3;
  var E = {
    x: p2.x - p0.x,
    y: p2.y - p0.y
  };
  var D0 = {
    x: p1.x - p0.x,
    y: p1.y - p0.y
  };
  var D1 = {
    x: p3.x - p2.x,
    y: p3.y - p2.y
  };
  var kross = D0.x * D1.y - D0.y * D1.x;
  var sqrKross = kross * kross;
  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;
  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;
  var point2 = null;
  if (sqrKross > tolerance2 * sqrLen0 * sqrLen1) {
    var s = (E.x * D1.y - E.y * D1.x) / kross;
    var t = (E.x * D0.y - E.y * D0.x) / kross;
    if (isBetween$2(s, 0, 1) && isBetween$2(t, 0, 1)) {
      point2 = {
        x: p0.x + s * D0.x,
        y: p0.y + s * D0.y
      };
    }
  }
  return point2;
}
var tolerance$1 = 1e-6;
function dcmp$1(x) {
  if (Math.abs(x) < tolerance$1) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment$1(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon$1(points2, x, y) {
  var isHit = false;
  var n = points2.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points2[i];
    var p2 = points2[(i + 1) % n];
    if (onSegment$1(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp$1(p1[1] - y) > 0 !== dcmp$1(p2[1] - y) > 0 && dcmp$1(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function parseToLines(points2) {
  var lines = [];
  var count2 = points2.length;
  for (var i = 0; i < count2 - 1; i++) {
    var point2 = points2[i];
    var next = points2[i + 1];
    lines.push({
      from: {
        x: point2[0],
        y: point2[1]
      },
      to: {
        x: next[0],
        y: next[1]
      }
    });
  }
  if (lines.length > 1) {
    var first = points2[0];
    var last2 = points2[count2 - 1];
    lines.push({
      from: {
        x: last2[0],
        y: last2[1]
      },
      to: {
        x: first[0],
        y: first[1]
      }
    });
  }
  return lines;
}
function lineIntersectPolygon(lines, line2) {
  var isIntersect = false;
  each$1(lines, function(l) {
    if (getLineIntersect(l.from, l.to, line2.from, line2.to)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getBBox(points2) {
  var xArr = points2.map(function(p) {
    return p[0];
  });
  var yArr = points2.map(function(p) {
    return p[1];
  });
  return {
    minX: Math.min.apply(null, xArr),
    maxX: Math.max.apply(null, xArr),
    minY: Math.min.apply(null, yArr),
    maxY: Math.max.apply(null, yArr)
  };
}
function intersectBBox$1(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function isPolygonsIntersect(points1, points2) {
  if (points1.length < 2 || points2.length < 2) {
    return false;
  }
  var bbox1 = getBBox(points1);
  var bbox2 = getBBox(points2);
  if (!intersectBBox$1(bbox1, bbox2)) {
    return false;
  }
  var isIn = false;
  each$1(points2, function(point2) {
    if (isInPolygon$1(points1, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  each$1(points1, function(point2) {
    if (isInPolygon$1(points2, point2[0], point2[1])) {
      isIn = true;
      return false;
    }
  });
  if (isIn) {
    return true;
  }
  var lines1 = parseToLines(points1);
  var lines2 = parseToLines(points2);
  var isIntersect = false;
  each$1(lines2, function(line2) {
    if (lineIntersectPolygon(lines1, line2)) {
      isIntersect = true;
      return false;
    }
  });
  return isIntersect;
}
function getPathBox(segments, lineWidth) {
  var xArr = [];
  var yArr = [];
  var segmentsWithAngle = [];
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint;
    var box2 = void 0;
    switch (segment.command) {
      case "Q":
        box2 = QuadUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4]);
        break;
      case "C":
        box2 = CubicUtil.box(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], params[5], params[6]);
        break;
      case "A":
        var arcParams = segment.arcParams;
        box2 = EllipseArcUtil.box(arcParams.cx, arcParams.cy, arcParams.rx, arcParams.ry, arcParams.xRotation, arcParams.startAngle, arcParams.endAngle);
        break;
      default:
        xArr.push(currentPoint[0]);
        yArr.push(currentPoint[1]);
        break;
    }
    if (box2) {
      segment.box = box2;
      xArr.push(box2.x, box2.x + box2.width);
      yArr.push(box2.y, box2.y + box2.height);
    }
    if (lineWidth && (segment.command === "L" || segment.command === "M") && segment.prePoint && segment.nextPoint) {
      segmentsWithAngle.push(segment);
    }
  }
  xArr = xArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  yArr = yArr.filter(function(item) {
    return !Number.isNaN(item) && item !== Infinity && item !== -Infinity;
  });
  var minX = min$2(xArr);
  var minY = min$2(yArr);
  var maxX = max$2(xArr);
  var maxY2 = max$2(yArr);
  if (segmentsWithAngle.length === 0) {
    return {
      x: minX,
      y: minY,
      width: maxX - minX,
      height: maxY2 - minY
    };
  }
  for (var i = 0; i < segmentsWithAngle.length; i++) {
    var segment = segmentsWithAngle[i];
    var currentPoint = segment.currentPoint;
    var extra = void 0;
    if (currentPoint[0] === minX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minX = minX - extra.xExtra;
    } else if (currentPoint[0] === maxX) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxX = maxX + extra.xExtra;
    }
    if (currentPoint[1] === minY) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      minY = minY - extra.yExtra;
    } else if (currentPoint[1] === maxY2) {
      extra = getExtraFromSegmentWithAngle(segment, lineWidth);
      maxY2 = maxY2 + extra.yExtra;
    }
  }
  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function getExtraFromSegmentWithAngle(segment, lineWidth) {
  var prePoint = segment.prePoint, currentPoint = segment.currentPoint, nextPoint = segment.nextPoint;
  var currentAndPre = Math.pow(currentPoint[0] - prePoint[0], 2) + Math.pow(currentPoint[1] - prePoint[1], 2);
  var currentAndNext = Math.pow(currentPoint[0] - nextPoint[0], 2) + Math.pow(currentPoint[1] - nextPoint[1], 2);
  var preAndNext = Math.pow(prePoint[0] - nextPoint[0], 2) + Math.pow(prePoint[1] - nextPoint[1], 2);
  var currentAngle = Math.acos((currentAndPre + currentAndNext - preAndNext) / (2 * Math.sqrt(currentAndPre) * Math.sqrt(currentAndNext)));
  if (!currentAngle || Math.sin(currentAngle) === 0 || isNumberEqual$1(currentAngle, 0)) {
    return {
      xExtra: 0,
      yExtra: 0
    };
  }
  var xAngle = Math.abs(Math.atan2(nextPoint[1] - currentPoint[1], nextPoint[0] - currentPoint[0]));
  var yAngle = Math.abs(Math.atan2(nextPoint[0] - currentPoint[0], nextPoint[1] - currentPoint[1]));
  xAngle = xAngle > Math.PI / 2 ? Math.PI - xAngle : xAngle;
  yAngle = yAngle > Math.PI / 2 ? Math.PI - yAngle : yAngle;
  var extra = {
    // 
    xExtra: Math.cos(currentAngle / 2 - xAngle) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0,
    // 
    yExtra: Math.cos(yAngle - currentAngle / 2) * (lineWidth / 2 * (1 / Math.sin(currentAngle / 2))) - lineWidth / 2 || 0
  };
  return extra;
}
function path(shape) {
  var attrs = shape.attr();
  var path2 = attrs.path, stroke = attrs.stroke;
  var lineWidth = stroke ? attrs.lineWidth : 0;
  var segments = shape.get("segments") || getSegments(path2);
  var _a2 = getPathBox(segments, lineWidth), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
  var bbox = {
    minX: x,
    minY: y,
    maxX: x + width,
    maxY: y + height
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function line$1(shape) {
  var attrs = shape.attr();
  var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2;
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY2 = Math.max(y1, y2);
  var bbox = {
    minX,
    maxX,
    minY,
    maxY: maxY2
  };
  bbox = mergeArrowBBox(shape, bbox);
  return {
    x: bbox.minX,
    y: bbox.minY,
    width: bbox.maxX - bbox.minX,
    height: bbox.maxY - bbox.minY
  };
}
function ellipse(shape) {
  var attrs = shape.attr();
  var x = attrs.x, y = attrs.y, rx = attrs.rx, ry = attrs.ry;
  return {
    x: x - rx,
    y: y - ry,
    width: rx * 2,
    height: ry * 2
  };
}
register("rect", rect$1);
register("image", rect$1);
register("circle", circle$1);
register("marker", circle$1);
register("polyline", polyline);
register("polygon", polygon$1);
register("text", text);
register("path", path);
register("line", line$1);
register("ellipse", ellipse);
var DEFAULT_Y = 0;
var MARGIN_RATIO = 1 / 2;
var DODGE_RATIO = 1 / 2;
var GAP = 0.05;
var Adjust = (
  /** @class */
  function() {
    function Adjust2(cfg) {
      var xField = cfg.xField, yField = cfg.yField, _a2 = cfg.adjustNames, adjustNames = _a2 === void 0 ? ["x", "y"] : _a2, dimValuesMap = cfg.dimValuesMap;
      this.adjustNames = adjustNames;
      this.xField = xField;
      this.yField = yField;
      this.dimValuesMap = dimValuesMap;
    }
    Adjust2.prototype.isAdjust = function(dim) {
      return this.adjustNames.indexOf(dim) >= 0;
    };
    Adjust2.prototype.getAdjustRange = function(dim, dimValue, values2) {
      var yField = this.yField;
      var index2 = values2.indexOf(dimValue);
      var length2 = values2.length;
      var pre;
      var next;
      if (!yField && this.isAdjust("y")) {
        pre = 0;
        next = 1;
      } else if (length2 > 1) {
        pre = values2[index2 === 0 ? 0 : index2 - 1];
        next = values2[index2 === length2 - 1 ? length2 - 1 : index2 + 1];
        if (index2 !== 0) {
          pre += (dimValue - pre) / 2;
        } else {
          pre -= (next - dimValue) / 2;
        }
        if (index2 !== length2 - 1) {
          next -= (next - dimValue) / 2;
        } else {
          next += (dimValue - values2[length2 - 2]) / 2;
        }
      } else {
        pre = dimValue === 0 ? 0 : dimValue - 0.5;
        next = dimValue === 0 ? 1 : dimValue + 0.5;
      }
      return {
        pre,
        next
      };
    };
    Adjust2.prototype.adjustData = function(groupedDataArray, mergedData) {
      var _this = this;
      var dimValuesMap = this.getDimValues(mergedData);
      each$1(groupedDataArray, function(dataArray, index2) {
        each$1(dimValuesMap, function(values2, dim) {
          _this.adjustDim(dim, values2, dataArray, index2);
        });
      });
    };
    Adjust2.prototype.groupData = function(data2, dim) {
      each$1(data2, function(record) {
        if (record[dim] === void 0) {
          record[dim] = DEFAULT_Y;
        }
      });
      return groupBy(data2, dim);
    };
    Adjust2.prototype.adjustDim = function(dim, values2, data2, index2) {
    };
    Adjust2.prototype.getDimValues = function(mergedData) {
      var _a2 = this, xField = _a2.xField, yField = _a2.yField;
      var dimValuesMap = mix({}, this.dimValuesMap);
      var dims = [];
      if (xField && this.isAdjust("x")) {
        dims.push(xField);
      }
      if (yField && this.isAdjust("y")) {
        dims.push(yField);
      }
      dims.forEach(function(dim2) {
        if (dimValuesMap && dimValuesMap[dim2]) {
          return;
        }
        dimValuesMap[dim2] = valuesOfKey(mergedData, dim2).sort(function(v1, v2) {
          return v1 - v2;
        });
      });
      if (!yField && this.isAdjust("y")) {
        var dim = "y";
        dimValuesMap[dim] = [DEFAULT_Y, 1];
      }
      return dimValuesMap;
    };
    return Adjust2;
  }()
);
var ADJUST_MAP = {};
var getAdjust = function(type) {
  return ADJUST_MAP[type.toLowerCase()];
};
var registerAdjust = function(type, ctor) {
  if (getAdjust(type)) {
    throw new Error("Adjust type '" + type + "' existed.");
  }
  ADJUST_MAP[type.toLowerCase()] = ctor;
};
/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */
var extendStatics = function(d, b) {
  extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b10) {
    d2.__proto__ = b10;
  } || function(d2, b10) {
    for (var p in b10)
      if (b10.hasOwnProperty(p))
        d2[p] = b10[p];
  };
  return extendStatics(d, b);
};
function __extends(d, b) {
  extendStatics(d, b);
  function __() {
    this.constructor = d;
  }
  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}
var __assign = function() {
  __assign = Object.assign || function __assign2(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var Dodge = (
  /** @class */
  function(_super) {
    __extends(Dodge2, _super);
    function Dodge2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.cacheMap = {};
      _this.adjustDataArray = [];
      _this.mergeData = [];
      var _a2 = cfg.marginRatio, marginRatio = _a2 === void 0 ? MARGIN_RATIO : _a2, _b = cfg.dodgeRatio, dodgeRatio = _b === void 0 ? DODGE_RATIO : _b, dodgeBy = cfg.dodgeBy, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, xDimensionLength = cfg.xDimensionLength, groupNum = cfg.groupNum, defaultSize = cfg.defaultSize, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, customOffset = cfg.customOffset;
      _this.marginRatio = marginRatio;
      _this.dodgeRatio = dodgeRatio;
      _this.dodgeBy = dodgeBy;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.xDimensionLegenth = xDimensionLength;
      _this.groupNum = groupNum;
      _this.defaultSize = defaultSize;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.customOffset = customOffset;
      return _this;
    }
    Dodge2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone(groupDataArray);
      var mergeData = flatten(groupedDataArray);
      var dodgeBy = this.dodgeBy;
      var adjustDataArray = dodgeBy ? group$1(mergeData, dodgeBy) : groupedDataArray;
      this.cacheMap = {};
      this.adjustDataArray = adjustDataArray;
      this.mergeData = mergeData;
      this.adjustData(adjustDataArray, mergeData);
      this.adjustDataArray = [];
      this.mergeData = [];
      return groupedDataArray;
    };
    Dodge2.prototype.adjustDim = function(dim, values2, data2, frameIndex) {
      var _this = this;
      var customOffset = this.customOffset;
      var map2 = this.getDistribution(dim);
      var groupData = this.groupData(data2, dim);
      each$1(groupData, function(group2, key) {
        var range;
        if (values2.length === 1) {
          range = {
            pre: values2[0] - 1,
            next: values2[0] + 1
          };
        } else {
          range = _this.getAdjustRange(dim, parseFloat(key), values2);
        }
        each$1(group2, function(d) {
          var value2 = d[dim];
          var valueArr = map2[value2];
          var valIndex = valueArr.indexOf(frameIndex);
          if (!isNil(customOffset)) {
            var pre = range.pre, next = range.next;
            d[dim] = isFunction(customOffset) ? customOffset(d, range) : (pre + next) / 2 + customOffset;
          } else {
            d[dim] = _this.getDodgeOffset(range, valIndex, valueArr.length);
          }
        });
      });
      return [];
    };
    Dodge2.prototype.getDodgeOffset = function(range, idx, len) {
      var _a2 = this, dodgeRatio = _a2.dodgeRatio, marginRatio = _a2.marginRatio, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding;
      var pre = range.pre, next = range.next;
      var tickLength = next - pre;
      var position;
      if (!isNil(intervalPadding) && isNil(dodgePadding) && intervalPadding >= 0) {
        var offset = this.getIntervalOnlyOffset(len, idx);
        position = pre + offset;
      } else if (!isNil(dodgePadding) && isNil(intervalPadding) && dodgePadding >= 0) {
        var offset = this.getDodgeOnlyOffset(len, idx);
        position = pre + offset;
      } else if (!isNil(intervalPadding) && !isNil(dodgePadding) && intervalPadding >= 0 && dodgePadding >= 0) {
        var offset = this.getIntervalAndDodgeOffset(len, idx);
        position = pre + offset;
      } else {
        var width = tickLength * dodgeRatio / len;
        var margin = marginRatio * width;
        var offset = 1 / 2 * (tickLength - len * width - (len - 1) * margin) + ((idx + 1) * width + idx * margin) - 1 / 2 * width - 1 / 2 * tickLength;
        position = (pre + next) / 2 + offset;
      }
      return position;
    };
    Dodge2.prototype.getIntervalOnlyOffset = function(len, idx) {
      var _a2 = this, defaultSize = _a2.defaultSize, intervalPadding = _a2.intervalPadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum, dodgeRatio = _a2.dodgeRatio, maxColumnWidth = _a2.maxColumnWidth, minColumnWidth = _a2.minColumnWidth, columnWidthRatio = _a2.columnWidthRatio;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = (1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum * dodgeRatio / (len - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
      geomWidth = !isNil(columnWidthRatio) ? 1 / groupNum / len * columnWidthRatio : geomWidth;
      if (!isNil(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!isNil(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedDodgePadding = ((1 - (groupNum - 1) * normalizedIntervalPadding) / groupNum - len * geomWidth) / (len - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDodgeOnlyOffset = function(len, idx) {
      var _a2 = this, defaultSize = _a2.defaultSize, dodgePadding = _a2.dodgePadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum, marginRatio = _a2.marginRatio, maxColumnWidth = _a2.maxColumnWidth, minColumnWidth = _a2.minColumnWidth, columnWidthRatio = _a2.columnWidthRatio;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var normalizedIntervalPadding = 1 * marginRatio / (groupNum - 1);
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
      geomWidth = columnWidthRatio ? 1 / groupNum / len * columnWidthRatio : geomWidth;
      if (!isNil(maxColumnWidth)) {
        var normalizedMaxWidht = maxColumnWidth / xDimensionLegenth;
        geomWidth = Math.min(geomWidth, normalizedMaxWidht);
      }
      if (!isNil(minColumnWidth)) {
        var normalizedMinWidht = minColumnWidth / xDimensionLegenth;
        geomWidth = Math.max(geomWidth, normalizedMinWidht);
      }
      geomWidth = defaultSize ? defaultSize / xDimensionLegenth : geomWidth;
      normalizedIntervalPadding = (1 - (geomWidth * len + normalizedDodgePadding * (len - 1)) * groupNum) / (groupNum - 1);
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getIntervalAndDodgeOffset = function(len, idx) {
      var _a2 = this, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding, xDimensionLegenth = _a2.xDimensionLegenth, groupNum = _a2.groupNum;
      var normalizedIntervalPadding = intervalPadding / xDimensionLegenth;
      var normalizedDodgePadding = dodgePadding / xDimensionLegenth;
      var geomWidth = ((1 - normalizedIntervalPadding * (groupNum - 1)) / groupNum - normalizedDodgePadding * (len - 1)) / len;
      var offset = ((1 / 2 + idx) * geomWidth + idx * normalizedDodgePadding + 1 / 2 * normalizedIntervalPadding) * groupNum - normalizedIntervalPadding / 2;
      return offset;
    };
    Dodge2.prototype.getDistribution = function(dim) {
      var groupedDataArray = this.adjustDataArray;
      var cacheMap = this.cacheMap;
      var map2 = cacheMap[dim];
      if (!map2) {
        map2 = {};
        each$1(groupedDataArray, function(data2, index2) {
          var values2 = valuesOfKey(data2, dim);
          if (!values2.length) {
            values2.push(0);
          }
          each$1(values2, function(val) {
            if (!map2[val]) {
              map2[val] = [];
            }
            map2[val].push(index2);
          });
        });
        cacheMap[dim] = map2;
      }
      return map2;
    };
    return Dodge2;
  }(Adjust)
);
function randomNumber(min2, max2) {
  return (max2 - min2) * Math.random() + min2;
}
var Jitter = (
  /** @class */
  function(_super) {
    __extends(Jitter2, _super);
    function Jitter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Jitter2.prototype.process = function(groupDataArray) {
      var groupedDataArray = clone(groupDataArray);
      var mergeData = flatten(groupedDataArray);
      this.adjustData(groupedDataArray, mergeData);
      return groupedDataArray;
    };
    Jitter2.prototype.adjustDim = function(dim, values2, dataArray) {
      var _this = this;
      var groupDataArray = this.groupData(dataArray, dim);
      return each$1(groupDataArray, function(data2, dimValue) {
        return _this.adjustGroup(data2, dim, parseFloat(dimValue), values2);
      });
    };
    Jitter2.prototype.getAdjustOffset = function(range) {
      var pre = range.pre, next = range.next;
      var margin = (next - pre) * GAP;
      return randomNumber(pre + margin, next - margin);
    };
    Jitter2.prototype.adjustGroup = function(group2, dim, dimValue, values2) {
      var _this = this;
      var range = this.getAdjustRange(dim, dimValue, values2);
      each$1(group2, function(data2) {
        data2[dim] = _this.getAdjustOffset(range);
      });
      return group2;
    };
    return Jitter2;
  }(Adjust)
);
var Cache = default_1;
var Stack = (
  /** @class */
  function(_super) {
    __extends(Stack2, _super);
    function Stack2(cfg) {
      var _this = _super.call(this, cfg) || this;
      var _a2 = cfg.adjustNames, adjustNames = _a2 === void 0 ? ["y"] : _a2, _b = cfg.height, height = _b === void 0 ? NaN : _b, _c = cfg.size, size2 = _c === void 0 ? 10 : _c, _d = cfg.reverseOrder, reverseOrder = _d === void 0 ? false : _d;
      _this.adjustNames = adjustNames;
      _this.height = height;
      _this.size = size2;
      _this.reverseOrder = reverseOrder;
      return _this;
    }
    Stack2.prototype.process = function(groupDataArray) {
      var _a2 = this, yField = _a2.yField, reverseOrder = _a2.reverseOrder;
      var d = yField ? this.processStack(groupDataArray) : this.processOneDimStack(groupDataArray);
      return reverseOrder ? this.reverse(d) : d;
    };
    Stack2.prototype.reverse = function(groupedDataArray) {
      return groupedDataArray.slice(0).reverse();
    };
    Stack2.prototype.processStack = function(groupDataArray) {
      var _a2 = this, xField = _a2.xField, yField = _a2.yField, reverseOrder = _a2.reverseOrder;
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var positive = new Cache();
      var negative = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data2) {
          var _a3;
          var x = get(data2, xField, 0);
          var y = get(data2, [yField]);
          var xKey = x.toString();
          y = isArray$1(y) ? y[1] : y;
          if (!isNil(y)) {
            var cache2 = y >= 0 ? positive : negative;
            if (!cache2.has(xKey)) {
              cache2.set(xKey, 0);
            }
            var xValue = cache2.get(xKey);
            var newXValue = y + xValue;
            cache2.set(xKey, newXValue);
            return __assign(__assign({}, data2), (_a3 = {}, _a3[yField] = [xValue, newXValue], _a3));
          }
          return data2;
        });
      });
    };
    Stack2.prototype.processOneDimStack = function(groupDataArray) {
      var _this = this;
      var _a2 = this, xField = _a2.xField, height = _a2.height, reverseOrder = _a2.reverseOrder;
      var yField = "y";
      var groupedDataArray = reverseOrder ? this.reverse(groupDataArray) : groupDataArray;
      var cache2 = new Cache();
      return groupedDataArray.map(function(dataArray) {
        return dataArray.map(function(data2) {
          var _a3;
          var size2 = _this.size;
          var xValue = data2[xField];
          var stackHeight = size2 * 2 / height;
          if (!cache2.has(xValue)) {
            cache2.set(xValue, stackHeight / 2);
          }
          var stackValue = cache2.get(xValue);
          cache2.set(xValue, stackValue + stackHeight);
          return __assign(__assign({}, data2), (_a3 = {}, _a3[yField] = stackValue, _a3));
        });
      });
    };
    return Stack2;
  }(Adjust)
);
var Symmetric = (
  /** @class */
  function(_super) {
    __extends(Symmetric2, _super);
    function Symmetric2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Symmetric2.prototype.process = function(groupDataArray) {
      var mergeData = flatten(groupDataArray);
      var _a2 = this, xField = _a2.xField, yField = _a2.yField;
      var cache2 = this.getXValuesMaxMap(mergeData);
      var max2 = Math.max.apply(Math, Object.keys(cache2).map(function(key) {
        return cache2[key];
      }));
      return map$2(groupDataArray, function(dataArray) {
        return map$2(dataArray, function(data2) {
          var _a3, _b;
          var yValue = data2[yField];
          var xValue = data2[xField];
          if (isArray$1(yValue)) {
            var off_1 = (max2 - cache2[xValue]) / 2;
            return __assign(__assign({}, data2), (_a3 = {}, _a3[yField] = map$2(yValue, function(y) {
              return off_1 + y;
            }), _a3));
          }
          var offset = (max2 - yValue) / 2;
          return __assign(__assign({}, data2), (_b = {}, _b[yField] = [offset, yValue + offset], _b));
        });
      });
    };
    Symmetric2.prototype.getXValuesMaxMap = function(mergeData) {
      var _this = this;
      var _a2 = this, xField = _a2.xField, yField = _a2.yField;
      var groupDataArray = groupBy(mergeData, function(data2) {
        return data2[xField];
      });
      return mapValues(groupDataArray, function(dataArray) {
        return _this.getDimMaxValue(dataArray, yField);
      });
    };
    Symmetric2.prototype.getDimMaxValue = function(mergeData, dim) {
      var dimValues = map$2(mergeData, function(data2) {
        return get(data2, dim, []);
      });
      var flattenValues = flatten(dimValues);
      return Math.max.apply(Math, flattenValues);
    };
    return Symmetric2;
  }(Adjust)
);
registerAdjust("Dodge", Dodge);
registerAdjust("Jitter", Jitter);
registerAdjust("Stack", Stack);
registerAdjust("Symmetric", Symmetric);
var toScaleString = function(scale2, value2) {
  if (isString(value2)) {
    return value2;
  }
  return scale2.invert(scale2.scale(value2));
};
var Attribute = (
  /** @class */
  function() {
    function Attribute2(cfg) {
      this.names = [];
      this.scales = [];
      this.linear = false;
      this.values = [];
      this.callback = function() {
        return [];
      };
      this._parseCfg(cfg);
    }
    Attribute2.prototype.mapping = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      var values2 = params.map(function(param, idx) {
        return _this._toOriginParam(param, _this.scales[idx]);
      });
      return this.callback.apply(this, values2);
    };
    Attribute2.prototype.getLinearValue = function(percent2) {
      var steps = this.values.length - 1;
      var step = Math.floor(steps * percent2);
      var leftPercent = steps * percent2 - step;
      var start = this.values[step];
      var end = step === steps ? start : this.values[step + 1];
      return start + (end - start) * leftPercent;
    };
    Attribute2.prototype.getNames = function() {
      var scales = this.scales;
      var names = this.names;
      var length2 = Math.min(scales.length, names.length);
      var rst = [];
      for (var i = 0; i < length2; i += 1) {
        rst.push(names[i]);
      }
      return rst;
    };
    Attribute2.prototype.getFields = function() {
      return this.scales.map(function(scale2) {
        return scale2.field;
      });
    };
    Attribute2.prototype.getScale = function(name) {
      return this.scales[this.names.indexOf(name)];
    };
    Attribute2.prototype.defaultCallback = function() {
      var _this = this;
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 0) {
        return this.values;
      }
      return params.map(function(param, idx) {
        var scale2 = _this.scales[idx];
        return scale2.type === "identity" ? scale2.values[0] : _this._getAttributeValue(scale2, param);
      });
    };
    Attribute2.prototype._parseCfg = function(cfg) {
      var _this = this;
      var _a2 = cfg.type, type = _a2 === void 0 ? "base" : _a2, _b = cfg.names, names = _b === void 0 ? [] : _b, _c = cfg.scales, scales = _c === void 0 ? [] : _c, _d = cfg.values, values2 = _d === void 0 ? [] : _d, callback = cfg.callback;
      this.type = type;
      this.scales = scales;
      this.values = values2;
      this.names = names;
      this.callback = function() {
        var params = [];
        for (var _i = 0; _i < arguments.length; _i++) {
          params[_i] = arguments[_i];
        }
        if (callback) {
          var ret = callback.apply(void 0, params);
          if (!isNil(ret)) {
            return [ret];
          }
        }
        return _this.defaultCallback.apply(_this, params);
      };
    };
    Attribute2.prototype._getAttributeValue = function(scale2, value2) {
      if (scale2.isCategory && !this.linear) {
        var idx = scale2.translate(value2);
        return this.values[idx % this.values.length];
      }
      var percent2 = scale2.scale(value2);
      return this.getLinearValue(percent2);
    };
    Attribute2.prototype._toOriginParam = function(param, scale2) {
      return !scale2.isLinear ? isArray$1(param) ? param.map(function(p) {
        return toScaleString(scale2, p);
      }) : toScaleString(scale2, param) : param;
    };
    return Attribute2;
  }()
);
var RGB_REG = /rgba?\(([\s.,0-9]+)\)/;
var regexLG$2 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$2 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop$2 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
var isGradientColor = function(val) {
  return /^[r,R,L,l]{1}[\s]*\(/.test(val);
};
var createTmp = function() {
  var i = document.createElement("i");
  i.title = "Web Colour Picker";
  i.style.display = "none";
  document.body.appendChild(i);
  return i;
};
var getValue = function(start, end, percent2, index2) {
  return start[index2] + (end[index2] - start[index2]) * percent2;
};
function arr2rgb(arr) {
  return "#" + toHex(arr[0]) + toHex(arr[1]) + toHex(arr[2]);
}
var rgb2arr = function(str) {
  return [
    parseInt(str.substr(1, 2), 16),
    parseInt(str.substr(3, 2), 16),
    parseInt(str.substr(5, 2), 16)
  ];
};
var toHex = function(value2) {
  var x16Value = Math.round(value2).toString(16);
  return x16Value.length === 1 ? "0" + x16Value : x16Value;
};
var calColor = function(points2, percent2) {
  var fixedPercent = isNaN(Number(percent2)) || percent2 < 0 ? 0 : percent2 > 1 ? 1 : Number(percent2);
  var steps = points2.length - 1;
  var step = Math.floor(steps * fixedPercent);
  var left2 = steps * fixedPercent - step;
  var start = points2[step];
  var end = step === steps ? start : points2[step + 1];
  return arr2rgb([
    getValue(start, end, left2, 0),
    getValue(start, end, left2, 1),
    getValue(start, end, left2, 2)
  ]);
};
var iEl;
var toRGB = function(color2) {
  if (color2[0] === "#" && color2.length === 7) {
    return color2;
  }
  if (!iEl) {
    iEl = createTmp();
  }
  iEl.style.color = color2;
  var rst = document.defaultView.getComputedStyle(iEl, "").getPropertyValue("color");
  var matches = RGB_REG.exec(rst);
  var cArray = matches[1].split(/\s*,\s*/).map(function(s) {
    return Number(s);
  });
  rst = arr2rgb(cArray);
  return rst;
};
var gradient = function(colors) {
  var colorArray = isString(colors) ? colors.split("-") : colors;
  var points2 = map$2(colorArray, function(color2) {
    return rgb2arr(color2.indexOf("#") === -1 ? toRGB(color2) : color2);
  });
  return function(percent2) {
    return calColor(points2, percent2);
  };
};
var toCSSGradient = function(gradientColor) {
  if (isGradientColor(gradientColor)) {
    var cssColor_1;
    var steps = void 0;
    if (gradientColor[0] === "l") {
      var arr = regexLG$2.exec(gradientColor);
      var angle2 = +arr[1] + 90;
      steps = arr[2];
      cssColor_1 = "linear-gradient(" + angle2 + "deg, ";
    } else if (gradientColor[0] === "r") {
      cssColor_1 = "radial-gradient(";
      var arr = regexRG$2.exec(gradientColor);
      steps = arr[4];
    }
    var colorStops_1 = steps.match(regexColorStop$2);
    each$1(colorStops_1, function(item, index2) {
      var itemArr = item.split(":");
      cssColor_1 += itemArr[1] + " " + itemArr[0] * 100 + "%";
      if (index2 !== colorStops_1.length - 1) {
        cssColor_1 += ", ";
      }
    });
    cssColor_1 += ")";
    return cssColor_1;
  }
  return gradientColor;
};
const colorUtil = {
  rgb2arr,
  gradient,
  toRGB: memoize(toRGB),
  toCSSGradient
};
var Color = (
  /** @class */
  function(_super) {
    __extends$1(Color2, _super);
    function Color2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "color";
      _this.names = ["color"];
      if (isString(_this.values)) {
        _this.linear = true;
      }
      _this.gradient = colorUtil.gradient(_this.values);
      return _this;
    }
    Color2.prototype.getLinearValue = function(percent2) {
      return this.gradient(percent2);
    };
    return Color2;
  }(Attribute)
);
var Opacity = (
  /** @class */
  function(_super) {
    __extends$1(Opacity2, _super);
    function Opacity2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "opacity";
      _this.names = ["opacity"];
      return _this;
    }
    return Opacity2;
  }(Attribute)
);
var Position = (
  /** @class */
  function(_super) {
    __extends$1(Position2, _super);
    function Position2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.names = ["x", "y"];
      _this.type = "position";
      return _this;
    }
    Position2.prototype.mapping = function(x, y) {
      var _a2 = this.scales, scaleX = _a2[0], scaleY = _a2[1];
      if (isNil(x) || isNil(y)) {
        return [];
      }
      return [
        isArray$1(x) ? x.map(function(xi) {
          return scaleX.scale(xi);
        }) : scaleX.scale(x),
        isArray$1(y) ? y.map(function(yi) {
          return scaleY.scale(yi);
        }) : scaleY.scale(y)
      ];
    };
    return Position2;
  }(Attribute)
);
var Shape$2 = (
  /** @class */
  function(_super) {
    __extends$1(Shape2, _super);
    function Shape2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "shape";
      _this.names = ["shape"];
      return _this;
    }
    Shape2.prototype.getLinearValue = function(percent2) {
      var idx = Math.round((this.values.length - 1) * percent2);
      return this.values[idx];
    };
    return Shape2;
  }(Attribute)
);
var Size = (
  /** @class */
  function(_super) {
    __extends$1(Size2, _super);
    function Size2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "size";
      _this.names = ["size"];
      return _this;
    }
    return Size2;
  }(Attribute)
);
var methodCache = {};
function getTickMethod(key) {
  return methodCache[key];
}
function registerTickMethod(key, method) {
  methodCache[key] = method;
}
var Scale = (
  /** @class */
  function() {
    function Scale2(cfg) {
      this.type = "base";
      this.isCategory = false;
      this.isLinear = false;
      this.isContinuous = false;
      this.isIdentity = false;
      this.values = [];
      this.range = [0, 1];
      this.ticks = [];
      this.__cfg__ = cfg;
      this.initCfg();
      this.init();
    }
    Scale2.prototype.translate = function(v) {
      return v;
    };
    Scale2.prototype.change = function(cfg) {
      mix(this.__cfg__, cfg);
      this.init();
    };
    Scale2.prototype.clone = function() {
      return this.constructor(this.__cfg__);
    };
    Scale2.prototype.getTicks = function() {
      var _this = this;
      return map$2(this.ticks, function(tick, idx) {
        if (isObject(tick)) {
          return tick;
        }
        return {
          text: _this.getText(tick, idx),
          tickValue: tick,
          value: _this.scale(tick)
        };
      });
    };
    Scale2.prototype.getText = function(value2, key) {
      var formatter = this.formatter;
      var res = formatter ? formatter(value2, key) : value2;
      if (isNil(res) || !isFunction(res.toString)) {
        return "";
      }
      return res.toString();
    };
    Scale2.prototype.getConfig = function(key) {
      return this.__cfg__[key];
    };
    Scale2.prototype.init = function() {
      mix(this, this.__cfg__);
      this.setDomain();
      if (isEmpty(this.getConfig("ticks"))) {
        this.ticks = this.calculateTicks();
      }
    };
    Scale2.prototype.initCfg = function() {
    };
    Scale2.prototype.setDomain = function() {
    };
    Scale2.prototype.calculateTicks = function() {
      var tickMethod = this.tickMethod;
      var ticks = [];
      if (isString(tickMethod)) {
        var method = getTickMethod(tickMethod);
        if (!method) {
          throw new Error("There is no method to to calculate ticks!");
        }
        ticks = method(this);
      } else if (isFunction(tickMethod)) {
        ticks = tickMethod(this);
      }
      return ticks;
    };
    Scale2.prototype.rangeMin = function() {
      return this.range[0];
    };
    Scale2.prototype.rangeMax = function() {
      return this.range[1];
    };
    Scale2.prototype.calcPercent = function(value2, min2, max2) {
      if (isNumber$1(value2)) {
        return (value2 - min2) / (max2 - min2);
      }
      return NaN;
    };
    Scale2.prototype.calcValue = function(percent2, min2, max2) {
      return min2 + percent2 * (max2 - min2);
    };
    return Scale2;
  }()
);
var Category$1 = (
  /** @class */
  function(_super) {
    __extends$1(Category2, _super);
    function Category2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "cat";
      _this.isCategory = true;
      return _this;
    }
    Category2.prototype.buildIndexMap = function() {
      if (!this.translateIndexMap) {
        this.translateIndexMap = /* @__PURE__ */ new Map();
        for (var i = 0; i < this.values.length; i++) {
          this.translateIndexMap.set(this.values[i], i);
        }
      }
    };
    Category2.prototype.translate = function(value2) {
      this.buildIndexMap();
      var idx = this.translateIndexMap.get(value2);
      if (idx === void 0) {
        idx = isNumber$1(value2) ? value2 : NaN;
      }
      return idx;
    };
    Category2.prototype.scale = function(value2) {
      var order = this.translate(value2);
      var percent2 = this.calcPercent(order, this.min, this.max);
      return this.calcValue(percent2, this.rangeMin(), this.rangeMax());
    };
    Category2.prototype.invert = function(scaledValue) {
      var domainRange = this.max - this.min;
      var percent2 = this.calcPercent(scaledValue, this.rangeMin(), this.rangeMax());
      var idx = Math.round(domainRange * percent2) + this.min;
      if (idx < this.min || idx > this.max) {
        return NaN;
      }
      return this.values[idx];
    };
    Category2.prototype.getText = function(value2) {
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var v = value2;
      if (isNumber$1(value2) && !this.values.includes(value2)) {
        v = this.values[v];
      }
      return _super.prototype.getText.apply(this, __spreadArrays([v], args));
    };
    Category2.prototype.initCfg = function() {
      this.tickMethod = "cat";
    };
    Category2.prototype.setDomain = function() {
      if (isNil(this.getConfig("min"))) {
        this.min = 0;
      }
      if (isNil(this.getConfig("max"))) {
        var size2 = this.values.length;
        this.max = size2 > 1 ? size2 - 1 : size2;
      }
      if (this.translateIndexMap) {
        this.translateIndexMap = void 0;
      }
    };
    return Category2;
  }(Scale)
);
var token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
var twoDigitsOptional = "\\d\\d?";
var twoDigits = "\\d\\d";
var threeDigits = "\\d{3}";
var fourDigits = "\\d{4}";
var word = "[^\\s]+";
var literal = /\[([^]*?)\]/gm;
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
var monthUpdate = function(arrName) {
  return function(v, i18n) {
    var lowerCaseArr = i18n[arrName].map(function(v2) {
      return v2.toLowerCase();
    });
    var index2 = lowerCaseArr.indexOf(v.toLowerCase());
    if (index2 > -1) {
      return index2;
    }
    return null;
  };
};
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
var dayNames = [
  "Sunday",
  "Monday",
  "Tuesday",
  "Wednesday",
  "Thursday",
  "Friday",
  "Saturday"
];
var monthNames = [
  "January",
  "February",
  "March",
  "April",
  "May",
  "June",
  "July",
  "August",
  "September",
  "October",
  "November",
  "December"
];
var monthNamesShort = shorten(monthNames, 3);
var dayNamesShort = shorten(dayNames, 3);
var defaultI18n = {
  dayNamesShort,
  dayNames,
  monthNamesShort,
  monthNames,
  amPm: ["am", "pm"],
  DoFn: function(dayOfMonth) {
    return dayOfMonth + ["th", "st", "nd", "rd"][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
  }
};
var globalI18n = assign({}, defaultI18n);
var setGlobalDateI18n = function(i18n) {
  return globalI18n = assign(globalI18n, i18n);
};
var regexEscape = function(str) {
  return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
};
var pad = function(val, len) {
  if (len === void 0) {
    len = 2;
  }
  val = String(val);
  while (val.length < len) {
    val = "0" + val;
  }
  return val;
};
var formatFlags = {
  D: function(dateObj) {
    return String(dateObj.getDate());
  },
  DD: function(dateObj) {
    return pad(dateObj.getDate());
  },
  Do: function(dateObj, i18n) {
    return i18n.DoFn(dateObj.getDate());
  },
  d: function(dateObj) {
    return String(dateObj.getDay());
  },
  dd: function(dateObj) {
    return pad(dateObj.getDay());
  },
  ddd: function(dateObj, i18n) {
    return i18n.dayNamesShort[dateObj.getDay()];
  },
  dddd: function(dateObj, i18n) {
    return i18n.dayNames[dateObj.getDay()];
  },
  M: function(dateObj) {
    return String(dateObj.getMonth() + 1);
  },
  MM: function(dateObj) {
    return pad(dateObj.getMonth() + 1);
  },
  MMM: function(dateObj, i18n) {
    return i18n.monthNamesShort[dateObj.getMonth()];
  },
  MMMM: function(dateObj, i18n) {
    return i18n.monthNames[dateObj.getMonth()];
  },
  YY: function(dateObj) {
    return pad(String(dateObj.getFullYear()), 4).substr(2);
  },
  YYYY: function(dateObj) {
    return pad(dateObj.getFullYear(), 4);
  },
  h: function(dateObj) {
    return String(dateObj.getHours() % 12 || 12);
  },
  hh: function(dateObj) {
    return pad(dateObj.getHours() % 12 || 12);
  },
  H: function(dateObj) {
    return String(dateObj.getHours());
  },
  HH: function(dateObj) {
    return pad(dateObj.getHours());
  },
  m: function(dateObj) {
    return String(dateObj.getMinutes());
  },
  mm: function(dateObj) {
    return pad(dateObj.getMinutes());
  },
  s: function(dateObj) {
    return String(dateObj.getSeconds());
  },
  ss: function(dateObj) {
    return pad(dateObj.getSeconds());
  },
  S: function(dateObj) {
    return String(Math.round(dateObj.getMilliseconds() / 100));
  },
  SS: function(dateObj) {
    return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
  },
  SSS: function(dateObj) {
    return pad(dateObj.getMilliseconds(), 3);
  },
  a: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
  },
  A: function(dateObj, i18n) {
    return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
  },
  ZZ: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
  },
  Z: function(dateObj) {
    var offset = dateObj.getTimezoneOffset();
    return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
  }
};
var monthParse = function(v) {
  return +v - 1;
};
var emptyDigits = [null, twoDigitsOptional];
var emptyWord = [null, word];
var amPm = [
  "isPm",
  word,
  function(v, i18n) {
    var val = v.toLowerCase();
    if (val === i18n.amPm[0]) {
      return 0;
    } else if (val === i18n.amPm[1]) {
      return 1;
    }
    return null;
  }
];
var timezoneOffset = [
  "timezoneOffset",
  "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
  function(v) {
    var parts = (v + "").match(/([+-]|\d\d)/gi);
    if (parts) {
      var minutes = +parts[1] * 60 + parseInt(parts[2], 10);
      return parts[0] === "+" ? minutes : -minutes;
    }
    return 0;
  }
];
var parseFlags = {
  D: ["day", twoDigitsOptional],
  DD: ["day", twoDigits],
  Do: ["day", twoDigitsOptional + word, function(v) {
    return parseInt(v, 10);
  }],
  M: ["month", twoDigitsOptional, monthParse],
  MM: ["month", twoDigits, monthParse],
  YY: [
    "year",
    twoDigits,
    function(v) {
      var now2 = /* @__PURE__ */ new Date();
      var cent = +("" + now2.getFullYear()).substr(0, 2);
      return +("" + (+v > 68 ? cent - 1 : cent) + v);
    }
  ],
  h: ["hour", twoDigitsOptional, void 0, "isPm"],
  hh: ["hour", twoDigits, void 0, "isPm"],
  H: ["hour", twoDigitsOptional],
  HH: ["hour", twoDigits],
  m: ["minute", twoDigitsOptional],
  mm: ["minute", twoDigits],
  s: ["second", twoDigitsOptional],
  ss: ["second", twoDigits],
  YYYY: ["year", fourDigits],
  S: ["millisecond", "\\d", function(v) {
    return +v * 100;
  }],
  SS: ["millisecond", twoDigits, function(v) {
    return +v * 10;
  }],
  SSS: ["millisecond", threeDigits],
  d: emptyDigits,
  dd: emptyDigits,
  ddd: emptyWord,
  dddd: emptyWord,
  MMM: ["month", word, monthUpdate("monthNamesShort")],
  MMMM: ["month", word, monthUpdate("monthNames")],
  a: amPm,
  A: amPm,
  ZZ: timezoneOffset,
  Z: timezoneOffset
};
var globalMasks = {
  default: "ddd MMM DD YYYY HH:mm:ss",
  shortDate: "M/D/YY",
  mediumDate: "MMM D, YYYY",
  longDate: "MMMM D, YYYY",
  fullDate: "dddd, MMMM D, YYYY",
  isoDate: "YYYY-MM-DD",
  isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
  shortTime: "HH:mm",
  mediumTime: "HH:mm:ss",
  longTime: "HH:mm:ss.SSS"
};
var setGlobalDateMasks = function(masks) {
  return assign(globalMasks, masks);
};
var format = function(dateObj, mask, i18n) {
  if (mask === void 0) {
    mask = globalMasks["default"];
  }
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof dateObj === "number") {
    dateObj = new Date(dateObj);
  }
  if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
    throw new Error("Invalid Date pass to format");
  }
  mask = globalMasks[mask] || mask;
  var literals = [];
  mask = mask.replace(literal, function($0, $1) {
    literals.push($1);
    return "@@@";
  });
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  mask = mask.replace(token, function($0) {
    return formatFlags[$0](dateObj, combinedI18nSettings);
  });
  return mask.replace(/@@@/g, function() {
    return literals.shift();
  });
};
function parse(dateStr, format2, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format2 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format2 = globalMasks[format2] || format2;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = /* @__PURE__ */ new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format2.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field3 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field3]) {
      throw new Error("Invalid format. " + field3 + " specified twice in format");
    }
    specifiedFields[field3] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field3) {
    if (!specifiedFields[field3]) {
      throw new Error("Invalid format. " + field3 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i = 1; i < matches.length; i++) {
    var _a2 = parseInfo[i - 1], field2 = _a2[0], parser = _a2[2];
    var value2 = parser ? parser(matches[i], combinedI18nSettings) : +matches[i];
    if (value2 == null) {
      return null;
    }
    dateInfo[field2] = value2;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      ["month", "getMonth"],
      ["day", "getDate"],
      ["hour", "getHours"],
      ["minute", "getMinutes"],
      ["second", "getSeconds"]
    ];
    for (var i = 0, len = validateFields.length; i < len; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var fecha = {
  format,
  parse,
  defaultI18n,
  setGlobalDateI18n,
  setGlobalDateMasks
};
const fecha1 = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  assign,
  default: fecha,
  defaultI18n,
  format,
  parse,
  setGlobalDateI18n,
  setGlobalDateMasks
}, Symbol.toStringTag, { value: "Module" }));
function bisector(getter) {
  return function(a, x, _lo, _hi) {
    var lo = isNil(_lo) ? 0 : _lo;
    var hi = isNil(_hi) ? a.length : _hi;
    while (lo < hi) {
      var mid2 = lo + hi >>> 1;
      if (getter(a[mid2]) > x) {
        hi = mid2;
      } else {
        lo = mid2 + 1;
      }
    }
    return lo;
  };
}
var FORMAT_METHOD = "format";
function timeFormat(time, mask) {
  var method = fecha1[FORMAT_METHOD] || fecha[FORMAT_METHOD];
  return method(time, mask);
}
function toTimeStamp(value2) {
  if (isString(value2)) {
    if (value2.indexOf("T") > 0) {
      value2 = new Date(value2).getTime();
    } else {
      value2 = new Date(value2.replace(/-/gi, "/")).getTime();
    }
  }
  if (isDate(value2)) {
    value2 = value2.getTime();
  }
  return value2;
}
var SECOND = 1e3;
var MINUTE = 60 * SECOND;
var HOUR = 60 * MINUTE;
var DAY = 24 * HOUR;
var MONTH = DAY * 31;
var YEAR = DAY * 365;
var intervals = [
  ["HH:mm:ss", SECOND],
  ["HH:mm:ss", SECOND * 10],
  ["HH:mm:ss", SECOND * 30],
  ["HH:mm", MINUTE],
  ["HH:mm", MINUTE * 10],
  ["HH:mm", MINUTE * 30],
  ["HH", HOUR],
  ["HH", HOUR * 6],
  ["HH", HOUR * 12],
  ["YYYY-MM-DD", DAY],
  ["YYYY-MM-DD", DAY * 4],
  ["YYYY-WW", DAY * 7],
  ["YYYY-MM", MONTH],
  ["YYYY-MM", MONTH * 4],
  ["YYYY-MM", MONTH * 6],
  ["YYYY", DAY * 380]
];
function getTickInterval(min2, max2, tickCount) {
  var target2 = (max2 - min2) / tickCount;
  var idx = bisector(function(o) {
    return o[1];
  })(intervals, target2) - 1;
  var interval2 = intervals[idx];
  if (idx < 0) {
    interval2 = intervals[0];
  } else if (idx >= intervals.length) {
    interval2 = last(intervals);
  }
  return interval2;
}
var TimeCat = (
  /** @class */
  function(_super) {
    __extends$1(TimeCat2, _super);
    function TimeCat2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "timeCat";
      return _this;
    }
    TimeCat2.prototype.translate = function(value2) {
      value2 = toTimeStamp(value2);
      var index2 = this.values.indexOf(value2);
      if (index2 === -1) {
        if (isNumber$1(value2) && value2 < this.values.length) {
          index2 = value2;
        } else {
          index2 = NaN;
        }
      }
      return index2;
    };
    TimeCat2.prototype.getText = function(value2, tickIndex) {
      var index2 = this.translate(value2);
      if (index2 > -1) {
        var result = this.values[index2];
        var formatter = this.formatter;
        result = formatter ? formatter(result, tickIndex) : timeFormat(result, this.mask);
        return result;
      }
      return value2;
    };
    TimeCat2.prototype.initCfg = function() {
      this.tickMethod = "time-cat";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
    };
    TimeCat2.prototype.setDomain = function() {
      var values2 = this.values;
      each$1(values2, function(v, i) {
        values2[i] = toTimeStamp(v);
      });
      values2.sort(function(v1, v2) {
        return v1 - v2;
      });
      _super.prototype.setDomain.call(this);
    };
    return TimeCat2;
  }(Category$1)
);
var Continuous = (
  /** @class */
  function(_super) {
    __extends$1(Continuous2, _super);
    function Continuous2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isContinuous = true;
      return _this;
    }
    Continuous2.prototype.scale = function(value2) {
      if (isNil(value2)) {
        return NaN;
      }
      var rangeMin = this.rangeMin();
      var rangeMax = this.rangeMax();
      var max2 = this.max;
      var min2 = this.min;
      if (max2 === min2) {
        return rangeMin;
      }
      var percent2 = this.getScalePercent(value2);
      return rangeMin + percent2 * (rangeMax - rangeMin);
    };
    Continuous2.prototype.init = function() {
      _super.prototype.init.call(this);
      var ticks = this.ticks;
      var firstTick = head(ticks);
      var lastTick = last(ticks);
      if (firstTick < this.min) {
        this.min = firstTick;
      }
      if (lastTick > this.max) {
        this.max = lastTick;
      }
      if (!isNil(this.minLimit)) {
        this.min = firstTick;
      }
      if (!isNil(this.maxLimit)) {
        this.max = lastTick;
      }
    };
    Continuous2.prototype.setDomain = function() {
      var _a2 = getRange(this.values), min2 = _a2.min, max2 = _a2.max;
      if (isNil(this.min)) {
        this.min = min2;
      }
      if (isNil(this.max)) {
        this.max = max2;
      }
      if (this.min > this.max) {
        this.min = min2;
        this.max = max2;
      }
    };
    Continuous2.prototype.calculateTicks = function() {
      var _this = this;
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        ticks = filter(ticks, function(tick) {
          return tick >= _this.min && tick <= _this.max;
        });
      }
      return ticks;
    };
    Continuous2.prototype.getScalePercent = function(value2) {
      var max2 = this.max;
      var min2 = this.min;
      return (value2 - min2) / (max2 - min2);
    };
    Continuous2.prototype.getInvertPercent = function(value2) {
      return (value2 - this.rangeMin()) / (this.rangeMax() - this.rangeMin());
    };
    return Continuous2;
  }(Scale)
);
var Linear = (
  /** @class */
  function(_super) {
    __extends$1(Linear2, _super);
    function Linear2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "linear";
      _this.isLinear = true;
      return _this;
    }
    Linear2.prototype.invert = function(value2) {
      var percent2 = this.getInvertPercent(value2);
      return this.min + percent2 * (this.max - this.min);
    };
    Linear2.prototype.initCfg = function() {
      this.tickMethod = "wilkinson-extended";
      this.nice = false;
    };
    return Linear2;
  }(Continuous)
);
function calBase(a, b) {
  var e = Math.E;
  var value2;
  if (b >= 0) {
    value2 = Math.pow(e, Math.log(b) / a);
  } else {
    value2 = Math.pow(e, Math.log(-b) / a) * -1;
  }
  return value2;
}
function log$1(a, b) {
  if (a === 1) {
    return 1;
  }
  return Math.log(b) / Math.log(a);
}
function getLogPositiveMin(values2, base, max2) {
  if (isNil(max2)) {
    max2 = Math.max.apply(null, values2);
  }
  var positiveMin = max2;
  each$1(values2, function(value2) {
    if (value2 > 0 && value2 < positiveMin) {
      positiveMin = value2;
    }
  });
  if (positiveMin === max2) {
    positiveMin = max2 / base;
  }
  if (positiveMin > 1) {
    positiveMin = 1;
  }
  return positiveMin;
}
var Log = (
  /** @class */
  function(_super) {
    __extends$1(Log2, _super);
    function Log2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "log";
      return _this;
    }
    Log2.prototype.invert = function(value2) {
      var base = this.base;
      var max2 = log$1(base, this.max);
      var rangeMin = this.rangeMin();
      var range = this.rangeMax() - rangeMin;
      var min2;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        if (value2 === 0) {
          return 0;
        }
        min2 = log$1(base, positiveMin / base);
        var appendPercent = 1 / (max2 - min2) * range;
        if (value2 < appendPercent) {
          return value2 / appendPercent * positiveMin;
        }
      } else {
        min2 = log$1(base, this.min);
      }
      var percent2 = (value2 - rangeMin) / range;
      var tmp = percent2 * (max2 - min2) + min2;
      return Math.pow(base, tmp);
    };
    Log2.prototype.initCfg = function() {
      this.tickMethod = "log";
      this.base = 10;
      this.tickCount = 6;
      this.nice = true;
    };
    Log2.prototype.setDomain = function() {
      _super.prototype.setDomain.call(this);
      var min2 = this.min;
      if (min2 < 0) {
        throw new Error("When you use log scale, the minimum value must be greater than zero!");
      }
      if (min2 === 0) {
        this.positiveMin = getLogPositiveMin(this.values, this.base, this.max);
      }
    };
    Log2.prototype.getScalePercent = function(value2) {
      var max2 = this.max;
      var min2 = this.min;
      if (max2 === min2) {
        return 0;
      }
      if (value2 <= 0) {
        return 0;
      }
      var base = this.base;
      var positiveMin = this.positiveMin;
      if (positiveMin) {
        min2 = positiveMin * 1 / base;
      }
      var percent2;
      if (value2 < positiveMin) {
        percent2 = value2 / positiveMin / (log$1(base, max2) - log$1(base, min2));
      } else {
        percent2 = (log$1(base, value2) - log$1(base, min2)) / (log$1(base, max2) - log$1(base, min2));
      }
      return percent2;
    };
    return Log2;
  }(Continuous)
);
var Pow = (
  /** @class */
  function(_super) {
    __extends$1(Pow2, _super);
    function Pow2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pow";
      return _this;
    }
    Pow2.prototype.invert = function(value2) {
      var percent2 = this.getInvertPercent(value2);
      var exponent2 = this.exponent;
      var max2 = calBase(exponent2, this.max);
      var min2 = calBase(exponent2, this.min);
      var tmp = percent2 * (max2 - min2) + min2;
      var factor = tmp >= 0 ? 1 : -1;
      return Math.pow(tmp, exponent2) * factor;
    };
    Pow2.prototype.initCfg = function() {
      this.tickMethod = "pow";
      this.exponent = 2;
      this.tickCount = 5;
      this.nice = true;
    };
    Pow2.prototype.getScalePercent = function(value2) {
      var max2 = this.max;
      var min2 = this.min;
      if (max2 === min2) {
        return 0;
      }
      var exponent2 = this.exponent;
      var percent2 = (calBase(exponent2, value2) - calBase(exponent2, min2)) / (calBase(exponent2, max2) - calBase(exponent2, min2));
      return percent2;
    };
    return Pow2;
  }(Continuous)
);
var Time = (
  /** @class */
  function(_super) {
    __extends$1(Time2, _super);
    function Time2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "time";
      return _this;
    }
    Time2.prototype.getText = function(value2, index2) {
      var numberValue = this.translate(value2);
      var formatter = this.formatter;
      return formatter ? formatter(numberValue, index2) : timeFormat(numberValue, this.mask);
    };
    Time2.prototype.scale = function(value2) {
      var v = value2;
      if (isString(v) || isDate(v)) {
        v = this.translate(v);
      }
      return _super.prototype.scale.call(this, v);
    };
    Time2.prototype.translate = function(v) {
      return toTimeStamp(v);
    };
    Time2.prototype.initCfg = function() {
      this.tickMethod = "time-pretty";
      this.mask = "YYYY-MM-DD";
      this.tickCount = 7;
      this.nice = false;
    };
    Time2.prototype.setDomain = function() {
      var values2 = this.values;
      var minConfig = this.getConfig("min");
      var maxConfig = this.getConfig("max");
      if (!isNil(minConfig) || !isNumber$1(minConfig)) {
        this.min = this.translate(this.min);
      }
      if (!isNil(maxConfig) || !isNumber$1(maxConfig)) {
        this.max = this.translate(this.max);
      }
      if (values2 && values2.length) {
        var timeStamps_1 = [];
        var min_1 = Infinity;
        var secondMin_1 = min_1;
        var max_1 = 0;
        each$1(values2, function(v) {
          var timeStamp = toTimeStamp(v);
          if (isNaN(timeStamp)) {
            throw new TypeError("Invalid Time: " + v + " in time scale!");
          }
          if (min_1 > timeStamp) {
            secondMin_1 = min_1;
            min_1 = timeStamp;
          } else if (secondMin_1 > timeStamp) {
            secondMin_1 = timeStamp;
          }
          if (max_1 < timeStamp) {
            max_1 = timeStamp;
          }
          timeStamps_1.push(timeStamp);
        });
        if (values2.length > 1) {
          this.minTickInterval = secondMin_1 - min_1;
        }
        if (isNil(minConfig)) {
          this.min = min_1;
        }
        if (isNil(maxConfig)) {
          this.max = max_1;
        }
      }
    };
    return Time2;
  }(Linear)
);
var Quantize = (
  /** @class */
  function(_super) {
    __extends$1(Quantize2, _super);
    function Quantize2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantize";
      return _this;
    }
    Quantize2.prototype.invert = function(value2) {
      var ticks = this.ticks;
      var length2 = ticks.length;
      var percent2 = this.getInvertPercent(value2);
      var minIndex = Math.floor(percent2 * (length2 - 1));
      if (minIndex >= length2 - 1) {
        return last(ticks);
      }
      if (minIndex < 0) {
        return head(ticks);
      }
      var minTick = ticks[minIndex];
      var nextTick2 = ticks[minIndex + 1];
      var minIndexPercent = minIndex / (length2 - 1);
      var maxIndexPercent = (minIndex + 1) / (length2 - 1);
      return minTick + (percent2 - minIndexPercent) / (maxIndexPercent - minIndexPercent) * (nextTick2 - minTick);
    };
    Quantize2.prototype.initCfg = function() {
      this.tickMethod = "r-pretty";
      this.tickCount = 5;
      this.nice = true;
    };
    Quantize2.prototype.calculateTicks = function() {
      var ticks = _super.prototype.calculateTicks.call(this);
      if (!this.nice) {
        if (last(ticks) !== this.max) {
          ticks.push(this.max);
        }
        if (head(ticks) !== this.min) {
          ticks.unshift(this.min);
        }
      }
      return ticks;
    };
    Quantize2.prototype.getScalePercent = function(value2) {
      var ticks = this.ticks;
      if (value2 < head(ticks)) {
        return 0;
      }
      if (value2 > last(ticks)) {
        return 1;
      }
      var minIndex = 0;
      each$1(ticks, function(tick, index2) {
        if (value2 >= tick) {
          minIndex = index2;
        } else {
          return false;
        }
      });
      return minIndex / (ticks.length - 1);
    };
    return Quantize2;
  }(Continuous)
);
var Quantile = (
  /** @class */
  function(_super) {
    __extends$1(Quantile2, _super);
    function Quantile2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "quantile";
      return _this;
    }
    Quantile2.prototype.initCfg = function() {
      this.tickMethod = "quantile";
      this.tickCount = 5;
      this.nice = true;
    };
    return Quantile2;
  }(Quantize)
);
var map = {};
function getClass(key) {
  return map[key];
}
function registerClass(key, cls) {
  if (getClass(key)) {
    throw new Error("type '" + key + "' existed.");
  }
  map[key] = cls;
}
var Identity = (
  /** @class */
  function(_super) {
    __extends$1(Identity2, _super);
    function Identity2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "identity";
      _this.isIdentity = true;
      return _this;
    }
    Identity2.prototype.calculateTicks = function() {
      return this.values;
    };
    Identity2.prototype.scale = function(value2) {
      if (this.values[0] !== value2 && isNumber$1(value2)) {
        return value2;
      }
      return this.range[0];
    };
    Identity2.prototype.invert = function(value2) {
      var range = this.range;
      if (value2 < range[0] || value2 > range[1]) {
        return NaN;
      }
      return this.values[0];
    };
    return Identity2;
  }(Scale)
);
function calculateCatTicks(cfg) {
  var values2 = cfg.values, tickInterval = cfg.tickInterval, tickCount = cfg.tickCount, showLast = cfg.showLast;
  if (isNumber$1(tickInterval)) {
    var ticks_1 = filter(values2, function(__, i2) {
      return i2 % tickInterval === 0;
    });
    var lastValue = last(values2);
    if (showLast && last(ticks_1) !== lastValue) {
      ticks_1.push(lastValue);
    }
    return ticks_1;
  }
  var len = values2.length;
  var min2 = cfg.min, max2 = cfg.max;
  if (isNil(min2)) {
    min2 = 0;
  }
  if (isNil(max2)) {
    max2 = values2.length - 1;
  }
  if (!isNumber$1(tickCount) || tickCount >= len)
    return values2.slice(min2, max2 + 1);
  if (tickCount <= 0 || max2 <= 0)
    return [];
  var interval2 = tickCount === 1 ? len : Math.floor(len / (tickCount - 1));
  var ticks = [];
  var idx = min2;
  for (var i = 0; i < tickCount; i++) {
    if (idx >= max2)
      break;
    idx = Math.min(min2 + i * interval2, max2);
    if (i === tickCount - 1 && showLast)
      ticks.push(values2[max2]);
    else
      ticks.push(values2[idx]);
  }
  return ticks;
}
function d3Linear(cfg) {
  var min2 = cfg.min, max2 = cfg.max, nice = cfg.nice, tickCount = cfg.tickCount;
  var linear2 = new D3Linear();
  linear2.domain([min2, max2]);
  if (nice) {
    linear2.nice(tickCount);
  }
  return linear2.ticks(tickCount);
}
var DEFAULT_COUNT = 5;
var e10 = Math.sqrt(50);
var e5 = Math.sqrt(10);
var e2 = Math.sqrt(2);
var D3Linear = (
  /** @class */
  function() {
    function D3Linear2() {
      this._domain = [0, 1];
    }
    D3Linear2.prototype.domain = function(domain) {
      if (domain) {
        this._domain = Array.from(domain, Number);
        return this;
      }
      return this._domain.slice();
    };
    D3Linear2.prototype.nice = function(count2) {
      var _a2, _b;
      if (count2 === void 0) {
        count2 = DEFAULT_COUNT;
      }
      var d = this._domain.slice();
      var i0 = 0;
      var i1 = this._domain.length - 1;
      var start = this._domain[i0];
      var stop = this._domain[i1];
      var step;
      if (stop < start) {
        _a2 = [stop, start], start = _a2[0], stop = _a2[1];
        _b = [i1, i0], i0 = _b[0], i1 = _b[1];
      }
      step = tickIncrement(start, stop, count2);
      if (step > 0) {
        start = Math.floor(start / step) * step;
        stop = Math.ceil(stop / step) * step;
        step = tickIncrement(start, stop, count2);
      } else if (step < 0) {
        start = Math.ceil(start * step) / step;
        stop = Math.floor(stop * step) / step;
        step = tickIncrement(start, stop, count2);
      }
      if (step > 0) {
        d[i0] = Math.floor(start / step) * step;
        d[i1] = Math.ceil(stop / step) * step;
        this.domain(d);
      } else if (step < 0) {
        d[i0] = Math.ceil(start * step) / step;
        d[i1] = Math.floor(stop * step) / step;
        this.domain(d);
      }
      return this;
    };
    D3Linear2.prototype.ticks = function(count2) {
      if (count2 === void 0) {
        count2 = DEFAULT_COUNT;
      }
      return d3ArrayTicks(this._domain[0], this._domain[this._domain.length - 1], count2 || DEFAULT_COUNT);
    };
    return D3Linear2;
  }()
);
function d3ArrayTicks(start, stop, count2) {
  var reverse;
  var i = -1;
  var n;
  var ticks;
  var step;
  stop = +stop, start = +start, count2 = +count2;
  if (start === stop && count2 > 0) {
    return [start];
  }
  if (reverse = stop < start) {
    n = start, start = stop, stop = n;
  }
  if ((step = tickIncrement(start, stop, count2)) === 0 || !isFinite(step)) {
    return [];
  }
  if (step > 0) {
    start = Math.ceil(start / step);
    stop = Math.floor(stop / step);
    ticks = new Array(n = Math.ceil(stop - start + 1));
    while (++i < n) {
      ticks[i] = (start + i) * step;
    }
  } else {
    start = Math.floor(start * step);
    stop = Math.ceil(stop * step);
    ticks = new Array(n = Math.ceil(start - stop + 1));
    while (++i < n) {
      ticks[i] = (start - i) / step;
    }
  }
  if (reverse) {
    ticks.reverse();
  }
  return ticks;
}
function tickIncrement(start, stop, count2) {
  var step = (stop - start) / Math.max(0, count2);
  var power2 = Math.floor(Math.log(step) / Math.LN10);
  var error = step / Math.pow(10, power2);
  return power2 >= 0 ? (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1) * Math.pow(10, power2) : -Math.pow(10, -power2) / (error >= e10 ? 10 : error >= e5 ? 5 : error >= e2 ? 2 : 1);
}
function snapMultiple(v, base, snapType) {
  var div;
  if (snapType === "ceil") {
    div = Math.ceil(v / base);
  } else if (snapType === "floor") {
    div = Math.floor(v / base);
  } else {
    div = Math.round(v / base);
  }
  return div * base;
}
function intervalTicks(min2, max2, interval2) {
  var minTick = snapMultiple(min2, interval2, "floor");
  var maxTick = snapMultiple(max2, interval2, "ceil");
  minTick = fixedBase(minTick, interval2);
  maxTick = fixedBase(maxTick, interval2);
  var ticks = [];
  var availableInterval = Math.max((maxTick - minTick) / (Math.pow(2, 12) - 1), interval2);
  for (var i = minTick; i <= maxTick; i = i + availableInterval) {
    var tickValue = fixedBase(i, availableInterval);
    ticks.push(tickValue);
  }
  return {
    min: minTick,
    max: maxTick,
    ticks
  };
}
function strictLimit(cfg, defaultMin, defaultMax) {
  var _a2;
  var minLimit = cfg.minLimit, maxLimit = cfg.maxLimit, min2 = cfg.min, max2 = cfg.max, _b = cfg.tickCount, tickCount = _b === void 0 ? 5 : _b;
  var tickMin = isNil(minLimit) ? isNil(defaultMin) ? min2 : defaultMin : minLimit;
  var tickMax = isNil(maxLimit) ? isNil(defaultMax) ? max2 : defaultMax : maxLimit;
  if (tickMin > tickMax) {
    _a2 = [tickMin, tickMax], tickMax = _a2[0], tickMin = _a2[1];
  }
  if (tickCount <= 2) {
    return [tickMin, tickMax];
  }
  var step = (tickMax - tickMin) / (tickCount - 1);
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    ticks.push(tickMin + step * i);
  }
  return ticks;
}
function d3LinearTickMethod(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = d3Linear(cfg);
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function prettyNumber(n) {
  return Math.abs(n) < 1e-15 ? n : parseFloat(n.toFixed(15));
}
var DEFAULT_Q = [1, 5, 2, 2.5, 4, 3];
var eps = Number.EPSILON * 100;
function mod(n, m) {
  return (n % m + m) % m;
}
function round(n) {
  return Math.round(n * 1e12) / 1e12;
}
function simplicity(q, Q, j, lmin, lmax, lstep) {
  var n = size(Q);
  var i = indexOf(Q, q);
  var v = 0;
  var m = mod(lmin, lstep);
  if ((m < eps || lstep - m < eps) && lmin <= 0 && lmax >= 0) {
    v = 1;
  }
  return 1 - i / (n - 1) - j + v;
}
function simplicityMax(q, Q, j) {
  var n = size(Q);
  var i = indexOf(Q, q);
  var v = 1;
  return 1 - i / (n - 1) - j + v;
}
function density(k, m, dMin, dMax, lMin, lMax) {
  var r = (k - 1) / (lMax - lMin);
  var rt = (m - 1) / (Math.max(lMax, dMax) - Math.min(dMin, lMin));
  return 2 - Math.max(r / rt, rt / r);
}
function densityMax(k, m) {
  if (k >= m) {
    return 2 - (k - 1) / (m - 1);
  }
  return 1;
}
function coverage(dMin, dMax, lMin, lMax) {
  var range = dMax - dMin;
  return 1 - 0.5 * (Math.pow(dMax - lMax, 2) + Math.pow(dMin - lMin, 2)) / Math.pow(0.1 * range, 2);
}
function coverageMax(dMin, dMax, span) {
  var range = dMax - dMin;
  if (span > range) {
    var half = (span - range) / 2;
    return 1 - Math.pow(half, 2) / Math.pow(0.1 * range, 2);
  }
  return 1;
}
function legibility() {
  return 1;
}
function extended(dMin, dMax, n, onlyLoose, Q, w) {
  if (n === void 0) {
    n = 5;
  }
  if (onlyLoose === void 0) {
    onlyLoose = true;
  }
  if (Q === void 0) {
    Q = DEFAULT_Q;
  }
  if (w === void 0) {
    w = [0.25, 0.2, 0.5, 0.05];
  }
  var m = n < 0 ? 0 : Math.round(n);
  if (Number.isNaN(dMin) || Number.isNaN(dMax) || typeof dMin !== "number" || typeof dMax !== "number" || !m) {
    return {
      min: 0,
      max: 0,
      ticks: []
    };
  }
  if (dMax - dMin < 1e-15 || m === 1) {
    return {
      min: dMin,
      max: dMax,
      ticks: [dMin]
    };
  }
  if (dMax - dMin > 1e148) {
    var count2 = n || 5;
    var step_1 = (dMax - dMin) / count2;
    return {
      min: dMin,
      max: dMax,
      ticks: Array(count2).fill(null).map(function(_, idx) {
        return prettyNumber(dMin + step_1 * idx);
      })
    };
  }
  var best = {
    score: -2,
    lmin: 0,
    lmax: 0,
    lstep: 0
  };
  var j = 1;
  while (j < Infinity) {
    for (var i = 0; i < Q.length; i += 1) {
      var q = Q[i];
      var sm = simplicityMax(q, Q, j);
      if (w[0] * sm + w[1] + w[2] + w[3] < best.score) {
        j = Infinity;
        break;
      }
      var k = 2;
      while (k < Infinity) {
        var dm = densityMax(k, m);
        if (w[0] * sm + w[1] + w[2] * dm + w[3] < best.score) {
          break;
        }
        var delta = (dMax - dMin) / (k + 1) / j / q;
        var z = Math.ceil(Math.log10(delta));
        while (z < Infinity) {
          var step = j * q * Math.pow(10, z);
          var cm = coverageMax(dMin, dMax, step * (k - 1));
          if (w[0] * sm + w[1] * cm + w[2] * dm + w[3] < best.score) {
            break;
          }
          var minStart = Math.floor(dMax / step) * j - (k - 1) * j;
          var maxStart = Math.ceil(dMin / step) * j;
          if (minStart <= maxStart) {
            var count2 = maxStart - minStart;
            for (var i_1 = 0; i_1 <= count2; i_1 += 1) {
              var start = minStart + i_1;
              var lMin = start * (step / j);
              var lMax = lMin + step * (k - 1);
              var lStep = step;
              var s = simplicity(q, Q, j, lMin, lMax, lStep);
              var c = coverage(dMin, dMax, lMin, lMax);
              var g = density(k, m, dMin, dMax, lMin, lMax);
              var l = legibility();
              var score2 = w[0] * s + w[1] * c + w[2] * g + w[3] * l;
              if (score2 > best.score && (!onlyLoose || lMin <= dMin && lMax >= dMax)) {
                best.lmin = lMin;
                best.lmax = lMax;
                best.lstep = lStep;
                best.score = score2;
              }
            }
          }
          z += 1;
        }
        k += 1;
      }
    }
    j += 1;
  }
  var lmax = prettyNumber(best.lmax);
  var lmin = prettyNumber(best.lmin);
  var lstep = prettyNumber(best.lstep);
  var tickCount = Math.floor(round((lmax - lmin) / lstep)) + 1;
  var ticks = new Array(tickCount);
  ticks[0] = prettyNumber(lmin);
  for (var i = 1; i < tickCount; i++) {
    ticks[i] = prettyNumber(ticks[i - 1] + lstep);
  }
  return {
    min: Math.min(dMin, head(ticks)),
    max: Math.max(dMax, last(ticks)),
    ticks
  };
}
function linear$1(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickCount = cfg.tickCount, nice = cfg.nice, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = extended(min2, max2, tickCount, nice).ticks;
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function calculateLogTicks(cfg) {
  var base = cfg.base, tickCount = cfg.tickCount, min2 = cfg.min, max2 = cfg.max, values2 = cfg.values;
  var minTick;
  var maxTick = log$1(base, max2);
  if (min2 > 0) {
    minTick = Math.floor(log$1(base, min2));
  } else {
    var positiveMin = getLogPositiveMin(values2, base, max2);
    minTick = Math.floor(log$1(base, positiveMin));
  }
  var count2 = maxTick - minTick;
  var avg2 = Math.ceil(count2 / tickCount);
  var ticks = [];
  for (var i = minTick; i < maxTick + avg2; i = i + avg2) {
    ticks.push(Math.pow(base, i));
  }
  if (min2 <= 0) {
    ticks.unshift(0);
  }
  return ticks;
}
function pretty(min2, max2, m) {
  if (m === void 0) {
    m = 5;
  }
  if (min2 === max2) {
    return {
      max: max2,
      min: min2,
      ticks: [min2]
    };
  }
  var n = m < 0 ? 0 : Math.round(m);
  if (n === 0)
    return { max: max2, min: min2, ticks: [] };
  var h = 1.5;
  var h5 = 0.5 + 1.5 * h;
  var d = max2 - min2;
  var c = d / n;
  var base = Math.pow(10, Math.floor(Math.log10(c)));
  var unit = base;
  if (2 * base - c < h * (c - unit)) {
    unit = 2 * base;
    if (5 * base - c < h5 * (c - unit)) {
      unit = 5 * base;
      if (10 * base - c < h * (c - unit)) {
        unit = 10 * base;
      }
    }
  }
  var nu = Math.ceil(max2 / unit);
  var ns = Math.floor(min2 / unit);
  var hi = Math.max(nu * unit, max2);
  var lo = Math.min(ns * unit, min2);
  var size2 = Math.floor((hi - lo) / unit) + 1;
  var ticks = new Array(size2);
  for (var i = 0; i < size2; i++) {
    ticks[i] = prettyNumber(lo + i * unit);
  }
  return {
    min: lo,
    max: hi,
    ticks
  };
}
function calculatePowTicks(cfg) {
  var exponent2 = cfg.exponent, tickCount = cfg.tickCount;
  var max2 = Math.ceil(calBase(exponent2, cfg.max));
  var min2 = Math.floor(calBase(exponent2, cfg.min));
  var ticks = pretty(min2, max2, tickCount).ticks;
  return ticks.map(function(tick) {
    var factor = tick >= 0 ? 1 : -1;
    return Math.pow(tick, exponent2) * factor;
  });
}
function quantileSorted$1(x, p) {
  var idx = x.length * p;
  if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function calculateTicks(cfg) {
  var tickCount = cfg.tickCount, values2 = cfg.values;
  if (!values2 || !values2.length) {
    return [];
  }
  var sorted = values2.slice().sort(function(a, b) {
    return a - b;
  });
  var ticks = [];
  for (var i = 0; i < tickCount; i++) {
    var p = i / (tickCount - 1);
    ticks.push(quantileSorted$1(sorted, p));
  }
  return ticks;
}
function linearPretty(cfg) {
  var min2 = cfg.min, max2 = cfg.max, tickCount = cfg.tickCount, tickInterval = cfg.tickInterval, minLimit = cfg.minLimit, maxLimit = cfg.maxLimit;
  var ticks = pretty(min2, max2, tickCount).ticks;
  if (!isNil(minLimit) || !isNil(maxLimit)) {
    return strictLimit(cfg, head(ticks), last(ticks));
  }
  if (tickInterval) {
    return intervalTicks(min2, max2, tickInterval).ticks;
  }
  return ticks;
}
function calculateTimeTicks(cfg) {
  var min2 = cfg.min, max2 = cfg.max, minTickInterval = cfg.minTickInterval;
  var tickInterval = cfg.tickInterval;
  var tickCount = cfg.tickCount;
  if (tickInterval) {
    tickCount = Math.ceil((max2 - min2) / tickInterval);
  } else {
    tickInterval = getTickInterval(min2, max2, tickCount)[1];
    var count2 = (max2 - min2) / tickInterval;
    var ratio = count2 / tickCount;
    if (ratio > 1) {
      tickInterval = tickInterval * Math.ceil(ratio);
    }
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max2 - min2) / (Math.pow(2, 12) - 1)), tickInterval);
  var ticks = [];
  for (var i = min2; i < max2 + tickInterval; i += tickInterval) {
    ticks.push(i);
  }
  return ticks;
}
function timeCat(cfg) {
  var ticks = calculateCatTicks(__assign$1({ showLast: true }, cfg));
  return ticks;
}
function getYear(date2) {
  return new Date(date2).getFullYear();
}
function createYear(year) {
  return new Date(year, 0, 1).getTime();
}
function getMonth(date2) {
  return new Date(date2).getMonth();
}
function diffMonth(min2, max2) {
  var minYear = getYear(min2);
  var maxYear = getYear(max2);
  var minMonth = getMonth(min2);
  var maxMonth = getMonth(max2);
  return (maxYear - minYear) * 12 + (maxMonth - minMonth) % 12;
}
function creatMonth(year, month) {
  return new Date(year, month, 1).getTime();
}
function diffDay(min2, max2) {
  return Math.ceil((max2 - min2) / DAY);
}
function diffHour(min2, max2) {
  return Math.ceil((max2 - min2) / HOUR);
}
function diffMinus(min2, max2) {
  return Math.ceil((max2 - min2) / (60 * 1e3));
}
function timePretty(cfg) {
  var min2 = cfg.min, max2 = cfg.max, minTickInterval = cfg.minTickInterval, tickCount = cfg.tickCount;
  var tickInterval = cfg.tickInterval;
  var ticks = [];
  if (!tickInterval) {
    tickInterval = (max2 - min2) / tickCount;
    if (minTickInterval && tickInterval < minTickInterval) {
      tickInterval = minTickInterval;
    }
  }
  tickInterval = Math.max(Math.floor((max2 - min2) / (Math.pow(2, 12) - 1)), tickInterval);
  var minYear = getYear(min2);
  if (tickInterval > YEAR) {
    var maxYear = getYear(max2);
    var yearInterval = Math.ceil(tickInterval / YEAR);
    for (var i = minYear; i <= maxYear + yearInterval; i = i + yearInterval) {
      ticks.push(createYear(i));
    }
  } else if (tickInterval > MONTH) {
    var monthInterval = Math.ceil(tickInterval / MONTH);
    var mmMoth = getMonth(min2);
    var dMonths = diffMonth(min2, max2);
    for (var i = 0; i <= dMonths + monthInterval; i = i + monthInterval) {
      ticks.push(creatMonth(minYear, i + mmMoth));
    }
  } else if (tickInterval > DAY) {
    var date2 = new Date(min2);
    var year = date2.getFullYear();
    var month = date2.getMonth();
    var mday = date2.getDate();
    var day = Math.ceil(tickInterval / DAY);
    var ddays = diffDay(min2, max2);
    for (var i = 0; i < ddays + day; i = i + day) {
      ticks.push(new Date(year, month, mday + i).getTime());
    }
  } else if (tickInterval > HOUR) {
    var date2 = new Date(min2);
    var year = date2.getFullYear();
    var month = date2.getMonth();
    var day = date2.getDate();
    var hour = date2.getHours();
    var hours = Math.ceil(tickInterval / HOUR);
    var dHours = diffHour(min2, max2);
    for (var i = 0; i <= dHours + hours; i = i + hours) {
      ticks.push(new Date(year, month, day, hour + i).getTime());
    }
  } else if (tickInterval > MINUTE) {
    var dMinus = diffMinus(min2, max2);
    var minutes = Math.ceil(tickInterval / MINUTE);
    for (var i = 0; i <= dMinus + minutes; i = i + minutes) {
      ticks.push(min2 + i * MINUTE);
    }
  } else {
    var interval2 = tickInterval;
    if (interval2 < SECOND) {
      interval2 = SECOND;
    }
    var minSecond = Math.floor(min2 / SECOND) * SECOND;
    var dSeconds = Math.ceil((max2 - min2) / SECOND);
    var seconds = Math.ceil(interval2 / SECOND);
    for (var i = 0; i < dSeconds + seconds; i = i + seconds) {
      ticks.push(minSecond + i * SECOND);
    }
  }
  if (ticks.length >= 512) {
    console.warn("Notice: current ticks length(" + ticks.length + ') >= 512, may cause performance issues, even out of memory. Because of the configure "tickInterval"(in milliseconds, current is ' + tickInterval + ") is too small, increase the value to solve the problem!");
  }
  return ticks;
}
registerTickMethod("cat", calculateCatTicks);
registerTickMethod("time-cat", timeCat);
registerTickMethod("wilkinson-extended", linear$1);
registerTickMethod("r-pretty", linearPretty);
registerTickMethod("time", calculateTimeTicks);
registerTickMethod("time-pretty", timePretty);
registerTickMethod("log", calculateLogTicks);
registerTickMethod("pow", calculatePowTicks);
registerTickMethod("quantile", calculateTicks);
registerTickMethod("d3-linear", d3LinearTickMethod);
registerClass("cat", Category$1);
registerClass("category", Category$1);
registerClass("identity", Identity);
registerClass("linear", Linear);
registerClass("log", Log);
registerClass("pow", Pow);
registerClass("time", Time);
registerClass("timeCat", TimeCat);
registerClass("quantize", Quantize);
registerClass("quantile", Quantile);
var ATTRIBUTE_MAP = {};
var getAttribute = function(type) {
  return ATTRIBUTE_MAP[type.toLowerCase()];
};
var registerAttribute = function(type, ctor) {
  if (getAttribute(type)) {
    throw new Error("Attribute type '".concat(type, "' existed."));
  }
  ATTRIBUTE_MAP[type.toLowerCase()] = ctor;
};
registerAttribute("Color", Color);
registerAttribute("Opacity", Opacity);
registerAttribute("Position", Position);
registerAttribute("Shape", Shape$2);
registerAttribute("Size", Size);
var Coordinate = (
  /** @class */
  function() {
    function Coordinate2(cfg) {
      this.type = "coordinate";
      this.isRect = false;
      this.isHelix = false;
      this.isPolar = false;
      this.isReflectX = false;
      this.isReflectY = false;
      var start = cfg.start, end = cfg.end, _a2 = cfg.matrix, matrix = _a2 === void 0 ? [1, 0, 0, 0, 1, 0, 0, 0, 1] : _a2, _b = cfg.isTransposed, isTransposed = _b === void 0 ? false : _b;
      this.start = start;
      this.end = end;
      this.matrix = matrix;
      this.originalMatrix = __spreadArray$1([], matrix);
      this.isTransposed = isTransposed;
    }
    Coordinate2.prototype.initial = function() {
      this.center = {
        x: (this.start.x + this.end.x) / 2,
        y: (this.start.y + this.end.y) / 2
      };
      this.width = Math.abs(this.end.x - this.start.x);
      this.height = Math.abs(this.end.y - this.start.y);
    };
    Coordinate2.prototype.update = function(cfg) {
      mix(this, cfg);
      this.initial();
    };
    Coordinate2.prototype.convertDim = function(percent2, dim) {
      var _a2;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a2 = [end, start], start = _a2[0], end = _a2[1];
      }
      return start + percent2 * (end - start);
    };
    Coordinate2.prototype.invertDim = function(value2, dim) {
      var _a2;
      var _b = this[dim], start = _b.start, end = _b.end;
      if (this.isReflect(dim)) {
        _a2 = [end, start], start = _a2[0], end = _a2[1];
      }
      return (value2 - start) / (end - start);
    };
    Coordinate2.prototype.applyMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var vector = [x, y, tag];
      transformMat3$1(vector, vector, matrix);
      return vector;
    };
    Coordinate2.prototype.invertMatrix = function(x, y, tag) {
      if (tag === void 0) {
        tag = 0;
      }
      var matrix = this.matrix;
      var inverted = invert$1([0, 0, 0, 0, 0, 0, 0, 0, 0], matrix);
      var vector = [x, y, tag];
      if (inverted) {
        transformMat3$1(vector, vector, inverted);
      }
      return vector;
    };
    Coordinate2.prototype.convert = function(point2) {
      var _a2 = this.convertPoint(point2), x = _a2.x, y = _a2.y;
      var vector = this.applyMatrix(x, y, 1);
      return {
        x: vector[0],
        y: vector[1]
      };
    };
    Coordinate2.prototype.invert = function(point2) {
      var vector = this.invertMatrix(point2.x, point2.y, 1);
      return this.invertPoint({
        x: vector[0],
        y: vector[1]
      });
    };
    Coordinate2.prototype.rotate = function(radian) {
      var matrix = this.matrix;
      var center2 = this.center;
      leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
      leftRotate(matrix, matrix, radian);
      leftTranslate(matrix, matrix, [center2.x, center2.y]);
      return this;
    };
    Coordinate2.prototype.reflect = function(dim) {
      if (dim === "x") {
        this.isReflectX = !this.isReflectX;
      } else {
        this.isReflectY = !this.isReflectY;
      }
      return this;
    };
    Coordinate2.prototype.scale = function(s1, s2) {
      var matrix = this.matrix;
      var center2 = this.center;
      leftTranslate(matrix, matrix, [-center2.x, -center2.y]);
      leftScale(matrix, matrix, [s1, s2]);
      leftTranslate(matrix, matrix, [center2.x, center2.y]);
      return this;
    };
    Coordinate2.prototype.translate = function(x, y) {
      var matrix = this.matrix;
      leftTranslate(matrix, matrix, [x, y]);
      return this;
    };
    Coordinate2.prototype.transpose = function() {
      this.isTransposed = !this.isTransposed;
      return this;
    };
    Coordinate2.prototype.getCenter = function() {
      return this.center;
    };
    Coordinate2.prototype.getWidth = function() {
      return this.width;
    };
    Coordinate2.prototype.getHeight = function() {
      return this.height;
    };
    Coordinate2.prototype.getRadius = function() {
      return this.radius;
    };
    Coordinate2.prototype.isReflect = function(dim) {
      return dim === "x" ? this.isReflectX : this.isReflectY;
    };
    Coordinate2.prototype.resetMatrix = function(matrix) {
      this.matrix = matrix ? matrix : __spreadArray$1([], this.originalMatrix);
    };
    return Coordinate2;
  }()
);
var Cartesian = (
  /** @class */
  function(_super) {
    __extends$1(Cartesian2, _super);
    function Cartesian2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isRect = true;
      _this.type = "cartesian";
      _this.initial();
      return _this;
    }
    Cartesian2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var start = this.start;
      var end = this.end;
      this.x = {
        start: start.x,
        end: end.x
      };
      this.y = {
        start: start.y,
        end: end.y
      };
    };
    Cartesian2.prototype.convertPoint = function(point2) {
      var _a2;
      var x = point2.x, y = point2.y;
      if (this.isTransposed) {
        _a2 = [y, x], x = _a2[0], y = _a2[1];
      }
      return {
        x: this.convertDim(x, "x"),
        y: this.convertDim(y, "y")
      };
    };
    Cartesian2.prototype.invertPoint = function(point2) {
      var _a2;
      var x = this.invertDim(point2.x, "x");
      var y = this.invertDim(point2.y, "y");
      if (this.isTransposed) {
        _a2 = [y, x], x = _a2[0], y = _a2[1];
      }
      return { x, y };
    };
    return Cartesian2;
  }(Coordinate)
);
var Helix = (
  /** @class */
  function(_super) {
    __extends$1(Helix2, _super);
    function Helix2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isHelix = true;
      _this.type = "helix";
      var _a2 = cfg.startAngle, startAngle = _a2 === void 0 ? 1.25 * Math.PI : _a2, _b = cfg.endAngle, endAngle = _b === void 0 ? 7.25 * Math.PI : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Helix2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      var index2 = (this.endAngle - this.startAngle) / (2 * Math.PI) + 1;
      var maxRadius = Math.min(this.width, this.height) / 2;
      if (this.radius && this.radius >= 0 && this.radius <= 1) {
        maxRadius = maxRadius * this.radius;
      }
      this.d = Math.floor(maxRadius * (1 - this.innerRadius) / index2);
      this.a = this.d / (Math.PI * 2);
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * maxRadius,
        end: this.innerRadius * maxRadius + this.d * 0.99
      };
    };
    Helix2.prototype.convertPoint = function(point2) {
      var _a2;
      var x = point2.x, y = point2.y;
      if (this.isTransposed) {
        _a2 = [y, x], x = _a2[0], y = _a2[1];
      }
      var thi = this.convertDim(x, "x");
      var r = this.a * thi;
      var newY = this.convertDim(y, "y");
      return {
        x: this.center.x + Math.cos(thi) * (r + newY),
        y: this.center.y + Math.sin(thi) * (r + newY)
      };
    };
    Helix2.prototype.invertPoint = function(point2) {
      var _a2;
      var d = this.d + this.y.start;
      var v = subtract([0, 0], [point2.x, point2.y], [this.center.x, this.center.y]);
      var thi = angleTo(v, [1, 0], true);
      var rMin = thi * this.a;
      if (length(v) < rMin) {
        rMin = length(v);
      }
      var index2 = Math.floor((length(v) - rMin) / d);
      thi = 2 * index2 * Math.PI + thi;
      var r = this.a * thi;
      var newY = length(v) - r;
      newY = isNumberEqual$1(newY, 0) ? 0 : newY;
      var x = this.invertDim(thi, "x");
      var y = this.invertDim(newY, "y");
      x = isNumberEqual$1(x, 0) ? 0 : x;
      y = isNumberEqual$1(y, 0) ? 0 : y;
      if (this.isTransposed) {
        _a2 = [y, x], x = _a2[0], y = _a2[1];
      }
      return { x, y };
    };
    return Helix2;
  }(Coordinate)
);
var Polar = (
  /** @class */
  function(_super) {
    __extends$1(Polar2, _super);
    function Polar2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.isPolar = true;
      _this.type = "polar";
      var _a2 = cfg.startAngle, startAngle = _a2 === void 0 ? -Math.PI / 2 : _a2, _b = cfg.endAngle, endAngle = _b === void 0 ? Math.PI * 3 / 2 : _b, _c = cfg.innerRadius, innerRadius = _c === void 0 ? 0 : _c, radius = cfg.radius;
      _this.startAngle = startAngle;
      _this.endAngle = endAngle;
      _this.innerRadius = innerRadius;
      _this.radius = radius;
      _this.initial();
      return _this;
    }
    Polar2.prototype.initial = function() {
      _super.prototype.initial.call(this);
      while (this.endAngle < this.startAngle) {
        this.endAngle += Math.PI * 2;
      }
      var oneBox = this.getOneBox();
      var oneWidth = oneBox.maxX - oneBox.minX;
      var oneHeight = oneBox.maxY - oneBox.minY;
      var left2 = Math.abs(oneBox.minX) / oneWidth;
      var top = Math.abs(oneBox.minY) / oneHeight;
      var maxRadius;
      if (this.height / oneHeight > this.width / oneWidth) {
        maxRadius = this.width / oneWidth;
        this.circleCenter = {
          x: this.center.x - (0.5 - left2) * this.width,
          y: this.center.y - (0.5 - top) * maxRadius * oneHeight
        };
      } else {
        maxRadius = this.height / oneHeight;
        this.circleCenter = {
          x: this.center.x - (0.5 - left2) * maxRadius * oneWidth,
          y: this.center.y - (0.5 - top) * this.height
        };
      }
      this.polarRadius = this.radius;
      if (!this.radius) {
        this.polarRadius = maxRadius;
      } else if (this.radius > 0 && this.radius <= 1) {
        this.polarRadius = maxRadius * this.radius;
      } else if (this.radius <= 0 || this.radius > maxRadius) {
        this.polarRadius = maxRadius;
      }
      this.x = {
        start: this.startAngle,
        end: this.endAngle
      };
      this.y = {
        start: this.innerRadius * this.polarRadius,
        end: this.polarRadius
      };
    };
    Polar2.prototype.getRadius = function() {
      return this.polarRadius;
    };
    Polar2.prototype.convertPoint = function(point2) {
      var _a2;
      var center2 = this.getCenter();
      var x = point2.x, y = point2.y;
      if (this.isTransposed) {
        _a2 = [y, x], x = _a2[0], y = _a2[1];
      }
      x = this.convertDim(x, "x");
      y = this.convertDim(y, "y");
      return {
        x: center2.x + Math.cos(x) * y,
        y: center2.y + Math.sin(x) * y
      };
    };
    Polar2.prototype.invertPoint = function(point2) {
      var _a2;
      var center2 = this.getCenter();
      var vPoint = [point2.x - center2.x, point2.y - center2.y];
      var _b = this, startAngle = _b.startAngle, endAngle = _b.endAngle;
      if (this.isReflect("x")) {
        _a2 = [endAngle, startAngle], startAngle = _a2[0], endAngle = _a2[1];
      }
      var m = [1, 0, 0, 0, 1, 0, 0, 0, 1];
      leftRotate(m, m, startAngle);
      var vStart3 = [1, 0, 0];
      transformMat3$1(vStart3, vStart3, m);
      var vStart2 = [vStart3[0], vStart3[1]];
      var angle2 = angleTo(vStart2, vPoint, endAngle < startAngle);
      if (isNumberEqual$1(angle2, Math.PI * 2)) {
        angle2 = 0;
      }
      var radius = length(vPoint);
      var xPercent = angle2 / (endAngle - startAngle);
      xPercent = endAngle - startAngle > 0 ? xPercent : -xPercent;
      var yPercent = this.invertDim(radius, "y");
      var rst = { x: 0, y: 0 };
      rst.x = this.isTransposed ? yPercent : xPercent;
      rst.y = this.isTransposed ? xPercent : yPercent;
      return rst;
    };
    Polar2.prototype.getCenter = function() {
      return this.circleCenter;
    };
    Polar2.prototype.getOneBox = function() {
      var startAngle = this.startAngle;
      var endAngle = this.endAngle;
      if (Math.abs(endAngle - startAngle) >= Math.PI * 2) {
        return {
          minX: -1,
          maxX: 1,
          minY: -1,
          maxY: 1
        };
      }
      var xs = [0, Math.cos(startAngle), Math.cos(endAngle)];
      var ys = [0, Math.sin(startAngle), Math.sin(endAngle)];
      for (var i = Math.min(startAngle, endAngle); i < Math.max(startAngle, endAngle); i += Math.PI / 18) {
        xs.push(Math.cos(i));
        ys.push(Math.sin(i));
      }
      return {
        minX: Math.min.apply(Math, xs),
        maxX: Math.max.apply(Math, xs),
        minY: Math.min.apply(Math, ys),
        maxY: Math.max.apply(Math, ys)
      };
    };
    return Polar2;
  }(Coordinate)
);
var COORDINATE_MAP = {};
var getCoordinate = function(type) {
  return COORDINATE_MAP[type.toLowerCase()];
};
var registerCoordinate = function(type, ctor) {
  COORDINATE_MAP[type.toLowerCase()] = ctor;
};
registerCoordinate("rect", Cartesian);
registerCoordinate("cartesian", Cartesian);
registerCoordinate("polar", Polar);
registerCoordinate("helix", Helix);
function propagationDelegate(group2, eventName, eventObject) {
  var event = new GraphEvent(eventName, eventObject);
  event.target = group2;
  event.propagationPath.push(group2);
  group2.emitDelegation(eventName, event);
  var parent = group2.getParent();
  while (parent) {
    parent.emitDelegation(eventName, event);
    event.propagationPath.push(parent);
    parent = parent.getParent();
  }
}
var identityMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function getMatrixByAngle(point2, angle2, matrix) {
  if (matrix === void 0) {
    matrix = identityMatrix;
  }
  if (!angle2) {
    return null;
  }
  var m = transform$6(matrix, [
    ["t", -point2.x, -point2.y],
    ["r", angle2],
    ["t", point2.x, point2.y]
  ]);
  return m;
}
function getMatrixByTranslate(point2, currentMatrix) {
  if (!point2.x && !point2.y) {
    return null;
  }
  return transform$6(currentMatrix || identityMatrix, [["t", point2.x, point2.y]]);
}
function getAngleByMatrix(matrix) {
  var xVector = [1, 0, 0];
  var out = [0, 0, 0];
  transformMat3$1(out, xVector, matrix);
  return Math.atan2(out[1], out[0]);
}
function multiplyVec2(matrix, v) {
  var out = [0, 0];
  transformMat3(out, v, matrix);
  return out;
}
function applyMatrix2BBox(matrix, bbox) {
  var topLeft = multiplyVec2(matrix, [bbox.minX, bbox.minY]);
  var topRight = multiplyVec2(matrix, [bbox.maxX, bbox.minY]);
  var bottomLeft = multiplyVec2(matrix, [bbox.minX, bbox.maxY]);
  var bottomRight = multiplyVec2(matrix, [bbox.maxX, bbox.maxY]);
  var minX = Math.min(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var maxX = Math.max(topLeft[0], topRight[0], bottomLeft[0], bottomRight[0]);
  var minY = Math.min(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  var maxY2 = Math.max(topLeft[1], topRight[1], bottomLeft[1], bottomRight[1]);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function applyRotate(shape, rotate2, x, y) {
  if (rotate2) {
    var matrix = getMatrixByAngle({ x, y }, rotate2, shape.getMatrix());
    shape.setMatrix(matrix);
  }
}
function applyTranslate(shape, x, y) {
  var translateMatrix = getMatrixByTranslate({ x, y });
  shape.attr("matrix", translateMatrix);
}
function formatPadding(padding2) {
  var top = 0;
  var left2 = 0;
  var right2 = 0;
  var bottom = 0;
  if (isNumber$1(padding2)) {
    top = left2 = right2 = bottom = padding2;
  } else if (isArray$1(padding2)) {
    top = padding2[0];
    right2 = !isNil(padding2[1]) ? padding2[1] : padding2[0];
    bottom = !isNil(padding2[2]) ? padding2[2] : padding2[0];
    left2 = !isNil(padding2[3]) ? padding2[3] : right2;
  }
  return [top, right2, bottom, left2];
}
function clearDom(container) {
  var children = container.childNodes;
  var length2 = children.length;
  for (var i = length2 - 1; i >= 0; i--) {
    container.removeChild(children[i]);
  }
}
function hasClass(elements, cName) {
  return !!elements.className.match(new RegExp("(\\s|^)" + cName + "(\\s|$)"));
}
function regionToBBox(region) {
  var start = region.start, end = region.end;
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  var maxX = Math.max(start.x, end.x);
  var maxY2 = Math.max(start.y, end.y);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function pointsToBBox(points2) {
  var xs = points2.map(function(point2) {
    return point2.x;
  });
  var ys = points2.map(function(point2) {
    return point2.y;
  });
  var minX = Math.min.apply(Math, xs);
  var minY = Math.min.apply(Math, ys);
  var maxX = Math.max.apply(Math, xs);
  var maxY2 = Math.max.apply(Math, ys);
  return {
    x: minX,
    y: minY,
    minX,
    minY,
    maxX,
    maxY: maxY2,
    width: maxX - minX,
    height: maxY2 - minY
  };
}
function createBBox(x, y, width, height) {
  var maxX = x + width;
  var maxY2 = y + height;
  return {
    x,
    y,
    width,
    height,
    minX: x,
    minY: y,
    //  js 
    // Infinity + Infinity = Infinity
    // Infinity - Infinity = NaN
    // fixed https://github.com/antvis/G2Plot/issues/1243
    maxX: isNaN(maxX) ? 0 : maxX,
    maxY: isNaN(maxY2) ? 0 : maxY2
  };
}
function getValueByPercent(min2, max2, percent2) {
  return (1 - percent2) * min2 + max2 * percent2;
}
function getCirclePoint(center2, radius, angle2) {
  return {
    x: center2.x + Math.cos(angle2) * radius,
    y: center2.y + Math.sin(angle2) * radius
  };
}
function distance$4(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
var near = function(x, y, e) {
  if (e === void 0) {
    e = Math.pow(Number.EPSILON, 0.5);
  }
  return [x, y].includes(Infinity) ? Math.abs(x) === Math.abs(y) : Math.abs(x - y) < e;
};
function intersectBBox(box1, box2) {
  var minX = Math.max(box1.minX, box2.minX);
  var minY = Math.max(box1.minY, box2.minY);
  var maxX = Math.min(box1.maxX, box2.maxX);
  var maxY2 = Math.min(box1.maxY, box2.maxY);
  return createBBox(minX, minY, maxX - minX, maxY2 - minY);
}
function getBBoxWithClip(element) {
  var clipShape = element.getClip();
  var clipBBox = clipShape && clipShape.getBBox();
  var bbox;
  if (!element.isGroup()) {
    bbox = element.getBBox();
  } else {
    var minX_1 = Infinity;
    var maxX_1 = -Infinity;
    var minY_1 = Infinity;
    var maxY_1 = -Infinity;
    var children = element.getChildren();
    if (children.length > 0) {
      each$1(children, function(child) {
        if (child.get("visible")) {
          if (child.isGroup() && child.get("children").length === 0) {
            return true;
          }
          var box2 = getBBoxWithClip(child);
          var leftTop = child.applyToMatrix([box2.minX, box2.minY, 1]);
          var leftBottom = child.applyToMatrix([box2.minX, box2.maxY, 1]);
          var rightTop = child.applyToMatrix([box2.maxX, box2.minY, 1]);
          var rightBottom = child.applyToMatrix([box2.maxX, box2.maxY, 1]);
          var boxMinX = Math.min(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMaxX = Math.max(leftTop[0], leftBottom[0], rightTop[0], rightBottom[0]);
          var boxMinY = Math.min(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          var boxMaxY = Math.max(leftTop[1], leftBottom[1], rightTop[1], rightBottom[1]);
          if (boxMinX < minX_1) {
            minX_1 = boxMinX;
          }
          if (boxMaxX > maxX_1) {
            maxX_1 = boxMaxX;
          }
          if (boxMinY < minY_1) {
            minY_1 = boxMinY;
          }
          if (boxMaxY > maxY_1) {
            maxY_1 = boxMaxY;
          }
        }
      });
    } else {
      minX_1 = 0;
      maxX_1 = 0;
      minY_1 = 0;
      maxY_1 = 0;
    }
    bbox = createBBox(minX_1, minY_1, maxX_1 - minX_1, maxY_1 - minY_1);
  }
  if (clipBBox) {
    return intersectBBox(bbox, clipBBox);
  } else {
    return bbox;
  }
}
function updateClip(element, newElement) {
  if (!element.getClip() && !newElement.getClip()) {
    return;
  }
  var newClipShape = newElement.getClip();
  if (!newClipShape) {
    element.setClip(null);
    return;
  }
  var clipCfg = {
    type: newClipShape.get("type"),
    attrs: newClipShape.attr()
  };
  element.setClip(clipCfg);
}
function toPx(number2) {
  return number2 + "px";
}
function getTextPoint(start, end, position, offset) {
  var lineLength = distance$4(start, end);
  var offsetPercent = offset / lineLength;
  var percent2 = 0;
  if (position === "start") {
    percent2 = 0 - offsetPercent;
  } else if (position === "end") {
    percent2 = 1 + offsetPercent;
  }
  return {
    x: getValueByPercent(start.x, end.x, percent2),
    y: getValueByPercent(start.y, end.y, percent2)
  };
}
var LOCATION_FIELD_MAP = {
  none: [],
  point: ["x", "y"],
  region: ["start", "end"],
  points: ["points"],
  circle: ["center", "radius", "startAngle", "endAngle"]
};
var Component = (
  /** @class */
  function(_super) {
    __extends$1(Component2, _super);
    function Component2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.initCfg();
      return _this;
    }
    Component2.prototype.getDefaultCfg = function() {
      return {
        id: "",
        name: "",
        type: "",
        locationType: "none",
        offsetX: 0,
        offsetY: 0,
        animate: false,
        capture: true,
        updateAutoRender: false,
        animateOption: {
          appear: null,
          update: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          enter: {
            duration: 400,
            easing: "easeQuadInOut"
          },
          leave: {
            duration: 350,
            easing: "easeQuadIn"
          }
        },
        events: null,
        defaultCfg: {},
        visible: true
      };
    };
    Component2.prototype.clear = function() {
    };
    Component2.prototype.update = function(cfg) {
      var _this = this;
      var defaultCfg = this.get("defaultCfg") || {};
      each$1(cfg, function(value2, name) {
        var originCfg = _this.get(name);
        var newCfg = value2;
        if (originCfg !== value2) {
          if (isObject(value2) && defaultCfg[name]) {
            newCfg = deepMix({}, defaultCfg[name], value2);
          }
          _this.set(name, newCfg);
        }
      });
      this.updateInner(cfg);
      this.afterUpdate(cfg);
    };
    Component2.prototype.updateInner = function(cfg) {
    };
    Component2.prototype.afterUpdate = function(cfg) {
      if (has(cfg, "visible")) {
        if (cfg.visible) {
          this.show();
        } else {
          this.hide();
        }
      }
      if (has(cfg, "capture")) {
        this.setCapture(cfg.capture);
      }
    };
    Component2.prototype.getLayoutBBox = function() {
      return this.getBBox();
    };
    Component2.prototype.getLocationType = function() {
      return this.get("locationType");
    };
    Component2.prototype.getOffset = function() {
      return {
        offsetX: this.get("offsetX"),
        offsetY: this.get("offsetY")
      };
    };
    Component2.prototype.setOffset = function(offsetX, offsetY) {
      this.update({
        offsetX,
        offsetY
      });
    };
    Component2.prototype.setLocation = function(cfg) {
      var location = __assign$1({}, cfg);
      this.update(location);
    };
    Component2.prototype.getLocation = function() {
      var _this = this;
      var location = {};
      var locationType = this.get("locationType");
      var fields = LOCATION_FIELD_MAP[locationType];
      each$1(fields, function(field2) {
        location[field2] = _this.get(field2);
      });
      return location;
    };
    Component2.prototype.isList = function() {
      return false;
    };
    Component2.prototype.isSlider = function() {
      return false;
    };
    Component2.prototype.init = function() {
    };
    Component2.prototype.initCfg = function() {
      var _this = this;
      var defaultCfg = this.get("defaultCfg");
      each$1(defaultCfg, function(value2, name) {
        var cfg = _this.get(name);
        if (isObject(cfg)) {
          var newCfg = deepMix({}, value2, cfg);
          _this.set(name, newCfg);
        }
      });
    };
    return Component2;
  }(Base)
);
var STATUS_UPDATE = "update_status";
var COPY_PROPERTIES = ["visible", "tip", "delegateObject"];
var COPY_PROPERTIES_EXCLUDES = ["container", "group", "shapesMap", "isRegister", "isUpdating", "destroyed"];
var GroupComponent = (
  /** @class */
  function(_super) {
    __extends$1(GroupComponent2, _super);
    function GroupComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GroupComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), {
        container: null,
        /**
         * @private
         *  Map
         */
        shapesMap: {},
        group: null,
        capture: true,
        /**
         * @private 
         * @type {false}
         */
        isRegister: false,
        /**
         * @private 
         * @type {false}
         */
        isUpdating: false,
        /**
         * @private
         *  renderupdate  false, clear 
         */
        isInit: true
      });
    };
    GroupComponent2.prototype.remove = function() {
      this.clear();
      var group2 = this.get("group");
      group2.remove();
    };
    GroupComponent2.prototype.clear = function() {
      var group2 = this.get("group");
      group2.clear();
      this.set("shapesMap", {});
      this.clearOffScreenCache();
      this.set("isInit", true);
    };
    GroupComponent2.prototype.getChildComponentById = function(id2) {
      var group2 = this.getElementById(id2);
      var inst = group2 && group2.get("component");
      return inst;
    };
    GroupComponent2.prototype.getElementById = function(id2) {
      return this.get("shapesMap")[id2];
    };
    GroupComponent2.prototype.getElementByLocalId = function(localId) {
      var id2 = this.getElementId(localId);
      return this.getElementById(id2);
    };
    GroupComponent2.prototype.getElementsByName = function(name) {
      var rst = [];
      each$1(this.get("shapesMap"), function(elem) {
        if (elem.get("name") === name) {
          rst.push(elem);
        }
      });
      return rst;
    };
    GroupComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    GroupComponent2.prototype.updateInner = function(cfg) {
      this.offScreenRender();
      if (this.get("updateAutoRender")) {
        this.render();
      }
    };
    GroupComponent2.prototype.render = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (!offScreenGroup) {
        offScreenGroup = this.offScreenRender();
      }
      var group2 = this.get("group");
      this.updateElements(offScreenGroup, group2);
      this.deleteElements();
      this.applyOffset();
      if (!this.get("eventInitted")) {
        this.initEvent();
        this.set("eventInitted", true);
      }
      this.set("isInit", false);
    };
    GroupComponent2.prototype.show = function() {
      var group2 = this.get("group");
      group2.show();
      this.set("visible", true);
    };
    GroupComponent2.prototype.hide = function() {
      var group2 = this.get("group");
      group2.hide();
      this.set("visible", false);
    };
    GroupComponent2.prototype.setCapture = function(capture) {
      var group2 = this.get("group");
      group2.set("capture", capture);
      this.set("capture", capture);
    };
    GroupComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.remove();
      _super.prototype.destroy.call(this);
    };
    GroupComponent2.prototype.getBBox = function() {
      return this.get("group").getCanvasBBox();
    };
    GroupComponent2.prototype.getLayoutBBox = function() {
      var group2 = this.get("group");
      var bbox = this.getInnerLayoutBBox();
      var matrix = group2.getTotalMatrix();
      if (matrix) {
        bbox = applyMatrix2BBox(matrix, bbox);
      }
      return bbox;
    };
    GroupComponent2.prototype.on = function(evt, callback, once) {
      var group2 = this.get("group");
      group2.on(evt, callback, once);
      return this;
    };
    GroupComponent2.prototype.off = function(evt, callback) {
      var group2 = this.get("group");
      group2 && group2.off(evt, callback);
      return this;
    };
    GroupComponent2.prototype.emit = function(eventName, eventObject) {
      var group2 = this.get("group");
      group2.emit(eventName, eventObject);
    };
    GroupComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      if (!this.get("group")) {
        this.initGroup();
      }
      this.offScreenRender();
    };
    GroupComponent2.prototype.getInnerLayoutBBox = function() {
      return this.get("offScreenBBox") || this.get("group").getBBox();
    };
    GroupComponent2.prototype.delegateEmit = function(eventName, eventObject) {
      var group2 = this.get("group");
      eventObject.target = group2;
      group2.emit(eventName, eventObject);
      propagationDelegate(group2, eventName, eventObject);
    };
    GroupComponent2.prototype.createOffScreenGroup = function() {
      var group2 = this.get("group");
      var GroupClass = group2.getGroupBase();
      var newGroup = new GroupClass({
        delegateObject: this.getDelegateObject()
      });
      return newGroup;
    };
    GroupComponent2.prototype.applyOffset = function() {
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: offsetX,
        y: offsetY
      });
    };
    GroupComponent2.prototype.initGroup = function() {
      var container = this.get("container");
      this.set("group", container.addGroup({
        id: this.get("id"),
        name: this.get("name"),
        capture: this.get("capture"),
        visible: this.get("visible"),
        isComponent: true,
        component: this,
        delegateObject: this.getDelegateObject()
      }));
    };
    GroupComponent2.prototype.offScreenRender = function() {
      this.clearOffScreenCache();
      var offScreenGroup = this.createOffScreenGroup();
      this.renderInner(offScreenGroup);
      this.set("offScreenGroup", offScreenGroup);
      this.set("offScreenBBox", getBBoxWithClip(offScreenGroup));
      return offScreenGroup;
    };
    GroupComponent2.prototype.addGroup = function(parent, cfg) {
      this.appendDelegateObject(parent, cfg);
      var group2 = parent.addGroup(cfg);
      if (this.get("isRegister")) {
        this.registerElement(group2);
      }
      return group2;
    };
    GroupComponent2.prototype.addShape = function(parent, cfg) {
      this.appendDelegateObject(parent, cfg);
      var shape = parent.addShape(cfg);
      if (this.get("isRegister")) {
        this.registerElement(shape);
      }
      return shape;
    };
    GroupComponent2.prototype.addComponent = function(parent, cfg) {
      var id2 = cfg.id, Ctor = cfg.component, restCfg = __rest(cfg, ["id", "component"]);
      var inst = new Ctor(__assign$1(__assign$1({}, restCfg), { id: id2, container: parent, updateAutoRender: this.get("updateAutoRender") }));
      inst.init();
      inst.render();
      if (this.get("isRegister")) {
        this.registerElement(inst.get("group"));
      }
      return inst;
    };
    GroupComponent2.prototype.initEvent = function() {
    };
    GroupComponent2.prototype.removeEvent = function() {
      var group2 = this.get("group");
      group2.off();
    };
    GroupComponent2.prototype.getElementId = function(localId) {
      var id2 = this.get("id");
      var name = this.get("name");
      return id2 + "-" + name + "-" + localId;
    };
    GroupComponent2.prototype.registerElement = function(element) {
      var id2 = element.get("id");
      this.get("shapesMap")[id2] = element;
    };
    GroupComponent2.prototype.unregisterElement = function(element) {
      var id2 = element.get("id");
      delete this.get("shapesMap")[id2];
    };
    GroupComponent2.prototype.moveElementTo = function(element, point2) {
      var matrix = getMatrixByTranslate(point2);
      element.attr("matrix", matrix);
    };
    GroupComponent2.prototype.addAnimation = function(elmentName, newElement, animateCfg) {
      var originOpacity = newElement.attr("opacity");
      if (isNil(originOpacity)) {
        originOpacity = 1;
      }
      newElement.attr("opacity", 0);
      newElement.animate({ opacity: originOpacity }, animateCfg);
    };
    GroupComponent2.prototype.removeAnimation = function(elementName, originElement, animateCfg) {
      originElement.animate({ opacity: 0 }, animateCfg);
    };
    GroupComponent2.prototype.updateAnimation = function(elementName, originElement, newAttrs, animateCfg) {
      originElement.animate(newAttrs, animateCfg);
    };
    GroupComponent2.prototype.updateElements = function(newGroup, originGroup) {
      var _this = this;
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      var children = newGroup.getChildren().slice(0);
      var preElement;
      each$1(children, function(element) {
        var elementId = element.get("id");
        var originElement = _this.getElementById(elementId);
        var elementName = element.get("name");
        if (originElement) {
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            var origChildComponent = originElement.get("component");
            var newCfg = pick$1(childComponent.cfg, difference(keys(childComponent.cfg), COPY_PROPERTIES_EXCLUDES));
            origChildComponent.update(newCfg);
            originElement.set(STATUS_UPDATE, "update");
          } else {
            var replaceAttrs = _this.getReplaceAttrs(originElement, element);
            if (animate && animateOption.update) {
              _this.updateAnimation(elementName, originElement, replaceAttrs, animateOption.update);
            } else {
              originElement.attr(replaceAttrs);
            }
            if (element.isGroup()) {
              _this.updateElements(element, originElement);
            }
            each$1(COPY_PROPERTIES, function(name) {
              originElement.set(name, element.get(name));
            });
            updateClip(originElement, element);
            preElement = originElement;
            originElement.set(STATUS_UPDATE, "update");
          }
        } else {
          originGroup.add(element);
          var siblings2 = originGroup.getChildren();
          siblings2.splice(siblings2.length - 1, 1);
          if (preElement) {
            var index2 = siblings2.indexOf(preElement);
            siblings2.splice(index2 + 1, 0, element);
          } else {
            siblings2.unshift(element);
          }
          _this.registerElement(element);
          element.set(STATUS_UPDATE, "add");
          if (element.get("isComponent")) {
            var childComponent = element.get("component");
            childComponent.set("container", originGroup);
          } else if (element.isGroup()) {
            _this.registerNewGroup(element);
          }
          preElement = element;
          if (animate) {
            var animateCfg = _this.get("isInit") ? animateOption.appear : animateOption.enter;
            if (animateCfg) {
              _this.addAnimation(elementName, element, animateCfg);
            }
          }
        }
      });
    };
    GroupComponent2.prototype.clearUpdateStatus = function(group2) {
      var children = group2.getChildren();
      each$1(children, function(el) {
        el.set(STATUS_UPDATE, null);
      });
    };
    GroupComponent2.prototype.clearOffScreenCache = function() {
      var offScreenGroup = this.get("offScreenGroup");
      if (offScreenGroup) {
        offScreenGroup.destroy();
      }
      this.set("offScreenGroup", null);
      this.set("offScreenBBox", null);
    };
    GroupComponent2.prototype.getDelegateObject = function() {
      var _a2;
      var name = this.get("name");
      var delegateObject = (_a2 = {}, _a2[name] = this, _a2.component = this, _a2);
      return delegateObject;
    };
    GroupComponent2.prototype.appendDelegateObject = function(parent, cfg) {
      var parentObject = parent.get("delegateObject");
      if (!cfg.delegateObject) {
        cfg.delegateObject = {};
      }
      mix(cfg.delegateObject, parentObject);
    };
    GroupComponent2.prototype.getReplaceAttrs = function(originElement, newElement) {
      var originAttrs = originElement.attr();
      var newAttrs = newElement.attr();
      each$1(originAttrs, function(v, k) {
        if (newAttrs[k] === void 0) {
          newAttrs[k] = void 0;
        }
      });
      return newAttrs;
    };
    GroupComponent2.prototype.registerNewGroup = function(group2) {
      var _this = this;
      var children = group2.getChildren();
      each$1(children, function(element) {
        _this.registerElement(element);
        element.set(STATUS_UPDATE, "add");
        if (element.isGroup()) {
          _this.registerNewGroup(element);
        }
      });
    };
    GroupComponent2.prototype.deleteElements = function() {
      var _this = this;
      var shapesMap = this.get("shapesMap");
      var deleteArray = [];
      each$1(shapesMap, function(element, id2) {
        if (!element.get(STATUS_UPDATE) || element.destroyed) {
          deleteArray.push([id2, element]);
        } else {
          element.set(STATUS_UPDATE, null);
        }
      });
      var animate = this.get("animate");
      var animateOption = this.get("animateOption");
      each$1(deleteArray, function(item) {
        var id2 = item[0], element = item[1];
        if (!element.destroyed) {
          var elementName = element.get("name");
          if (animate && animateOption.leave) {
            var callbackAnimCfg = mix({
              callback: function() {
                _this.removeElement(element);
              }
            }, animateOption.leave);
            _this.removeAnimation(elementName, element, callbackAnimCfg);
          } else {
            _this.removeElement(element);
          }
        }
        delete shapesMap[id2];
      });
    };
    GroupComponent2.prototype.removeElement = function(element) {
      if (element.get("isGroup")) {
        var component2 = element.get("component");
        if (component2) {
          component2.destroy();
        }
      }
      element.remove();
    };
    return GroupComponent2;
  }(Component)
);
var ELLIPSIS_CODE$1 = "";
function strLen(str) {
  var len = 0;
  for (var i = 0; i < str.length; i++) {
    len += charAtLength(str, i);
  }
  return len;
}
function charAtLength(str, i) {
  if (str.charCodeAt(i) > 0 && str.charCodeAt(i) < 128) {
    return 1;
  } else {
    return 2;
  }
}
function ellipsisString(str, reseveLength, position) {
  if (position === void 0) {
    position = "tail";
  }
  var count2 = str.length;
  var rst = "";
  if (position === "tail") {
    for (var i = 0, index2 = 0; i < reseveLength; ) {
      var charLength = charAtLength(str, index2);
      if (i + charLength <= reseveLength) {
        rst += str[index2];
        i += charAtLength(str, index2);
        index2++;
      } else {
        break;
      }
    }
    rst += ELLIPSIS_CODE$1;
  } else if (position === "head") {
    for (var i = 0, index2 = count2 - 1; i < reseveLength; ) {
      var charLength = charAtLength(str, index2);
      if (i + charLength <= reseveLength) {
        rst += str[index2];
        i += charAtLength(str, index2);
        index2--;
      } else {
        break;
      }
    }
    rst = ELLIPSIS_CODE$1 + rst;
  } else {
    var startStr = "";
    var endStr = "";
    for (var i = 0, startIndex = 0, endIndex = count2 - 1; i < reseveLength; ) {
      var startCodeLen = charAtLength(str, startIndex);
      var hasAdd = false;
      if (startCodeLen + i <= reseveLength) {
        startStr += str[startIndex];
        startIndex++;
        i += startCodeLen;
        hasAdd = true;
      }
      var endCodeLen = charAtLength(str, endIndex);
      if (endCodeLen + i <= reseveLength) {
        endStr = str[endIndex] + endStr;
        i += endCodeLen;
        endIndex--;
        hasAdd = true;
      }
      if (!hasAdd) {
        break;
      }
    }
    rst = startStr + ELLIPSIS_CODE$1 + endStr;
  }
  return rst;
}
var ELLIPSIS_CODE = "";
var ELLIPSIS_CODE_LENGTH = 2;
var OPTIMIZE_THRESHOLD = 400;
function getMaxLabelWidthOptimized(labels) {
  var texts = labels.map(function(label2) {
    var text2 = label2.attr("text");
    return isNil(text2) ? "" : "" + text2;
  });
  var maxLen = 0;
  var maxIdx = 0;
  for (var i = 0; i < texts.length; i += 1) {
    var len = 0;
    for (var j = 0; j <= texts[i].length; j += 1) {
      var code2 = texts[i].charCodeAt(j);
      if (code2 >= 19968 && code2 <= 40869) {
        len += 2;
      } else {
        len += 1;
      }
    }
    if (len > maxLen) {
      maxLen = len;
      maxIdx = i;
    }
  }
  return labels[maxIdx].getBBox().width;
}
function getMaxLabelWidth(labels) {
  if (labels.length > OPTIMIZE_THRESHOLD) {
    return getMaxLabelWidthOptimized(labels);
  }
  var max2 = 0;
  each$1(labels, function(label2) {
    var bbox = label2.getBBox();
    var width = bbox.width;
    if (max2 < width) {
      max2 = width;
    }
  });
  return max2;
}
function getLabelLength(isVertical2, label2) {
  var bbox = label2.getCanvasBBox();
  return isVertical2 ? bbox.width : bbox.height;
}
function ellipsisLabel(isVertical2, label2, limitLength, position) {
  var _a2;
  if (position === void 0) {
    position = "tail";
  }
  var text2 = (_a2 = label2.attr("text")) !== null && _a2 !== void 0 ? _a2 : "";
  if (position === "tail") {
    var font = pick$1(label2.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
    var ellipsisText = getEllipsisText$1(text2, limitLength, font, "");
    if (text2 !== ellipsisText) {
      label2.attr("text", ellipsisText);
      label2.set("tip", text2);
      return true;
    }
    label2.set("tip", null);
    return false;
  }
  var labelLength = getLabelLength(isVertical2, label2);
  var codeLength = strLen(text2);
  var ellipsisFlag = false;
  if (limitLength < labelLength) {
    var reserveLength = Math.floor(limitLength / labelLength * codeLength) - ELLIPSIS_CODE_LENGTH;
    var newText = void 0;
    if (reserveLength >= 0) {
      newText = ellipsisString(text2, reserveLength, position);
    } else {
      newText = ELLIPSIS_CODE;
    }
    if (newText) {
      label2.attr("text", newText);
      ellipsisFlag = true;
    }
  }
  if (ellipsisFlag) {
    label2.set("tip", text2);
  } else {
    label2.set("tip", null);
  }
  return ellipsisFlag;
}
function renderTag$1(container, tagCfg) {
  var x = tagCfg.x, y = tagCfg.y, content = tagCfg.content, style = tagCfg.style, id2 = tagCfg.id, name = tagCfg.name, rotate2 = tagCfg.rotate, maxLength = tagCfg.maxLength, autoEllipsis2 = tagCfg.autoEllipsis, isVertical2 = tagCfg.isVertical, ellipsisPosition = tagCfg.ellipsisPosition, background = tagCfg.background;
  var tagGroup = container.addGroup({
    id: id2 + "-group",
    name: name + "-group",
    attrs: {
      x,
      y
    }
  });
  var text2 = tagGroup.addShape({
    type: "text",
    id: id2,
    name,
    attrs: __assign$1({ x: 0, y: 0, text: content }, style)
  });
  var padding2 = formatPadding(get(background, "padding", 0));
  if (maxLength && autoEllipsis2) {
    var maxTextLength = maxLength - (padding2[1] + padding2[3]);
    ellipsisLabel(!isVertical2, text2, maxTextLength, ellipsisPosition);
  }
  if (background) {
    var backgroundStyle = get(background, "style", {});
    var _a2 = text2.getCanvasBBox(), minX = _a2.minX, minY = _a2.minY, width = _a2.width, height = _a2.height;
    var tagBg = tagGroup.addShape("rect", {
      id: id2 + "-bg",
      name: id2 + "-bg",
      attrs: __assign$1({ x: minX - padding2[3], y: minY - padding2[0], width: width + padding2[1] + padding2[3], height: height + padding2[0] + padding2[2] }, backgroundStyle)
    });
    tagBg.toBack();
  }
  applyTranslate(tagGroup, x, y);
  applyRotate(tagGroup, rotate2, x, y);
}
const Theme = {
  fontFamily: '\n  BlinkMacSystemFont, "Segoe UI", Roboto,"Helvetica Neue",\n  Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei",\n  SimSun, "sans-serif"',
  textColor: "#2C3542",
  activeTextColor: "#333333",
  uncheckedColor: "#D8D8D8",
  lineColor: "#416180",
  regionColor: "#CCD7EB",
  verticalAxisRotate: -Math.PI / 4,
  horizontalAxisRotate: Math.PI / 4,
  // descriptionIcon theme
  descriptionIconStroke: "#fff",
  descriptionIconFill: "rgba(58, 73, 101, .25)"
};
var LineAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(LineAnnotation2, _super);
    function LineAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "line", locationType: "region", start: null, end: null, style: {}, text: null, defaultCfg: {
        style: {
          fill: Theme.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "bottom",
          fontFamily: Theme.fontFamily
        },
        text: {
          position: "center",
          autoRotate: true,
          content: null,
          offsetX: 0,
          offsetY: 0,
          style: {
            stroke: Theme.lineColor,
            lineWidth: 1
          }
        }
      } });
    };
    LineAnnotation2.prototype.renderInner = function(group2) {
      this.renderLine(group2);
      if (this.get("text")) {
        this.renderLabel(group2);
      }
    };
    LineAnnotation2.prototype.renderLine = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      this.addShape(group2, {
        type: "line",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: __assign$1({ x1: start.x, y1: start.y, x2: end.x, y2: end.y }, style)
      });
    };
    LineAnnotation2.prototype.getLabelPoint = function(start, end, position) {
      var percent2;
      if (position === "start") {
        percent2 = 0;
      } else if (position === "center") {
        percent2 = 0.5;
      } else if (isString(position) && position.indexOf("%") !== -1) {
        percent2 = parseInt(position, 10) / 100;
      } else if (isNumber$1(position)) {
        percent2 = position;
      } else {
        percent2 = 1;
      }
      if (percent2 > 1 || percent2 < 0) {
        percent2 = 1;
      }
      return {
        x: getValueByPercent(start.x, end.x, percent2),
        y: getValueByPercent(start.y, end.y, percent2)
      };
    };
    LineAnnotation2.prototype.renderLabel = function(group2) {
      var text2 = this.get("text");
      var start = this.get("start");
      var end = this.get("end");
      var position = text2.position, content = text2.content, style = text2.style, offsetX = text2.offsetX, offsetY = text2.offsetY, autoRotate2 = text2.autoRotate, maxLength = text2.maxLength, autoEllipsis2 = text2.autoEllipsis, ellipsisPosition = text2.ellipsisPosition, background = text2.background, _a2 = text2.isVertical, isVertical2 = _a2 === void 0 ? false : _a2;
      var point2 = this.getLabelPoint(start, end, position);
      var x = point2.x + offsetX;
      var y = point2.y + offsetY;
      var cfg = {
        id: this.getElementId("line-text"),
        name: "annotation-line-text",
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis: autoEllipsis2,
        ellipsisPosition,
        background,
        isVertical: isVertical2
      };
      if (autoRotate2) {
        var vector = [end.x - start.x, end.y - start.y];
        cfg.rotate = Math.atan2(vector[1], vector[0]);
      }
      renderTag$1(group2, cfg);
    };
    return LineAnnotation2;
  }(GroupComponent)
);
var TextAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(TextAnnotation2, _super);
    function TextAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    TextAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "text", locationType: "point", x: 0, y: 0, content: "", rotate: null, style: {}, background: null, maxLength: null, autoEllipsis: true, isVertical: false, ellipsisPosition: "tail", defaultCfg: {
        style: {
          fill: Theme.textColor,
          fontSize: 12,
          textAlign: "center",
          textBaseline: "middle",
          fontFamily: Theme.fontFamily
        }
      } });
    };
    TextAnnotation2.prototype.setLocation = function(location) {
      this.set("x", location.x);
      this.set("y", location.y);
      this.resetLocation();
    };
    TextAnnotation2.prototype.renderInner = function(group2) {
      var _a2 = this.getLocation(), x = _a2.x, y = _a2.y;
      var content = this.get("content");
      var style = this.get("style");
      var id2 = this.getElementId("text");
      var name = this.get("name") + "-text";
      var maxLength = this.get("maxLength");
      var autoEllipsis2 = this.get("autoEllipsis");
      var isVertical2 = this.get("isVertical");
      var ellipsisPosition = this.get("ellipsisPosition");
      var background = this.get("background");
      var rotate2 = this.get("rotate");
      var cfg = {
        id: id2,
        name,
        x,
        y,
        content,
        style,
        maxLength,
        autoEllipsis: autoEllipsis2,
        isVertical: isVertical2,
        ellipsisPosition,
        background,
        rotate: rotate2
      };
      renderTag$1(group2, cfg);
    };
    TextAnnotation2.prototype.resetLocation = function() {
      var textGroup = this.getElementByLocalId("text-group");
      if (textGroup) {
        var _a2 = this.getLocation(), x = _a2.x, y = _a2.y;
        var rotate2 = this.get("rotate");
        applyTranslate(textGroup, x, y);
        applyRotate(textGroup, rotate2, x, y);
      }
    };
    return TextAnnotation2;
  }(GroupComponent)
);
var ArcAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(ArcAnnotation2, _super);
    function ArcAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ArcAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "arc", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2, style: {
        stroke: "#999",
        lineWidth: 1
      } });
    };
    ArcAnnotation2.prototype.renderInner = function(group2) {
      this.renderArc(group2);
    };
    ArcAnnotation2.prototype.getArcPath = function() {
      var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
      var startPoint = getCirclePoint(center2, radius, startAngle);
      var endPoint = getCirclePoint(center2, radius, endAngle);
      var largeFlag = endAngle - startAngle > Math.PI ? 1 : 0;
      var path2 = [["M", startPoint.x, startPoint.y]];
      if (endAngle - startAngle === Math.PI * 2) {
        var middlePoint = getCirclePoint(center2, radius, startAngle + Math.PI);
        path2.push(["A", radius, radius, 0, largeFlag, 1, middlePoint.x, middlePoint.y]);
        path2.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      } else {
        path2.push(["A", radius, radius, 0, largeFlag, 1, endPoint.x, endPoint.y]);
      }
      return path2;
    };
    ArcAnnotation2.prototype.renderArc = function(group2) {
      var path2 = this.getArcPath();
      var style = this.get("style");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("arc"),
        name: "annotation-arc",
        attrs: __assign$1({ path: path2 }, style)
      });
    };
    return ArcAnnotation2;
  }(GroupComponent)
);
var RegionAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(RegionAnnotation2, _super);
    function RegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "region", locationType: "region", start: null, end: null, style: {}, defaultCfg: {
        style: {
          lineWidth: 0,
          fill: Theme.regionColor,
          opacity: 0.4
        }
      } });
    };
    RegionAnnotation2.prototype.renderInner = function(group2) {
      this.renderRegion(group2);
    };
    RegionAnnotation2.prototype.renderRegion = function(group2) {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign$1({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height }, style)
      });
    };
    return RegionAnnotation2;
  }(GroupComponent)
);
var ImageAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(ImageAnnotation2, _super);
    function ImageAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "image", locationType: "region", start: null, end: null, src: null, style: {} });
    };
    ImageAnnotation2.prototype.renderInner = function(group2) {
      this.renderImage(group2);
    };
    ImageAnnotation2.prototype.getImageAttrs = function() {
      var start = this.get("start");
      var end = this.get("end");
      var style = this.get("style");
      var bbox = regionToBBox({ start, end });
      var src2 = this.get("src");
      return __assign$1({ x: bbox.x, y: bbox.y, img: src2, width: bbox.width, height: bbox.height }, style);
    };
    ImageAnnotation2.prototype.renderImage = function(group2) {
      this.addShape(group2, {
        type: "image",
        id: this.getElementId("image"),
        name: "annotation-image",
        attrs: this.getImageAttrs()
      });
    };
    return ImageAnnotation2;
  }(GroupComponent)
);
var DataMarkerAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(DataMarkerAnnotation2, _super);
    function DataMarkerAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataMarkerAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "dataMarker", locationType: "point", x: 0, y: 0, point: {}, line: {}, text: {}, direction: "upward", autoAdjust: true, coordinateBBox: null, defaultCfg: {
        point: {
          display: true,
          style: {
            r: 3,
            fill: "#FFFFFF",
            stroke: "#1890FF",
            lineWidth: 2
          }
        },
        line: {
          display: true,
          length: 20,
          style: {
            stroke: Theme.lineColor,
            lineWidth: 1
          }
        },
        text: {
          content: "",
          display: true,
          style: {
            fill: Theme.textColor,
            opacity: 0.65,
            fontSize: 12,
            textAlign: "start",
            fontFamily: Theme.fontFamily
          }
        }
      } });
    };
    DataMarkerAnnotation2.prototype.renderInner = function(group2) {
      if (get(this.get("line"), "display")) {
        this.renderLine(group2);
      }
      if (get(this.get("text"), "display")) {
        this.renderText(group2);
      }
      if (get(this.get("point"), "display")) {
        this.renderPoint(group2);
      }
      if (this.get("autoAdjust")) {
        this.autoAdjust(group2);
      }
    };
    DataMarkerAnnotation2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x") + this.get("offsetX"),
        y: this.get("y") + this.get("offsetY")
      });
    };
    DataMarkerAnnotation2.prototype.renderPoint = function(group2) {
      var point2 = this.getShapeAttrs().point;
      this.addShape(group2, {
        type: "circle",
        id: this.getElementId("point"),
        name: "annotation-point",
        attrs: point2
      });
    };
    DataMarkerAnnotation2.prototype.renderLine = function(group2) {
      var line2 = this.getShapeAttrs().line;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "annotation-line",
        attrs: line2
      });
    };
    DataMarkerAnnotation2.prototype.renderText = function(group2) {
      var textAttrs = this.getShapeAttrs().text;
      var x = textAttrs.x, y = textAttrs.y, text2 = textAttrs.text, style = __rest(textAttrs, ["x", "y", "text"]);
      var _a2 = this.get("text"), background = _a2.background, maxLength = _a2.maxLength, autoEllipsis2 = _a2.autoEllipsis, isVertival = _a2.isVertival, ellipsisPosition = _a2.ellipsisPosition;
      var tagCfg = {
        x,
        y,
        id: this.getElementId("text"),
        name: "annotation-text",
        content: text2,
        style,
        background,
        maxLength,
        autoEllipsis: autoEllipsis2,
        isVertival,
        ellipsisPosition
      };
      renderTag$1(group2, tagCfg);
    };
    DataMarkerAnnotation2.prototype.autoAdjust = function(group2) {
      var direction2 = this.get("direction");
      var x = this.get("x");
      var y = this.get("y");
      var lineLength = get(this.get("line"), "length", 0);
      var coordinateBBox = this.get("coordinateBBox");
      var _a2 = group2.getBBox(), minX = _a2.minX, maxX = _a2.maxX, minY = _a2.minY, maxY2 = _a2.maxY;
      var textGroup = group2.findById(this.getElementId("text-group"));
      var textShape = group2.findById(this.getElementId("text"));
      var lineShape = group2.findById(this.getElementId("line"));
      if (!coordinateBBox) {
        return;
      }
      if (textGroup) {
        if (x + minX <= coordinateBBox.minX) {
          var overflow = coordinateBBox.minX - (x + minX);
          applyTranslate(textGroup, textGroup.attr("x") + overflow, textGroup.attr("y"));
        }
        if (x + maxX >= coordinateBBox.maxX) {
          var overflow = x + maxX - coordinateBBox.maxX;
          applyTranslate(textGroup, textGroup.attr("x") - overflow, textGroup.attr("y"));
        }
      }
      if (direction2 === "upward" && y + minY <= coordinateBBox.minY || direction2 !== "upward" && y + maxY2 >= coordinateBBox.maxY) {
        var textBaseline = void 0;
        var factor = void 0;
        if (direction2 === "upward" && y + minY <= coordinateBBox.minY) {
          textBaseline = "top";
          factor = 1;
        } else {
          textBaseline = "bottom";
          factor = -1;
        }
        textShape.attr("textBaseline", textBaseline);
        if (lineShape) {
          lineShape.attr("path", [
            ["M", 0, 0],
            ["L", 0, lineLength * factor]
          ]);
        }
        applyTranslate(textGroup, textGroup.attr("x"), (lineLength + 2) * factor);
      }
    };
    DataMarkerAnnotation2.prototype.getShapeAttrs = function() {
      var lineDisplay = get(this.get("line"), "display");
      var pointStyle = get(this.get("point"), "style", {});
      var lineStyle = get(this.get("line"), "style", {});
      var textStyle2 = get(this.get("text"), "style", {});
      var direction2 = this.get("direction");
      var lineLength = lineDisplay ? get(this.get("line"), "length", 0) : 0;
      var factor = direction2 === "upward" ? -1 : 1;
      return {
        point: __assign$1({ x: 0, y: 0 }, pointStyle),
        line: __assign$1({ path: [
          ["M", 0, 0],
          ["L", 0, lineLength * factor]
        ] }, lineStyle),
        text: __assign$1({ x: 0, y: (lineLength + 2) * factor, text: get(this.get("text"), "content", ""), textBaseline: direction2 === "upward" ? "bottom" : "top" }, textStyle2)
      };
    };
    return DataMarkerAnnotation2;
  }(GroupComponent)
);
var DataRegionAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(DataRegionAnnotation2, _super);
    function DataRegionAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataRegionAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "dataRegion", locationType: "points", points: [], lineLength: 0, region: {}, text: {}, defaultCfg: {
        region: {
          style: {
            lineWidth: 0,
            fill: Theme.regionColor,
            opacity: 0.4
          }
        },
        text: {
          content: "",
          style: {
            textAlign: "center",
            textBaseline: "bottom",
            fontSize: 12,
            fill: Theme.textColor,
            fontFamily: Theme.fontFamily
          }
        }
      } });
    };
    DataRegionAnnotation2.prototype.renderInner = function(group2) {
      var regionStyle = get(this.get("region"), "style", {});
      get(this.get("text"), "style", {});
      var lineLength = this.get("lineLength") || 0;
      var points2 = this.get("points");
      if (!points2.length) {
        return;
      }
      var bbox = pointsToBBox(points2);
      var path2 = [];
      path2.push(["M", points2[0].x, bbox.minY - lineLength]);
      points2.forEach(function(point2) {
        path2.push(["L", point2.x, point2.y]);
      });
      path2.push(["L", points2[points2.length - 1].x, points2[points2.length - 1].y - lineLength]);
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("region"),
        name: "annotation-region",
        attrs: __assign$1({ path: path2 }, regionStyle)
      });
      var textCfg = __assign$1({ id: this.getElementId("text"), name: "annotation-text", x: (bbox.minX + bbox.maxX) / 2, y: bbox.minY - lineLength }, this.get("text"));
      renderTag$1(group2, textCfg);
    };
    return DataRegionAnnotation2;
  }(GroupComponent)
);
var RegionFilterAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(RegionFilterAnnotation2, _super);
    function RegionFilterAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RegionFilterAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "regionFilter", locationType: "region", start: null, end: null, color: null, shape: [] });
    };
    RegionFilterAnnotation2.prototype.renderInner = function(group2) {
      var _this = this;
      var start = this.get("start");
      var end = this.get("end");
      var layer = this.addGroup(group2, {
        id: this.getElementId("region-filter"),
        capture: false
      });
      each$1(this.get("shapes"), function(shape, shapeIdx) {
        var type = shape.get("type");
        var attrs = clone(shape.attr());
        _this.adjustShapeAttrs(attrs);
        _this.addShape(layer, {
          id: _this.getElementId("shape-" + type + "-" + shapeIdx),
          capture: false,
          type,
          attrs
        });
      });
      var clipBBox = regionToBBox({ start, end });
      layer.setClip({
        type: "rect",
        attrs: {
          x: clipBBox.minX,
          y: clipBBox.minY,
          width: clipBBox.width,
          height: clipBBox.height
        }
      });
    };
    RegionFilterAnnotation2.prototype.adjustShapeAttrs = function(attr) {
      var color2 = this.get("color");
      if (attr.fill) {
        attr.fill = attr.fillStyle = color2;
      }
      attr.stroke = attr.strokeStyle = color2;
    };
    return RegionFilterAnnotation2;
  }(GroupComponent)
);
var ShapeAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(ShapeAnnotation2, _super);
    function ShapeAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "shape", draw: noop });
    };
    ShapeAnnotation2.prototype.renderInner = function(group2) {
      var render = this.get("render");
      if (isFunction(render)) {
        render(group2);
      }
    };
    return ShapeAnnotation2;
  }(GroupComponent)
);
var HtmlComponent = (
  /** @class */
  function(_super) {
    __extends$1(HtmlComponent2, _super);
    function HtmlComponent2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlComponent2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { container: null, containerTpl: "<div></div>", updateAutoRender: true, containerClassName: "", parent: null });
    };
    HtmlComponent2.prototype.getContainer = function() {
      return this.get("container");
    };
    HtmlComponent2.prototype.show = function() {
      var container = this.get("container");
      container.style.display = "";
      this.set("visible", true);
    };
    HtmlComponent2.prototype.hide = function() {
      var container = this.get("container");
      container.style.display = "none";
      this.set("visible", false);
    };
    HtmlComponent2.prototype.setCapture = function(capture) {
      var container = this.getContainer();
      var value2 = capture ? "auto" : "none";
      container.style.pointerEvents = value2;
      this.set("capture", capture);
    };
    HtmlComponent2.prototype.getBBox = function() {
      var container = this.getContainer();
      var x = parseFloat(container.style.left) || 0;
      var y = parseFloat(container.style.top) || 0;
      return createBBox(x, y, container.clientWidth, container.clientHeight);
    };
    HtmlComponent2.prototype.clear = function() {
      var container = this.get("container");
      clearDom(container);
    };
    HtmlComponent2.prototype.destroy = function() {
      this.removeEvent();
      this.removeDom();
      _super.prototype.destroy.call(this);
    };
    HtmlComponent2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.initContainer();
      this.initDom();
      this.resetStyles();
      this.applyStyles();
      this.initEvent();
      this.initCapture();
      this.initVisible();
    };
    HtmlComponent2.prototype.initCapture = function() {
      this.setCapture(this.get("capture"));
    };
    HtmlComponent2.prototype.initVisible = function() {
      if (!this.get("visible")) {
        this.hide();
      } else {
        this.show();
      }
    };
    HtmlComponent2.prototype.initDom = function() {
    };
    HtmlComponent2.prototype.initContainer = function() {
      var container = this.get("container");
      if (isNil(container)) {
        container = this.createDom();
        var parent_1 = this.get("parent");
        if (isString(parent_1)) {
          parent_1 = document.getElementById(parent_1);
          this.set("parent", parent_1);
        }
        parent_1.appendChild(container);
        if (this.get("containerId")) {
          container.setAttribute("id", this.get("containerId"));
        }
        this.set("container", container);
      } else if (isString(container)) {
        container = document.getElementById(container);
        this.set("container", container);
      }
      if (!this.get("parent")) {
        this.set("parent", container.parentNode);
      }
    };
    HtmlComponent2.prototype.resetStyles = function() {
      var style = this.get("domStyles");
      var defaultStyles = this.get("defaultStyles");
      if (!style) {
        style = defaultStyles;
      } else {
        style = deepMix({}, defaultStyles, style);
      }
      this.set("domStyles", style);
    };
    HtmlComponent2.prototype.applyStyles = function() {
      var domStyles = this.get("domStyles");
      if (!domStyles) {
        return;
      }
      var container = this.getContainer();
      this.applyChildrenStyles(container, domStyles);
      var containerClassName = this.get("containerClassName");
      if (containerClassName && hasClass(container, containerClassName)) {
        var containerCss = domStyles[containerClassName];
        modifyCSS(container, containerCss);
      }
    };
    HtmlComponent2.prototype.applyChildrenStyles = function(element, styles) {
      each$1(styles, function(style, name) {
        var elements = element.getElementsByClassName(name);
        each$1(elements, function(el) {
          modifyCSS(el, style);
        });
      });
    };
    HtmlComponent2.prototype.applyStyle = function(cssName, dom) {
      var domStyles = this.get("domStyles");
      modifyCSS(dom, domStyles[cssName]);
    };
    HtmlComponent2.prototype.createDom = function() {
      var containerTpl = this.get("containerTpl");
      return createDom$1(containerTpl);
    };
    HtmlComponent2.prototype.initEvent = function() {
    };
    HtmlComponent2.prototype.removeDom = function() {
      var container = this.get("container");
      container && container.parentNode && container.parentNode.removeChild(container);
    };
    HtmlComponent2.prototype.removeEvent = function() {
    };
    HtmlComponent2.prototype.updateInner = function(cfg) {
      if (has(cfg, "domStyles")) {
        this.resetStyles();
        this.applyStyles();
      }
      this.resetPosition();
    };
    HtmlComponent2.prototype.resetPosition = function() {
    };
    return HtmlComponent2;
  }(Component)
);
var HtmlAnnotation = (
  /** @class */
  function(_super) {
    __extends$1(HtmlAnnotation2, _super);
    function HtmlAnnotation2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlAnnotation2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "annotation", type: "html", locationType: "point", x: 0, y: 0, containerTpl: '<div class="g2-html-annotation" style="position:absolute"></div>', alignX: "left", alignY: "top", html: "", zIndex: 7 });
    };
    HtmlAnnotation2.prototype.render = function() {
      var container = this.getContainer();
      var html = this.get("html");
      clearDom(container);
      var rst = isFunction(html) ? html(container) : html;
      if (isElement(rst)) {
        container.appendChild(rst);
      } else if (isString(rst) || isNumber$1(rst)) {
        var dom = createDom$1("" + rst);
        if (dom) {
          container.appendChild(dom);
        }
      }
      this.resetPosition();
    };
    HtmlAnnotation2.prototype.resetPosition = function() {
      var container = this.getContainer();
      var _a2 = this.getLocation(), x = _a2.x, y = _a2.y;
      var alignX = this.get("alignX");
      var alignY = this.get("alignY");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      var domWidth = getOuterWidth(container);
      var domHeight = getOuterHeight(container);
      var position = {
        x,
        y
      };
      if (alignX === "middle") {
        position.x -= Math.round(domWidth / 2);
      } else if (alignX === "right") {
        position.x -= Math.round(domWidth);
      }
      if (alignY === "middle") {
        position.y -= Math.round(domHeight / 2);
      } else if (alignY === "bottom") {
        position.y -= Math.round(domHeight);
      }
      if (offsetX) {
        position.x += offsetX;
      }
      if (offsetY) {
        position.y += offsetY;
      }
      modifyCSS(container, {
        position: "absolute",
        left: position.x + "px",
        top: position.y + "px",
        zIndex: this.get("zIndex")
      });
    };
    return HtmlAnnotation2;
  }(HtmlComponent)
);
const AnnotationComponent = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Arc: ArcAnnotation,
  DataMarker: DataMarkerAnnotation,
  DataRegion: DataRegionAnnotation,
  Html: HtmlAnnotation,
  Image: ImageAnnotation,
  Line: LineAnnotation,
  Region: RegionAnnotation,
  RegionFilter: RegionFilterAnnotation,
  Shape: ShapeAnnotation,
  Text: TextAnnotation
}, Symbol.toStringTag, { value: "Module" }));
function getStatesStyle(item, elementName, stateStyles) {
  var styleName = elementName + "Style";
  var styles = null;
  each$1(stateStyles, function(v, state2) {
    if (item[state2] && v[styleName]) {
      if (!styles) {
        styles = {};
      }
      mix(styles, v[styleName]);
    }
  });
  return styles;
}
var AxisBase = (
  /** @class */
  function(_super) {
    __extends$1(AxisBase2, _super);
    function AxisBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), {
        name: "axis",
        ticks: [],
        line: {},
        tickLine: {},
        subTickLine: null,
        title: null,
        /**
         * 
         */
        label: {},
        /**
         * titletickLine 
         */
        verticalFactor: 1,
        // 
        verticalLimitLength: null,
        overlapOrder: ["autoRotate", "autoEllipsis", "autoHide"],
        tickStates: {},
        optimize: {},
        defaultCfg: {
          line: {
            // @type {Attrs} ,null
            style: {
              lineWidth: 1,
              stroke: Theme.lineColor
            }
          },
          tickLine: {
            // @type {Attrs} 
            style: {
              lineWidth: 1,
              stroke: Theme.lineColor
            },
            alignTick: true,
            length: 5,
            displayWithLabel: true
          },
          subTickLine: {
            // @type {Attrs} 
            style: {
              lineWidth: 1,
              stroke: Theme.lineColor
            },
            count: 4,
            length: 2
          },
          label: {
            autoRotate: true,
            autoHide: false,
            autoEllipsis: false,
            style: {
              fontSize: 12,
              fill: Theme.textColor,
              fontFamily: Theme.fontFamily,
              fontWeight: "normal"
            },
            offset: 10,
            offsetX: 0,
            offsetY: 0
          },
          title: {
            autoRotate: true,
            spacing: 5,
            position: "center",
            style: {
              fontSize: 12,
              fill: Theme.textColor,
              textBaseline: "middle",
              fontFamily: Theme.fontFamily,
              textAlign: "center"
            },
            iconStyle: {
              fill: Theme.descriptionIconFill,
              stroke: Theme.descriptionIconStroke
            },
            description: ""
          },
          tickStates: {
            active: {
              labelStyle: {
                fontWeight: 500
              },
              tickLineStyle: {
                lineWidth: 2
              }
            },
            inactive: {
              labelStyle: {
                fill: Theme.uncheckedColor
              }
            }
          },
          // 
          optimize: {
            enable: true,
            threshold: 400
          }
        },
        theme: {}
      });
    };
    AxisBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.drawLine(group2);
      }
      this.drawTicks(group2);
      if (this.get("title")) {
        this.drawTitle(group2);
      }
    };
    AxisBase2.prototype.isList = function() {
      return true;
    };
    AxisBase2.prototype.getItems = function() {
      return this.get("ticks");
    };
    AxisBase2.prototype.setItems = function(items) {
      this.update({
        ticks: items
      });
    };
    AxisBase2.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    AxisBase2.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("label-group");
      itemGroup && itemGroup.clear();
    };
    AxisBase2.prototype.setItemState = function(item, state2, value2) {
      item[state2] = value2;
      this.updateTickStates(item);
    };
    AxisBase2.prototype.hasState = function(item, state2) {
      return !!item[state2];
    };
    AxisBase2.prototype.getItemStates = function(item) {
      var tickStates = this.get("tickStates");
      var rst = [];
      each$1(tickStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    AxisBase2.prototype.clearItemsState = function(state2) {
      var _this = this;
      var items = this.getItemsByState(state2);
      each$1(items, function(item) {
        _this.setItemState(item, state2, false);
      });
    };
    AxisBase2.prototype.getItemsByState = function(state2) {
      var _this = this;
      var items = this.getItems();
      return filter(items, function(item) {
        return _this.hasState(item, state2);
      });
    };
    AxisBase2.prototype.getSidePoint = function(point2, offset) {
      var self2 = this;
      var vector = self2.getSideVector(offset, point2);
      return {
        x: point2.x + vector[0],
        y: point2.y + vector[1]
      };
    };
    AxisBase2.prototype.getTextAnchor = function(vector) {
      var align;
      if (isNumberEqual$1(vector[0], 0)) {
        align = "center";
      } else if (vector[0] > 0) {
        align = "start";
      } else if (vector[0] < 0) {
        align = "end";
      }
      return align;
    };
    AxisBase2.prototype.getTextBaseline = function(vector) {
      var base;
      if (isNumberEqual$1(vector[1], 0)) {
        base = "middle";
      } else if (vector[1] > 0) {
        base = "top";
      } else if (vector[1] < 0) {
        base = "bottom";
      }
      return base;
    };
    AxisBase2.prototype.processOverlap = function(labelGroup) {
    };
    AxisBase2.prototype.drawLine = function(group2) {
      var path2 = this.getLinePath();
      var line2 = this.get("line");
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("line"),
        name: "axis-line",
        attrs: mix({
          path: path2
        }, line2.style)
      });
    };
    AxisBase2.prototype.getTickLineItems = function(ticks) {
      var _this = this;
      var tickLineItems = [];
      var tickLine = this.get("tickLine");
      var alignTick = tickLine.alignTick;
      var tickLineLength = tickLine.length;
      var tickSegment = 1;
      var tickCount = ticks.length;
      if (tickCount >= 2) {
        tickSegment = ticks[1].value - ticks[0].value;
      }
      each$1(ticks, function(tick) {
        var point2 = tick.point;
        if (!alignTick) {
          point2 = _this.getTickPoint(tick.value - tickSegment / 2);
        }
        var endPoint = _this.getSidePoint(point2, tickLineLength);
        tickLineItems.push({
          startPoint: point2,
          tickValue: tick.value,
          endPoint,
          tickId: tick.id,
          id: "tickline-" + tick.id
        });
      });
      return tickLineItems;
    };
    AxisBase2.prototype.getSubTickLineItems = function(tickLineItems) {
      var subTickLineItems = [];
      var subTickLine = this.get("subTickLine");
      var subCount = subTickLine.count;
      var tickLineCount = tickLineItems.length;
      if (tickLineCount >= 2) {
        for (var i = 0; i < tickLineCount - 1; i++) {
          var pre = tickLineItems[i];
          var next = tickLineItems[i + 1];
          for (var j = 0; j < subCount; j++) {
            var percent2 = (j + 1) / (subCount + 1);
            var tickValue = (1 - percent2) * pre.tickValue + percent2 * next.tickValue;
            var point2 = this.getTickPoint(tickValue);
            var endPoint = this.getSidePoint(point2, subTickLine.length);
            subTickLineItems.push({
              startPoint: point2,
              endPoint,
              tickValue,
              id: "sub-" + pre.id + "-" + j
            });
          }
        }
      }
      return subTickLineItems;
    };
    AxisBase2.prototype.getTickLineAttrs = function(tickItem, type, index2, tickItems) {
      var style = this.get(type).style;
      var item = {
        points: [tickItem.startPoint, tickItem.endPoint]
      };
      var defaultTickLineStyle = get(this.get("theme"), ["tickLine", "style"], {});
      style = isFunction(style) ? mix({}, defaultTickLineStyle, style(item, index2, tickItems)) : style;
      var startPoint = tickItem.startPoint, endPoint = tickItem.endPoint;
      return __assign$1({ x1: startPoint.x, y1: startPoint.y, x2: endPoint.x, y2: endPoint.y }, style);
    };
    AxisBase2.prototype.drawTick = function(tickItem, tickLineGroup, type, index2, tickItems) {
      this.addShape(tickLineGroup, {
        type: "line",
        id: this.getElementId(tickItem.id),
        name: "axis-" + type,
        attrs: this.getTickLineAttrs(tickItem, type, index2, tickItems)
      });
    };
    AxisBase2.prototype.drawTickLines = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var subTickLine = this.get("subTickLine");
      var tickLineItems = this.getTickLineItems(ticks);
      var tickLineGroup = this.addGroup(group2, {
        name: "axis-tickline-group",
        id: this.getElementId("tickline-group")
      });
      var tickCfg = this.get("tickLine");
      each$1(tickLineItems, function(item, index2) {
        if (tickCfg.displayWithLabel) {
          var labelId = _this.getElementId("label-" + item.tickId);
          if (group2.findById(labelId)) {
            _this.drawTick(item, tickLineGroup, "tickLine", index2, tickLineItems);
          }
        } else {
          _this.drawTick(item, tickLineGroup, "tickLine", index2, tickLineItems);
        }
      });
      if (subTickLine) {
        var subTickLineItems_1 = this.getSubTickLineItems(tickLineItems);
        each$1(subTickLineItems_1, function(item, index2) {
          _this.drawTick(item, tickLineGroup, "subTickLine", index2, subTickLineItems_1);
        });
      }
    };
    AxisBase2.prototype.processTicks = function() {
      var _this = this;
      var ticks = this.get("ticks");
      each$1(ticks, function(tick) {
        tick.point = _this.getTickPoint(tick.value);
        if (isNil(tick.id)) {
          tick.id = tick.name;
        }
      });
    };
    AxisBase2.prototype.drawTicks = function(group2) {
      var _this = this;
      this.optimizeTicks();
      this.processTicks();
      if (this.get("label")) {
        this.drawLabels(group2);
      }
      if (this.get("tickLine")) {
        this.drawTickLines(group2);
      }
      var ticks = this.get("ticks");
      each$1(ticks, function(tick) {
        _this.applyTickStates(tick, group2);
      });
    };
    AxisBase2.prototype.optimizeTicks = function() {
      var optimize = this.get("optimize");
      var ticks = this.get("ticks");
      if (optimize && optimize.enable && optimize.threshold > 0) {
        var len = size(ticks);
        if (len > optimize.threshold) {
          var page_1 = Math.ceil(len / optimize.threshold);
          var optimizedTicks = ticks.filter(function(tick, idx) {
            return idx % page_1 === 0;
          });
          this.set("ticks", optimizedTicks);
          this.set("originalTicks", ticks);
        }
      }
    };
    AxisBase2.prototype.getLabelAttrs = function(tick, index2, ticks) {
      var labelCfg = this.get("label");
      var offset = labelCfg.offset, offsetX = labelCfg.offsetX, offsetY = labelCfg.offsetY, rotate2 = labelCfg.rotate, formatter = labelCfg.formatter;
      var point2 = this.getSidePoint(tick.point, offset);
      var vector = this.getSideVector(offset, point2);
      var text2 = formatter ? formatter(tick.name, tick, index2) : tick.name;
      var style = labelCfg.style;
      style = isFunction(style) ? get(this.get("theme"), ["label", "style"], {}) : style;
      var attrs = mix({
        x: point2.x + offsetX,
        y: point2.y + offsetY,
        text: text2,
        textAlign: this.getTextAnchor(vector),
        textBaseline: this.getTextBaseline(vector)
      }, style);
      if (rotate2) {
        attrs.matrix = getMatrixByAngle(point2, rotate2);
      }
      return attrs;
    };
    AxisBase2.prototype.drawLabels = function(group2) {
      var _this = this;
      var ticks = this.get("ticks");
      var labelGroup = this.addGroup(group2, {
        name: "axis-label-group",
        id: this.getElementId("label-group")
      });
      each$1(ticks, function(tick, index2) {
        _this.addShape(labelGroup, {
          type: "text",
          name: "axis-label",
          id: _this.getElementId("label-" + tick.id),
          attrs: _this.getLabelAttrs(tick, index2, ticks),
          delegateObject: {
            tick,
            item: tick,
            index: index2
          }
        });
      });
      this.processOverlap(labelGroup);
      var labels = labelGroup.getChildren();
      var defaultLabelStyle = get(this.get("theme"), ["label", "style"], {});
      var _a2 = this.get("label"), style = _a2.style, formatter = _a2.formatter;
      if (isFunction(style)) {
        var afterProcessTicks_1 = labels.map(function(label2) {
          return get(label2.get("delegateObject"), "tick");
        });
        each$1(labels, function(label2, index2) {
          var tick = label2.get("delegateObject").tick;
          var text2 = formatter ? formatter(tick.name, tick, index2) : tick.name;
          var newStyle = mix({}, defaultLabelStyle, style(text2, index2, afterProcessTicks_1));
          label2.attr(newStyle);
        });
      }
    };
    AxisBase2.prototype.getTitleAttrs = function() {
      var titleCfg = this.get("title");
      var style = titleCfg.style, position = titleCfg.position, offset = titleCfg.offset, _a2 = titleCfg.spacing, spacing = _a2 === void 0 ? 0 : _a2, autoRotate2 = titleCfg.autoRotate;
      var titleHeight = style.fontSize;
      var percent2 = 0.5;
      if (position === "start") {
        percent2 = 0;
      } else if (position === "end") {
        percent2 = 1;
      }
      var point2 = this.getTickPoint(percent2);
      var titlePoint = this.getSidePoint(point2, offset || spacing + titleHeight / 2);
      var attrs = mix({
        x: titlePoint.x,
        y: titlePoint.y,
        text: titleCfg.text
      }, style);
      var rotate2 = titleCfg.rotate;
      var angle2 = rotate2;
      if (isNil(rotate2) && autoRotate2) {
        var vector = this.getAxisVector(point2);
        var v1 = [1, 0];
        angle2 = angleTo(vector, v1, true);
      }
      if (angle2) {
        var matrix = getMatrixByAngle(titlePoint, angle2);
        attrs.matrix = matrix;
      }
      return attrs;
    };
    AxisBase2.prototype.drawTitle = function(group2) {
      var _a2;
      var titleAttrs = this.getTitleAttrs();
      var titleShape = this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "axis-title",
        attrs: titleAttrs
      });
      if ((_a2 = this.get("title")) === null || _a2 === void 0 ? void 0 : _a2.description) {
        this.drawDescriptionIcon(group2, titleShape, titleAttrs.matrix);
      }
    };
    AxisBase2.prototype.drawDescriptionIcon = function(group2, titleShape, matrix) {
      var descriptionShape = this.addGroup(group2, {
        name: "axis-description",
        id: this.getElementById("description")
      });
      var _a2 = titleShape.getBBox(), maxX = _a2.maxX, maxY2 = _a2.maxY, height = _a2.height;
      var iconStyle = this.get("title").iconStyle;
      var spacing = 4;
      var r = height / 2;
      var lineWidth = r / 6;
      var startX = maxX + spacing;
      var startY = maxY2 - height / 2;
      var _b = [startX + r, startY - r], x0 = _b[0], y0 = _b[1];
      var _c = [x0 + r, y0 + r], x1 = _c[0], y1 = _c[1];
      var _d = [x0, y1 + r], x2 = _d[0], y2 = _d[1];
      var _e = [startX, y0 + r], x3 = _e[0], y3 = _e[1];
      var _f = [startX + r, startY - height / 4], x4 = _f[0], y4 = _f[1];
      var _g = [x4, y4 + lineWidth], x5 = _g[0], y5 = _g[1];
      var _h = [x5, y5 + lineWidth], x6 = _h[0], y6 = _h[1];
      var _j = [x6, y6 + r * 3 / 4], x7 = _j[0], y7 = _j[1];
      this.addShape(descriptionShape, {
        type: "path",
        id: this.getElementId("title-description-icon"),
        name: "axis-title-description-icon",
        attrs: __assign$1({
          path: [
            ["M", x0, y0],
            ["A", r, r, 0, 0, 1, x1, y1],
            ["A", r, r, 0, 0, 1, x2, y2],
            ["A", r, r, 0, 0, 1, x3, y3],
            ["A", r, r, 0, 0, 1, x0, y0],
            ["M", x4, y4],
            ["L", x5, y5],
            ["M", x6, y6],
            ["L", x7, y7]
          ],
          lineWidth,
          matrix
        }, iconStyle)
      });
      this.addShape(descriptionShape, {
        type: "rect",
        id: this.getElementId("title-description-rect"),
        name: "axis-title-description-rect",
        attrs: {
          x: startX,
          y: startY - height / 2,
          width: height,
          height,
          stroke: "#000",
          fill: "#000",
          opacity: 0,
          matrix,
          cursor: "pointer"
        }
      });
    };
    AxisBase2.prototype.applyTickStates = function(tick, group2) {
      var states = this.getItemStates(tick);
      if (states.length) {
        var tickStates = this.get("tickStates");
        var labelId = this.getElementId("label-" + tick.id);
        var labelShape = group2.findById(labelId);
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        var tickLineId = this.getElementId("tickline-" + tick.id);
        var tickLineShape = group2.findById(tickLineId);
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      }
    };
    AxisBase2.prototype.updateTickStates = function(tick) {
      var states = this.getItemStates(tick);
      var tickStates = this.get("tickStates");
      var labelCfg = this.get("label");
      var labelShape = this.getElementByLocalId("label-" + tick.id);
      var tickLineCfg = this.get("tickLine");
      var tickLineShape = this.getElementByLocalId("tickline-" + tick.id);
      if (states.length) {
        if (labelShape) {
          var labelStateStyle = getStatesStyle(tick, "label", tickStates);
          labelStateStyle && labelShape.attr(labelStateStyle);
        }
        if (tickLineShape) {
          var tickLineStateStyle = getStatesStyle(tick, "tickLine", tickStates);
          tickLineStateStyle && tickLineShape.attr(tickLineStateStyle);
        }
      } else {
        if (labelShape) {
          labelShape.attr(labelCfg.style);
        }
        if (tickLineShape) {
          tickLineShape.attr(tickLineCfg.style);
        }
      }
    };
    return AxisBase2;
  }(GroupComponent)
);
function ellipseLabels(isVertical2, labelGroup, limitLength, position) {
  var children = labelGroup.getChildren();
  var ellipsisFlag = false;
  each$1(children, function(label2) {
    var rst = ellipsisLabel(isVertical2, label2, limitLength, position);
    ellipsisFlag = ellipsisFlag || rst;
  });
  return ellipsisFlag;
}
function getDefault$2() {
  return ellipsisTail;
}
function ellipsisHead(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "head");
}
function ellipsisTail(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "tail");
}
function ellipsisMiddle(isVertical2, labelGroup, limitLength) {
  return ellipseLabels(isVertical2, labelGroup, limitLength, "middle");
}
const autoEllipsis = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  ellipsisHead,
  ellipsisMiddle,
  ellipsisTail,
  getDefault: getDefault$2
}, Symbol.toStringTag, { value: "Module" }));
function isRotate(label2) {
  var matrix = label2.attr("matrix");
  return matrix && matrix[0] !== 1;
}
function getRotateAngle(label2) {
  var angle2 = isRotate(label2) ? getAngleByMatrix(label2.attr("matrix")) : 0;
  return angle2 % 360;
}
function isOverlap(isVertical2, first, second, minGap) {
  var overlap2 = false;
  var angle2 = getRotateAngle(first);
  var distance2 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var prevBBox = (isVertical2 ? second.attr("y") > first.attr("y") : second.attr("x") > first.attr("x")) ? first.getBBox() : second.getBBox();
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance2;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance2;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      overlap2 = prevBBox.width + minGap > distance2;
    } else {
      overlap2 = prevBBox.height / ratio + minGap > distance2;
    }
  }
  return overlap2;
}
function reserveOne(isVertical2, labelsGroup, reversed, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice().filter(function(item) {
    return item.get("visible");
  });
  if (!labels.length) {
    return false;
  }
  var hasHide = false;
  if (reversed) {
    labels.reverse();
  }
  var count2 = labels.length;
  var first = labels[0];
  var prev = first;
  for (var i = 1; i < count2; i++) {
    var label2 = labels[i];
    label2.getBBox();
    var isHide = isOverlap(isVertical2, prev, label2, minGap);
    if (isHide) {
      label2.hide();
      hasHide = true;
    } else {
      prev = label2;
    }
  }
  return hasHide;
}
function parityHide(isVertical2, labelsGroup, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length < 2) {
    return false;
  }
  var hasHide = false;
  var first = labels[0];
  var firstBBox = first.getBBox();
  var second = labels[1];
  var count2 = labels.length;
  var angle2 = getRotateAngle(first);
  var distance2 = isVertical2 ? Math.abs(second.attr("y") - first.attr("y")) : Math.abs(second.attr("x") - first.attr("x"));
  var interval2 = 0;
  if (isVertical2) {
    var ratio = Math.abs(Math.cos(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance2;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance2;
    }
  } else {
    var ratio = Math.abs(Math.sin(angle2));
    if (near(ratio, 0, Math.PI / 180)) {
      var maxWidth = getMaxLabelWidth(labels);
      interval2 = (maxWidth + minGap) / distance2;
    } else {
      interval2 = (firstBBox.height / ratio + minGap) / distance2;
    }
  }
  if (interval2 > 1) {
    interval2 = Math.ceil(interval2);
    for (var i = 0; i < count2; i++) {
      if (i % interval2 !== 0) {
        labels[i].hide();
        hasHide = true;
      }
    }
  }
  return hasHide;
}
function getDefault$1() {
  return equidistance;
}
function reserveFirst(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, false, autoHideCfg);
}
function reserveLast(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  return reserveOne(isVertical2, labelsGroup, true, autoHideCfg);
}
function reserveBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var minGap = (autoHideCfg === null || autoHideCfg === void 0 ? void 0 : autoHideCfg.minGap) || 0;
  var labels = labelsGroup.getChildren().slice();
  if (labels.length <= 2) {
    return false;
  }
  var hasHide = false;
  var count2 = labels.length;
  var first = labels[0];
  var last2 = labels[count2 - 1];
  var preLabel = first;
  for (var i = 1; i < count2 - 1; i++) {
    var label2 = labels[i];
    label2.getBBox();
    var isHide = isOverlap(isVertical2, preLabel, label2, minGap);
    if (isHide) {
      label2.hide();
      hasHide = true;
    } else {
      preLabel = label2;
    }
  }
  var overlap2 = isOverlap(isVertical2, preLabel, last2, minGap);
  if (overlap2) {
    preLabel.hide();
    hasHide = true;
  }
  return hasHide;
}
function equidistance(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (reserveOne(isVertical2, labelsGroup, false)) {
    hasHide = true;
  }
  return hasHide;
}
function equidistanceWithReverseBoth(isVertical2, labelsGroup, limitLength, autoHideCfg) {
  var labels = labelsGroup.getChildren().slice();
  var hasHide = parityHide(isVertical2, labelsGroup, autoHideCfg);
  if (labels.length > 2) {
    var first = labels[0];
    var last2 = labels[labels.length - 1];
    if (!first.get("visible")) {
      first.show();
      if (reserveOne(isVertical2, labelsGroup, false, autoHideCfg)) {
        hasHide = true;
      }
    }
    if (!last2.get("visible")) {
      last2.show();
      if (reserveOne(isVertical2, labelsGroup, true, autoHideCfg)) {
        hasHide = true;
      }
    }
  }
  return hasHide;
}
const autoHide = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  equidistance,
  equidistanceWithReverseBoth,
  getDefault: getDefault$1,
  reserveBoth,
  reserveFirst,
  reserveLast
}, Symbol.toStringTag, { value: "Module" }));
function setLabelsAngle(labels, angle2) {
  each$1(labels, function(label2) {
    var x = label2.attr("x");
    var y = label2.attr("y");
    var matrix = getMatrixByAngle({ x, y }, angle2);
    label2.attr("matrix", matrix);
  });
}
function labelRotate(isVertical2, labelsGroup, limitLength, getAngle2) {
  var labels = labelsGroup.getChildren();
  if (!labels.length) {
    return false;
  }
  if (!isVertical2 && labels.length < 2) {
    return false;
  }
  var maxWidth = getMaxLabelWidth(labels);
  var isOverlap2 = false;
  if (isVertical2) {
    isOverlap2 = !!limitLength && maxWidth > limitLength;
  } else {
    var tickWidth = Math.abs(labels[1].attr("x") - labels[0].attr("x"));
    isOverlap2 = maxWidth > tickWidth;
  }
  if (isOverlap2) {
    var angle2 = getAngle2(limitLength, maxWidth);
    setLabelsAngle(labels, angle2);
  }
  return isOverlap2;
}
function getDefault() {
  return fixedAngle;
}
function fixedAngle(isVertical2, labelsGroup, limitLength, customRotate) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function() {
    if (isNumber$1(customRotate)) {
      return customRotate;
    }
    return isVertical2 ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;
  });
}
function unfixedAngle(isVertical2, labelsGroup, limitLength) {
  return labelRotate(isVertical2, labelsGroup, limitLength, function(length2, maxWidth) {
    if (!length2) {
      return isVertical2 ? Theme.verticalAxisRotate : Theme.horizontalAxisRotate;
    }
    if (isVertical2) {
      return -Math.acos(length2 / maxWidth);
    } else {
      var angle2 = 0;
      if (length2 > maxWidth) {
        angle2 = Math.PI / 4;
      } else {
        angle2 = Math.asin(length2 / maxWidth);
        if (angle2 > Math.PI / 4) {
          angle2 = Math.PI / 4;
        }
      }
      return angle2;
    }
  });
}
const autoRotate = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  fixedAngle,
  getDefault,
  unfixedAngle
}, Symbol.toStringTag, { value: "Module" }));
const OverlapUtil = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  autoEllipsis,
  autoHide,
  autoRotate
}, Symbol.toStringTag, { value: "Module" }));
var Line$5 = (
  /** @class */
  function(_super) {
    __extends$1(Line2, _super);
    function Line2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), {
        type: "line",
        locationType: "region",
        /**
         * , x, y
         * @type {object}
         */
        start: null,
        /**
         * , x, y
         * @type {object}
         */
        end: null
      });
    };
    Line2.prototype.getLinePath = function() {
      var start = this.get("start");
      var end = this.get("end");
      var path2 = [];
      path2.push(["M", start.x, start.y]);
      path2.push(["L", end.x, end.y]);
      return path2;
    };
    Line2.prototype.getInnerLayoutBBox = function() {
      var start = this.get("start");
      var end = this.get("end");
      var bbox = _super.prototype.getInnerLayoutBBox.call(this);
      var minX = Math.min(start.x, end.x, bbox.x);
      var minY = Math.min(start.y, end.y, bbox.y);
      var maxX = Math.max(start.x, end.x, bbox.maxX);
      var maxY2 = Math.max(start.y, end.y, bbox.maxY);
      return {
        x: minX,
        y: minY,
        minX,
        minY,
        maxX,
        maxY: maxY2,
        width: maxX - minX,
        height: maxY2 - minY
      };
    };
    Line2.prototype.isVertical = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual$1(start.x, end.x);
    };
    Line2.prototype.isHorizontal = function() {
      var start = this.get("start");
      var end = this.get("end");
      return isNumberEqual$1(start.y, end.y);
    };
    Line2.prototype.getTickPoint = function(tickValue) {
      var self2 = this;
      var start = self2.get("start");
      var end = self2.get("end");
      var regionX = end.x - start.x;
      var regionY = end.y - start.y;
      return {
        x: start.x + regionX * tickValue,
        y: start.y + regionY * tickValue
      };
    };
    Line2.prototype.getSideVector = function(offset) {
      var axisVector = this.getAxisVector();
      var normal = normalize([0, 0], axisVector);
      var factor = this.get("verticalFactor");
      var verticalVector = [normal[1], normal[0] * -1];
      return scale$3([0, 0], verticalVector, offset * factor);
    };
    Line2.prototype.getAxisVector = function() {
      var start = this.get("start");
      var end = this.get("end");
      return [end.x - start.x, end.y - start.y];
    };
    Line2.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var isHorizontal2 = this.isHorizontal();
      if (!isVertical2 && !isHorizontal2) {
        return;
      }
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each$1(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (isNil(titleCfg.offset)) {
          var bbox = labelGroup.getCanvasBBox();
          var length_1 = isVertical2 ? bbox.width : bbox.height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Line2.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return isNil(labelCfg.rotate);
      }
      return true;
    };
    Line2.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
      var _this = this;
      var isVertical2 = this.isVertical();
      var hasAdjusted = false;
      var util = OverlapUtil[name];
      if (value2 === true) {
        this.get("label");
        hasAdjusted = util.getDefault()(isVertical2, labelGroup, limitLength);
      } else if (isFunction(value2)) {
        hasAdjusted = value2(isVertical2, labelGroup, limitLength);
      } else if (isObject(value2)) {
        var overlapCfg = value2;
        if (util[overlapCfg.type]) {
          hasAdjusted = util[overlapCfg.type](isVertical2, labelGroup, limitLength, overlapCfg.cfg);
        }
      } else if (util[value2]) {
        hasAdjusted = util[value2](isVertical2, labelGroup, limitLength);
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each$1(labels, function(label2) {
            var textAlign = label2.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label2.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each$1(children, function(label2) {
          if (!label2.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label2);
            }
            label2.remove();
          }
        });
      }
    };
    return Line2;
  }(AxisBase)
);
var Circle$4 = (
  /** @class */
  function(_super) {
    __extends$1(Circle2, _super);
    function Circle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { type: "circle", locationType: "circle", center: null, radius: null, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    Circle2.prototype.getLinePath = function() {
      var center2 = this.get("center");
      var x = center2.x;
      var y = center2.y;
      var rx = this.get("radius");
      var ry = rx;
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var path2 = [];
      if (Math.abs(endAngle - startAngle) === Math.PI * 2) {
        path2 = [["M", x, y - ry], ["A", rx, ry, 0, 1, 1, x, y + ry], ["A", rx, ry, 0, 1, 1, x, y - ry], ["Z"]];
      } else {
        var startPoint = this.getCirclePoint(startAngle);
        var endPoint = this.getCirclePoint(endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path2 = [
          ["M", x, y],
          ["L", startPoint.x, startPoint.y],
          ["A", rx, ry, 0, large, sweep, endPoint.x, endPoint.y],
          ["L", x, y]
        ];
      }
      return path2;
    };
    Circle2.prototype.getTickPoint = function(tickValue) {
      var startAngle = this.get("startAngle");
      var endAngle = this.get("endAngle");
      var angle2 = startAngle + (endAngle - startAngle) * tickValue;
      return this.getCirclePoint(angle2);
    };
    Circle2.prototype.getSideVector = function(offset, point2) {
      var center2 = this.get("center");
      var vector = [point2.x - center2.x, point2.y - center2.y];
      var factor = this.get("verticalFactor");
      var vecLen = length(vector);
      scale$3(vector, vector, factor * offset / vecLen);
      return vector;
    };
    Circle2.prototype.getAxisVector = function(point2) {
      var center2 = this.get("center");
      var vector = [point2.x - center2.x, point2.y - center2.y];
      return [vector[1], -1 * vector[0]];
    };
    Circle2.prototype.getCirclePoint = function(angle2, radius) {
      var center2 = this.get("center");
      radius = radius || this.get("radius");
      return {
        x: center2.x + Math.cos(angle2) * radius,
        y: center2.y + Math.sin(angle2) * radius
      };
    };
    Circle2.prototype.canProcessOverlap = function(name) {
      var labelCfg = this.get("label");
      if (name === "autoRotate") {
        return isNil(labelCfg.rotate);
      }
      return true;
    };
    Circle2.prototype.processOverlap = function(labelGroup) {
      var _this = this;
      var labelCfg = this.get("label");
      var titleCfg = this.get("title");
      var verticalLimitLength = this.get("verticalLimitLength");
      var labelOffset = labelCfg.offset;
      var limitLength = verticalLimitLength;
      var titleHeight = 0;
      var titleSpacing = 0;
      if (titleCfg) {
        titleHeight = titleCfg.style.fontSize;
        titleSpacing = titleCfg.spacing;
      }
      if (limitLength) {
        limitLength = limitLength - labelOffset - titleSpacing - titleHeight;
      }
      var overlapOrder = this.get("overlapOrder");
      each$1(overlapOrder, function(name) {
        if (labelCfg[name] && _this.canProcessOverlap(name)) {
          _this.autoProcessOverlap(name, labelCfg[name], labelGroup, limitLength);
        }
      });
      if (titleCfg) {
        if (isNil(titleCfg.offset)) {
          var length_1 = labelGroup.getCanvasBBox().height;
          titleCfg.offset = labelOffset + length_1 + titleSpacing + titleHeight / 2;
        }
      }
    };
    Circle2.prototype.autoProcessOverlap = function(name, value2, labelGroup, limitLength) {
      var _this = this;
      var hasAdjusted = false;
      var util = OverlapUtil[name];
      if (limitLength > 0) {
        if (value2 === true) {
          hasAdjusted = util.getDefault()(false, labelGroup, limitLength);
        } else if (isFunction(value2)) {
          hasAdjusted = value2(false, labelGroup, limitLength);
        } else if (isObject(value2)) {
          var overlapCfg = value2;
          if (util[overlapCfg.type]) {
            hasAdjusted = util[overlapCfg.type](false, labelGroup, limitLength, overlapCfg.cfg);
          }
        } else if (util[value2]) {
          hasAdjusted = util[value2](false, labelGroup, limitLength);
        }
      }
      if (name === "autoRotate") {
        if (hasAdjusted) {
          var labels = labelGroup.getChildren();
          var verticalFactor_1 = this.get("verticalFactor");
          each$1(labels, function(label2) {
            var textAlign = label2.attr("textAlign");
            if (textAlign === "center") {
              var newAlign = verticalFactor_1 > 0 ? "end" : "start";
              label2.attr("textAlign", newAlign);
            }
          });
        }
      } else if (name === "autoHide") {
        var children = labelGroup.getChildren().slice(0);
        each$1(children, function(label2) {
          if (!label2.get("visible")) {
            if (_this.get("isRegister")) {
              _this.unregisterElement(label2);
            }
            label2.remove();
          }
        });
      }
    };
    return Circle2;
  }(AxisBase)
);
var CrosshairBase = (
  /** @class */
  function(_super) {
    __extends$1(CrosshairBase2, _super);
    function CrosshairBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CrosshairBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "crosshair", type: "base", line: {}, text: null, textBackground: {}, capture: false, defaultCfg: {
        line: {
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          }
        },
        text: {
          position: "start",
          offset: 10,
          autoRotate: false,
          content: null,
          style: {
            fill: Theme.textColor,
            textAlign: "center",
            textBaseline: "middle",
            fontFamily: Theme.fontFamily
          }
        },
        textBackground: {
          padding: 5,
          style: {
            stroke: Theme.lineColor
          }
        }
      } });
    };
    CrosshairBase2.prototype.renderInner = function(group2) {
      if (this.get("line")) {
        this.renderLine(group2);
      }
      if (this.get("text")) {
        this.renderText(group2);
        this.renderBackground(group2);
      }
    };
    CrosshairBase2.prototype.renderText = function(group2) {
      var text2 = this.get("text");
      var style = text2.style, autoRotate2 = text2.autoRotate, content = text2.content;
      if (!isNil(content)) {
        var textPoint = this.getTextPoint();
        var matrix = null;
        if (autoRotate2) {
          var angle2 = this.getRotateAngle();
          matrix = getMatrixByAngle(textPoint, angle2);
        }
        this.addShape(group2, {
          type: "text",
          name: "crosshair-text",
          id: this.getElementId("text"),
          attrs: __assign$1(__assign$1(__assign$1({}, textPoint), { text: content, matrix }), style)
        });
      }
    };
    CrosshairBase2.prototype.renderLine = function(group2) {
      var path2 = this.getLinePath();
      var line2 = this.get("line");
      var style = line2.style;
      this.addShape(group2, {
        type: "path",
        name: "crosshair-line",
        id: this.getElementId("line"),
        attrs: __assign$1({ path: path2 }, style)
      });
    };
    CrosshairBase2.prototype.renderBackground = function(group2) {
      var textId = this.getElementId("text");
      var textShape = group2.findById(textId);
      var textBackground = this.get("textBackground");
      if (textBackground && textShape) {
        var textBBox = textShape.getBBox();
        var padding2 = formatPadding(textBackground.padding);
        var style = textBackground.style;
        var backgroundShape = this.addShape(group2, {
          type: "rect",
          name: "crosshair-text-background",
          id: this.getElementId("text-background"),
          attrs: __assign$1({ x: textBBox.x - padding2[3], y: textBBox.y - padding2[0], width: textBBox.width + padding2[1] + padding2[3], height: textBBox.height + padding2[0] + padding2[2], matrix: textShape.attr("matrix") }, style)
        });
        backgroundShape.toBack();
      }
    };
    return CrosshairBase2;
  }(GroupComponent)
);
var LineCrosshair$1 = (
  /** @class */
  function(_super) {
    __extends$1(LineCrosshair2, _super);
    function LineCrosshair2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { type: "line", locationType: "region", start: null, end: null });
    };
    LineCrosshair2.prototype.getRotateAngle = function() {
      var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
      var position = this.get("text").position;
      var angle2 = Math.atan2(end.y - start.y, end.x - start.x);
      var tangentAngle = position === "start" ? angle2 - Math.PI / 2 : angle2 + Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair2.prototype.getTextPoint = function() {
      var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    LineCrosshair2.prototype.getLinePath = function() {
      var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
      return [
        ["M", start.x, start.y],
        ["L", end.x, end.y]
      ];
    };
    return LineCrosshair2;
  }(CrosshairBase)
);
var LineCrosshair = (
  /** @class */
  function(_super) {
    __extends$1(LineCrosshair2, _super);
    function LineCrosshair2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LineCrosshair2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { type: "circle", locationType: "circle", center: null, radius: 100, startAngle: -Math.PI / 2, endAngle: Math.PI * 3 / 2 });
    };
    LineCrosshair2.prototype.getRotateAngle = function() {
      var _a2 = this.getLocation(), startAngle = _a2.startAngle, endAngle = _a2.endAngle;
      var position = this.get("text").position;
      var tangentAngle = position === "start" ? startAngle + Math.PI / 2 : endAngle - Math.PI / 2;
      return tangentAngle;
    };
    LineCrosshair2.prototype.getTextPoint = function() {
      var text2 = this.get("text");
      var position = text2.position, offset = text2.offset;
      var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
      var angle2 = position === "start" ? startAngle : endAngle;
      var tangentAngle = this.getRotateAngle() - Math.PI;
      var point2 = getCirclePoint(center2, radius, angle2);
      var offsetX = Math.cos(tangentAngle) * offset;
      var offsetY = Math.sin(tangentAngle) * offset;
      return {
        x: point2.x + offsetX,
        y: point2.y + offsetY
      };
    };
    LineCrosshair2.prototype.getLinePath = function() {
      var _a2 = this.getLocation(), center2 = _a2.center, radius = _a2.radius, startAngle = _a2.startAngle, endAngle = _a2.endAngle;
      var path2 = null;
      if (endAngle - startAngle === Math.PI * 2) {
        var x = center2.x, y = center2.y;
        path2 = [
          ["M", x, y - radius],
          ["A", radius, radius, 0, 1, 1, x, y + radius],
          ["A", radius, radius, 0, 1, 1, x, y - radius],
          ["Z"]
        ];
      } else {
        var startPoint = getCirclePoint(center2, radius, startAngle);
        var endPoint = getCirclePoint(center2, radius, endAngle);
        var large = Math.abs(endAngle - startAngle) > Math.PI ? 1 : 0;
        var sweep = startAngle > endAngle ? 0 : 1;
        path2 = [
          ["M", startPoint.x, startPoint.y],
          ["A", radius, radius, 0, large, sweep, endPoint.x, endPoint.y]
        ];
      }
      return path2;
    };
    return LineCrosshair2;
  }(CrosshairBase)
);
var CONTAINER_CLASS$1 = "g2-crosshair";
var CROSSHAIR_LINE = CONTAINER_CLASS$1 + "-line";
var CROSSHAIR_TEXT = CONTAINER_CLASS$1 + "-text";
var _a$4;
const HtmlTheme = (_a$4 = {}, // css style for tooltip
_a$4["" + CONTAINER_CLASS$1] = {
  position: "relative"
}, _a$4["" + CROSSHAIR_LINE] = {
  position: "absolute",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$4["" + CROSSHAIR_TEXT] = {
  position: "absolute",
  color: Theme.textColor,
  fontFamily: Theme.fontFamily
}, _a$4);
var HtmlCrosshair = (
  /** @class */
  function(_super) {
    __extends$1(HtmlCrosshair2, _super);
    function HtmlCrosshair2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HtmlCrosshair2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "crosshair", type: "html", locationType: "region", start: { x: 0, y: 0 }, end: { x: 0, y: 0 }, capture: false, text: null, containerTpl: '<div class="' + CONTAINER_CLASS$1 + '"></div>', crosshairTpl: '<div class="' + CROSSHAIR_LINE + '"></div>', textTpl: '<span class="' + CROSSHAIR_TEXT + '">{content}</span>', domStyles: null, containerClassName: CONTAINER_CLASS$1, defaultStyles: HtmlTheme, defaultCfg: {
        text: {
          position: "start",
          content: null,
          align: "center",
          offset: 10
        }
      } });
    };
    HtmlCrosshair2.prototype.render = function() {
      this.resetText();
      this.resetPosition();
    };
    HtmlCrosshair2.prototype.initCrossHair = function() {
      var container = this.getContainer();
      var crosshairTpl = this.get("crosshairTpl");
      var crosshairEl = createDom$1(crosshairTpl);
      container.appendChild(crosshairEl);
      this.applyStyle(CROSSHAIR_LINE, crosshairEl);
      this.set("crosshairEl", crosshairEl);
    };
    HtmlCrosshair2.prototype.getTextPoint = function() {
      var _a2 = this.getLocation(), start = _a2.start, end = _a2.end;
      var _b = this.get("text"), position = _b.position, offset = _b.offset;
      return getTextPoint(start, end, position, offset);
    };
    HtmlCrosshair2.prototype.resetText = function() {
      var text2 = this.get("text");
      var textEl = this.get("textEl");
      if (text2) {
        var content = text2.content;
        if (!textEl) {
          var container = this.getContainer();
          var textTpl = substitute(this.get("textTpl"), text2);
          textEl = createDom$1(textTpl);
          container.appendChild(textEl);
          this.applyStyle(CROSSHAIR_TEXT, textEl);
          this.set("textEl", textEl);
        }
        textEl.innerHTML = content;
      } else if (textEl) {
        textEl.remove();
      }
    };
    HtmlCrosshair2.prototype.isVertical = function(start, end) {
      return start.x === end.x;
    };
    HtmlCrosshair2.prototype.resetPosition = function() {
      var crosshairEl = this.get("crosshairEl");
      if (!crosshairEl) {
        this.initCrossHair();
        crosshairEl = this.get("crosshairEl");
      }
      var start = this.get("start");
      var end = this.get("end");
      var minX = Math.min(start.x, end.x);
      var minY = Math.min(start.y, end.y);
      if (this.isVertical(start, end)) {
        modifyCSS(crosshairEl, {
          width: "1px",
          height: toPx(Math.abs(end.y - start.y))
        });
      } else {
        modifyCSS(crosshairEl, {
          height: "1px",
          width: toPx(Math.abs(end.x - start.x))
        });
      }
      modifyCSS(crosshairEl, {
        top: toPx(minY),
        left: toPx(minX)
      });
      this.alignText();
    };
    HtmlCrosshair2.prototype.alignText = function() {
      var textEl = this.get("textEl");
      if (textEl) {
        var align = this.get("text").align;
        var clientWidth = textEl.clientWidth;
        var point2 = this.getTextPoint();
        switch (align) {
          case "center":
            point2.x = point2.x - clientWidth / 2;
            break;
          case "right":
            point2.x = point2.x - clientWidth;
        }
        modifyCSS(textEl, {
          top: toPx(point2.y),
          left: toPx(point2.x)
        });
      }
    };
    HtmlCrosshair2.prototype.updateInner = function(cfg) {
      if (has(cfg, "text")) {
        this.resetText();
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    return HtmlCrosshair2;
  }(HtmlComponent)
);
const Crosshair = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  Base: CrosshairBase,
  Circle: LineCrosshair,
  Html: HtmlCrosshair,
  Line: LineCrosshair$1
}, Symbol.toStringTag, { value: "Module" }));
var GridBase = (
  /** @class */
  function(_super) {
    __extends$1(GridBase2, _super);
    function GridBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    GridBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "grid", line: {}, alternateColor: null, capture: false, items: [], closed: false, defaultCfg: {
        line: {
          type: "line",
          style: {
            lineWidth: 1,
            stroke: Theme.lineColor
          }
        }
      } });
    };
    GridBase2.prototype.getLineType = function() {
      var line2 = this.get("line") || this.get("defaultCfg").line;
      return line2.type;
    };
    GridBase2.prototype.renderInner = function(group2) {
      this.drawGrid(group2);
    };
    GridBase2.prototype.getAlternatePath = function(prePoints, points2) {
      var regionPath = this.getGridPath(prePoints);
      var reversePoints = points2.slice(0).reverse();
      var nextPath = this.getGridPath(reversePoints, true);
      var closed = this.get("closed");
      if (closed) {
        regionPath = regionPath.concat(nextPath);
      } else {
        nextPath[0][0] = "L";
        regionPath = regionPath.concat(nextPath);
        regionPath.push(["Z"]);
      }
      return regionPath;
    };
    GridBase2.prototype.getPathStyle = function() {
      return this.get("line").style;
    };
    GridBase2.prototype.drawGrid = function(group2) {
      var _this = this;
      var line2 = this.get("line");
      var items = this.get("items");
      var alternateColor = this.get("alternateColor");
      var preItem = null;
      each$1(items, function(item, index2) {
        var id2 = item.id || index2;
        if (line2) {
          var style = _this.getPathStyle();
          style = isFunction(style) ? style(item, index2, items) : style;
          var lineId = _this.getElementId("line-" + id2);
          var gridPath = _this.getGridPath(item.points);
          _this.addShape(group2, {
            type: "path",
            name: "grid-line",
            id: lineId,
            attrs: mix({
              path: gridPath
            }, style)
          });
        }
        if (alternateColor && index2 > 0) {
          var regionId = _this.getElementId("region-" + id2);
          var isEven = index2 % 2 === 0;
          if (isString(alternateColor)) {
            if (isEven) {
              _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, alternateColor);
            }
          } else {
            var color2 = isEven ? alternateColor[1] : alternateColor[0];
            _this.drawAlternateRegion(regionId, group2, preItem.points, item.points, color2);
          }
        }
        preItem = item;
      });
    };
    GridBase2.prototype.drawAlternateRegion = function(id2, group2, prePoints, points2, color2) {
      var regionPath = this.getAlternatePath(prePoints, points2);
      this.addShape(group2, {
        type: "path",
        id: id2,
        name: "grid-region",
        attrs: {
          path: regionPath,
          fill: color2
        }
      });
    };
    return GridBase2;
  }(GroupComponent)
);
function distance$3(x1, y1, x2, y2) {
  var dx = x2 - x1;
  var dy = y2 - y1;
  return Math.sqrt(dx * dx + dy * dy);
}
var Circle$3 = (
  /** @class */
  function(_super) {
    __extends$1(Circle2, _super);
    function Circle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), {
        type: "circle",
        /**
         * 
         * @type {object}
         */
        center: null,
        /**
         * 
         * @type {true}
         */
        closed: true
      });
    };
    Circle2.prototype.getGridPath = function(points2, reversed) {
      var lineType = this.getLineType();
      var closed = this.get("closed");
      var path2 = [];
      if (points2.length) {
        if (lineType === "circle") {
          var center2 = this.get("center");
          var firstPoint = points2[0];
          var radius_1 = distance$3(center2.x, center2.y, firstPoint.x, firstPoint.y);
          var sweepFlag_1 = reversed ? 0 : 1;
          if (closed) {
            path2.push(["M", center2.x, center2.y - radius_1]);
            path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y + radius_1]);
            path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, center2.x, center2.y - radius_1]);
            path2.push(["Z"]);
          } else {
            each$1(points2, function(point2, index2) {
              if (index2 === 0) {
                path2.push(["M", point2.x, point2.y]);
              } else {
                path2.push(["A", radius_1, radius_1, 0, 0, sweepFlag_1, point2.x, point2.y]);
              }
            });
          }
        } else {
          each$1(points2, function(point2, index2) {
            if (index2 === 0) {
              path2.push(["M", point2.x, point2.y]);
            } else {
              path2.push(["L", point2.x, point2.y]);
            }
          });
          if (closed) {
            path2.push(["Z"]);
          }
        }
      }
      return path2;
    };
    return Circle2;
  }(GridBase)
);
var Line$4 = (
  /** @class */
  function(_super) {
    __extends$1(Line2, _super);
    function Line2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { type: "line" });
    };
    Line2.prototype.getGridPath = function(points2) {
      var path2 = [];
      each$1(points2, function(point2, index2) {
        if (index2 === 0) {
          path2.push(["M", point2.x, point2.y]);
        } else {
          path2.push(["L", point2.x, point2.y]);
        }
      });
      return path2;
    };
    return Line2;
  }(GridBase)
);
var LegendBase = (
  /** @class */
  function(_super) {
    __extends$1(LegendBase2, _super);
    function LegendBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    LegendBase2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), {
        name: "legend",
        /**
         *  horizontalvertical
         * @type {String}
         */
        layout: "horizontal",
        locationType: "point",
        x: 0,
        y: 0,
        offsetX: 0,
        offsetY: 0,
        title: null,
        background: null
      });
    };
    LegendBase2.prototype.getLayoutBBox = function() {
      var bbox = _super.prototype.getLayoutBBox.call(this);
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var width = bbox.width, height = bbox.height;
      if (maxWidth) {
        width = Math.min(width, maxWidth);
      }
      if (maxHeight) {
        height = Math.min(height, maxHeight);
      }
      return createBBox(bbox.minX, bbox.minY, width, height);
    };
    LegendBase2.prototype.setLocation = function(cfg) {
      this.set("x", cfg.x);
      this.set("y", cfg.y);
      this.resetLocation();
    };
    LegendBase2.prototype.resetLocation = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offsetX = this.get("offsetX");
      var offsetY = this.get("offsetY");
      this.moveElementTo(this.get("group"), {
        x: x + offsetX,
        y: y + offsetY
      });
    };
    LegendBase2.prototype.applyOffset = function() {
      this.resetLocation();
    };
    LegendBase2.prototype.getDrawPoint = function() {
      return this.get("currentPoint");
    };
    LegendBase2.prototype.setDrawPoint = function(point2) {
      return this.set("currentPoint", point2);
    };
    LegendBase2.prototype.renderInner = function(group2) {
      this.resetDraw();
      if (this.get("title")) {
        this.drawTitle(group2);
      }
      this.drawLegendContent(group2);
      if (this.get("background")) {
        this.drawBackground(group2);
      }
    };
    LegendBase2.prototype.drawBackground = function(group2) {
      var background = this.get("background");
      var bbox = group2.getBBox();
      var padding2 = formatPadding(background.padding);
      var attrs = __assign$1({
        //  (0,0) 
        x: 0,
        y: 0,
        width: bbox.width + padding2[1] + padding2[3],
        height: bbox.height + padding2[0] + padding2[2]
      }, background.style);
      var backgroundShape = this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        name: "legend-background",
        attrs
      });
      backgroundShape.toBack();
    };
    LegendBase2.prototype.drawTitle = function(group2) {
      var currentPoint = this.get("currentPoint");
      var titleCfg = this.get("title");
      var spacing = titleCfg.spacing, style = titleCfg.style, text2 = titleCfg.text;
      var shape = this.addShape(group2, {
        type: "text",
        id: this.getElementId("title"),
        name: "legend-title",
        attrs: __assign$1({ text: text2, x: currentPoint.x, y: currentPoint.y }, style)
      });
      var bbox = shape.getBBox();
      this.set("currentPoint", { x: currentPoint.x, y: bbox.maxY + spacing });
    };
    LegendBase2.prototype.resetDraw = function() {
      var background = this.get("background");
      var currentPoint = { x: 0, y: 0 };
      if (background) {
        var padding2 = formatPadding(background.padding);
        currentPoint.x = padding2[3];
        currentPoint.y = padding2[0];
      }
      this.set("currentPoint", currentPoint);
    };
    return LegendBase2;
  }(GroupComponent)
);
var DEFAULT_PAGE_NAVIGATOR = {
  marker: {
    style: {
      inactiveFill: "#000",
      inactiveOpacity: 0.45,
      fill: "#000",
      opacity: 1,
      size: 12
    }
  },
  text: {
    style: {
      fill: "#ccc",
      fontSize: 12
    }
  }
};
var textStyle = {
  fill: Theme.textColor,
  fontSize: 12,
  textAlign: "start",
  textBaseline: "middle",
  fontFamily: Theme.fontFamily,
  fontWeight: "normal",
  lineHeight: 12
};
var RIGHT_ARROW_NAME = "navigation-arrow-right";
var LEFT_ARROW_NAME = "navigation-arrow-left";
var ROTATE_MAP = {
  right: 90 * Math.PI / 180,
  left: (360 - 90) * Math.PI / 180,
  up: 0,
  down: 180 * Math.PI / 180
};
var Category = (
  /** @class */
  function(_super) {
    __extends$1(Category2, _super);
    function Category2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.currentPageIndex = 1;
      _this.totalPagesCnt = 1;
      _this.pageWidth = 0;
      _this.pageHeight = 0;
      _this.startX = 0;
      _this.startY = 0;
      _this.onNavigationBack = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex > 1) {
          _this.currentPageIndex -= 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      _this.onNavigationAfter = function() {
        var itemGroup = _this.getElementByLocalId("item-group");
        if (_this.currentPageIndex < _this.totalPagesCnt) {
          _this.currentPageIndex += 1;
          _this.updateNavigation();
          var matrix = _this.getCurrentNavigationMatrix();
          if (_this.get("animate")) {
            itemGroup.animate({
              matrix
            }, 100);
          } else {
            itemGroup.attr({ matrix });
          }
        }
      };
      return _this;
    }
    Category2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "legend", type: "category", itemSpacing: 24, itemMarginBottom: 8, maxItemWidth: null, itemWidth: null, itemHeight: null, itemName: {}, itemValue: null, maxWidth: null, maxHeight: null, marker: {}, radio: null, items: [], itemStates: {}, itemBackground: {}, pageNavigator: {}, defaultCfg: {
        title: {
          spacing: 5,
          style: {
            fill: Theme.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        },
        background: {
          padding: 5,
          style: {
            stroke: Theme.lineColor
          }
        },
        itemBackground: {
          style: {
            opacity: 0,
            fill: "#fff"
          }
        },
        pageNavigator: DEFAULT_PAGE_NAVIGATOR,
        itemName: {
          spacing: 16,
          style: textStyle
        },
        marker: {
          spacing: 8,
          style: {
            r: 6,
            symbol: "circle"
          }
        },
        itemValue: {
          alignRight: false,
          formatter: null,
          style: textStyle,
          spacing: 6
        },
        itemStates: {
          active: {
            nameStyle: {
              opacity: 0.8
            }
          },
          unchecked: {
            nameStyle: {
              fill: Theme.uncheckedColor
            },
            markerStyle: {
              fill: Theme.uncheckedColor,
              stroke: Theme.uncheckedColor
            }
          },
          inactive: {
            nameStyle: {
              fill: Theme.uncheckedColor
            },
            markerStyle: {
              opacity: 0.2
            }
          }
        }
      } });
    };
    Category2.prototype.isList = function() {
      return true;
    };
    Category2.prototype.getItems = function() {
      return this.get("items");
    };
    Category2.prototype.setItems = function(items) {
      this.update({
        items
      });
    };
    Category2.prototype.updateItem = function(item, cfg) {
      mix(item, cfg);
      this.clear();
      this.render();
    };
    Category2.prototype.clearItems = function() {
      var itemGroup = this.getElementByLocalId("item-group");
      itemGroup && itemGroup.clear();
    };
    Category2.prototype.setItemState = function(item, state2, value2) {
      item[state2] = value2;
      var itemElement = this.getElementByLocalId("item-" + item.id);
      if (itemElement) {
        var items = this.getItems();
        var index2 = items.indexOf(item);
        var offsetGroup = this.createOffScreenGroup();
        var newElement = this.drawItem(item, index2, this.getItemHeight(), offsetGroup);
        this.updateElements(newElement, itemElement);
        this.clearUpdateStatus(itemElement);
      }
    };
    Category2.prototype.hasState = function(item, state2) {
      return !!item[state2];
    };
    Category2.prototype.getItemStates = function(item) {
      var itemStates = this.get("itemStates");
      var rst = [];
      each$1(itemStates, function(v, k) {
        if (item[k]) {
          rst.push(k);
        }
      });
      return rst;
    };
    Category2.prototype.clearItemsState = function(state2) {
      var _this = this;
      var items = this.getItemsByState(state2);
      each$1(items, function(item) {
        _this.setItemState(item, state2, false);
      });
    };
    Category2.prototype.getItemsByState = function(state2) {
      var _this = this;
      var items = this.getItems();
      return filter(items, function(item) {
        return _this.hasState(item, state2);
      });
    };
    Category2.prototype.drawLegendContent = function(group2) {
      this.processItems();
      this.drawItems(group2);
    };
    Category2.prototype.processItems = function() {
      var items = this.get("items");
      each$1(items, function(item) {
        if (!item.id) {
          item.id = item.name;
        }
      });
    };
    Category2.prototype.drawItems = function(group2) {
      var _this = this;
      var itemContainerGroup = this.addGroup(group2, {
        id: this.getElementId("item-container-group"),
        name: "legend-item-container-group"
      });
      var itemGroup = this.addGroup(itemContainerGroup, {
        id: this.getElementId("item-group"),
        name: "legend-item-group"
      });
      var itemHeight = this.getItemHeight();
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemMarginBottom = this.get("itemMarginBottom");
      var currentPoint = this.get("currentPoint");
      var startX = currentPoint.x;
      var startY = currentPoint.y;
      var layout2 = this.get("layout");
      var items = this.get("items");
      var wrapped = false;
      var pageWidth = 0;
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      each$1(items, function(item, index2) {
        var subGroup = _this.drawItem(item, index2, itemHeight, itemGroup);
        var bbox = subGroup.getBBox();
        var width = itemWidth || bbox.width;
        if (width > pageWidth) {
          pageWidth = width;
        }
        if (layout2 === "horizontal") {
          if (maxWidth && maxWidth < currentPoint.x + width - startX) {
            wrapped = true;
            currentPoint.x = startX;
            currentPoint.y += itemHeight + itemMarginBottom;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.x += width + itemSpacing;
        } else {
          if (maxHeight && maxHeight < currentPoint.y + itemHeight + itemMarginBottom - startY) {
            wrapped = true;
            currentPoint.x += pageWidth + itemSpacing;
            currentPoint.y = startY;
            pageWidth = 0;
          }
          _this.moveElementTo(subGroup, currentPoint);
          currentPoint.y += itemHeight + itemMarginBottom;
        }
      });
      if (wrapped && this.get("flipPage")) {
        this.pageHeight = 0;
        this.pageWidth = 0;
        this.totalPagesCnt = 1;
        this.startX = startX;
        this.startY = startY;
        this.adjustNavigation(group2, itemGroup);
      }
    };
    Category2.prototype.getItemHeight = function() {
      var itemHeight = this.get("itemHeight");
      if (!itemHeight) {
        var style_1 = (this.get("itemName") || {}).style;
        if (isFunction(style_1)) {
          var items_1 = this.getItems();
          items_1.forEach(function(item, index2) {
            var fontSize = __assign$1(__assign$1({}, textStyle), style_1(item, index2, items_1)).fontSize;
            if (itemHeight < fontSize) {
              itemHeight = fontSize;
            }
          });
        } else if (style_1) {
          itemHeight = style_1.fontSize;
        }
      }
      return itemHeight;
    };
    Category2.prototype.drawMarker = function(container, markerCfg, item, itemHeight) {
      var markerAttrs = __assign$1(__assign$1(__assign$1({ x: 0, y: itemHeight / 2 }, markerCfg.style), { symbol: get(item.marker, "symbol", "circle") }), get(item.marker, "style", {}));
      var shape = this.addShape(container, {
        type: "marker",
        id: this.getElementId("item-" + item.id + "-marker"),
        name: "legend-item-marker",
        attrs: markerAttrs
      });
      var bbox = shape.getBBox();
      shape.attr("x", bbox.width / 2);
      var _a2 = shape.attr(), stroke = _a2.stroke, fill = _a2.fill;
      if (stroke) {
        shape.set("isStroke", true);
      }
      if (fill) {
        shape.set("isFill", true);
      }
      return shape;
    };
    Category2.prototype.drawItemText = function(container, textName, cfg, item, itemHeight, xPosition, index2) {
      var formatter = cfg.formatter;
      var style = cfg.style;
      var attrs = __assign$1(__assign$1({ x: xPosition, y: itemHeight / 2, text: formatter ? formatter(item[textName], item, index2) : item[textName] }, textStyle), isFunction(style) ? style(item, index2, this.getItems()) : style);
      return this.addShape(container, {
        type: "text",
        id: this.getElementId("item-" + item.id + "-" + textName),
        name: "legend-item-" + textName,
        attrs
      });
    };
    Category2.prototype.drawRadio = function(container, radioCfg, item, itemHeight, x) {
      var _a2, _b;
      var style = radioCfg.style || {};
      var r = (_a2 = style.r) !== null && _a2 !== void 0 ? _a2 : itemHeight / 2;
      var lineWidth = r * 3.6 / 8;
      var _c = [x + r, itemHeight / 2 - r], x0 = _c[0], y0 = _c[1];
      var _d = [x0 + r, y0 + r], x1 = _d[0], y1 = _d[1];
      var _e = [x0, y1 + r], x2 = _e[0], y2 = _e[1];
      var _f = [x, y0 + r], x3 = _f[0], y3 = _f[1];
      var showRadio = item.showRadio;
      var attrs = __assign$1(__assign$1({ path: [
        ["M", x0, y0],
        ["A", r, r, 0, 0, 1, x1, y1],
        ["L", x1 - lineWidth, y1],
        ["L", x1, y1],
        ["A", r, r, 0, 0, 1, x2, y2],
        ["L", x2, y2 - lineWidth],
        ["L", x2, y2],
        ["A", r, r, 0, 0, 1, x3, y3],
        ["L", x3 + lineWidth, y3],
        ["L", x3, y3],
        ["A", r, r, 0, 0, 1, x0, y0],
        ["L", x0, y0 + lineWidth]
      ], stroke: "#000000", fill: "#ffffff" }, style), { opacity: showRadio ? (_b = style === null || style === void 0 ? void 0 : style.opacity) !== null && _b !== void 0 ? _b : 0.45 : 0 });
      var radioShape = this.addShape(container, {
        type: "path",
        id: this.getElementId("item-" + item.id + "-radio"),
        name: "legend-item-radio",
        attrs
      });
      radioShape.set("tip", radioCfg.tip);
      return radioShape;
    };
    Category2.prototype.drawItem = function(item, index2, itemHeight, itemGroup) {
      var groupId = "item-" + item.id;
      var subContainer = this.addGroup(itemGroup, {
        name: "legend-item-container",
        id: this.getElementId("item-container-" + groupId),
        delegateObject: {
          item,
          index: index2
        }
      });
      var subGroup = this.addGroup(subContainer, {
        name: "legend-item",
        id: this.getElementId(groupId),
        delegateObject: {
          item,
          index: index2
        }
      });
      var marker = this.get("marker");
      var itemName = this.get("itemName");
      var itemValue = this.get("itemValue");
      var itemBackground = this.get("itemBackground");
      var radio = this.get("radio");
      var itemWidth = this.getLimitItemWidth();
      var curX = 0;
      if (marker) {
        var markerShape = this.drawMarker(subGroup, marker, item, itemHeight);
        var spacing = marker.spacing;
        var itemMarkerSpacing = get(item, ["marker", "spacing"]);
        if (isNumber$1(itemMarkerSpacing)) {
          spacing = itemMarkerSpacing;
        }
        curX = markerShape.getBBox().maxX + spacing;
      }
      if (itemName) {
        var nameShape = this.drawItemText(subGroup, "name", itemName, item, itemHeight, curX, index2);
        if (itemWidth) {
          ellipsisLabel(true, nameShape, clamp(itemWidth - curX, 0, itemWidth));
        }
        curX = nameShape.getBBox().maxX + itemName.spacing;
      }
      if (itemValue) {
        var valueShape = this.drawItemText(subGroup, "value", itemValue, item, itemHeight, curX, index2);
        if (itemWidth) {
          if (itemValue.alignRight) {
            valueShape.attr({
              textAlign: "right",
              x: itemWidth
            });
            ellipsisLabel(true, valueShape, clamp(itemWidth - curX, 0, itemWidth), "head");
          } else {
            ellipsisLabel(true, valueShape, clamp(itemWidth - curX, 0, itemWidth));
          }
        }
        curX = valueShape.getBBox().maxX + itemValue.spacing;
      }
      if (radio) {
        this.drawRadio(subGroup, radio, item, itemHeight, curX);
      }
      if (itemBackground) {
        var bbox = subGroup.getBBox();
        var backShape = this.addShape(subGroup, {
          type: "rect",
          name: "legend-item-background",
          id: this.getElementId(groupId + "-background"),
          attrs: __assign$1({ x: 0, y: 0, width: bbox.width, height: itemHeight }, itemBackground.style)
        });
        backShape.toBack();
      }
      this.applyItemStates(item, subGroup);
      return subGroup;
    };
    Category2.prototype.adjustNavigation = function(container, itemGroup) {
      var _this = this;
      var startX = this.startX;
      var startY = this.startY;
      var layout2 = this.get("layout");
      var subGroups = itemGroup.findAll(function(item) {
        return item.get("name") === "legend-item";
      });
      var maxWidth = this.get("maxWidth");
      var maxHeight = this.get("maxHeight");
      var itemWidth = this.get("itemWidth");
      var itemSpacing = this.get("itemSpacing");
      var itemHeight = this.getItemHeight();
      var pageNavigator = deepMix({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var navigation = this.drawNavigation(container, layout2, "00/00", pageNavigator);
      var navigationBBox = navigation.getBBox();
      var currentPoint = { x: startX, y: startY };
      var pages = 1;
      var widthLimit = 0;
      var pageWidth = 0;
      var maxItemWidth = 0;
      var itemMarginBottom = this.get("itemMarginBottom");
      if (layout2 === "horizontal") {
        var maxRow = this.get("maxRow") || 1;
        var maxRowHeight_1 = itemHeight + (maxRow === 1 ? 0 : itemMarginBottom);
        this.pageHeight = maxRowHeight_1 * maxRow;
        each$1(subGroups, function(item) {
          var bbox = item.getBBox();
          var width = itemWidth || bbox.width;
          if (widthLimit && widthLimit < currentPoint.x + width + itemSpacing || maxWidth < currentPoint.x + width + itemSpacing + navigationBBox.width) {
            if (pages === 1) {
              widthLimit = currentPoint.x + itemSpacing;
              _this.pageWidth = widthLimit;
              _this.moveElementTo(navigation, {
                x: maxWidth - itemSpacing - navigationBBox.width - navigationBBox.minX,
                y: currentPoint.y + itemHeight / 2 - navigationBBox.height / 2 - navigationBBox.minY
              });
            }
            pages += 1;
            currentPoint.x = startX;
            currentPoint.y += maxRowHeight_1;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: width + itemSpacing,
              height: itemHeight
            }
          });
          currentPoint.x += width + itemSpacing;
        });
      } else {
        each$1(subGroups, function(item) {
          var bbox = item.getBBox();
          if (bbox.width > pageWidth) {
            pageWidth = bbox.width;
          }
        });
        maxItemWidth = pageWidth;
        pageWidth += itemSpacing;
        if (maxWidth) {
          pageWidth = Math.min(maxWidth, pageWidth);
          maxItemWidth = Math.min(maxWidth, maxItemWidth);
        }
        this.pageWidth = pageWidth;
        this.pageHeight = maxHeight - Math.max(navigationBBox.height, itemHeight + itemMarginBottom);
        var cntPerPage_1 = Math.floor(this.pageHeight / (itemHeight + itemMarginBottom));
        each$1(subGroups, function(item, index2) {
          if (index2 !== 0 && index2 % cntPerPage_1 === 0) {
            pages += 1;
            currentPoint.x += pageWidth;
            currentPoint.y = startY;
          }
          _this.moveElementTo(item, currentPoint);
          item.getParent().setClip({
            type: "rect",
            attrs: {
              x: currentPoint.x,
              y: currentPoint.y,
              width: pageWidth,
              height: itemHeight
            }
          });
          currentPoint.y += itemHeight + itemMarginBottom;
        });
        this.totalPagesCnt = pages;
        this.moveElementTo(navigation, {
          x: startX + maxItemWidth / 2 - navigationBBox.width / 2 - navigationBBox.minX,
          y: maxHeight - navigationBBox.height - navigationBBox.minY
        });
      }
      if (this.pageHeight && this.pageWidth) {
        itemGroup.getParent().setClip({
          type: "rect",
          attrs: {
            x: this.startX,
            y: this.startY,
            width: this.pageWidth,
            height: this.pageHeight
          }
        });
      }
      if (layout2 === "horizontal" && this.get("maxRow")) {
        this.totalPagesCnt = Math.ceil(pages / this.get("maxRow"));
      } else {
        this.totalPagesCnt = pages;
      }
      if (this.currentPageIndex > this.totalPagesCnt) {
        this.currentPageIndex = 1;
      }
      this.updateNavigation(navigation);
      itemGroup.attr("matrix", this.getCurrentNavigationMatrix());
    };
    Category2.prototype.drawNavigation = function(group2, layout2, text2, styleCfg) {
      var currentPoint = { x: 0, y: 0 };
      var subGroup = this.addGroup(group2, {
        id: this.getElementId("navigation-group"),
        name: "legend-navigation"
      });
      var _a2 = get(styleCfg.marker, "style", {}), _b = _a2.size, size2 = _b === void 0 ? 12 : _b, arrowStyle = __rest(_a2, ["size"]);
      var leftArrow = this.drawArrow(subGroup, currentPoint, LEFT_ARROW_NAME, layout2 === "horizontal" ? "up" : "left", size2, arrowStyle);
      leftArrow.on("click", this.onNavigationBack);
      var leftArrowBBox = leftArrow.getBBox();
      currentPoint.x += leftArrowBBox.width + 2;
      var textShape = this.addShape(subGroup, {
        type: "text",
        id: this.getElementId("navigation-text"),
        name: "navigation-text",
        attrs: __assign$1({ x: currentPoint.x, y: currentPoint.y + size2 / 2, text: text2, textBaseline: "middle" }, get(styleCfg.text, "style"))
      });
      var textBBox = textShape.getBBox();
      currentPoint.x += textBBox.width + 2;
      var rightArrow = this.drawArrow(subGroup, currentPoint, RIGHT_ARROW_NAME, layout2 === "horizontal" ? "down" : "right", size2, arrowStyle);
      rightArrow.on("click", this.onNavigationAfter);
      return subGroup;
    };
    Category2.prototype.updateNavigation = function(navigation) {
      var pageNavigator = deepMix({}, DEFAULT_PAGE_NAVIGATOR, this.get("pageNavigator"));
      var _a2 = pageNavigator.marker.style, fill = _a2.fill, opacity = _a2.opacity, inactiveFill = _a2.inactiveFill, inactiveOpacity = _a2.inactiveOpacity;
      var text2 = this.currentPageIndex + "/" + this.totalPagesCnt;
      var textShape = navigation ? navigation.getChildren()[1] : this.getElementByLocalId("navigation-text");
      var leftArrow = navigation ? navigation.findById(this.getElementId(LEFT_ARROW_NAME)) : this.getElementByLocalId(LEFT_ARROW_NAME);
      var rightArrow = navigation ? navigation.findById(this.getElementId(RIGHT_ARROW_NAME)) : this.getElementByLocalId(RIGHT_ARROW_NAME);
      textShape.attr("text", text2);
      leftArrow.attr("opacity", this.currentPageIndex === 1 ? inactiveOpacity : opacity);
      leftArrow.attr("fill", this.currentPageIndex === 1 ? inactiveFill : fill);
      leftArrow.attr("cursor", this.currentPageIndex === 1 ? "not-allowed" : "pointer");
      rightArrow.attr("opacity", this.currentPageIndex === this.totalPagesCnt ? inactiveOpacity : opacity);
      rightArrow.attr("fill", this.currentPageIndex === this.totalPagesCnt ? inactiveFill : fill);
      rightArrow.attr("cursor", this.currentPageIndex === this.totalPagesCnt ? "not-allowed" : "pointer");
      var cursorX = leftArrow.getBBox().maxX + 2;
      textShape.attr("x", cursorX);
      cursorX += textShape.getBBox().width + 2;
      this.updateArrowPath(rightArrow, { x: cursorX, y: 0 });
    };
    Category2.prototype.drawArrow = function(group2, currentPoint, name, direction2, size2, style) {
      var x = currentPoint.x, y = currentPoint.y;
      var shape = this.addShape(group2, {
        type: "path",
        id: this.getElementId(name),
        name,
        attrs: __assign$1({
          size: size2,
          direction: direction2,
          path: [["M", x + size2 / 2, y], ["L", x, y + size2], ["L", x + size2, y + size2], ["Z"]],
          cursor: "pointer"
        }, style)
      });
      shape.attr("matrix", getMatrixByAngle({ x: x + size2 / 2, y: y + size2 / 2 }, ROTATE_MAP[direction2]));
      return shape;
    };
    Category2.prototype.updateArrowPath = function(arrow, point2) {
      var x = point2.x, y = point2.y;
      var _a2 = arrow.attr(), size2 = _a2.size, direction2 = _a2.direction;
      var matrix = getMatrixByAngle({ x: x + size2 / 2, y: y + size2 / 2 }, ROTATE_MAP[direction2]);
      arrow.attr("path", [["M", x + size2 / 2, y], ["L", x, y + size2], ["L", x + size2, y + size2], ["Z"]]);
      arrow.attr("matrix", matrix);
    };
    Category2.prototype.getCurrentNavigationMatrix = function() {
      var _a2 = this, currentPageIndex = _a2.currentPageIndex, pageWidth = _a2.pageWidth, pageHeight = _a2.pageHeight;
      var layout2 = this.get("layout");
      var translate2 = layout2 === "horizontal" ? {
        x: 0,
        y: pageHeight * (1 - currentPageIndex)
      } : {
        x: pageWidth * (1 - currentPageIndex),
        y: 0
      };
      return getMatrixByTranslate(translate2);
    };
    Category2.prototype.applyItemStates = function(item, subGroup) {
      var states = this.getItemStates(item);
      var hasStates = states.length > 0;
      if (hasStates) {
        var children = subGroup.getChildren();
        var itemStates_1 = this.get("itemStates");
        each$1(children, function(element) {
          var name = element.get("name");
          var elName = name.split("-")[2];
          var statesStyle = getStatesStyle(item, elName, itemStates_1);
          if (statesStyle) {
            element.attr(statesStyle);
            if (elName === "marker" && !(element.get("isStroke") && element.get("isFill"))) {
              if (element.get("isStroke")) {
                element.attr("fill", null);
              }
              if (element.get("isFill")) {
                element.attr("stroke", null);
              }
            }
          }
        });
      }
    };
    Category2.prototype.getLimitItemWidth = function() {
      var itemWidth = this.get("itemWidth");
      var maxItemWidth = this.get("maxItemWidth");
      if (maxItemWidth) {
        if (itemWidth) {
          maxItemWidth = itemWidth <= maxItemWidth ? itemWidth : maxItemWidth;
        }
      } else if (itemWidth) {
        maxItemWidth = itemWidth;
      }
      return maxItemWidth;
    };
    return Category2;
  }(LegendBase)
);
var HANDLER_HEIGHT_RATIO = 1.4;
var HANDLER_TRIANGLE_RATIO = 0.4;
var ContinueLegend = (
  /** @class */
  function(_super) {
    __extends$1(ContinueLegend2, _super);
    function ContinueLegend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ContinueLegend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { type: "continue", min: 0, max: 100, value: null, colors: [], track: {}, rail: {}, label: {}, handler: {}, slidable: true, tip: null, step: null, maxWidth: null, maxHeight: null, defaultCfg: {
        label: {
          align: "rail",
          spacing: 5,
          formatter: null,
          style: {
            fontSize: 12,
            fill: Theme.textColor,
            textBaseline: "middle",
            fontFamily: Theme.fontFamily
          }
        },
        handler: {
          size: 10,
          style: {
            fill: "#fff",
            stroke: "#333"
          }
        },
        track: {},
        rail: {
          type: "color",
          size: 20,
          defaultLength: 100,
          style: {
            fill: "#DCDEE2"
          }
        },
        title: {
          spacing: 5,
          style: {
            fill: Theme.textColor,
            fontSize: 12,
            textAlign: "start",
            textBaseline: "top"
          }
        }
      } });
    };
    ContinueLegend2.prototype.isSlider = function() {
      return true;
    };
    ContinueLegend2.prototype.getValue = function() {
      return this.getCurrentValue();
    };
    ContinueLegend2.prototype.getRange = function() {
      return {
        min: this.get("min"),
        max: this.get("max")
      };
    };
    ContinueLegend2.prototype.setRange = function(min2, max2) {
      this.update({
        min: min2,
        max: max2
      });
    };
    ContinueLegend2.prototype.setValue = function(value2) {
      var originValue = this.getValue();
      this.set("value", value2);
      var group2 = this.get("group");
      this.resetTrackClip();
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
      this.delegateEmit("valuechanged", {
        originValue,
        value: value2
      });
    };
    ContinueLegend2.prototype.initEvent = function() {
      var group2 = this.get("group");
      this.bindSliderEvent(group2);
      this.bindRailEvent(group2);
      this.bindTrackEvent(group2);
    };
    ContinueLegend2.prototype.drawLegendContent = function(group2) {
      this.drawRail(group2);
      this.drawLabels(group2);
      this.fixedElements(group2);
      this.resetTrack(group2);
      this.resetTrackClip(group2);
      if (this.get("slidable")) {
        this.resetHandlers(group2);
      }
    };
    ContinueLegend2.prototype.bindSliderEvent = function(group2) {
      this.bindHandlersEvent(group2);
    };
    ContinueLegend2.prototype.bindHandlersEvent = function(group2) {
      var _this = this;
      group2.on("legend-handler-min:drag", function(ev) {
        var minValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var maxValue = currentValue[1];
        if (maxValue < minValue) {
          maxValue = minValue;
        }
        _this.setValue([minValue, maxValue]);
      });
      group2.on("legend-handler-max:drag", function(ev) {
        var maxValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var minValue = currentValue[0];
        if (minValue > maxValue) {
          minValue = maxValue;
        }
        _this.setValue([minValue, maxValue]);
      });
    };
    ContinueLegend2.prototype.bindRailEvent = function(group2) {
    };
    ContinueLegend2.prototype.bindTrackEvent = function(group2) {
      var _this = this;
      var prePoint = null;
      group2.on("legend-track:dragstart", function(ev) {
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:drag", function(ev) {
        if (!prePoint) {
          return;
        }
        var preValue = _this.getValueByCanvasPoint(prePoint.x, prePoint.y);
        var curValue = _this.getValueByCanvasPoint(ev.x, ev.y);
        var currentValue = _this.getCurrentValue();
        var curDiff = currentValue[1] - currentValue[0];
        var range = _this.getRange();
        var dValue = curValue - preValue;
        if (dValue < 0) {
          if (currentValue[0] + dValue > range.min) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range.min, range.min + curDiff]);
          }
        } else if (dValue > 0) {
          if (dValue > 0 && currentValue[1] + dValue < range.max) {
            _this.setValue([currentValue[0] + dValue, currentValue[1] + dValue]);
          } else {
            _this.setValue([range.max - curDiff, range.max]);
          }
        }
        prePoint = {
          x: ev.x,
          y: ev.y
        };
      });
      group2.on("legend-track:dragend", function(ev) {
        prePoint = null;
      });
    };
    ContinueLegend2.prototype.drawLabels = function(group2) {
      this.drawLabel("min", group2);
      this.drawLabel("max", group2);
    };
    ContinueLegend2.prototype.drawLabel = function(name, group2) {
      var labelCfg = this.get("label");
      var style = labelCfg.style;
      var labelAlign = labelCfg.align;
      var labelFormatter = labelCfg.formatter;
      var value2 = this.get(name);
      var alignAttrs = this.getLabelAlignAttrs(name, labelAlign);
      var localId = "label-" + name;
      this.addShape(group2, {
        type: "text",
        id: this.getElementId(localId),
        name: "legend-label-" + name,
        attrs: __assign$1(__assign$1({ x: 0, y: 0, text: isFunction(labelFormatter) ? labelFormatter(value2) : value2 }, style), alignAttrs)
      });
    };
    ContinueLegend2.prototype.getLabelAlignAttrs = function(name, align) {
      var isVertical2 = this.isVertical();
      var textAlign = "center";
      var textBaseline = "middle";
      if (isVertical2) {
        textAlign = "start";
        if (align !== "rail") {
          if (name === "min") {
            textBaseline = "top";
          } else {
            textBaseline = "bottom";
          }
        } else {
          textBaseline = "top";
        }
      } else {
        if (align !== "rail") {
          textBaseline = "top";
          if (name === "min") {
            textAlign = "start";
          } else {
            textAlign = "end";
          }
        } else {
          textAlign = "start";
          textBaseline = "middle";
        }
      }
      return {
        textAlign,
        textBaseline
      };
    };
    ContinueLegend2.prototype.getRailPath = function(x, y, w, h) {
      var railCfg = this.get("rail");
      var size2 = railCfg.size, defaultLength = railCfg.defaultLength, type = railCfg.type;
      var isVertical2 = this.isVertical();
      var length2 = defaultLength;
      var width = w;
      var height = h;
      if (!width) {
        width = isVertical2 ? size2 : length2;
      }
      if (!height) {
        height = isVertical2 ? length2 : size2;
      }
      var path2 = [];
      if (type === "color") {
        path2.push(["M", x, y]);
        path2.push(["L", x + width, y]);
        path2.push(["L", x + width, y + height]);
        path2.push(["L", x, y + height]);
        path2.push(["Z"]);
      } else {
        path2.push(["M", x + width, y]);
        path2.push(["L", x + width, y + height]);
        path2.push(["L", x, y + height]);
        path2.push(["Z"]);
      }
      return path2;
    };
    ContinueLegend2.prototype.drawRail = function(group2) {
      var railCfg = this.get("rail");
      var style = railCfg.style;
      this.addShape(group2, {
        type: "path",
        id: this.getElementId("rail"),
        name: "legend-rail",
        attrs: __assign$1({ path: this.getRailPath(0, 0) }, style)
      });
    };
    ContinueLegend2.prototype.getTrackColor = function(colors) {
      var count2 = colors.length;
      if (!count2) {
        return null;
      }
      if (count2 === 1) {
        return colors[0];
      }
      var color2;
      if (this.isVertical()) {
        color2 = "l(90)";
      } else {
        color2 = "l(0)";
      }
      for (var i = 0; i < count2; i++) {
        var percent2 = i / (count2 - 1);
        color2 += " " + percent2 + ":" + colors[i];
      }
      return color2;
    };
    ContinueLegend2.prototype.getTrackPath = function(group2) {
      var railShape = this.getRailShape(group2);
      var path2 = railShape.attr("path");
      return clone(path2);
    };
    ContinueLegend2.prototype.getClipTrackAttrs = function(group2) {
      var value2 = this.getCurrentValue();
      var min2 = value2[0], max2 = value2[1];
      var railBBox = this.getRailBBox(group2);
      var startPoint = this.getPointByValue(min2, group2);
      var endPoint = this.getPointByValue(max2, group2);
      var isVertical2 = this.isVertical();
      var x;
      var y;
      var width;
      var height;
      if (isVertical2) {
        x = railBBox.minX;
        y = startPoint.y;
        width = railBBox.width;
        height = endPoint.y - startPoint.y;
      } else {
        x = startPoint.x;
        y = railBBox.minY;
        width = endPoint.x - startPoint.x;
        height = railBBox.height;
      }
      return {
        x,
        y,
        width,
        height
      };
    };
    ContinueLegend2.prototype.getTrackAttrs = function(group2) {
      var trackCfg = this.get("track");
      var colors = this.get("colors");
      var path2 = this.getTrackPath(group2);
      return mix({
        path: path2,
        fill: this.getTrackColor(colors)
      }, trackCfg.style);
    };
    ContinueLegend2.prototype.resetTrackClip = function(group2) {
      var container = group2 || this.get("group");
      var trackId = this.getElementId("track");
      var trackShape = container.findById(trackId);
      var clipShape = trackShape.getClip();
      var attrs = this.getClipTrackAttrs(group2);
      if (!clipShape) {
        trackShape.setClip({
          type: "rect",
          attrs
        });
      } else {
        clipShape.attr(attrs);
      }
    };
    ContinueLegend2.prototype.resetTrack = function(group2) {
      var trackId = this.getElementId("track");
      var trackShape = group2.findById(trackId);
      var trackAttrs = this.getTrackAttrs(group2);
      if (trackShape) {
        trackShape.attr(trackAttrs);
      } else {
        this.addShape(group2, {
          type: "path",
          id: trackId,
          draggable: this.get("slidable"),
          name: "legend-track",
          attrs: trackAttrs
        });
      }
    };
    ContinueLegend2.prototype.getPointByValue = function(value2, group2) {
      var _a2 = this.getRange(), min2 = _a2.min, max2 = _a2.max;
      var percent2 = (value2 - min2) / (max2 - min2);
      var bbox = this.getRailBBox(group2);
      var isVertcal = this.isVertical();
      var point2 = { x: 0, y: 0 };
      if (isVertcal) {
        point2.x = bbox.minX + bbox.width / 2;
        point2.y = getValueByPercent(bbox.minY, bbox.maxY, percent2);
      } else {
        point2.x = getValueByPercent(bbox.minX, bbox.maxX, percent2);
        point2.y = bbox.minY + bbox.height / 2;
      }
      return point2;
    };
    ContinueLegend2.prototype.getRailShape = function(group2) {
      var container = group2 || this.get("group");
      return container.findById(this.getElementId("rail"));
    };
    ContinueLegend2.prototype.getRailBBox = function(group2) {
      var railShape = this.getRailShape(group2);
      var bbox = railShape.getBBox();
      return bbox;
    };
    ContinueLegend2.prototype.getRailCanvasBBox = function() {
      var container = this.get("group");
      var railShape = container.findById(this.getElementId("rail"));
      var bbox = railShape.getCanvasBBox();
      return bbox;
    };
    ContinueLegend2.prototype.isVertical = function() {
      return this.get("layout") === "vertical";
    };
    ContinueLegend2.prototype.getValueByCanvasPoint = function(x, y) {
      var _a2 = this.getRange(), min2 = _a2.min, max2 = _a2.max;
      var bbox = this.getRailCanvasBBox();
      var isVertcal = this.isVertical();
      var step = this.get("step");
      var percent2;
      if (isVertcal) {
        percent2 = (y - bbox.minY) / bbox.height;
      } else {
        percent2 = (x - bbox.minX) / bbox.width;
      }
      var value2 = getValueByPercent(min2, max2, percent2);
      if (step) {
        var count2 = Math.round((value2 - min2) / step);
        value2 = min2 + count2 * step;
      }
      if (value2 > max2) {
        value2 = max2;
      }
      if (value2 < min2) {
        value2 = min2;
      }
      return value2;
    };
    ContinueLegend2.prototype.getCurrentValue = function() {
      var value2 = this.get("value");
      if (!value2) {
        var values2 = this.get("values");
        if (!values2) {
          return [this.get("min"), this.get("max")];
        }
        return [Math.max(Math.min.apply(Math, __spreadArrays(values2, [this.get("max")])), this.get("min")), Math.min(Math.max.apply(Math, __spreadArrays(values2, [this.get("min")])), this.get("max"))];
      }
      return value2;
    };
    ContinueLegend2.prototype.resetHandlers = function(group2) {
      var currentValue = this.getCurrentValue();
      var min2 = currentValue[0], max2 = currentValue[1];
      this.resetHandler(group2, "min", min2);
      this.resetHandler(group2, "max", max2);
    };
    ContinueLegend2.prototype.getHandlerPath = function(handlerCfg, point2) {
      var isVertical2 = this.isVertical();
      var path2 = [];
      var width = handlerCfg.size;
      var x = point2.x, y = point2.y;
      var height = width * HANDLER_HEIGHT_RATIO;
      var halfWidth = width / 2;
      var oneSixthWidth = width / 6;
      if (isVertical2) {
        var triangleX = x + height * HANDLER_TRIANGLE_RATIO;
        path2.push(["M", x, y]);
        path2.push(["L", triangleX, y + halfWidth]);
        path2.push(["L", x + height, y + halfWidth]);
        path2.push(["L", x + height, y - halfWidth]);
        path2.push(["L", triangleX, y - halfWidth]);
        path2.push(["Z"]);
        path2.push(["M", triangleX, y + oneSixthWidth]);
        path2.push(["L", x + height - 2, y + oneSixthWidth]);
        path2.push(["M", triangleX, y - oneSixthWidth]);
        path2.push(["L", x + height - 2, y - oneSixthWidth]);
      } else {
        var triangleY = y + height * HANDLER_TRIANGLE_RATIO;
        path2.push(["M", x, y]);
        path2.push(["L", x - halfWidth, triangleY]);
        path2.push(["L", x - halfWidth, y + height]);
        path2.push(["L", x + halfWidth, y + height]);
        path2.push(["L", x + halfWidth, triangleY]);
        path2.push(["Z"]);
        path2.push(["M", x - oneSixthWidth, triangleY]);
        path2.push(["L", x - oneSixthWidth, y + height - 2]);
        path2.push(["M", x + oneSixthWidth, triangleY]);
        path2.push(["L", x + oneSixthWidth, y + height - 2]);
      }
      return path2;
    };
    ContinueLegend2.prototype.resetHandler = function(group2, name, value2) {
      var point2 = this.getPointByValue(value2, group2);
      var handlerCfg = this.get("handler");
      var path2 = this.getHandlerPath(handlerCfg, point2);
      var id2 = this.getElementId("handler-" + name);
      var handlerShape = group2.findById(id2);
      var isVertical2 = this.isVertical();
      if (handlerShape) {
        handlerShape.attr("path", path2);
      } else {
        this.addShape(group2, {
          type: "path",
          name: "legend-handler-" + name,
          draggable: true,
          id: id2,
          attrs: __assign$1(__assign$1({ path: path2 }, handlerCfg.style), { cursor: isVertical2 ? "ns-resize" : "ew-resize" })
        });
      }
    };
    ContinueLegend2.prototype.fixedElements = function(group2) {
      var railShape = group2.findById(this.getElementId("rail"));
      var minLabel = group2.findById(this.getElementId("label-min"));
      var maxLabel = group2.findById(this.getElementId("label-max"));
      var startPoint = this.getDrawPoint();
      if (this.isVertical()) {
        this.fixedVertail(minLabel, maxLabel, railShape, startPoint);
      } else {
        this.fixedHorizontal(minLabel, maxLabel, railShape, startPoint);
      }
    };
    ContinueLegend2.prototype.fitRailLength = function(minLabelBBox, maxLabelBBox, railBBox, railShape) {
      var isVertical2 = this.isVertical();
      var lengthField = isVertical2 ? "height" : "width";
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var maxLength = this.get("max" + upperFirst(lengthField));
      if (maxLength) {
        var elementsLength = labelAlign === "rail" ? railBBox[lengthField] + minLabelBBox[lengthField] + maxLabelBBox[lengthField] + spacing * 2 : railBBox[lengthField];
        var diff2 = elementsLength - maxLength;
        if (diff2 > 0) {
          this.changeRailLength(railShape, lengthField, railBBox[lengthField] - diff2);
        }
      }
    };
    ContinueLegend2.prototype.changeRailLength = function(railShape, lengthField, length2) {
      var bbox = railShape.getBBox();
      var path2;
      if (lengthField === "height") {
        path2 = this.getRailPath(bbox.x, bbox.y, bbox.width, length2);
      } else {
        path2 = this.getRailPath(bbox.x, bbox.y, length2, bbox.height);
      }
      railShape.attr("path", path2);
    };
    ContinueLegend2.prototype.changeRailPosition = function(railShape, x, y) {
      var bbox = railShape.getBBox();
      var path2 = this.getRailPath(x, y, bbox.width, bbox.height);
      railShape.attr("path", path2);
    };
    ContinueLegend2.prototype.fixedHorizontal = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      var railHeight = railBBox.height;
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railHeight / 2
        });
        this.changeRailPosition(railShape, startPoint.x + minLabelBBox.width + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + minLabelBBox.width + railBBox.width + spacing * 2,
          y: startPoint.y + railHeight / 2
        });
      } else if (labelAlign === "top") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
      } else {
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height + spacing
        });
        maxLabel.attr({
          x: startPoint.x + railBBox.width,
          y: startPoint.y + railBBox.height + spacing
        });
      }
    };
    ContinueLegend2.prototype.fixedVertail = function(minLabel, maxLabel, railShape, startPoint) {
      var labelCfg = this.get("label");
      var labelAlign = labelCfg.align;
      var spacing = labelCfg.spacing;
      var railBBox = railShape.getBBox();
      var minLabelBBox = minLabel.getBBox();
      var maxLabelBBox = maxLabel.getBBox();
      this.fitRailLength(minLabelBBox, maxLabelBBox, railBBox, railShape);
      railBBox = railShape.getBBox();
      if (labelAlign === "rail") {
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y + minLabelBBox.height + spacing);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + minLabelBBox.height + railBBox.height + spacing * 2
        });
      } else if (labelAlign === "right") {
        minLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x, startPoint.y);
        maxLabel.attr({
          x: startPoint.x + railBBox.width + spacing,
          y: startPoint.y + railBBox.height
        });
      } else {
        var maxLabelWidth = Math.max(minLabelBBox.width, maxLabelBBox.width);
        minLabel.attr({
          x: startPoint.x,
          y: startPoint.y
        });
        this.changeRailPosition(railShape, startPoint.x + maxLabelWidth + spacing, startPoint.y);
        maxLabel.attr({
          x: startPoint.x,
          y: startPoint.y + railBBox.height
        });
      }
    };
    return ContinueLegend2;
  }(LegendBase)
);
var CONTAINER_CLASS = "g2-tooltip";
var TITLE_CLASS = "g2-tooltip-title";
var LIST_CLASS = "g2-tooltip-list";
var LIST_ITEM_CLASS = "g2-tooltip-list-item";
var MARKER_CLASS = "g2-tooltip-marker";
var VALUE_CLASS = "g2-tooltip-value";
var NAME_CLASS = "g2-tooltip-name";
var CROSSHAIR_X = "g2-tooltip-crosshair-x";
var CROSSHAIR_Y = "g2-tooltip-crosshair-y";
const CssConst = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  CONTAINER_CLASS,
  CROSSHAIR_X,
  CROSSHAIR_Y,
  LIST_CLASS,
  LIST_ITEM_CLASS,
  MARKER_CLASS,
  NAME_CLASS,
  TITLE_CLASS,
  VALUE_CLASS
}, Symbol.toStringTag, { value: "Module" }));
var _a$3;
const TooltipTheme = (_a$3 = {}, // css style for tooltip
_a$3["" + CONTAINER_CLASS] = {
  position: "absolute",
  visibility: "visible",
  // @2018-07-25 by blue.lb 
  // whiteSpace: 'nowrap',
  zIndex: 8,
  transition: "visibility 0.2s cubic-bezier(0.23, 1, 0.32, 1), left 0.4s cubic-bezier(0.23, 1, 0.32, 1), top 0.4s cubic-bezier(0.23, 1, 0.32, 1)",
  backgroundColor: "rgba(255, 255, 255, 0.9)",
  boxShadow: "0px 0px 10px #aeaeae",
  borderRadius: "3px",
  color: "rgb(87, 87, 87)",
  fontSize: "12px",
  fontFamily: Theme.fontFamily,
  lineHeight: "20px",
  padding: "10px 10px 6px 10px"
}, _a$3["" + TITLE_CLASS] = {
  marginBottom: "4px"
}, _a$3["" + LIST_CLASS] = {
  margin: "0px",
  listStyleType: "none",
  padding: "0px"
}, _a$3["" + LIST_ITEM_CLASS] = {
  listStyleType: "none",
  marginBottom: "4px"
}, _a$3["" + MARKER_CLASS] = {
  width: "8px",
  height: "8px",
  borderRadius: "50%",
  display: "inline-block",
  marginRight: "8px"
}, _a$3["" + VALUE_CLASS] = {
  display: "inline-block",
  float: "right",
  marginLeft: "30px"
}, _a$3["" + CROSSHAIR_X] = {
  position: "absolute",
  width: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3["" + CROSSHAIR_Y] = {
  position: "absolute",
  height: "1px",
  backgroundColor: "rgba(0, 0, 0, 0.25)"
}, _a$3);
function getOutSides(x, y, width, height, limitBox) {
  var hits = {
    left: x < limitBox.x,
    right: x + width > limitBox.x + limitBox.width,
    top: y < limitBox.y,
    bottom: y + height > limitBox.y + limitBox.height
  };
  return hits;
}
function getPointByPosition(x, y, offset, width, height, position) {
  var px = x;
  var py = y;
  switch (position) {
    case "left":
      px = x - width - offset;
      py = y - height / 2;
      break;
    case "right":
      px = x + offset;
      py = y - height / 2;
      break;
    case "top":
      px = x - width / 2;
      py = y - height - offset;
      break;
    case "bottom":
      px = x - width / 2;
      py = y + offset;
      break;
    default:
      px = x + offset;
      py = y - height - offset;
      break;
  }
  return {
    x: px,
    y: py
  };
}
function getAlignPoint(x, y, offset, width, height, position, limitBox) {
  var point2 = getPointByPosition(x, y, offset, width, height, position);
  if (limitBox) {
    var outSides = getOutSides(point2.x, point2.y, width, height, limitBox);
    if (position === "auto") {
      if (outSides.right) {
        point2.x = Math.max(0, x - width - offset);
      }
      if (outSides.top) {
        point2.y = Math.max(0, y - height - offset);
      }
    } else if (position === "top" || position === "bottom") {
      if (outSides.left) {
        point2.x = limitBox.x;
      }
      if (outSides.right) {
        point2.x = limitBox.x + limitBox.width - width;
      }
      if (position === "top" && outSides.top) {
        point2.y = y + offset;
      }
      if (position === "bottom" && outSides.bottom) {
        point2.y = y - height - offset;
      }
    } else {
      if (outSides.top) {
        point2.y = limitBox.y;
      }
      if (outSides.bottom) {
        point2.y = limitBox.y + limitBox.height - height;
      }
      if (position === "left" && outSides.left) {
        point2.x = x + offset;
      }
      if (position === "right" && outSides.right) {
        point2.x = x - width - offset;
      }
    }
  }
  return point2;
}
function hasOneKey(obj, keys2) {
  var result = false;
  each$1(keys2, function(key) {
    if (has(obj, key)) {
      result = true;
      return false;
    }
  });
  return result;
}
var Tooltip$1 = (
  /** @class */
  function(_super) {
    __extends$1(Tooltip2, _super);
    function Tooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Tooltip2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), {
        name: "tooltip",
        type: "html",
        x: 0,
        y: 0,
        items: [],
        customContent: null,
        containerTpl: '<div class="' + CONTAINER_CLASS + '"><div class="' + TITLE_CLASS + '"></div><ul class="' + LIST_CLASS + '"></ul></div>',
        itemTpl: '<li class="' + LIST_ITEM_CLASS + '" data-index={index}>\n          <span class="' + MARKER_CLASS + '" style="background:{color}"></span>\n          <span class="' + NAME_CLASS + '">{name}</span>:\n          <span class="' + VALUE_CLASS + '">{value}</span>\n        </li>',
        xCrosshairTpl: '<div class="' + CROSSHAIR_X + '"></div>',
        yCrosshairTpl: '<div class="' + CROSSHAIR_Y + '"></div>',
        title: null,
        showTitle: true,
        /**
         * tooltip 
         * @type {Region}
         */
        region: null,
        // crosshair 
        crosshairsRegion: null,
        containerClassName: CONTAINER_CLASS,
        // x, y, xy
        crosshairs: null,
        offset: 10,
        position: "right",
        domStyles: null,
        defaultStyles: TooltipTheme
      });
    };
    Tooltip2.prototype.render = function() {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        this.resetTitle();
        this.renderItems();
      }
      this.resetPosition();
    };
    Tooltip2.prototype.clear = function() {
      this.clearCrosshairs();
      this.setTitle("");
      this.clearItemDoms();
    };
    Tooltip2.prototype.show = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", true);
      modifyCSS(container, {
        visibility: "visible"
      });
      this.setCrossHairsVisible(true);
    };
    Tooltip2.prototype.hide = function() {
      var container = this.getContainer();
      if (!container || this.destroyed) {
        return;
      }
      this.set("visible", false);
      modifyCSS(container, {
        visibility: "hidden"
      });
      this.setCrossHairsVisible(false);
    };
    Tooltip2.prototype.getLocation = function() {
      return { x: this.get("x"), y: this.get("y") };
    };
    Tooltip2.prototype.setLocation = function(point2) {
      this.set("x", point2.x);
      this.set("y", point2.y);
      this.resetPosition();
    };
    Tooltip2.prototype.setCrossHairsVisible = function(visible) {
      var display = visible ? "" : "none";
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && modifyCSS(xCrosshairDom, {
        display
      });
      yCrosshairDom && modifyCSS(yCrosshairDom, {
        display
      });
    };
    Tooltip2.prototype.initContainer = function() {
      _super.prototype.initContainer.call(this);
      if (this.get("customContent")) {
        if (this.get("container")) {
          this.get("container").remove();
        }
        var container = this.getHtmlContentNode();
        this.get("parent").appendChild(container);
        this.set("container", container);
        this.resetStyles();
        this.applyStyles();
      }
    };
    Tooltip2.prototype.updateInner = function(cfg) {
      if (this.get("customContent")) {
        this.renderCustomContent();
      } else {
        if (hasOneKey(cfg, ["title", "showTitle"])) {
          this.resetTitle();
        }
        if (has(cfg, "items")) {
          this.renderItems();
        }
      }
      _super.prototype.updateInner.call(this, cfg);
    };
    Tooltip2.prototype.initDom = function() {
      this.cacheDoms();
    };
    Tooltip2.prototype.removeDom = function() {
      _super.prototype.removeDom.call(this);
      this.clearCrosshairs();
    };
    Tooltip2.prototype.resetPosition = function() {
      var x = this.get("x");
      var y = this.get("y");
      var offset = this.get("offset");
      var _a2 = this.getOffset(), offsetX = _a2.offsetX, offsetY = _a2.offsetY;
      var position = this.get("position");
      var region = this.get("region");
      var container = this.getContainer();
      var bbox = this.getBBox();
      var width = bbox.width, height = bbox.height;
      var limitBox;
      if (region) {
        limitBox = regionToBBox(region);
      }
      var point2 = getAlignPoint(x, y, offset, width, height, position, limitBox);
      modifyCSS(container, {
        left: toPx(point2.x + offsetX),
        top: toPx(point2.y + offsetY)
      });
      this.resetCrosshairs();
    };
    Tooltip2.prototype.renderCustomContent = function() {
      var node = this.getHtmlContentNode();
      var parent = this.get("parent");
      var curContainer = this.get("container");
      if (curContainer && curContainer.parentNode === parent) {
        parent.replaceChild(node, curContainer);
      } else {
        parent.appendChild(node);
      }
      this.set("container", node);
      this.resetStyles();
      this.applyStyles();
    };
    Tooltip2.prototype.getHtmlContentNode = function() {
      var node;
      var customContent = this.get("customContent");
      if (customContent) {
        var elem = customContent(this.get("title"), this.get("items"));
        if (isElement(elem)) {
          node = elem;
        } else {
          node = createDom$1(elem);
        }
      }
      return node;
    };
    Tooltip2.prototype.cacheDoms = function() {
      var container = this.getContainer();
      var titleDom = container.getElementsByClassName(TITLE_CLASS)[0];
      var listDom = container.getElementsByClassName(LIST_CLASS)[0];
      this.set("titleDom", titleDom);
      this.set("listDom", listDom);
    };
    Tooltip2.prototype.resetTitle = function() {
      var title = this.get("title");
      var showTitle = this.get("showTitle");
      if (showTitle && title) {
        this.setTitle(title);
      } else {
        this.setTitle("");
      }
    };
    Tooltip2.prototype.setTitle = function(text2) {
      var titleDom = this.get("titleDom");
      if (titleDom) {
        titleDom.innerText = text2;
      }
    };
    Tooltip2.prototype.resetCrosshairs = function() {
      var crosshairsRegion = this.get("crosshairsRegion");
      var crosshairs = this.get("crosshairs");
      if (!crosshairsRegion || !crosshairs) {
        this.clearCrosshairs();
      } else {
        var crosshairBox = regionToBBox(crosshairsRegion);
        var xCrosshairDom = this.get("xCrosshairDom");
        var yCrosshairDom = this.get("yCrosshairDom");
        if (crosshairs === "x") {
          this.resetCrosshair("x", crosshairBox);
          if (yCrosshairDom) {
            yCrosshairDom.remove();
            this.set("yCrosshairDom", null);
          }
        } else if (crosshairs === "y") {
          this.resetCrosshair("y", crosshairBox);
          if (xCrosshairDom) {
            xCrosshairDom.remove();
            this.set("xCrosshairDom", null);
          }
        } else {
          this.resetCrosshair("x", crosshairBox);
          this.resetCrosshair("y", crosshairBox);
        }
        this.setCrossHairsVisible(this.get("visible"));
      }
    };
    Tooltip2.prototype.resetCrosshair = function(name, bbox) {
      var croshairDom = this.checkCrosshair(name);
      var value2 = this.get(name);
      if (name === "x") {
        modifyCSS(croshairDom, {
          left: toPx(value2),
          top: toPx(bbox.y),
          height: toPx(bbox.height)
        });
      } else {
        modifyCSS(croshairDom, {
          top: toPx(value2),
          left: toPx(bbox.x),
          width: toPx(bbox.width)
        });
      }
    };
    Tooltip2.prototype.checkCrosshair = function(name) {
      var domName = name + "CrosshairDom";
      var tplName = name + "CrosshairTpl";
      var constName = "CROSSHAIR_" + name.toUpperCase();
      var styleName = CssConst[constName];
      var croshairDom = this.get(domName);
      var parent = this.get("parent");
      if (!croshairDom) {
        croshairDom = createDom$1(this.get(tplName));
        this.applyStyle(styleName, croshairDom);
        parent.appendChild(croshairDom);
        this.set(domName, croshairDom);
      }
      return croshairDom;
    };
    Tooltip2.prototype.renderItems = function() {
      this.clearItemDoms();
      var items = this.get("items");
      var itemTpl = this.get("itemTpl");
      var listDom = this.get("listDom");
      if (listDom) {
        each$1(items, function(item) {
          var color2 = colorUtil.toCSSGradient(item.color);
          var substituteObj = __assign$1(__assign$1({}, item), { color: color2 });
          var domStr = substitute(itemTpl, substituteObj);
          var itemDom = createDom$1(domStr);
          listDom.appendChild(itemDom);
        });
        this.applyChildrenStyles(listDom, this.get("domStyles"));
      }
    };
    Tooltip2.prototype.clearItemDoms = function() {
      if (this.get("listDom")) {
        clearDom(this.get("listDom"));
      }
    };
    Tooltip2.prototype.clearCrosshairs = function() {
      var xCrosshairDom = this.get("xCrosshairDom");
      var yCrosshairDom = this.get("yCrosshairDom");
      xCrosshairDom && xCrosshairDom.remove();
      yCrosshairDom && yCrosshairDom.remove();
      this.set("xCrosshairDom", null);
      this.set("yCrosshairDom", null);
    };
    return Tooltip2;
  }(HtmlComponent)
);
var BACKGROUND_STYLE$1 = {
  // fill: 'red',
  opacity: 0
};
var LINE_STYLE = {
  stroke: "#C5C5C5",
  strokeOpacity: 0.85
};
var AREA_STYLE = {
  fill: "#CACED4",
  opacity: 0.85
};
function pointsToPath(points2) {
  return map$2(points2, function(p, idx) {
    var command = idx === 0 ? "M" : "L";
    var x = p[0], y = p[1];
    return [command, x, y];
  });
}
function getLinePath$1(points2) {
  return pointsToPath(points2);
}
function getSmoothLinePath(points2) {
  if (points2.length <= 2) {
    return getLinePath$1(points2);
  }
  var data2 = [];
  each$1(points2, function(p) {
    if (!isEqual$1(p, data2.slice(data2.length - 2))) {
      data2.push(p[0], p[1]);
    }
  });
  var path2 = catmullRom2Bezier(data2, false);
  var _a2 = head(points2), x = _a2[0], y = _a2[1];
  path2.unshift(["M", x, y]);
  return path2;
}
function dataToPath(data2, width, height, smooth) {
  if (smooth === void 0) {
    smooth = true;
  }
  var y = new Linear({
    values: data2
  });
  var x = new Category$1({
    values: map$2(data2, function(v, idx) {
      return idx;
    })
  });
  var points2 = map$2(data2, function(v, idx) {
    return [x.scale(idx) * width, height - y.scale(v) * height];
  });
  return smooth ? getSmoothLinePath(points2) : getLinePath$1(points2);
}
function getAreaLineY(data2, height) {
  var y = new Linear({
    values: data2
  });
  var lineY = y.max < 0 ? y.max : Math.max(0, y.min);
  return height - y.scale(lineY) * height;
}
function linePathToAreaPath(path2, width, height, data2) {
  var areaPath = __spreadArrays(path2);
  var lineYPx = getAreaLineY(data2, height);
  areaPath.push(["L", width, lineYPx]);
  areaPath.push(["L", 0, lineYPx]);
  areaPath.push(["Z"]);
  return areaPath;
}
var Trend = (
  /** @class */
  function(_super) {
    __extends$1(Trend2, _super);
    function Trend2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Trend2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "trend", x: 0, y: 0, width: 200, height: 16, smooth: true, isArea: false, data: [], backgroundStyle: BACKGROUND_STYLE$1, lineStyle: LINE_STYLE, areaStyle: AREA_STYLE });
    };
    Trend2.prototype.renderInner = function(group2) {
      var _a2 = this.cfg, width = _a2.width, height = _a2.height, data2 = _a2.data, smooth = _a2.smooth, isArea = _a2.isArea, backgroundStyle = _a2.backgroundStyle, lineStyle = _a2.lineStyle, areaStyle = _a2.areaStyle;
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign$1({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      var path2 = dataToPath(data2, width, height, smooth);
      this.addShape(group2, {
        id: this.getElementId("line"),
        type: "path",
        attrs: __assign$1({ path: path2 }, lineStyle)
      });
      if (isArea) {
        var areaPath = linePathToAreaPath(path2, width, height, data2);
        this.addShape(group2, {
          id: this.getElementId("area"),
          type: "path",
          attrs: __assign$1({ path: areaPath }, areaStyle)
        });
      }
    };
    Trend2.prototype.applyOffset = function() {
      var _a2 = this.cfg, x = _a2.x, y = _a2.y;
      this.moveElementTo(this.get("group"), {
        x,
        y
      });
    };
    return Trend2;
  }(GroupComponent)
);
var DEFAULT_HANDLER_STYLE = {
  fill: "#F7F7F7",
  stroke: "#BFBFBF",
  radius: 2,
  opacity: 1,
  cursor: "ew-resize",
  // 
  highLightFill: "#FFF"
};
var Handler = (
  /** @class */
  function(_super) {
    __extends$1(Handler2, _super);
    function Handler2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Handler2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "handler", x: 0, y: 0, width: 10, height: 24, style: DEFAULT_HANDLER_STYLE });
    };
    Handler2.prototype.renderInner = function(group2) {
      var _a2 = this.cfg, width = _a2.width, height = _a2.height, style = _a2.style;
      var fill = style.fill, stroke = style.stroke, radius = style.radius, opacity = style.opacity, cursor = style.cursor;
      this.addShape(group2, {
        type: "rect",
        id: this.getElementId("background"),
        attrs: {
          x: 0,
          y: 0,
          width,
          height,
          fill,
          stroke,
          radius,
          opacity,
          cursor
        }
      });
      var x1 = 1 / 3 * width;
      var x2 = 2 / 3 * width;
      var y1 = 1 / 4 * height;
      var y2 = 3 / 4 * height;
      this.addShape(group2, {
        id: this.getElementId("line-left"),
        type: "line",
        attrs: {
          x1,
          y1,
          x2: x1,
          y2,
          stroke,
          cursor
        }
      });
      this.addShape(group2, {
        id: this.getElementId("line-right"),
        type: "line",
        attrs: {
          x1: x2,
          y1,
          x2,
          y2,
          stroke,
          cursor
        }
      });
    };
    Handler2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Handler2.prototype.initEvent = function() {
      this.bindEvents();
    };
    Handler2.prototype.bindEvents = function() {
      var _this = this;
      this.get("group").on("mouseenter", function() {
        var highLightFill = _this.get("style").highLightFill;
        _this.getElementByLocalId("background").attr("fill", highLightFill);
        _this.draw();
      });
      this.get("group").on("mouseleave", function() {
        var fill = _this.get("style").fill;
        _this.getElementByLocalId("background").attr("fill", fill);
        _this.draw();
      });
    };
    Handler2.prototype.draw = function() {
      var canvas = this.get("container").get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    return Handler2;
  }(GroupComponent)
);
var BACKGROUND_STYLE = {
  fill: "#416180",
  opacity: 0.05
};
var FOREGROUND_STYLE = {
  fill: "#5B8FF9",
  opacity: 0.15,
  cursor: "move"
};
var DEFAULT_HANDLER_WIDTH = 10;
var HANDLER_STYLE = {
  width: DEFAULT_HANDLER_WIDTH,
  height: 24
};
var TEXT_STYLE = {
  textBaseline: "middle",
  fill: "#000",
  opacity: 0.45
};
var SLIDER_CHANGE = "sliderchange";
var Slider$1 = (
  /** @class */
  function(_super) {
    __extends$1(Slider2, _super);
    function Slider2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.onMouseDown = function(target2) {
        return function(e) {
          _this.currentTarget = target2;
          var event = e.originalEvent;
          event.stopPropagation();
          event.preventDefault();
          _this.prevX = get(event, "touches.0.pageX", event.pageX);
          _this.prevY = get(event, "touches.0.pageY", event.pageY);
          var containerDOM = _this.getContainerDOM();
          containerDOM.addEventListener("mousemove", _this.onMouseMove);
          containerDOM.addEventListener("mouseup", _this.onMouseUp);
          containerDOM.addEventListener("mouseleave", _this.onMouseUp);
          containerDOM.addEventListener("touchmove", _this.onMouseMove);
          containerDOM.addEventListener("touchend", _this.onMouseUp);
          containerDOM.addEventListener("touchcancel", _this.onMouseUp);
        };
      };
      _this.onMouseMove = function(event) {
        var width = _this.cfg.width;
        var originValue = [_this.get("start"), _this.get("end")];
        event.stopPropagation();
        event.preventDefault();
        var x = get(event, "touches.0.pageX", event.pageX);
        var y = get(event, "touches.0.pageY", event.pageY);
        var offsetX = x - _this.prevX;
        var offsetXRange = _this.adjustOffsetRange(offsetX / width);
        _this.updateStartEnd(offsetXRange);
        _this.updateUI(_this.getElementByLocalId("foreground"), _this.getElementByLocalId("minText"), _this.getElementByLocalId("maxText"));
        _this.prevX = x;
        _this.prevY = y;
        _this.draw();
        _this.emit(SLIDER_CHANGE, [_this.get("start"), _this.get("end")].sort());
        _this.delegateEmit("valuechanged", {
          originValue,
          value: [_this.get("start"), _this.get("end")]
        });
      };
      _this.onMouseUp = function() {
        if (_this.currentTarget) {
          _this.currentTarget = void 0;
        }
        var containerDOM = _this.getContainerDOM();
        if (containerDOM) {
          containerDOM.removeEventListener("mousemove", _this.onMouseMove);
          containerDOM.removeEventListener("mouseup", _this.onMouseUp);
          containerDOM.removeEventListener("mouseleave", _this.onMouseUp);
          containerDOM.removeEventListener("touchmove", _this.onMouseMove);
          containerDOM.removeEventListener("touchend", _this.onMouseUp);
          containerDOM.removeEventListener("touchcancel", _this.onMouseUp);
        }
      };
      return _this;
    }
    Slider2.prototype.setRange = function(min2, max2) {
      this.set("minLimit", min2);
      this.set("maxLimit", max2);
      var oldStart = this.get("start");
      var oldEnd = this.get("end");
      var newStart = clamp(oldStart, min2, max2);
      var newEnd = clamp(oldEnd, min2, max2);
      if (!this.get("isInit") && (oldStart !== newStart || oldEnd !== newEnd)) {
        this.setValue([newStart, newEnd]);
      }
    };
    Slider2.prototype.getRange = function() {
      return {
        min: this.get("minLimit") || 0,
        max: this.get("maxLimit") || 1
      };
    };
    Slider2.prototype.setValue = function(value2) {
      var range = this.getRange();
      if (isArray$1(value2) && value2.length === 2) {
        var originValue = [this.get("start"), this.get("end")];
        this.update({
          start: clamp(value2[0], range.min, range.max),
          end: clamp(value2[1], range.min, range.max)
        });
        if (!this.get("updateAutoRender")) {
          this.render();
        }
        this.delegateEmit("valuechanged", {
          originValue,
          value: value2
        });
      }
    };
    Slider2.prototype.getValue = function() {
      return [this.get("start"), this.get("end")];
    };
    Slider2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "slider", x: 0, y: 0, width: 100, height: 16, backgroundStyle: {}, foregroundStyle: {}, handlerStyle: {}, textStyle: {}, defaultCfg: {
        backgroundStyle: BACKGROUND_STYLE,
        foregroundStyle: FOREGROUND_STYLE,
        handlerStyle: HANDLER_STYLE,
        textStyle: TEXT_STYLE
      } });
    };
    Slider2.prototype.update = function(cfg) {
      var start = cfg.start, end = cfg.end;
      var validCfg = __assign$1({}, cfg);
      if (!isNil(start)) {
        validCfg.start = clamp(start, 0, 1);
      }
      if (!isNil(end)) {
        validCfg.end = clamp(end, 0, 1);
      }
      _super.prototype.update.call(this, validCfg);
      this.minHandler = this.getChildComponentById(this.getElementId("minHandler"));
      this.maxHandler = this.getChildComponentById(this.getElementId("maxHandler"));
      this.trend = this.getChildComponentById(this.getElementId("trend"));
    };
    Slider2.prototype.init = function() {
      this.set("start", clamp(this.get("start"), 0, 1));
      this.set("end", clamp(this.get("end"), 0, 1));
      _super.prototype.init.call(this);
    };
    Slider2.prototype.render = function() {
      _super.prototype.render.call(this);
      this.updateUI(this.getElementByLocalId("foreground"), this.getElementByLocalId("minText"), this.getElementByLocalId("maxText"));
    };
    Slider2.prototype.renderInner = function(group2) {
      var _a2 = this.cfg;
      _a2.start;
      _a2.end;
      var width = _a2.width, height = _a2.height, _b = _a2.trendCfg, trendCfg = _b === void 0 ? {} : _b, minText = _a2.minText, maxText = _a2.maxText, _c = _a2.backgroundStyle, backgroundStyle = _c === void 0 ? {} : _c, _d = _a2.foregroundStyle, foregroundStyle = _d === void 0 ? {} : _d, _e = _a2.textStyle, textStyle2 = _e === void 0 ? {} : _e;
      var handlerStyle = deepMix({}, DEFAULT_HANDLER_STYLE, this.cfg.handlerStyle);
      if (size(get(trendCfg, "data"))) {
        this.trend = this.addComponent(group2, __assign$1({
          component: Trend,
          id: this.getElementId("trend"),
          x: 0,
          y: 0,
          width,
          height
        }, trendCfg));
      }
      this.addShape(group2, {
        id: this.getElementId("background"),
        type: "rect",
        attrs: __assign$1({
          x: 0,
          y: 0,
          width,
          height
        }, backgroundStyle)
      });
      this.addShape(group2, {
        id: this.getElementId("minText"),
        type: "text",
        attrs: __assign$1({
          // x: 0,
          y: height / 2,
          textAlign: "right",
          text: minText,
          silent: false
        }, textStyle2)
      });
      this.addShape(group2, {
        id: this.getElementId("maxText"),
        type: "text",
        attrs: __assign$1({
          // x: 0,
          y: height / 2,
          textAlign: "left",
          text: maxText,
          silent: false
        }, textStyle2)
      });
      this.addShape(group2, {
        id: this.getElementId("foreground"),
        name: "foreground",
        type: "rect",
        attrs: __assign$1({
          // x: 0,
          y: 0,
          // width: 0,
          height
        }, foregroundStyle)
      });
      var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var handlerHeight = get(handlerStyle, "height", 24);
      this.minHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("minHandler"),
        name: "handler-min",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
      this.maxHandler = this.addComponent(group2, {
        component: Handler,
        id: this.getElementId("maxHandler"),
        name: "handler-max",
        x: 0,
        y: (height - handlerHeight) / 2,
        width: handlerWidth,
        height: handlerHeight,
        cursor: "ew-resize",
        style: handlerStyle
      });
    };
    Slider2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Slider2.prototype.initEvent = function() {
      this.bindEvents();
    };
    Slider2.prototype.updateUI = function(foregroundShape, minTextShape, maxTextShape) {
      var _a2 = this.cfg, start = _a2.start, end = _a2.end, width = _a2.width, minText = _a2.minText, maxText = _a2.maxText, handlerStyle = _a2.handlerStyle, height = _a2.height;
      var min2 = start * width;
      var max2 = end * width;
      if (this.trend) {
        this.trend.update({
          width,
          height
        });
        if (!this.get("updateAutoRender")) {
          this.trend.render();
        }
      }
      foregroundShape.attr("x", min2);
      foregroundShape.attr("width", max2 - min2);
      var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      minTextShape.attr("text", minText);
      maxTextShape.attr("text", maxText);
      var _b = this._dodgeText([min2, max2], minTextShape, maxTextShape), minAttrs = _b[0], maxAttrs = _b[1];
      if (this.minHandler) {
        this.minHandler.update({
          x: min2 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.minHandler.render();
        }
      }
      each$1(minAttrs, function(v, k) {
        return minTextShape.attr(k, v);
      });
      if (this.maxHandler) {
        this.maxHandler.update({
          x: max2 - handlerWidth / 2
        });
        if (!this.get("updateAutoRender")) {
          this.maxHandler.render();
        }
      }
      each$1(maxAttrs, function(v, k) {
        return maxTextShape.attr(k, v);
      });
    };
    Slider2.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("handler-min:mousedown", this.onMouseDown("minHandler"));
      group2.on("handler-min:touchstart", this.onMouseDown("minHandler"));
      group2.on("handler-max:mousedown", this.onMouseDown("maxHandler"));
      group2.on("handler-max:touchstart", this.onMouseDown("maxHandler"));
      var foreground = group2.findById(this.getElementId("foreground"));
      foreground.on("mousedown", this.onMouseDown("foreground"));
      foreground.on("touchstart", this.onMouseDown("foreground"));
    };
    Slider2.prototype.adjustOffsetRange = function(offsetRange) {
      var _a2 = this.cfg, start = _a2.start, end = _a2.end;
      switch (this.currentTarget) {
        case "minHandler": {
          var min2 = 0 - start;
          var max2 = 1 - start;
          return Math.min(max2, Math.max(min2, offsetRange));
        }
        case "maxHandler": {
          var min2 = 0 - end;
          var max2 = 1 - end;
          return Math.min(max2, Math.max(min2, offsetRange));
        }
        case "foreground": {
          var min2 = 0 - start;
          var max2 = 1 - end;
          return Math.min(max2, Math.max(min2, offsetRange));
        }
      }
    };
    Slider2.prototype.updateStartEnd = function(offsetRange) {
      var _a2 = this.cfg, start = _a2.start, end = _a2.end;
      switch (this.currentTarget) {
        case "minHandler":
          start += offsetRange;
          break;
        case "maxHandler":
          end += offsetRange;
          break;
        case "foreground":
          start += offsetRange;
          end += offsetRange;
          break;
      }
      this.set("start", start);
      this.set("end", end);
    };
    Slider2.prototype._dodgeText = function(range, minTextShape, maxTextShape) {
      var _a2, _b;
      var _c = this.cfg, handlerStyle = _c.handlerStyle, width = _c.width;
      var PADDING2 = 2;
      var handlerWidth = get(handlerStyle, "width", DEFAULT_HANDLER_WIDTH);
      var min2 = range[0], max2 = range[1];
      var sorted = false;
      if (min2 > max2) {
        _a2 = [max2, min2], min2 = _a2[0], max2 = _a2[1];
        _b = [maxTextShape, minTextShape], minTextShape = _b[0], maxTextShape = _b[1];
        sorted = true;
      }
      var minBBox = minTextShape.getBBox();
      var maxBBox = maxTextShape.getBBox();
      var minAttrs = minBBox.width > min2 - PADDING2 ? { x: min2 + handlerWidth / 2 + PADDING2, textAlign: "left" } : { x: min2 - handlerWidth / 2 - PADDING2, textAlign: "right" };
      var maxAttrs = maxBBox.width > width - max2 - PADDING2 ? { x: max2 - handlerWidth / 2 - PADDING2, textAlign: "right" } : { x: max2 + handlerWidth / 2 + PADDING2, textAlign: "left" };
      return !sorted ? [minAttrs, maxAttrs] : [maxAttrs, minAttrs];
    };
    Slider2.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Slider2.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    return Slider2;
  }(GroupComponent)
);
var DEFAULT_STYLE = {
  trackColor: "rgba(0,0,0,0)",
  thumbColor: "rgba(0,0,0,0.15)",
  size: 8,
  lineCap: "round"
};
var DEFAULT_THEME = {
  // 
  default: DEFAULT_STYLE,
  //  hover 
  hover: {
    thumbColor: "rgba(0,0,0,0.2)"
  }
};
var Scrollbar$1 = (
  /** @class */
  function(_super) {
    __extends$1(Scrollbar2, _super);
    function Scrollbar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.clearEvents = noop;
      _this.onStartEvent = function(isMobile) {
        return function(e) {
          _this.isMobile = isMobile;
          e.originalEvent.preventDefault();
          var clientX = isMobile ? get(e.originalEvent, "touches.0.clientX") : e.clientX;
          var clientY = isMobile ? get(e.originalEvent, "touches.0.clientY") : e.clientY;
          _this.startPos = _this.cfg.isHorizontal ? clientX : clientY;
          _this.bindLaterEvent();
        };
      };
      _this.bindLaterEvent = function() {
        var containerDOM = _this.getContainerDOM();
        var events = [];
        if (_this.isMobile) {
          events = [
            addEventListener(containerDOM, "touchmove", _this.onMouseMove),
            addEventListener(containerDOM, "touchend", _this.onMouseUp),
            addEventListener(containerDOM, "touchcancel", _this.onMouseUp)
          ];
        } else {
          events = [
            addEventListener(containerDOM, "mousemove", _this.onMouseMove),
            addEventListener(containerDOM, "mouseup", _this.onMouseUp),
            //  canvas containerDom  mouseup
            addEventListener(containerDOM, "mouseleave", _this.onMouseUp)
          ];
        }
        _this.clearEvents = function() {
          events.forEach(function(e) {
            e.remove();
          });
        };
      };
      _this.onMouseMove = function(e) {
        var _a2 = _this.cfg, isHorizontal2 = _a2.isHorizontal, thumbOffset = _a2.thumbOffset;
        e.preventDefault();
        var clientX = _this.isMobile ? get(e, "touches.0.clientX") : e.clientX;
        var clientY = _this.isMobile ? get(e, "touches.0.clientY") : e.clientY;
        var endPos = isHorizontal2 ? clientX : clientY;
        var diff2 = endPos - _this.startPos;
        _this.startPos = endPos;
        _this.updateThumbOffset(thumbOffset + diff2);
      };
      _this.onMouseUp = function(e) {
        e.preventDefault();
        _this.clearEvents();
      };
      _this.onTrackClick = function(e) {
        var _a2 = _this.cfg, isHorizontal2 = _a2.isHorizontal, x = _a2.x, y = _a2.y, thumbLen = _a2.thumbLen;
        var containerDOM = _this.getContainerDOM();
        var rect2 = containerDOM.getBoundingClientRect();
        var clientX = e.clientX, clientY = e.clientY;
        var offset = isHorizontal2 ? clientX - rect2.left - x - thumbLen / 2 : clientY - rect2.top - y - thumbLen / 2;
        var newOffset = _this.validateRange(offset);
        _this.updateThumbOffset(newOffset);
      };
      _this.onThumbMouseOver = function() {
        var thumbColor = _this.cfg.theme.hover.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      _this.onThumbMouseOut = function() {
        var thumbColor = _this.cfg.theme.default.thumbColor;
        _this.getElementByLocalId("thumb").attr("stroke", thumbColor);
        _this.draw();
      };
      return _this;
    }
    Scrollbar2.prototype.setRange = function(min2, max2) {
      this.set("minLimit", min2);
      this.set("maxLimit", max2);
      var curValue = this.getValue();
      var newValue = clamp(curValue, min2, max2);
      if (curValue !== newValue && !this.get("isInit")) {
        this.setValue(newValue);
      }
    };
    Scrollbar2.prototype.getRange = function() {
      var min2 = this.get("minLimit") || 0;
      var max2 = this.get("maxLimit") || 1;
      return { min: min2, max: max2 };
    };
    Scrollbar2.prototype.setValue = function(value2) {
      var range = this.getRange();
      var originalValue = this.getValue();
      this.update({
        thumbOffset: (this.get("trackLen") - this.get("thumbLen")) * clamp(value2, range.min, range.max)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: this.getValue()
      });
    };
    Scrollbar2.prototype.getValue = function() {
      return clamp(this.get("thumbOffset") / (this.get("trackLen") - this.get("thumbLen")), 0, 1);
    };
    Scrollbar2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      return __assign$1(__assign$1({}, cfg), { name: "scrollbar", isHorizontal: true, minThumbLen: 20, thumbOffset: 0, theme: DEFAULT_THEME });
    };
    Scrollbar2.prototype.renderInner = function(group2) {
      this.renderTrackShape(group2);
      this.renderThumbShape(group2);
    };
    Scrollbar2.prototype.applyOffset = function() {
      this.moveElementTo(this.get("group"), {
        x: this.get("x"),
        y: this.get("y")
      });
    };
    Scrollbar2.prototype.initEvent = function() {
      this.bindEvents();
    };
    Scrollbar2.prototype.renderTrackShape = function(group2) {
      var _a2 = this.cfg, trackLen = _a2.trackLen, _b = _a2.theme, theme2 = _b === void 0 ? { default: {} } : _b;
      var _c = deepMix({}, DEFAULT_THEME, theme2).default, lineCap = _c.lineCap, trackColor = _c.trackColor, themeSize = _c.size;
      var size2 = get(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: 0 + size2 / 2,
        y1: size2 / 2,
        x2: trackLen - size2 / 2,
        y2: size2 / 2,
        lineWidth: size2,
        stroke: trackColor,
        lineCap
      } : {
        x1: size2 / 2,
        y1: 0 + size2 / 2,
        x2: size2 / 2,
        y2: trackLen - size2 / 2,
        lineWidth: size2,
        stroke: trackColor,
        lineCap
      };
      return this.addShape(group2, {
        id: this.getElementId("track"),
        name: "track",
        type: "line",
        attrs
      });
    };
    Scrollbar2.prototype.renderThumbShape = function(group2) {
      var _a2 = this.cfg, thumbOffset = _a2.thumbOffset, thumbLen = _a2.thumbLen, theme2 = _a2.theme;
      var _b = deepMix({}, DEFAULT_THEME, theme2).default, themeSize = _b.size, lineCap = _b.lineCap, thumbColor = _b.thumbColor;
      var size2 = get(this.cfg, "size", themeSize);
      var attrs = this.get("isHorizontal") ? {
        x1: thumbOffset + size2 / 2,
        y1: size2 / 2,
        x2: thumbOffset + thumbLen - size2 / 2,
        y2: size2 / 2,
        lineWidth: size2,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      } : {
        x1: size2 / 2,
        y1: thumbOffset + size2 / 2,
        x2: size2 / 2,
        y2: thumbOffset + thumbLen - size2 / 2,
        lineWidth: size2,
        stroke: thumbColor,
        lineCap,
        cursor: "default"
      };
      return this.addShape(group2, {
        id: this.getElementId("thumb"),
        name: "thumb",
        type: "line",
        attrs
      });
    };
    Scrollbar2.prototype.bindEvents = function() {
      var group2 = this.get("group");
      group2.on("mousedown", this.onStartEvent(false));
      group2.on("mouseup", this.onMouseUp);
      group2.on("touchstart", this.onStartEvent(true));
      group2.on("touchend", this.onMouseUp);
      var trackShape = group2.findById(this.getElementId("track"));
      trackShape.on("click", this.onTrackClick);
      var thumbShape = group2.findById(this.getElementId("thumb"));
      thumbShape.on("mouseover", this.onThumbMouseOver);
      thumbShape.on("mouseout", this.onThumbMouseOut);
    };
    Scrollbar2.prototype.getContainerDOM = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      return canvas && canvas.get("container");
    };
    Scrollbar2.prototype.validateRange = function(offset) {
      var _a2 = this.cfg, thumbLen = _a2.thumbLen, trackLen = _a2.trackLen;
      var newOffset = offset;
      if (offset + thumbLen > trackLen) {
        newOffset = trackLen - thumbLen;
      } else if (offset + thumbLen < thumbLen) {
        newOffset = 0;
      }
      return newOffset;
    };
    Scrollbar2.prototype.draw = function() {
      var container = this.get("container");
      var canvas = container && container.get("canvas");
      if (canvas) {
        canvas.draw();
      }
    };
    Scrollbar2.prototype.updateThumbOffset = function(offset) {
      var _a2 = this.cfg, thumbOffset = _a2.thumbOffset, isHorizontal2 = _a2.isHorizontal, thumbLen = _a2.thumbLen, size2 = _a2.size;
      var newOffset = this.validateRange(offset);
      if (newOffset === thumbOffset) {
        return;
      }
      var thumbShape = this.getElementByLocalId("thumb");
      if (isHorizontal2) {
        thumbShape.attr({
          x1: newOffset + size2 / 2,
          x2: newOffset + thumbLen - size2 / 2
        });
      } else {
        thumbShape.attr({
          y1: newOffset + size2 / 2,
          y2: newOffset + thumbLen - size2 / 2
        });
      }
      this.emitOffsetChange(newOffset);
    };
    Scrollbar2.prototype.emitOffsetChange = function(offset) {
      var _a2 = this.cfg, originalValue = _a2.thumbOffset, trackLen = _a2.trackLen, thumbLen = _a2.thumbLen;
      this.cfg.thumbOffset = offset;
      this.emit("scrollchange", {
        thumbOffset: offset,
        ratio: clamp(offset / (trackLen - thumbLen), 0, 1)
      });
      this.delegateEmit("valuechange", {
        originalValue,
        value: offset
      });
    };
    return Scrollbar2;
  }(GroupComponent)
);
var LineAxis = Line$5, CircleAxis = Circle$4;
var LineGrid = Line$4, CircleGrid = Circle$3;
var CategoryLegend = Category, ContinuousLegend = ContinueLegend;
var HtmlTooltip = Tooltip$1;
function getPointsBox(points2) {
  if (isEmpty(points2)) {
    return null;
  }
  var minX = points2[0].x;
  var maxX = points2[0].x;
  var minY = points2[0].y;
  var maxY2 = points2[0].y;
  each$1(points2, function(point2) {
    minX = minX > point2.x ? point2.x : minX;
    maxX = maxX < point2.x ? point2.x : maxX;
    minY = minY > point2.y ? point2.y : minY;
    maxY2 = maxY2 < point2.y ? point2.y : maxY2;
  });
  return {
    minX,
    maxX,
    minY,
    maxY: maxY2,
    centerX: (minX + maxX) / 2,
    centerY: (minY + maxY2) / 2
  };
}
function uniqueValues(array2) {
  return Array.from(new Set(array2)).length === 1;
}
function mid(array2) {
  return (min$2(array2) + max$2(array2)) / 2;
}
function polarToCartesian(centerX, centerY, radius, angleInRadian) {
  return {
    x: centerX + radius * Math.cos(angleInRadian),
    y: centerY + radius * Math.sin(angleInRadian)
  };
}
function getSectorPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian, innerRadius) {
  if (innerRadius === void 0) {
    innerRadius = 0;
  }
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  var innerStart = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian);
  var innerEnd = polarToCartesian(centerX, centerY, innerRadius, endAngleInRadian);
  if (endAngleInRadian - startAngleInRadian === Math.PI * 2) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    var innerMiddlePoint = polarToCartesian(centerX, centerY, innerRadius, startAngleInRadian + Math.PI);
    var circlePathCommands = [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, end.x, end.y],
      ["M", innerStart.x, innerStart.y]
    ];
    if (innerRadius) {
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerMiddlePoint.x, innerMiddlePoint.y]);
      circlePathCommands.push(["A", innerRadius, innerRadius, 0, 1, 0, innerEnd.x, innerEnd.y]);
    }
    circlePathCommands.push(["M", start.x, start.y]);
    circlePathCommands.push(["Z"]);
    return circlePathCommands;
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  var sectorPathCommands = [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y],
    ["L", innerEnd.x, innerEnd.y]
  ];
  if (innerRadius) {
    sectorPathCommands.push(["A", innerRadius, innerRadius, 0, arcSweep, 0, innerStart.x, innerStart.y]);
  }
  sectorPathCommands.push(["L", start.x, start.y]);
  sectorPathCommands.push(["Z"]);
  return sectorPathCommands;
}
function getArcPath(centerX, centerY, radius, startAngleInRadian, endAngleInRadian) {
  var start = polarToCartesian(centerX, centerY, radius, startAngleInRadian);
  var end = polarToCartesian(centerX, centerY, radius, endAngleInRadian);
  if (isNumberEqual$1(endAngleInRadian - startAngleInRadian, Math.PI * 2)) {
    var middlePoint = polarToCartesian(centerX, centerY, radius, startAngleInRadian + Math.PI);
    return [
      ["M", start.x, start.y],
      ["A", radius, radius, 0, 1, 1, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 1, start.x, start.y],
      ["A", radius, radius, 0, 1, 0, middlePoint.x, middlePoint.y],
      ["A", radius, radius, 0, 1, 0, start.x, start.y],
      ["Z"]
    ];
  }
  var arcSweep = endAngleInRadian - startAngleInRadian <= Math.PI ? 0 : 1;
  return [
    ["M", start.x, start.y],
    ["A", radius, radius, 0, arcSweep, 1, end.x, end.y]
  ];
}
function getAngle$1(shapeModel, coordinate2) {
  var points2 = shapeModel.points;
  var box2 = getPointsBox(points2);
  var endAngle;
  var startAngle;
  var coordStartAngle = coordinate2.startAngle, coordEndAngle = coordinate2.endAngle;
  var diffAngle = coordEndAngle - coordStartAngle;
  if (coordinate2.isTransposed) {
    endAngle = box2.maxY * diffAngle;
    startAngle = box2.minY * diffAngle;
  } else {
    endAngle = box2.maxX * diffAngle;
    startAngle = box2.minX * diffAngle;
  }
  endAngle += coordStartAngle;
  startAngle += coordStartAngle;
  return {
    startAngle,
    endAngle
  };
}
function getPolygonCentroid(xs, ys) {
  if (isNumber$1(xs) && isNumber$1(ys)) {
    return [xs, ys];
  }
  xs = xs;
  ys = ys;
  if (uniqueValues(xs) || uniqueValues(ys))
    return [mid(xs), mid(ys)];
  var i = -1;
  var x = 0;
  var y = 0;
  var former;
  var current = xs.length - 1;
  var diff2;
  var k = 0;
  while (++i < xs.length) {
    former = current;
    current = i;
    k += diff2 = xs[former] * ys[current] - xs[current] * ys[former];
    x += (xs[former] + xs[current]) * diff2;
    y += (ys[former] + ys[current]) * diff2;
  }
  k *= 3;
  return [x / k, y / k];
}
function getReplaceAttrs(sourceShape, targetShape) {
  var originAttrs = sourceShape.attr();
  var newAttrs = targetShape.attr();
  each$1(originAttrs, function(v, k) {
    if (newAttrs[k] === void 0) {
      newAttrs[k] = void 0;
    }
  });
  return newAttrs;
}
function isBetween$1(value2, start, end) {
  var min2 = Math.min(start, end);
  var max2 = Math.max(start, end);
  return value2 >= min2 && value2 <= max2;
}
function padEnd(source, targetLength, padValue) {
  if (isString(source)) {
    return source.padEnd(targetLength, padValue);
  } else if (isArray$1(source)) {
    var sourceLength = source.length;
    if (sourceLength < targetLength) {
      var diff2 = targetLength - sourceLength;
      for (var i = 0; i < diff2; i++) {
        source.push(padValue);
      }
    }
  }
  return source;
}
function omit(obj, keys2) {
  if (typeof obj === "object") {
    keys2.forEach(function(key) {
      delete obj[key];
    });
  }
  return obj;
}
function uniq$1(sourceArray, targetArray, map2) {
  var e_1, _a2;
  if (targetArray === void 0) {
    targetArray = [];
  }
  if (map2 === void 0) {
    map2 = /* @__PURE__ */ new Map();
  }
  try {
    for (var sourceArray_1 = __values(sourceArray), sourceArray_1_1 = sourceArray_1.next(); !sourceArray_1_1.done; sourceArray_1_1 = sourceArray_1.next()) {
      var source = sourceArray_1_1.value;
      if (!map2.has(source)) {
        targetArray.push(source);
        map2.set(source, true);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (sourceArray_1_1 && !sourceArray_1_1.done && (_a2 = sourceArray_1.return))
        _a2.call(sourceArray_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  return targetArray;
}
var BBox = (
  /** @class */
  function() {
    function BBox2(x, y, width, height) {
      if (x === void 0) {
        x = 0;
      }
      if (y === void 0) {
        y = 0;
      }
      if (width === void 0) {
        width = 0;
      }
      if (height === void 0) {
        height = 0;
      }
      this.x = x;
      this.y = y;
      this.height = height;
      this.width = width;
    }
    BBox2.fromRange = function(minX, minY, maxX, maxY2) {
      return new BBox2(minX, minY, maxX - minX, maxY2 - minY);
    };
    BBox2.fromObject = function(bbox) {
      return new BBox2(bbox.minX, bbox.minY, bbox.width, bbox.height);
    };
    Object.defineProperty(BBox2.prototype, "minX", {
      get: function() {
        return this.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxX", {
      get: function() {
        return this.x + this.width;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "minY", {
      get: function() {
        return this.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "maxY", {
      get: function() {
        return this.y + this.height;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tl", {
      get: function() {
        return { x: this.x, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "tr", {
      get: function() {
        return { x: this.maxX, y: this.y };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bl", {
      get: function() {
        return { x: this.x, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "br", {
      get: function() {
        return { x: this.maxX, y: this.maxY };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "top", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.minY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "right", {
      get: function() {
        return {
          x: this.maxX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "bottom", {
      get: function() {
        return {
          x: this.x + this.width / 2,
          y: this.maxY
        };
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(BBox2.prototype, "left", {
      get: function() {
        return {
          x: this.minX,
          y: this.y + this.height / 2
        };
      },
      enumerable: false,
      configurable: true
    });
    BBox2.prototype.isEqual = function(bbox) {
      return this.x === bbox.x && this.y === bbox.y && this.width === bbox.width && this.height === bbox.height;
    };
    BBox2.prototype.contains = function(child) {
      return child.minX >= this.minX && child.maxX <= this.maxX && child.minY >= this.minY && child.maxY <= this.maxY;
    };
    BBox2.prototype.clone = function() {
      return new BBox2(this.x, this.y, this.width, this.height);
    };
    BBox2.prototype.add = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each$1(subBBox, function(b) {
        bbox.x = Math.min(b.x, bbox.x);
        bbox.y = Math.min(b.y, bbox.y);
        bbox.width = Math.max(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.max(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.merge = function() {
      var subBBox = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        subBBox[_i] = arguments[_i];
      }
      var bbox = this.clone();
      each$1(subBBox, function(b) {
        bbox.x = Math.max(b.x, bbox.x);
        bbox.y = Math.max(b.y, bbox.y);
        bbox.width = Math.min(b.maxX, bbox.maxX) - bbox.x;
        bbox.height = Math.min(b.maxY, bbox.maxY) - bbox.y;
      });
      return bbox;
    };
    BBox2.prototype.cut = function(subBBox, direction2) {
      var width = subBBox.width;
      var height = subBBox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          return BBox2.fromRange(this.minX, this.minY + height, this.maxX, this.maxY);
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          return BBox2.fromRange(this.minX, this.minY, this.maxX - width, this.maxY);
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          return BBox2.fromRange(this.minX, this.minY, this.maxX, this.maxY - height);
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          return BBox2.fromRange(this.minX + width, this.minY, this.maxX, this.maxY);
        default:
          return this;
      }
    };
    BBox2.prototype.shrink = function(gap) {
      var _a2 = __read(gap, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      return new BBox2(this.x + left2, this.y + top, this.width - left2 - right2, this.height - top - bottom);
    };
    BBox2.prototype.expand = function(gap) {
      var _a2 = __read(gap, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      return new BBox2(this.x - left2, this.y - top, this.width + left2 + right2, this.height + top + bottom);
    };
    BBox2.prototype.exceed = function(bbox) {
      return [
        Math.max(-this.minY + bbox.minY, 0),
        Math.max(this.maxX - bbox.maxX, 0),
        Math.max(this.maxY - bbox.maxY, 0),
        Math.max(-this.minX + bbox.minX, 0)
      ];
    };
    BBox2.prototype.collide = function(bbox) {
      return this.minX < bbox.maxX && this.maxX > bbox.minX && this.minY < bbox.maxY && this.maxY > bbox.minY;
    };
    BBox2.prototype.size = function() {
      return this.width * this.height;
    };
    BBox2.prototype.isPointIn = function(p) {
      return p.x >= this.minX && p.x <= this.maxX && p.y >= this.minY && p.y <= this.maxY;
    };
    return BBox2;
  }()
);
function toPoints(bbox) {
  return [
    [bbox.minX, bbox.minY],
    [bbox.maxX, bbox.minY],
    [bbox.maxX, bbox.maxY],
    [bbox.minX, bbox.maxY]
  ];
}
function getXDimensionLength(coordinate2) {
  if (coordinate2.isPolar && !coordinate2.isTransposed) {
    return (coordinate2.endAngle - coordinate2.startAngle) * coordinate2.getRadius();
  }
  var start = coordinate2.convert({ x: 0, y: 0 });
  var end = coordinate2.convert({ x: 1, y: 0 });
  return Math.sqrt(Math.pow(end.x - start.x, 2) + Math.pow(end.y - start.y, 2));
}
function isFullCircle(coordinate2) {
  if (coordinate2.isPolar) {
    var startAngle = coordinate2.startAngle, endAngle = coordinate2.endAngle;
    return endAngle - startAngle === Math.PI * 2;
  }
  return false;
}
function getDistanceToCenter(coordinate2, point2) {
  var center2 = coordinate2.getCenter();
  return Math.sqrt(Math.pow(point2.x - center2.x, 2) + Math.pow(point2.y - center2.y, 2));
}
function isPointInCoordinate(coordinate2, point2) {
  var result = false;
  if (coordinate2) {
    if (coordinate2.type === "theta") {
      var start = coordinate2.start, end = coordinate2.end;
      result = isBetween$1(point2.x, start.x, end.x) && isBetween$1(point2.y, start.y, end.y);
    } else {
      var invertPoint = coordinate2.invert(point2);
      result = isBetween$1(invertPoint.x, 0, 1) && isBetween$1(invertPoint.y, 0, 1);
    }
  }
  return result;
}
function getAngleByPoint(coordinate2, point2) {
  var center2 = coordinate2.getCenter();
  return Math.atan2(point2.y - center2.y, point2.x - center2.x);
}
function getCoordinateClipCfg(coordinate2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  if (coordinate2.isPolar) {
    var startAngle_1 = coordinate2.startAngle, endAngle_1 = coordinate2.endAngle;
    var center_1 = coordinate2.getCenter();
    var radius_1 = coordinate2.getRadius();
    return {
      type: "path",
      startState: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, startAngle_1)
      },
      endState: function(ratio) {
        var diff2 = (endAngle_1 - startAngle_1) * ratio + startAngle_1;
        var path2 = getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, diff2);
        return {
          path: path2
        };
      },
      attrs: {
        path: getSectorPath(center_1.x, center_1.y, radius_1 + margin, startAngle_1, endAngle_1)
      }
    };
  }
  var endState;
  if (coordinate2.isTransposed) {
    endState = {
      height: height + margin * 2
    };
  } else {
    endState = {
      width: width + margin * 2
    };
  }
  return {
    type: "rect",
    startState: {
      x: start.x - margin,
      y: end.y - margin,
      width: coordinate2.isTransposed ? width + margin * 2 : 0,
      height: coordinate2.isTransposed ? 0 : height + margin * 2
    },
    endState,
    attrs: {
      x: start.x - margin,
      y: end.y - margin,
      width: width + margin * 2,
      height: height + margin * 2
    }
  };
}
function getCoordinateBBox(coordinate2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  var minX = Math.min(start.x, end.x);
  var minY = Math.min(start.y, end.y);
  return BBox.fromRange(minX - margin, minY - margin, minX + width + margin, minY + height + margin);
}
var dateRegex = /^(?:(?!0000)[0-9]{4}([-/.]+)(?:(?:0?[1-9]|1[0-2])\1(?:0?[1-9]|1[0-9]|2[0-8])|(?:0?[13-9]|1[0-2])\1(?:29|30)|(?:0?[13578]|1[02])\1(?:31))|(?:[0-9]{2}(?:0[48]|[2468][048]|[13579][26])|(?:0[48]|[2468][048]|[13579][26])00)([-/.]+)0?2\2(?:29))(\s+([01]|([01][0-9]|2[0-3])):([0-9]|[0-5][0-9]):([0-9]|[0-5][0-9]))?$/;
function getDefaultType(value2) {
  var type = "linear";
  if (dateRegex.test(value2)) {
    type = "timeCat";
  } else if (isString(value2)) {
    type = "cat";
  }
  return type;
}
function inferScaleType(scale2, scaleDef, attrType, geometryType) {
  if (scaleDef === void 0) {
    scaleDef = {};
  }
  if (scaleDef.type)
    return scaleDef.type;
  if (scale2.type !== "identity" && GROUP_ATTRS.includes(attrType) && ["interval"].includes(geometryType)) {
    return "cat";
  }
  return scale2.isCategory ? "cat" : scale2.type;
}
function createScaleByField(field2, data2, scaleDef) {
  var validData = data2 || [];
  if (isNumber$1(field2) || isNil(firstValue(validData, field2)) && isEmpty(scaleDef)) {
    var Identity2 = getClass("identity");
    return new Identity2({
      field: field2.toString(),
      values: [field2]
    });
  }
  var values2 = valuesOfKey(validData, field2);
  var type = get(scaleDef, "type", getDefaultType(values2[0]));
  var ScaleCtor = getClass(type);
  return new ScaleCtor(__assign$1({ field: field2, values: values2 }, scaleDef));
}
function syncScale(scale2, newScale) {
  if (scale2.type !== "identity" && newScale.type !== "identity") {
    var obj = {};
    for (var k in newScale) {
      if (Object.prototype.hasOwnProperty.call(newScale, k)) {
        obj[k] = newScale[k];
      }
    }
    scale2.change(obj);
  }
}
function getName(scale2) {
  return scale2.alias || scale2.field;
}
function getDefaultCategoryScaleRange(scale2, coordinate2, theme2) {
  var values2 = scale2.values;
  var count2 = values2.length;
  var range;
  if (count2 === 1) {
    range = [0.5, 1];
  } else {
    var widthRatio = 1;
    var offset = 0;
    if (isFullCircle(coordinate2)) {
      if (!coordinate2.isTransposed) {
        range = [0, 1 - 1 / count2];
      } else {
        widthRatio = get(theme2, "widthRatio.multiplePie", 1 / 1.3);
        offset = 1 / count2 * widthRatio;
        range = [offset / 2, 1 - offset / 2];
      }
    } else {
      offset = 1 / count2 / 2;
      range = [offset, 1 - offset];
    }
  }
  return range;
}
function getMaxScale(scale2) {
  var values2 = scale2.values.filter(function(item) {
    return !isNil(item) && !isNaN(item);
  });
  return Math.max.apply(Math, __spreadArray$1(__spreadArray$1([], __read(values2), false), [isNil(scale2.max) ? -Infinity : scale2.max], false));
}
function getLineAxisRelativeRegion(direction2) {
  var start;
  var end;
  switch (direction2) {
    case DIRECTION.TOP:
      start = { x: 0, y: 1 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.RIGHT:
      start = { x: 1, y: 0 };
      end = { x: 1, y: 1 };
      break;
    case DIRECTION.BOTTOM:
      start = { x: 0, y: 0 };
      end = { x: 1, y: 0 };
      break;
    case DIRECTION.LEFT:
      start = { x: 0, y: 0 };
      end = { x: 0, y: 1 };
      break;
    default:
      start = end = { x: 0, y: 0 };
  }
  return { start, end };
}
function getCircleAxisRelativeRegion(coordinate2) {
  var start;
  var end;
  if (coordinate2.isTransposed) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  }
  return { start, end };
}
function getAxisRegion(coordinate2, direction2) {
  var region = { start: { x: 0, y: 0 }, end: { x: 0, y: 0 } };
  if (coordinate2.isRect) {
    region = getLineAxisRelativeRegion(direction2);
  } else if (coordinate2.isPolar) {
    region = getCircleAxisRelativeRegion(coordinate2);
  }
  var start = region.start, end = region.end;
  return {
    start: coordinate2.convert(start),
    end: coordinate2.convert(end)
  };
}
function isVertical(region) {
  var start = region.start, end = region.end;
  return start.x === end.x;
}
function getAxisFactorByRegion(region, center2) {
  var start = region.start, end = region.end;
  var isAxisVertical = isVertical(region);
  if (isAxisVertical) {
    if ((start.y - end.y) * (center2.x - start.x) > 0) {
      return 1;
    } else {
      return -1;
    }
  } else {
    if ((end.x - start.x) * (start.y - center2.y) > 0) {
      return -1;
    } else {
      return 1;
    }
  }
}
function getAxisThemeCfg(theme2, direction2) {
  var axisTheme = get(theme2, ["components", "axis"], {});
  return deepMix({}, get(axisTheme, ["common"], {}), deepMix({}, get(axisTheme, [direction2], {})));
}
function getAxisTitleOptions(theme2, direction2, axisOptions) {
  var axisTheme = get(theme2, ["components", "axis"], {});
  return deepMix({}, get(axisTheme, ["common", "title"], {}), deepMix({}, get(axisTheme, [direction2, "title"], {})), axisOptions);
}
function getCircleAxisCenterRadius(coordinate2) {
  var x = coordinate2.x, y = coordinate2.y, center2 = coordinate2.circleCenter;
  var isReflectY = y.start > y.end;
  var start = coordinate2.isTransposed ? coordinate2.convert({
    x: isReflectY ? 0 : 1,
    y: 0
  }) : coordinate2.convert({
    x: 0,
    y: isReflectY ? 0 : 1
  });
  var startVector = [start.x - center2.x, start.y - center2.y];
  var normalVector = [1, 0];
  var startAngle = start.y > center2.y ? angle$1(startVector, normalVector) : angle$1(startVector, normalVector) * -1;
  var endAngle = startAngle + (x.end - x.start);
  var radius = Math.sqrt(Math.pow(start.x - center2.x, 2) + Math.pow(start.y - center2.y, 2));
  return {
    center: center2,
    radius,
    startAngle,
    endAngle
  };
}
function getAxisOption(axes, field2) {
  if (isBoolean(axes)) {
    return axes === false ? false : {};
  }
  return get(axes, [field2]);
}
function getAxisDirection(axisOption, def) {
  return get(axisOption, "position", def);
}
function getAxisTitleText(scale2, axisOption) {
  return get(axisOption, ["title", "text"], getName(scale2));
}
var Facet = (
  /** @class */
  function() {
    function Facet2(view, cfg) {
      this.destroyed = false;
      this.facets = [];
      this.view = view;
      this.cfg = deepMix({}, this.getDefaultCfg(), cfg);
    }
    Facet2.prototype.init = function() {
      if (!this.container) {
        this.container = this.createContainer();
      }
      var data2 = this.view.getData();
      this.facets = this.generateFacets(data2);
    };
    Facet2.prototype.render = function() {
      this.renderViews();
    };
    Facet2.prototype.update = function() {
    };
    Facet2.prototype.clear = function() {
      this.clearFacetViews();
    };
    Facet2.prototype.destroy = function() {
      this.clear();
      if (this.container) {
        this.container.remove(true);
        this.container = void 0;
      }
      this.destroyed = true;
      this.view = void 0;
      this.facets = [];
    };
    Facet2.prototype.facetToView = function(facet) {
      var region = facet.region, data2 = facet.data, _a2 = facet.padding, padding2 = _a2 === void 0 ? this.cfg.padding : _a2;
      var view = this.view.createView({
        region,
        padding: padding2
      });
      view.data(data2 || []);
      facet.view = view;
      this.beforeEachView(view, facet);
      var eachView = this.cfg.eachView;
      if (eachView) {
        eachView(view, facet);
      }
      this.afterEachView(view, facet);
      return view;
    };
    Facet2.prototype.createContainer = function() {
      var foregroundGroup = this.view.getLayer(LAYER.FORE);
      return foregroundGroup.addGroup();
    };
    Facet2.prototype.renderViews = function() {
      this.createFacetViews();
    };
    Facet2.prototype.createFacetViews = function() {
      var _this = this;
      return this.facets.map(function(facet) {
        return _this.facetToView(facet);
      });
    };
    Facet2.prototype.clearFacetViews = function() {
      var _this = this;
      each$1(this.facets, function(facet) {
        if (facet.view) {
          _this.view.removeView(facet.view);
          facet.view = void 0;
        }
      });
    };
    Facet2.prototype.parseSpacing = function() {
      var _a2 = this.view.viewBBox, width = _a2.width, height = _a2.height;
      var spacing = this.cfg.spacing;
      return spacing.map(function(s, idx) {
        if (isNumber$1(s))
          return s / (idx === 0 ? width : height);
        else
          return parseFloat(s) / 100;
      });
    };
    Facet2.prototype.getFieldValues = function(data2, field2) {
      var rst = [];
      var cache2 = {};
      each$1(data2, function(d) {
        var value2 = d[field2];
        if (!isNil(value2) && !cache2[value2]) {
          rst.push(value2);
          cache2[value2] = true;
        }
      });
      return rst;
    };
    Facet2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var _a2 = __read(this.parseSpacing(), 2), xSpacing = _a2[0], ySpacing = _a2[1];
      var xRatio = (1 + xSpacing) / (cols === 0 ? 1 : cols) - xSpacing;
      var yRatio = (1 + ySpacing) / (rows === 0 ? 1 : rows) - ySpacing;
      var start = {
        x: (xRatio + xSpacing) * xIndex,
        y: (yRatio + ySpacing) * yIndex
      };
      var end = {
        x: start.x + xRatio,
        y: start.y + yRatio
      };
      return { start, end };
    };
    Facet2.prototype.getDefaultCfg = function() {
      return {
        eachView: void 0,
        showTitle: true,
        spacing: [0, 0],
        padding: 10,
        fields: []
      };
    };
    Facet2.prototype.getDefaultTitleCfg = function() {
      var fontFamily = this.view.getTheme().fontFamily;
      return {
        style: {
          fontSize: 14,
          fill: "#666",
          fontFamily
        }
      };
    };
    Facet2.prototype.processAxis = function(view, facet) {
      var options = view.getOptions();
      var coordinateOption = options.coordinate;
      var geometries = view.geometries;
      var coordinateType = get(coordinateOption, "type", "rect");
      if (coordinateType === "rect" && geometries.length) {
        if (isNil(options.axes)) {
          options.axes = {};
        }
        var axes = options.axes;
        var _a2 = __read(geometries[0].getXYFields(), 2), x = _a2[0], y = _a2[1];
        var xOption = getAxisOption(axes, x);
        var yOption = getAxisOption(axes, y);
        if (xOption !== false) {
          options.axes[x] = this.getXAxisOption(x, axes, xOption, facet);
        }
        if (yOption !== false) {
          options.axes[y] = this.getYAxisOption(y, axes, yOption, facet);
        }
      }
    };
    Facet2.prototype.getFacetDataFilter = function(conditions) {
      return function(datum) {
        return every(conditions, function(condition) {
          var field2 = condition.field, value2 = condition.value;
          if (!isNil(value2) && field2) {
            return datum[field2] === value2;
          }
          return true;
        });
      };
    };
    return Facet2;
  }()
);
var Facets = {};
var getFacet = function(type) {
  return Facets[lowerCase(type)];
};
var registerFacet = function(type, ctor) {
  Facets[lowerCase(type)] = ctor;
};
var Action = (
  /** @class */
  function() {
    function Action2(context, cfg) {
      this.context = context;
      this.cfg = cfg;
      context.addAction(this);
    }
    Action2.prototype.applyCfg = function(cfg) {
      mix(this, cfg);
    };
    Action2.prototype.init = function() {
      this.applyCfg(this.cfg);
    };
    Action2.prototype.destroy = function() {
      this.context.removeAction(this);
      this.context = null;
    };
    return Action2;
  }()
);
var CallbackAction = (
  /** @class */
  function(_super) {
    __extends$1(CallbackAction2, _super);
    function CallbackAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CallbackAction2.prototype.execute = function() {
      if (this.callback) {
        this.callback(this.context);
      }
    };
    CallbackAction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.callback = null;
    };
    return CallbackAction2;
  }(Action)
);
var ActionCache = {};
function createAction(actionName, context) {
  var actionOption = ActionCache[actionName];
  var action = null;
  if (actionOption) {
    var ActionClass = actionOption.ActionClass, cfg = actionOption.cfg;
    action = new ActionClass(context, cfg);
    action.name = actionName;
    action.init();
  }
  return action;
}
function getActionClass(actionName) {
  var actionOption = ActionCache[actionName];
  return get(actionOption, "ActionClass");
}
function registerAction(actionName, ActionClass, cfg) {
  ActionCache[actionName] = {
    ActionClass,
    cfg
  };
}
function createCallbackAction(callback, context) {
  var action = new CallbackAction(context);
  action.callback = callback;
  action.name = "callback";
  return action;
}
function _points2path(points2, isInCircle) {
  var path2 = [];
  if (points2.length) {
    path2.push(["M", points2[0].x, points2[0].y]);
    for (var i = 1, length_1 = points2.length; i < length_1; i += 1) {
      var item = points2[i];
      path2.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path2.push(["Z"]);
    }
  }
  return path2;
}
function _convertArr(arr, coord2) {
  var tmp = [arr[0]];
  for (var i = 1, len = arr.length; i < len; i = i + 2) {
    var point2 = coord2.convert({
      x: arr[i],
      y: arr[i + 1]
    });
    tmp.push(point2.x, point2.y);
  }
  return tmp;
}
function _convertArcPath(path2, coord2) {
  var isTransposed = coord2.isTransposed;
  var r = path2[1];
  var x = path2[6];
  var y = path2[7];
  var point2 = coord2.convert({ x, y });
  var direction2 = isTransposed ? 0 : 1;
  return ["A", r, r, 0, 0, direction2, point2.x, point2.y];
}
function _convertPolarPath(pre, cur, coord2) {
  var isTransposed = coord2.isTransposed, startAngle = coord2.startAngle, endAngle = coord2.endAngle;
  var prePoint = pre[0].toLowerCase() === "a" ? {
    x: pre[6],
    y: pre[7]
  } : {
    x: pre[1],
    y: pre[2]
  };
  var curPoint = {
    x: cur[1],
    y: cur[2]
  };
  var rst = [];
  var xDim = isTransposed ? "y" : "x";
  var angleRange = Math.abs(curPoint[xDim] - prePoint[xDim]) * (endAngle - startAngle);
  var direction2 = curPoint[xDim] >= prePoint[xDim] ? 1 : 0;
  var flag = angleRange > Math.PI ? 1 : 0;
  var convertPoint = coord2.convert(curPoint);
  var r = getDistanceToCenter(coord2, convertPoint);
  if (r >= 0.5) {
    if (angleRange === Math.PI * 2) {
      var middlePoint = {
        x: (curPoint.x + prePoint.x) / 2,
        y: (curPoint.y + prePoint.y) / 2
      };
      var middleConvertPoint = coord2.convert(middlePoint);
      rst.push(["A", r, r, 0, flag, direction2, middleConvertPoint.x, middleConvertPoint.y]);
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    } else {
      rst.push(["A", r, r, 0, flag, direction2, convertPoint.x, convertPoint.y]);
    }
  }
  return rst;
}
function _filterFullCirleLine(path2) {
  each$1(path2, function(subPath, index2) {
    var cur = subPath;
    if (cur[0].toLowerCase() === "a") {
      var pre = path2[index2 - 1];
      var next = path2[index2 + 1];
      if (next && next[0].toLowerCase() === "a") {
        if (pre && pre[0].toLowerCase() === "l") {
          pre[0] = "M";
        }
      } else if (pre && pre[0].toLowerCase() === "a") {
        if (next && next[0].toLowerCase() === "l") {
          next[0] = "M";
        }
      }
    }
  });
}
var smoothBezier$1 = function(points2, smooth, isLoop, constraint) {
  var _a2;
  var cps = [];
  var hasConstraint = !!constraint;
  var prevPoint;
  var nextPoint;
  var min2;
  var max2;
  var nextCp0;
  var cp1;
  var cp0;
  if (hasConstraint) {
    _a2 = __read(constraint, 2), min2 = _a2[0], max2 = _a2[1];
    for (var i = 0, l = points2.length; i < l; i++) {
      var point2 = points2[i];
      min2 = min$1([0, 0], min2, point2);
      max2 = max$1([0, 0], max2, point2);
    }
  }
  for (var i = 0, len = points2.length; i < len; i++) {
    var point2 = points2[i];
    if (i === 0 && !isLoop) {
      cp0 = point2;
    } else if (i === len - 1 && !isLoop) {
      cp1 = point2;
      cps.push(cp0);
      cps.push(cp1);
    } else {
      prevPoint = points2[isLoop ? i ? i - 1 : len - 1 : i - 1];
      nextPoint = points2[isLoop ? (i + 1) % len : i + 1];
      var v = [0, 0];
      v = sub(v, nextPoint, prevPoint);
      v = scale$3(v, v, smooth);
      var d0 = distance$6(point2, prevPoint);
      var d1 = distance$6(point2, nextPoint);
      var sum = d0 + d1;
      if (sum !== 0) {
        d0 /= sum;
        d1 /= sum;
      }
      var v1 = scale$3([0, 0], v, -d0);
      var v2 = scale$3([0, 0], v, d1);
      cp1 = add([0, 0], point2, v1);
      nextCp0 = add([0, 0], point2, v2);
      nextCp0 = min$1([0, 0], nextCp0, max$1([0, 0], nextPoint, point2));
      nextCp0 = max$1([0, 0], nextCp0, min$1([0, 0], nextPoint, point2));
      v1 = sub([0, 0], nextCp0, point2);
      v1 = scale$3([0, 0], v1, -d0 / d1);
      cp1 = add([0, 0], point2, v1);
      cp1 = min$1([0, 0], cp1, max$1([0, 0], prevPoint, point2));
      cp1 = max$1([0, 0], cp1, min$1([0, 0], prevPoint, point2));
      v2 = sub([0, 0], point2, cp1);
      v2 = scale$3([0, 0], v2, d1 / d0);
      nextCp0 = add([0, 0], point2, v2);
      if (hasConstraint) {
        cp1 = max$1([0, 0], cp1, min2);
        cp1 = min$1([0, 0], cp1, max2);
        nextCp0 = max$1([0, 0], nextCp0, min2);
        nextCp0 = min$1([0, 0], nextCp0, max2);
      }
      cps.push(cp0);
      cps.push(cp1);
      cp0 = nextCp0;
    }
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier$1(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier$1(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getLinePath(points2, isInCircle) {
  return _points2path(points2, isInCircle);
}
function getSplinePath$1(points2, isInCircle, constaint) {
  var data2 = [];
  var first = points2[0];
  var prePoint = null;
  if (points2.length <= 2) {
    return getLinePath(points2, isInCircle);
  }
  for (var i = 0, len = points2.length; i < len; i++) {
    var point2 = points2[i];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data2.push(point2.x);
      data2.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    // 
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier$1(data2, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
function convertNormalPath(coord2, path2) {
  var tmp = [];
  each$1(path2, function(subPath) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "l":
      case "c":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  return tmp;
}
function convertPolarPath(coord2, path2) {
  var tmp = [];
  var pre;
  var cur;
  var transposed;
  var equals;
  each$1(path2, function(subPath, index2) {
    var action = subPath[0];
    switch (action.toLowerCase()) {
      case "m":
      case "c":
      case "q":
        tmp.push(_convertArr(subPath, coord2));
        break;
      case "l":
        pre = path2[index2 - 1];
        cur = subPath;
        transposed = coord2.isTransposed;
        equals = transposed ? pre[pre.length - 2] === cur[1] : pre[pre.length - 1] === cur[2];
        if (equals) {
          tmp = tmp.concat(_convertPolarPath(pre, cur, coord2));
        } else {
          tmp.push(_convertArr(subPath, coord2));
        }
        break;
      case "a":
        tmp.push(_convertArcPath(subPath, coord2));
        break;
      case "z":
      default:
        tmp.push(subPath);
        break;
    }
  });
  _filterFullCirleLine(tmp);
  return tmp;
}
function getMaskBBox(context, tolerance2) {
  var event = context.event;
  var maskShape = event.target;
  return getMaskBBoxByShape(maskShape, tolerance2);
}
function isValidMaskBBox(maskShape, tolerance2) {
  var maskBBox = maskShape.getCanvasBBox();
  var width = maskBBox.width, height = maskBBox.height;
  return width > 0 && height > 0 && (width >= tolerance2 || height >= tolerance2);
}
function getMaskBBoxByShape(maskShape, tolerance2) {
  var maskBBox = maskShape.getCanvasBBox();
  return isValidMaskBBox(maskShape, tolerance2) ? maskBBox : null;
}
function getMultiMaskBBoxList(context, tolerance2) {
  var maskShapes = context.event.maskShapes;
  return maskShapes.map(function(maskShape) {
    return getMaskBBoxByShape(maskShape, tolerance2);
  }).filter(function(bBox) {
    return !!bBox;
  });
}
function getMaskPath$2(context, tolerance2) {
  var event = context.event;
  var maskShape = event.target;
  return getMaskPathByMaskShape(maskShape, tolerance2);
}
function getMaskPathByMaskShape(maskShape, tolerance2) {
  return isValidMaskBBox(maskShape, tolerance2) ? maskShape.attr("path") : null;
}
function getMultiMaskPathList(context, tolerance2) {
  var maskShapes = context.event.maskShapes;
  return maskShapes.map(function(maskShape) {
    return getMaskPathByMaskShape(maskShape, tolerance2);
  });
}
function getCurrentElement$1(context) {
  var event = context.event;
  var element;
  var target2 = event.target;
  if (target2) {
    element = target2.get("element");
  }
  return element;
}
function getDelegationObject(context) {
  var event = context.event;
  var target2 = event.target;
  var delegateObject;
  if (target2) {
    delegateObject = target2.get("delegateObject");
  }
  return delegateObject;
}
function isElementChange(context) {
  var event = context.event.gEvent;
  if (event && event.fromShape && event.toShape && event.fromShape.get("element") === event.toShape.get("element")) {
    return false;
  }
  return true;
}
function isList(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isList();
}
function isSlider(delegateObject) {
  return delegateObject && delegateObject.component && delegateObject.component.isSlider();
}
function isMask(context) {
  var event = context.event;
  var target2 = event.target;
  return target2 && (target2 === null || target2 === void 0 ? void 0 : target2.get("name")) === "mask" || isMultipleMask(context);
}
function isMultipleMask(context) {
  var _a2;
  return ((_a2 = context.event.target) === null || _a2 === void 0 ? void 0 : _a2.get("name")) === "multi-mask";
}
function getMaskedElements(context, tolerance2) {
  var target2 = context.event.target;
  if (isMultipleMask(context)) {
    return getMultiMaskedElements(context, tolerance2);
  }
  if (target2.get("type") === "path") {
    var maskPath = getMaskPath$2(context, tolerance2);
    if (!maskPath) {
      return;
    }
    return getElementsByPath(context.view, maskPath);
  }
  var maskBBox = getMaskBBox(context, tolerance2);
  if (!maskBBox) {
    return null;
  }
  return getIntersectElements(context.view, maskBBox);
}
function getMultiMaskedElements(context, tolerance2) {
  var target2 = context.event.target;
  if (target2.get("type") === "path") {
    var maskPathList = getMultiMaskPathList(context, tolerance2);
    if (maskPathList.length > 0) {
      return maskPathList.flatMap(function(maskPath) {
        return getElementsByPath(context.view, maskPath);
      });
    }
    return null;
  }
  var maskBBoxList = getMultiMaskBBoxList(context, tolerance2);
  if (maskBBoxList.length > 0) {
    return maskBBoxList.flatMap(function(maskBBox) {
      return getIntersectElements(context.view, maskBBox);
    });
  }
  return null;
}
function getSiblingMaskElements(context, sibling, tolerance2) {
  if (isMultipleMask(context)) {
    return getSiblingMultiMaskedElements(context, sibling, tolerance2);
  }
  var maskBBox = getMaskBBox(context, tolerance2);
  if (!maskBBox) {
    return null;
  }
  return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
}
function getSiblingMaskElementsByBBox(maskBBox, context, sibling) {
  var view = context.view;
  var start = getSiblingPoint(view, sibling, { x: maskBBox.x, y: maskBBox.y });
  var end = getSiblingPoint(view, sibling, { x: maskBBox.maxX, y: maskBBox.maxY });
  var box2 = {
    minX: start.x,
    minY: start.y,
    maxX: end.x,
    maxY: end.y
  };
  return getIntersectElements(sibling, box2);
}
function getSiblingMultiMaskedElements(context, sibling, tolerance2) {
  var maskBBoxList = getMultiMaskBBoxList(context, tolerance2);
  if (maskBBoxList.length > 0) {
    return maskBBoxList.flatMap(function(maskBBox) {
      return getSiblingMaskElementsByBBox(maskBBox, context, sibling);
    });
  }
  return null;
}
function getElements(view) {
  var geometries = view.geometries;
  var rst = [];
  each$1(geometries, function(geom) {
    var elements = geom.elements;
    rst = rst.concat(elements);
  });
  if (view.views && view.views.length) {
    each$1(view.views, function(subView) {
      rst = rst.concat(getElements(subView));
    });
  }
  return rst;
}
function getElementsByField(view, field2, value2) {
  var elements = getElements(view);
  return elements.filter(function(el) {
    return getElementValue$1(el, field2) === value2;
  });
}
function getElementsByState(view, stateName) {
  var geometries = view.geometries;
  var rst = [];
  each$1(geometries, function(geom) {
    var elements = geom.getElementsBy(function(el) {
      return el.hasState(stateName);
    });
    rst = rst.concat(elements);
  });
  return rst;
}
function getElementValue$1(element, field2) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (isArray$1(record)) {
    value2 = record[0][field2];
  } else {
    value2 = record[field2];
  }
  return value2;
}
function intersectRect$1(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function getIntersectElements(view, box2) {
  var elements = getElements(view);
  var rst = [];
  each$1(elements, function(el) {
    var shape = el.shape;
    var shapeBBox = shape.getCanvasBBox();
    if (intersectRect$1(box2, shapeBBox)) {
      rst.push(el);
    }
  });
  return rst;
}
function pathToPoints(path2) {
  var points2 = [];
  each$1(path2, function(seg) {
    var command = seg[0];
    if (command !== "A") {
      for (var i = 1; i < seg.length; i = i + 2) {
        points2.push([seg[i], seg[i + 1]]);
      }
    } else {
      var length_1 = seg.length;
      points2.push([seg[length_1 - 2], seg[length_1 - 1]]);
    }
  });
  return points2;
}
function getElementsByPath(view, path2) {
  var elements = getElements(view);
  var points2 = pathToPoints(path2);
  var rst = elements.filter(function(el) {
    var shape = el.shape;
    var shapePoints;
    if (shape.get("type") === "path") {
      shapePoints = pathToPoints(shape.attr("path"));
    } else {
      var shapeBBox = shape.getCanvasBBox();
      shapePoints = toPoints(shapeBBox);
    }
    return isPolygonsIntersect(points2, shapePoints);
  });
  return rst;
}
function getComponents(view) {
  return view.getComponents().map(function(co) {
    return co.component;
  });
}
function distance$2(p1, p2) {
  var dx = p2.x - p1.x;
  var dy = p2.y - p1.y;
  return Math.sqrt(dx * dx + dy * dy);
}
function getSpline(points2, z) {
  if (points2.length <= 2) {
    return getLinePath(points2, false);
  }
  var first = points2[0];
  var arr = [];
  each$1(points2, function(point2) {
    arr.push(point2.x);
    arr.push(point2.y);
  });
  var path2 = catmullRom2bezier$1(arr, z, null);
  path2.unshift(["M", first.x, first.y]);
  return path2;
}
function isInBox(box2, point2) {
  return box2.x <= point2.x && box2.maxX >= point2.x && box2.y <= point2.y && box2.maxY > point2.y;
}
function getSilbings(view) {
  var parent = view.parent;
  var siblings2 = null;
  if (parent) {
    siblings2 = parent.views.filter(function(sub2) {
      return sub2 !== view;
    });
  }
  return siblings2;
}
function point2Normalize(view, point2) {
  var coord2 = view.getCoordinate();
  return coord2.invert(point2);
}
function getSiblingPoint(view, sibling, point2) {
  var normalPoint = point2Normalize(view, point2);
  return sibling.getCoordinate().convert(normalPoint);
}
function isInRecords(records, record, xFiled, yField) {
  var isIn = false;
  each$1(records, function(r) {
    if (r[xFiled] === record[xFiled] && r[yField] === record[yField]) {
      isIn = true;
      return false;
    }
  });
  return isIn;
}
function getScaleByField(view, field2) {
  var scale2 = view.getScaleByField(field2);
  if (!scale2 && view.views) {
    each$1(view.views, function(subView) {
      scale2 = getScaleByField(subView, field2);
      if (scale2) {
        return false;
      }
    });
  }
  return scale2;
}
var Context = (
  /** @class */
  function() {
    function Context2(view) {
      this.actions = [];
      this.event = null;
      this.cacheMap = {};
      this.view = view;
    }
    Context2.prototype.cache = function() {
      var params = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        params[_i] = arguments[_i];
      }
      if (params.length === 1) {
        return this.cacheMap[params[0]];
      } else if (params.length === 2) {
        this.cacheMap[params[0]] = params[1];
      }
    };
    Context2.prototype.getAction = function(name) {
      return this.actions.find(function(action) {
        return action.name === name;
      });
    };
    Context2.prototype.addAction = function(action) {
      this.actions.push(action);
    };
    Context2.prototype.removeAction = function(action) {
      var actions = this.actions;
      var index2 = this.actions.indexOf(action);
      if (index2 >= 0) {
        actions.splice(index2, 1);
      }
    };
    Context2.prototype.getCurrentPoint = function() {
      var event = this.event;
      if (event) {
        if (event.target instanceof HTMLElement) {
          var canvas = this.view.getCanvas();
          var point2 = canvas.getPointByClient(event.clientX, event.clientY);
          return point2;
        } else {
          return {
            x: event.x,
            y: event.y
          };
        }
      }
      return null;
    };
    Context2.prototype.getCurrentShape = function() {
      return get(this.event, ["gEvent", "shape"]);
    };
    Context2.prototype.isInPlot = function() {
      var point2 = this.getCurrentPoint();
      if (point2) {
        return this.view.isPointInPlot(point2);
      }
      return false;
    };
    Context2.prototype.isInShape = function(name) {
      var shape = this.getCurrentShape();
      if (shape) {
        return shape.get("name") === name;
      }
      return false;
    };
    Context2.prototype.isInComponent = function(name) {
      var components = getComponents(this.view);
      var point2 = this.getCurrentPoint();
      if (point2) {
        return !!components.find(function(component2) {
          var bbox = component2.getBBox();
          if (name) {
            return component2.get("name") === name && isInBox(bbox, point2);
          } else {
            return isInBox(bbox, point2);
          }
        });
      }
      return false;
    };
    Context2.prototype.destroy = function() {
      each$1(this.actions.slice(), function(action) {
        action.destroy();
      });
      this.view = null;
      this.event = null;
      this.actions = null;
      this.cacheMap = null;
    };
    return Context2;
  }()
);
var Interaction = (
  /** @class */
  function() {
    function Interaction2(view, cfg) {
      this.view = view;
      this.cfg = cfg;
    }
    Interaction2.prototype.init = function() {
      this.initEvents();
    };
    Interaction2.prototype.initEvents = function() {
    };
    Interaction2.prototype.clearEvents = function() {
    };
    Interaction2.prototype.destroy = function() {
      this.clearEvents();
    };
    return Interaction2;
  }()
);
function parseAction(actionStr, context, arg) {
  var arr = actionStr.split(":");
  var actionName = arr[0];
  var action = context.getAction(actionName) || createAction(actionName, context);
  if (!action) {
    throw new Error("There is no action named ".concat(actionName));
  }
  var methodName = arr[1];
  return {
    action,
    methodName,
    arg
  };
}
function executeAction(actionObject) {
  var action = actionObject.action, methodName = actionObject.methodName, arg = actionObject.arg;
  if (action[methodName]) {
    action[methodName](arg);
  } else {
    throw new Error("Action(".concat(action.name, ") doesn't have a method called ").concat(methodName));
  }
}
var STEP_NAMES = {
  START: "start",
  SHOW_ENABLE: "showEnable",
  END: "end",
  ROLLBACK: "rollback",
  PROCESSING: "processing"
};
var GrammarInteraction = (
  /** @class */
  function(_super) {
    __extends$1(GrammarInteraction2, _super);
    function GrammarInteraction2(view, steps) {
      var _this = _super.call(this, view, steps) || this;
      _this.callbackCaches = {};
      _this.emitCaches = {};
      _this.steps = steps;
      return _this;
    }
    GrammarInteraction2.prototype.init = function() {
      this.initContext();
      _super.prototype.init.call(this);
    };
    GrammarInteraction2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.steps = null;
      if (this.context) {
        this.context.destroy();
        this.context = null;
      }
      this.callbackCaches = null;
      this.view = null;
    };
    GrammarInteraction2.prototype.initEvents = function() {
      var _this = this;
      each$1(this.steps, function(stepArr, stepName) {
        each$1(stepArr, function(step) {
          var callback = _this.getActionCallback(stepName, step);
          if (callback) {
            _this.bindEvent(step.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.clearEvents = function() {
      var _this = this;
      each$1(this.steps, function(stepArr, stepName) {
        each$1(stepArr, function(step) {
          var callback = _this.getActionCallback(stepName, step);
          if (callback) {
            _this.offEvent(step.trigger, callback);
          }
        });
      });
    };
    GrammarInteraction2.prototype.initContext = function() {
      var view = this.view;
      var context = new Context(view);
      this.context = context;
      var steps = this.steps;
      each$1(steps, function(subSteps) {
        each$1(subSteps, function(step) {
          if (isFunction(step.action)) {
            step.actionObject = {
              action: createCallbackAction(step.action, context),
              methodName: "execute"
            };
          } else if (isString(step.action)) {
            step.actionObject = parseAction(step.action, context, step.arg);
          } else if (isArray$1(step.action)) {
            var actionArr = step.action;
            var argArr_1 = isArray$1(step.arg) ? step.arg : [step.arg];
            step.actionObject = [];
            each$1(actionArr, function(actionStr, idx) {
              step.actionObject.push(parseAction(actionStr, context, argArr_1[idx]));
            });
          }
        });
      });
    };
    GrammarInteraction2.prototype.isAllowStep = function(stepName) {
      var currentStepName = this.currentStepName;
      var steps = this.steps;
      if (currentStepName === stepName) {
        return true;
      }
      if (stepName === STEP_NAMES.SHOW_ENABLE) {
        return true;
      }
      if (stepName === STEP_NAMES.PROCESSING) {
        return currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.START) {
        return currentStepName !== STEP_NAMES.PROCESSING;
      }
      if (stepName === STEP_NAMES.END) {
        return currentStepName === STEP_NAMES.PROCESSING || currentStepName === STEP_NAMES.START;
      }
      if (stepName === STEP_NAMES.ROLLBACK) {
        if (steps[STEP_NAMES.END]) {
          return currentStepName === STEP_NAMES.END;
        } else if (currentStepName === STEP_NAMES.START) {
          return true;
        }
      }
      return false;
    };
    GrammarInteraction2.prototype.isAllowExecute = function(stepName, step) {
      if (this.isAllowStep(stepName)) {
        var key = this.getKey(stepName, step);
        if (step.once && this.emitCaches[key]) {
          return false;
        }
        if (step.isEnable) {
          return step.isEnable(this.context);
        }
        return true;
      }
      return false;
    };
    GrammarInteraction2.prototype.enterStep = function(stepName) {
      this.currentStepName = stepName;
      this.emitCaches = {};
    };
    GrammarInteraction2.prototype.afterExecute = function(stepName, step) {
      if (stepName !== STEP_NAMES.SHOW_ENABLE && this.currentStepName !== stepName) {
        this.enterStep(stepName);
      }
      var key = this.getKey(stepName, step);
      this.emitCaches[key] = true;
    };
    GrammarInteraction2.prototype.getKey = function(stepName, step) {
      return stepName + step.trigger + step.action;
    };
    GrammarInteraction2.prototype.getActionCallback = function(stepName, step) {
      var _this = this;
      var context = this.context;
      var callbackCaches = this.callbackCaches;
      var actionObject = step.actionObject;
      if (step.action && actionObject) {
        var key = this.getKey(stepName, step);
        if (!callbackCaches[key]) {
          var actionCallback = function(event) {
            context.event = event;
            if (_this.isAllowExecute(stepName, step)) {
              if (isArray$1(actionObject)) {
                each$1(actionObject, function(obj) {
                  context.event = event;
                  executeAction(obj);
                });
              } else {
                context.event = event;
                executeAction(actionObject);
              }
              _this.afterExecute(stepName, step);
              if (step.callback) {
                context.event = event;
                step.callback(context);
              }
            } else {
              context.event = null;
            }
          };
          if (step.debounce) {
            callbackCaches[key] = debounce$1(actionCallback, step.debounce.wait, step.debounce.immediate);
          } else if (step.throttle) {
            callbackCaches[key] = throttle(actionCallback, step.throttle.wait, {
              leading: step.throttle.leading,
              trailing: step.throttle.trailing
            });
          } else {
            callbackCaches[key] = actionCallback;
          }
        }
        return callbackCaches[key];
      }
      return null;
    };
    GrammarInteraction2.prototype.bindEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.addEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.addEventListener(nameArr[1], callback);
      } else {
        this.view.on(eventName, callback);
      }
    };
    GrammarInteraction2.prototype.offEvent = function(eventName, callback) {
      var nameArr = eventName.split(":");
      if (nameArr[0] === "window") {
        window.removeEventListener(nameArr[1], callback);
      } else if (nameArr[0] === "document") {
        document.removeEventListener(nameArr[1], callback);
      } else {
        this.view.off(eventName, callback);
      }
    };
    return GrammarInteraction2;
  }(Interaction)
);
var Interactions = {};
function getInteraction(name) {
  return Interactions[lowerCase(name)];
}
function registerInteraction(name, interaction2) {
  Interactions[lowerCase(name)] = interaction2;
}
function createInteraction(name, view, cfg) {
  var interaciton = getInteraction(name);
  if (!interaciton) {
    return null;
  }
  if (isPlainObject$1(interaciton)) {
    var steps = mix(clone(interaciton), cfg);
    return new GrammarInteraction(view, steps);
  } else {
    var cls = interaciton;
    return new cls(view, cfg);
  }
}
function createAxisStyles(styleSheet) {
  return {
    title: {
      autoRotate: true,
      position: "center",
      spacing: styleSheet.axisTitleSpacing,
      style: {
        fill: styleSheet.axisTitleTextFillColor,
        fontSize: styleSheet.axisTitleTextFontSize,
        lineHeight: styleSheet.axisTitleTextLineHeight,
        textBaseline: "middle",
        fontFamily: styleSheet.fontFamily
      },
      iconStyle: {
        fill: styleSheet.axisDescriptionIconFillColor
      }
    },
    label: {
      autoRotate: false,
      autoEllipsis: false,
      autoHide: { type: "equidistance", cfg: { minGap: 6 } },
      offset: styleSheet.axisLabelOffset,
      style: {
        fill: styleSheet.axisLabelFillColor,
        fontSize: styleSheet.axisLabelFontSize,
        lineHeight: styleSheet.axisLabelLineHeight,
        fontFamily: styleSheet.fontFamily
      }
    },
    line: {
      style: {
        lineWidth: styleSheet.axisLineBorder,
        stroke: styleSheet.axisLineBorderColor
      }
    },
    grid: {
      line: {
        type: "line",
        style: {
          stroke: styleSheet.axisGridBorderColor,
          lineWidth: styleSheet.axisGridBorder,
          lineDash: styleSheet.axisGridLineDash
        }
      },
      alignTick: true,
      animate: true
    },
    tickLine: {
      style: {
        lineWidth: styleSheet.axisTickLineBorder,
        stroke: styleSheet.axisTickLineBorderColor
      },
      alignTick: true,
      length: styleSheet.axisTickLineLength
    },
    subTickLine: null,
    animate: true
  };
}
function createLegendStyles(styleSheet) {
  return {
    title: null,
    marker: {
      symbol: "circle",
      spacing: styleSheet.legendMarkerSpacing,
      style: {
        r: styleSheet.legendCircleMarkerSize,
        fill: styleSheet.legendMarkerColor
      }
    },
    itemName: {
      spacing: 5,
      style: {
        fill: styleSheet.legendItemNameFillColor,
        fontFamily: styleSheet.fontFamily,
        fontSize: styleSheet.legendItemNameFontSize,
        lineHeight: styleSheet.legendItemNameLineHeight,
        fontWeight: styleSheet.legendItemNameFontWeight,
        textAlign: "start",
        textBaseline: "middle"
      }
    },
    itemStates: {
      active: {
        nameStyle: {
          opacity: 0.8
        }
      },
      unchecked: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          fill: "#D8D8D8",
          stroke: "#D8D8D8"
        }
      },
      inactive: {
        nameStyle: {
          fill: "#D8D8D8"
        },
        markerStyle: {
          opacity: 0.2
        }
      }
    },
    flipPage: true,
    pageNavigator: {
      marker: {
        style: {
          size: styleSheet.legendPageNavigatorMarkerSize,
          inactiveFill: styleSheet.legendPageNavigatorMarkerInactiveFillColor,
          inactiveOpacity: styleSheet.legendPageNavigatorMarkerInactiveFillOpacity,
          fill: styleSheet.legendPageNavigatorMarkerFillColor,
          opacity: styleSheet.legendPageNavigatorMarkerFillOpacity
        }
      },
      text: {
        style: {
          fill: styleSheet.legendPageNavigatorTextFillColor,
          fontSize: styleSheet.legendPageNavigatorTextFontSize
        }
      }
    },
    animate: false,
    maxItemWidth: 200,
    itemSpacing: styleSheet.legendItemSpacing,
    itemMarginBottom: styleSheet.legendItemMarginBottom,
    padding: styleSheet.legendPadding
    // 
  };
}
function createThemeByStyleSheet(styleSheet) {
  var _a2;
  var shapeStyles = {
    point: {
      default: {
        fill: styleSheet.pointFillColor,
        r: styleSheet.pointSize,
        stroke: styleSheet.pointBorderColor,
        lineWidth: styleSheet.pointBorder,
        fillOpacity: styleSheet.pointFillOpacity
      },
      active: {
        stroke: styleSheet.pointActiveBorderColor,
        lineWidth: styleSheet.pointActiveBorder
      },
      selected: {
        stroke: styleSheet.pointSelectedBorderColor,
        lineWidth: styleSheet.pointSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.pointInactiveFillOpacity,
        strokeOpacity: styleSheet.pointInactiveBorderOpacity
      }
    },
    hollowPoint: {
      default: {
        fill: styleSheet.hollowPointFillColor,
        lineWidth: styleSheet.hollowPointBorder,
        stroke: styleSheet.hollowPointBorderColor,
        strokeOpacity: styleSheet.hollowPointBorderOpacity,
        r: styleSheet.hollowPointSize
      },
      active: {
        stroke: styleSheet.hollowPointActiveBorderColor,
        strokeOpacity: styleSheet.hollowPointActiveBorderOpacity
      },
      selected: {
        lineWidth: styleSheet.hollowPointSelectedBorder,
        stroke: styleSheet.hollowPointSelectedBorderColor,
        strokeOpacity: styleSheet.hollowPointSelectedBorderOpacity
      },
      inactive: {
        strokeOpacity: styleSheet.hollowPointInactiveBorderOpacity
      }
    },
    area: {
      default: {
        fill: styleSheet.areaFillColor,
        fillOpacity: styleSheet.areaFillOpacity,
        stroke: null
      },
      active: {
        fillOpacity: styleSheet.areaActiveFillOpacity
      },
      selected: {
        fillOpacity: styleSheet.areaSelectedFillOpacity
      },
      inactive: {
        fillOpacity: styleSheet.areaInactiveFillOpacity
      }
    },
    hollowArea: {
      default: {
        fill: null,
        stroke: styleSheet.hollowAreaBorderColor,
        lineWidth: styleSheet.hollowAreaBorder,
        strokeOpacity: styleSheet.hollowAreaBorderOpacity
      },
      active: {
        fill: null,
        lineWidth: styleSheet.hollowAreaActiveBorder
      },
      selected: {
        fill: null,
        lineWidth: styleSheet.hollowAreaSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.hollowAreaInactiveBorderOpacity
      }
    },
    interval: {
      default: {
        fill: styleSheet.intervalFillColor,
        fillOpacity: styleSheet.intervalFillOpacity
      },
      active: {
        stroke: styleSheet.intervalActiveBorderColor,
        lineWidth: styleSheet.intervalActiveBorder
      },
      selected: {
        stroke: styleSheet.intervalSelectedBorderColor,
        lineWidth: styleSheet.intervalSelectedBorder
      },
      inactive: {
        fillOpacity: styleSheet.intervalInactiveFillOpacity,
        strokeOpacity: styleSheet.intervalInactiveBorderOpacity
      }
    },
    hollowInterval: {
      default: {
        fill: styleSheet.hollowIntervalFillColor,
        stroke: styleSheet.hollowIntervalBorderColor,
        lineWidth: styleSheet.hollowIntervalBorder,
        strokeOpacity: styleSheet.hollowIntervalBorderOpacity
      },
      active: {
        stroke: styleSheet.hollowIntervalActiveBorderColor,
        lineWidth: styleSheet.hollowIntervalActiveBorder,
        strokeOpacity: styleSheet.hollowIntervalActiveBorderOpacity
      },
      selected: {
        stroke: styleSheet.hollowIntervalSelectedBorderColor,
        lineWidth: styleSheet.hollowIntervalSelectedBorder,
        strokeOpacity: styleSheet.hollowIntervalSelectedBorderOpacity
      },
      inactive: {
        stroke: styleSheet.hollowIntervalInactiveBorderColor,
        lineWidth: styleSheet.hollowIntervalInactiveBorder,
        strokeOpacity: styleSheet.hollowIntervalInactiveBorderOpacity
      }
    },
    line: {
      default: {
        stroke: styleSheet.lineBorderColor,
        lineWidth: styleSheet.lineBorder,
        strokeOpacity: styleSheet.lineBorderOpacity,
        fill: null,
        lineAppendWidth: 10,
        lineCap: "round",
        lineJoin: "round"
      },
      active: {
        lineWidth: styleSheet.lineActiveBorder
      },
      selected: {
        lineWidth: styleSheet.lineSelectedBorder
      },
      inactive: {
        strokeOpacity: styleSheet.lineInactiveBorderOpacity
      }
    }
  };
  var axisStyles = createAxisStyles(styleSheet);
  var legendStyles = createLegendStyles(styleSheet);
  return {
    background: styleSheet.backgroundColor,
    defaultColor: styleSheet.brandColor,
    subColor: styleSheet.subColor,
    semanticRed: styleSheet.paletteSemanticRed,
    semanticGreen: styleSheet.paletteSemanticGreen,
    padding: "auto",
    fontFamily: styleSheet.fontFamily,
    // Theme
    /** geometrygeometrynull */
    columnWidthRatio: 1 / 2,
    /**  */
    maxColumnWidth: null,
    /**  */
    minColumnWidth: null,
    /**  */
    roseWidthRatio: 0.9999999,
    /** / */
    multiplePieWidthRatio: 1 / 1.3,
    colors10: styleSheet.paletteQualitative10,
    colors20: styleSheet.paletteQualitative20,
    sequenceColors: styleSheet.paletteSequence,
    shapes: {
      point: [
        "hollow-circle",
        "hollow-square",
        "hollow-bowtie",
        "hollow-diamond",
        "hollow-hexagon",
        "hollow-triangle",
        "hollow-triangle-down",
        "circle",
        "square",
        "bowtie",
        "diamond",
        "hexagon",
        "triangle",
        "triangle-down",
        "cross",
        "tick",
        "plus",
        "hyphen",
        "line"
      ],
      line: ["line", "dash", "dot", "smooth"],
      area: ["area", "smooth", "line", "smooth-line"],
      interval: ["rect", "hollow-rect", "line", "tick"]
    },
    sizes: [1, 10],
    geometries: {
      interval: {
        rect: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: function(element) {
              var coordinate2 = element.geometry.coordinate;
              if (coordinate2.isPolar && coordinate2.isTransposed) {
                var _a3 = getAngle$1(element.getModel(), coordinate2), startAngle = _a3.startAngle, endAngle = _a3.endAngle;
                var middleAngle = (startAngle + endAngle) / 2;
                var r = 7.5;
                var x = r * Math.cos(middleAngle);
                var y = r * Math.sin(middleAngle);
                return {
                  matrix: transform$6(null, [["t", x, y]])
                };
              }
              return shapeStyles.interval.selected;
            }
          }
        },
        "hollow-rect": {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        funnel: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        },
        pyramid: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      line: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        dot: {
          default: {
            style: __assign$1(__assign$1({}, shapeStyles.line.default), { lineCap: null, lineDash: [1, 1] })
          },
          active: {
            style: __assign$1(__assign$1({}, shapeStyles.line.active), { lineCap: null, lineDash: [1, 1] })
          },
          inactive: {
            style: __assign$1(__assign$1({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [1, 1] })
          },
          selected: {
            style: __assign$1(__assign$1({}, shapeStyles.line.selected), { lineCap: null, lineDash: [1, 1] })
          }
        },
        dash: {
          default: {
            style: __assign$1(__assign$1({}, shapeStyles.line.default), { lineCap: null, lineDash: [5.5, 1] })
          },
          active: {
            style: __assign$1(__assign$1({}, shapeStyles.line.active), { lineCap: null, lineDash: [5.5, 1] })
          },
          inactive: {
            style: __assign$1(__assign$1({}, shapeStyles.line.inactive), { lineCap: null, lineDash: [5.5, 1] })
          },
          selected: {
            style: __assign$1(__assign$1({}, shapeStyles.line.selected), { lineCap: null, lineDash: [5.5, 1] })
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hvh: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      polygon: {
        polygon: {
          default: {
            style: shapeStyles.interval.default
          },
          active: {
            style: shapeStyles.interval.active
          },
          inactive: {
            style: shapeStyles.interval.inactive
          },
          selected: {
            style: shapeStyles.interval.selected
          }
        }
      },
      point: {
        circle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        square: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        bowtie: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        diamond: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        hexagon: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        triangle: {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "triangle-down": {
          default: {
            style: shapeStyles.point.default
          },
          active: {
            style: shapeStyles.point.active
          },
          inactive: {
            style: shapeStyles.point.inactive
          },
          selected: {
            style: shapeStyles.point.selected
          }
        },
        "hollow-circle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-square": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-bowtie": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-diamond": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-hexagon": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        "hollow-triangle-down": {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        cross: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        tick: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        plus: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        hyphen: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowPoint.default
          },
          active: {
            style: shapeStyles.hollowPoint.active
          },
          inactive: {
            style: shapeStyles.hollowPoint.inactive
          },
          selected: {
            style: shapeStyles.hollowPoint.selected
          }
        }
      },
      area: {
        area: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.area.default
          },
          active: {
            style: shapeStyles.area.active
          },
          inactive: {
            style: shapeStyles.area.inactive
          },
          selected: {
            style: shapeStyles.area.selected
          }
        },
        line: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "smooth-line": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      },
      schema: {
        candle: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        },
        box: {
          default: {
            style: shapeStyles.hollowInterval.default
          },
          active: {
            style: shapeStyles.hollowInterval.active
          },
          inactive: {
            style: shapeStyles.hollowInterval.inactive
          },
          selected: {
            style: shapeStyles.hollowInterval.selected
          }
        }
      },
      edge: {
        line: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        vhv: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        arc: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        }
      },
      violin: {
        violin: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        smooth: {
          default: {
            style: shapeStyles.line.default
          },
          active: {
            style: shapeStyles.line.active
          },
          inactive: {
            style: shapeStyles.line.inactive
          },
          selected: {
            style: shapeStyles.line.selected
          }
        },
        hollow: {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        },
        "hollow-smooth": {
          default: {
            style: shapeStyles.hollowArea.default
          },
          active: {
            style: shapeStyles.hollowArea.active
          },
          inactive: {
            style: shapeStyles.hollowArea.inactive
          },
          selected: {
            style: shapeStyles.hollowArea.selected
          }
        }
      }
    },
    components: {
      axis: {
        common: axisStyles,
        top: {
          position: "top",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        bottom: {
          position: "bottom",
          grid: null,
          title: null,
          verticalLimitLength: 1 / 2
        },
        left: {
          position: "left",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        right: {
          position: "right",
          title: null,
          line: null,
          tickLine: null,
          verticalLimitLength: 1 / 3
        },
        circle: {
          title: null,
          grid: deepMix({}, axisStyles.grid, { line: { type: "line" } })
        },
        radius: {
          title: null,
          grid: deepMix({}, axisStyles.grid, { line: { type: "circle" } })
        }
      },
      legend: {
        common: legendStyles,
        right: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        left: {
          layout: "vertical",
          padding: styleSheet.legendVerticalPadding
        },
        top: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        bottom: {
          layout: "horizontal",
          padding: styleSheet.legendHorizontalPadding
        },
        continuous: {
          title: null,
          background: null,
          track: {},
          rail: {
            type: "color",
            size: styleSheet.sliderRailHeight,
            defaultLength: styleSheet.sliderRailWidth,
            style: {
              fill: styleSheet.sliderRailFillColor,
              stroke: styleSheet.sliderRailBorderColor,
              lineWidth: styleSheet.sliderRailBorder
            }
          },
          label: {
            align: "rail",
            spacing: 4,
            formatter: null,
            style: {
              fill: styleSheet.sliderLabelTextFillColor,
              fontSize: styleSheet.sliderLabelTextFontSize,
              lineHeight: styleSheet.sliderLabelTextLineHeight,
              textBaseline: "middle",
              fontFamily: styleSheet.fontFamily
            }
          },
          handler: {
            size: styleSheet.sliderHandlerWidth,
            style: {
              fill: styleSheet.sliderHandlerFillColor,
              stroke: styleSheet.sliderHandlerBorderColor
            }
          },
          slidable: true,
          padding: legendStyles.padding
        }
      },
      tooltip: {
        showContent: true,
        follow: true,
        showCrosshairs: false,
        showMarkers: true,
        shared: false,
        enterable: false,
        position: "auto",
        marker: {
          symbol: "circle",
          stroke: "#fff",
          shadowBlur: 10,
          shadowOffsetX: 0,
          shadowOffsetY: 0,
          shadowColor: "rgba(0,0,0,0.09)",
          lineWidth: 2,
          r: 4
        },
        crosshairs: {
          line: {
            style: {
              stroke: styleSheet.tooltipCrosshairsBorderColor,
              lineWidth: styleSheet.tooltipCrosshairsBorder
            }
          },
          text: null,
          textBackground: {
            padding: 2,
            style: {
              fill: "rgba(0, 0, 0, 0.25)",
              lineWidth: 0,
              stroke: null
            }
          },
          follow: false
        },
        // tooltip dom 
        domStyles: (_a2 = {}, _a2["".concat(CONTAINER_CLASS)] = {
          position: "absolute",
          visibility: "hidden",
          zIndex: 8,
          transition: "left 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s, top 0.4s cubic-bezier(0.23, 1, 0.32, 1) 0s",
          backgroundColor: styleSheet.tooltipContainerFillColor,
          opacity: styleSheet.tooltipContainerFillOpacity,
          boxShadow: styleSheet.tooltipContainerShadow,
          borderRadius: "".concat(styleSheet.tooltipContainerBorderRadius, "px"),
          color: styleSheet.tooltipTextFillColor,
          fontSize: "".concat(styleSheet.tooltipTextFontSize, "px"),
          fontFamily: styleSheet.fontFamily,
          lineHeight: "".concat(styleSheet.tooltipTextLineHeight, "px"),
          padding: "0 12px 0 12px"
        }, _a2["".concat(TITLE_CLASS)] = {
          marginBottom: "12px",
          marginTop: "12px"
        }, _a2["".concat(LIST_CLASS)] = {
          margin: 0,
          listStyleType: "none",
          padding: 0
        }, _a2["".concat(LIST_ITEM_CLASS)] = {
          listStyleType: "none",
          padding: 0,
          marginBottom: "12px",
          marginTop: "12px",
          marginLeft: 0,
          marginRight: 0
        }, _a2["".concat(MARKER_CLASS)] = {
          width: "8px",
          height: "8px",
          borderRadius: "50%",
          display: "inline-block",
          marginRight: "8px"
        }, _a2["".concat(VALUE_CLASS)] = {
          display: "inline-block",
          float: "right",
          marginLeft: "30px"
        }, _a2)
      },
      annotation: {
        arc: {
          style: {
            stroke: styleSheet.annotationArcBorderColor,
            lineWidth: styleSheet.annotationArcBorder
          },
          animate: true
        },
        line: {
          style: {
            stroke: styleSheet.annotationLineBorderColor,
            lineDash: styleSheet.annotationLineDash,
            lineWidth: styleSheet.annotationLineBorder
          },
          text: {
            position: "start",
            autoRotate: true,
            style: {
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              textAlign: "start",
              fontFamily: styleSheet.fontFamily,
              textBaseline: "bottom"
            }
          },
          animate: true
        },
        text: {
          style: {
            fill: styleSheet.annotationTextFillColor,
            stroke: styleSheet.annotationTextBorderColor,
            lineWidth: styleSheet.annotationTextBorder,
            fontSize: styleSheet.annotationTextFontSize,
            textBaseline: "middle",
            textAlign: "start",
            fontFamily: styleSheet.fontFamily
          },
          animate: true
        },
        region: {
          top: false,
          style: {
            lineWidth: styleSheet.annotationRegionBorder,
            stroke: styleSheet.annotationRegionBorderColor,
            fill: styleSheet.annotationRegionFillColor,
            fillOpacity: styleSheet.annotationRegionFillOpacity
          },
          animate: true
        },
        image: {
          top: false,
          animate: true
        },
        dataMarker: {
          top: true,
          point: {
            style: {
              r: 3,
              stroke: styleSheet.brandColor,
              lineWidth: 2
            }
          },
          line: {
            style: {
              stroke: styleSheet.annotationLineBorderColor,
              lineWidth: styleSheet.annotationLineBorder
            },
            length: styleSheet.annotationDataMarkerLineLength
          },
          text: {
            style: {
              textAlign: "start",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          direction: "upward",
          autoAdjust: true,
          animate: true
        },
        dataRegion: {
          style: {
            region: {
              fill: styleSheet.annotationRegionFillColor,
              fillOpacity: styleSheet.annotationRegionFillOpacity
            },
            text: {
              textAlign: "center",
              textBaseline: "bottom",
              fill: styleSheet.annotationTextFillColor,
              stroke: styleSheet.annotationTextBorderColor,
              lineWidth: styleSheet.annotationTextBorder,
              fontSize: styleSheet.annotationTextFontSize,
              fontFamily: styleSheet.fontFamily
            }
          },
          animate: true
        }
      },
      slider: {
        common: {
          padding: [8, 8, 8, 8],
          backgroundStyle: {
            fill: styleSheet.cSliderBackgroundFillColor,
            opacity: styleSheet.cSliderBackgroundFillOpacity
          },
          foregroundStyle: {
            fill: styleSheet.cSliderForegroundFillColor,
            opacity: styleSheet.cSliderForegroundFillOpacity
          },
          handlerStyle: {
            width: styleSheet.cSliderHandlerWidth,
            height: styleSheet.cSliderHandlerHeight,
            fill: styleSheet.cSliderHandlerFillColor,
            opacity: styleSheet.cSliderHandlerFillOpacity,
            stroke: styleSheet.cSliderHandlerBorderColor,
            lineWidth: styleSheet.cSliderHandlerBorder,
            radius: styleSheet.cSliderHandlerBorderRadius,
            // 
            highLightFill: styleSheet.cSliderHandlerHighlightFillColor
          },
          textStyle: {
            fill: styleSheet.cSliderTextFillColor,
            opacity: styleSheet.cSliderTextFillOpacity,
            fontSize: styleSheet.cSliderTextFontSize,
            lineHeight: styleSheet.cSliderTextLineHeight,
            fontWeight: styleSheet.cSliderTextFontWeight,
            stroke: styleSheet.cSliderTextBorderColor,
            lineWidth: styleSheet.cSliderTextBorder
          }
        }
      },
      scrollbar: {
        common: {
          padding: [8, 8, 8, 8]
        },
        default: {
          style: {
            trackColor: styleSheet.scrollbarTrackFillColor,
            thumbColor: styleSheet.scrollbarThumbFillColor
          }
        },
        hover: {
          style: {
            thumbColor: styleSheet.scrollbarThumbHighlightFillColor
          }
        }
      }
    },
    labels: {
      offset: 12,
      style: {
        fill: styleSheet.labelFillColor,
        fontSize: styleSheet.labelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.labelBorderColor,
        lineWidth: styleSheet.labelBorder
      },
      fillColorDark: styleSheet.labelFillColorDark,
      fillColorLight: styleSheet.labelFillColorLight,
      autoRotate: true
    },
    innerLabels: {
      style: {
        fill: styleSheet.innerLabelFillColor,
        fontSize: styleSheet.innerLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.innerLabelBorderColor,
        lineWidth: styleSheet.innerLabelBorder
      },
      autoRotate: true
    },
    overflowLabels: {
      style: {
        fill: styleSheet.overflowLabelFillColor,
        fontSize: styleSheet.overflowLabelFontSize,
        fontFamily: styleSheet.fontFamily,
        stroke: styleSheet.overflowLabelBorderColor,
        lineWidth: styleSheet.overflowLabelBorder
      }
    },
    pieLabels: {
      labelHeight: 14,
      offset: 10,
      labelLine: {
        style: {
          lineWidth: styleSheet.labelLineBorder
        }
      },
      autoRotate: true
    }
  };
}
var BLACK_COLORS$1 = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var WHITE_COLORS$1 = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10$1 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#6F5EF9",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20$1 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#6F5EF9",
  "#D3CEFD",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE$1 = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createLightStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a2 = cfg.paletteQualitative10, paletteQualitative10 = _a2 === void 0 ? QUALITATIVE_10$1 : _a2, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20$1 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    /**  */
    backgroundColor: "transparent",
    /**  */
    brandColor,
    /**  */
    subColor: "rgba(0,0,0,0.05)",
    /**  1 10  */
    paletteQualitative10,
    /**  2 10  */
    paletteQualitative20,
    /**  */
    paletteSemanticRed: "#F4664A",
    /**  */
    paletteSemanticGreen: "#30BF78",
    /**  */
    paletteSemanticYellow: "#FAAD14",
    /** () */
    paletteSequence: SINGLE_SEQUENCE$1,
    /**  */
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    // --------------------  --------------------
    /**  */
    axisLineBorderColor: BLACK_COLORS$1[25],
    /**  */
    axisLineBorder: 1,
    /**  lineDash  */
    axisLineDash: null,
    /**  */
    axisTitleTextFillColor: BLACK_COLORS$1[65],
    /**  */
    axisTitleTextFontSize: 12,
    /**  */
    axisTitleTextLineHeight: 12,
    /**  */
    axisTitleTextFontWeight: "normal",
    /**  */
    axisTitleSpacing: 12,
    /** icon */
    axisDescriptionIconFillColor: WHITE_COLORS$1[85],
    /**  */
    axisTickLineBorderColor: BLACK_COLORS$1[25],
    /**  */
    axisTickLineLength: 4,
    /**  */
    axisTickLineBorder: 1,
    /**  */
    axisSubTickLineBorderColor: BLACK_COLORS$1[15],
    /**  */
    axisSubTickLineLength: 2,
    /**  */
    axisSubTickLineBorder: 1,
    /**  */
    axisLabelFillColor: BLACK_COLORS$1[45],
    /**  */
    axisLabelFontSize: 12,
    /**  */
    axisLabelLineHeight: 12,
    /**  */
    axisLabelFontWeight: "normal",
    /**  */
    axisLabelOffset: 8,
    /**  */
    axisGridBorderColor: BLACK_COLORS$1[15],
    /**  */
    axisGridBorder: 1,
    /**  */
    axisGridLineDash: null,
    // --------------------  --------------------
    /**  */
    legendTitleTextFillColor: BLACK_COLORS$1[45],
    /**  */
    legendTitleTextFontSize: 12,
    /**  */
    legendTitleTextLineHeight: 21,
    /**  */
    legendTitleTextFontWeight: "normal",
    /**  marker  */
    legendMarkerColor: brandColor,
    /**  marker  */
    legendMarkerSpacing: 8,
    /**  marker  */
    legendMarkerSize: 4,
    /**  'circle' marker  */
    legendCircleMarkerSize: 4,
    /**  'square' marker  */
    legendSquareMarkerSize: 4,
    /**  'line' marker  */
    legendLineMarkerSize: 5,
    /**  */
    legendItemNameFillColor: BLACK_COLORS$1[65],
    /**  */
    legendItemNameFontSize: 12,
    /**  */
    legendItemNameLineHeight: 12,
    /**  */
    legendItemNameFontWeight: "normal",
    /**  */
    legendItemSpacing: 24,
    /**  */
    legendItemMarginBottom: 12,
    /**   */
    legendPadding: [8, 8, 8, 8],
    /**  */
    legendHorizontalPadding: [8, 0, 8, 0],
    /**  */
    legendVerticalPadding: [0, 8, 0, 8],
    // 
    /**  marker  */
    legendPageNavigatorMarkerSize: 12,
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS$1[100],
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    /**  marker  */
    legendPageNavigatorMarkerFillColor: BLACK_COLORS$1[100],
    /**  marker  */
    legendPageNavigatorMarkerFillOpacity: 1,
    /**  */
    legendPageNavigatorTextFillColor: BLACK_COLORS$1[45],
    /**  */
    legendPageNavigatorTextFontSize: 12,
    /**  */
    sliderRailFillColor: BLACK_COLORS$1[15],
    /**  */
    sliderRailBorder: 0,
    /**  */
    sliderRailBorderColor: null,
    /**  */
    sliderRailWidth: 100,
    /**  */
    sliderRailHeight: 12,
    /**  */
    sliderLabelTextFillColor: BLACK_COLORS$1[45],
    /**  */
    sliderLabelTextFontSize: 12,
    /**  */
    sliderLabelTextLineHeight: 12,
    /**  */
    sliderLabelTextFontWeight: "normal",
    /**  */
    sliderHandlerFillColor: BLACK_COLORS$1[6],
    /**  */
    sliderHandlerWidth: 10,
    /**  */
    sliderHandlerHeight: 14,
    /**  */
    sliderHandlerBorder: 1,
    /**  */
    sliderHandlerBorderColor: BLACK_COLORS$1[25],
    // -------------------- Annotation --------------------
    /** arc  */
    annotationArcBorderColor: BLACK_COLORS$1[15],
    /** arc  */
    annotationArcBorder: 1,
    /** line  */
    annotationLineBorderColor: BLACK_COLORS$1[25],
    /** line  */
    annotationLineBorder: 1,
    /** lube  */
    annotationLineDash: null,
    /** text  */
    annotationTextFillColor: BLACK_COLORS$1[65],
    /** text  */
    annotationTextFontSize: 12,
    /** text  */
    annotationTextLineHeight: 12,
    /** text  */
    annotationTextFontWeight: "normal",
    /** text  */
    annotationTextBorderColor: null,
    /** text  */
    annotationTextBorder: 0,
    /** region  */
    annotationRegionFillColor: BLACK_COLORS$1[100],
    /** region  */
    annotationRegionFillOpacity: 0.06,
    /** region  */
    annotationRegionBorder: 0,
    /** region  */
    annotationRegionBorderColor: null,
    /** dataMarker  */
    annotationDataMarkerLineLength: 16,
    // -------------------- Tooltip --------------------
    /** tooltip crosshairs  */
    tooltipCrosshairsBorderColor: BLACK_COLORS$1[25],
    /** tooltip crosshairs  */
    tooltipCrosshairsBorder: 1,
    /** tooltip crosshairs  */
    tooltipCrosshairsLineDash: null,
    /** tooltip  */
    tooltipContainerFillColor: "rgb(255, 255, 255)",
    tooltipContainerFillOpacity: 0.95,
    /** tooltip  */
    tooltipContainerShadow: "0px 0px 10px #aeaeae",
    /** tooltip  */
    tooltipContainerBorderRadius: 3,
    /** tooltip  */
    tooltipTextFillColor: BLACK_COLORS$1[65],
    /** tooltip  */
    tooltipTextFontSize: 12,
    /** tooltip  */
    tooltipTextLineHeight: 12,
    /** tooltip  */
    tooltipTextFontWeight: "bold",
    // -------------------- Geometry labels --------------------
    /** Geometry label  */
    labelFillColor: BLACK_COLORS$1[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    /** Geometry label  */
    labelFontSize: 12,
    /** Geometry label  */
    labelLineHeight: 12,
    /** Geometry label  */
    labelFontWeight: "normal",
    /** Geometry label  */
    labelBorderColor: null,
    /** Geometry label  */
    labelBorder: 0,
    /** Geometry innerLabel  */
    innerLabelFillColor: WHITE_COLORS$1[100],
    /** Geometry innerLabel  */
    innerLabelFontSize: 12,
    /** Geometry innerLabel  */
    innerLabelLineHeight: 12,
    /** Geometry innerLabel  */
    innerLabelFontWeight: "normal",
    /** Geometry innerLabel  */
    innerLabelBorderColor: null,
    /** Geometry innerLabel  */
    innerLabelBorder: 0,
    /** Geometry overflowLabel  */
    overflowLabelFillColor: BLACK_COLORS$1[65],
    /** Geometry overflowLabel  */
    overflowLabelFontSize: 12,
    /** Geometry overflowLabel  */
    overflowLabelLineHeight: 12,
    /** Geometry overflowLabel  */
    overflowLabelFontWeight: "normal",
    /** Geometry overflowLabel  */
    overflowLabelBorderColor: WHITE_COLORS$1[100],
    /** Geometry overflowLabel  */
    overflowLabelBorder: 1,
    /** Geometry label  */
    labelLineBorder: 1,
    /** Geometry label  */
    labelLineBorderColor: BLACK_COLORS$1[25],
    // -------------------- Slider --------------------
    /** slider  */
    cSliderRailHieght: 16,
    /** slider  */
    cSliderBackgroundFillColor: "#416180",
    /** slider  */
    cSliderBackgroundFillOpacity: 0.05,
    /** slider  */
    cSliderForegroundFillColor: "#5B8FF9",
    /** slider  */
    cSliderForegroundFillOpacity: 0.15,
    // slider handlerStyle 
    /** slider  */
    cSliderHandlerHeight: 24,
    /** Slider  */
    cSliderHandlerWidth: 10,
    /** Slider  */
    cSliderHandlerFillColor: "#F7F7F7",
    /** Slider  */
    cSliderHandlerFillOpacity: 1,
    /** Slider  */
    cSliderHandlerHighlightFillColor: "#FFF",
    /** Slider  */
    cSliderHandlerBorderColor: "#BFBFBF",
    /** Slider  */
    cSliderHandlerBorder: 1,
    /** Slider  */
    cSliderHandlerBorderRadius: 2,
    // slider textStyle 
    /** Slider  */
    cSliderTextFillColor: "#000",
    /** Slider  */
    cSliderTextFillOpacity: 0.45,
    /** Slider  */
    cSliderTextFontSize: 12,
    /** Slider  */
    cSliderTextLineHeight: 12,
    /** Slider  */
    cSliderTextFontWeight: "normal",
    /** Slider  */
    cSliderTextBorderColor: null,
    /** Slider  */
    cSliderTextBorder: 0,
    // -------------------- Scrollbar --------------------
    /**   */
    scrollbarTrackFillColor: "rgba(0,0,0,0)",
    /**   */
    scrollbarThumbFillColor: "rgba(0,0,0,0.15)",
    /**   */
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.2)",
    // -------------------- Geometry --------------------
    /**  */
    pointFillColor: brandColor,
    /**  */
    pointFillOpacity: 0.95,
    /**  */
    pointSize: 4,
    /**  */
    pointBorder: 1,
    /**  */
    pointBorderColor: WHITE_COLORS$1[100],
    /**  */
    pointBorderOpacity: 1,
    /**  active  */
    pointActiveBorderColor: BLACK_COLORS$1[100],
    /**  selected  */
    pointSelectedBorder: 2,
    /**  selected  */
    pointSelectedBorderColor: BLACK_COLORS$1[100],
    /**  inactive  */
    pointInactiveFillOpacity: 0.3,
    /**  inactive  */
    pointInactiveBorderOpacity: 0.3,
    /**  */
    hollowPointSize: 4,
    /**  */
    hollowPointBorder: 1,
    /**  */
    hollowPointBorderColor: brandColor,
    /**  */
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS$1[100],
    /**  active  */
    hollowPointActiveBorder: 1,
    /**  active  */
    hollowPointActiveBorderColor: BLACK_COLORS$1[100],
    /**  active  */
    hollowPointActiveBorderOpacity: 1,
    /**  selected  */
    hollowPointSelectedBorder: 2,
    /**  selected  */
    hollowPointSelectedBorderColor: BLACK_COLORS$1[100],
    /**  selected  */
    hollowPointSelectedBorderOpacity: 1,
    /**  inactive  */
    hollowPointInactiveBorderOpacity: 0.3,
    /**  */
    lineBorder: 2,
    /**  */
    lineBorderColor: brandColor,
    /**  */
    lineBorderOpacity: 1,
    /**  Active  */
    lineActiveBorder: 3,
    /**  selected  */
    lineSelectedBorder: 3,
    /**  inactive  */
    lineInactiveBorderOpacity: 0.3,
    /** area  */
    areaFillColor: brandColor,
    /** area  */
    areaFillOpacity: 0.25,
    /** area  active  */
    areaActiveFillColor: brandColor,
    areaActiveFillOpacity: 0.5,
    /** area  selected  */
    areaSelectedFillColor: brandColor,
    areaSelectedFillOpacity: 0.5,
    /** area inactive  */
    areaInactiveFillOpacity: 0.3,
    /** hollowArea  */
    hollowAreaBorderColor: brandColor,
    /** hollowArea  */
    hollowAreaBorder: 2,
    /** hollowArea  */
    hollowAreaBorderOpacity: 1,
    /** hollowArea active  */
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS$1[100],
    /** hollowArea selected  */
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS$1[100],
    /** hollowArea inactive  */
    hollowAreaInactiveBorderOpacity: 0.3,
    /** interval  */
    intervalFillColor: brandColor,
    /** interval  */
    intervalFillOpacity: 0.95,
    /** interval active  */
    intervalActiveBorder: 1,
    /** interval active  */
    intervalActiveBorderColor: BLACK_COLORS$1[100],
    intervalActiveBorderOpacity: 1,
    /** interval selected  */
    intervalSelectedBorder: 2,
    /** interval selected  */
    intervalSelectedBorderColor: BLACK_COLORS$1[100],
    /** interval selected  */
    intervalSelectedBorderOpacity: 1,
    /** interval inactive  */
    intervalInactiveBorderOpacity: 0.3,
    /** interval inactive  */
    intervalInactiveFillOpacity: 0.3,
    /** interval  */
    hollowIntervalBorder: 2,
    /** hollowInterval  */
    hollowIntervalBorderColor: brandColor,
    /** hollowInterval  */
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS$1[100],
    /** hollowInterval active  */
    hollowIntervalActiveBorder: 2,
    /** hollowInterval active  */
    hollowIntervalActiveBorderColor: BLACK_COLORS$1[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorder: 3,
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderColor: BLACK_COLORS$1[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderOpacity: 1,
    /** hollowInterval inactive  */
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign$1(__assign$1({}, token2), cfg);
};
createLightStyleSheet();
function createTheme(themeCfg) {
  var _a2 = themeCfg.styleSheet, styleSheetCfg = _a2 === void 0 ? {} : _a2, themeObject = __rest(themeCfg, ["styleSheet"]);
  var styleSheet = createLightStyleSheet(styleSheetCfg);
  return deepMix({}, createThemeByStyleSheet(styleSheet), themeObject);
}
var defaultTheme = createTheme({});
var Themes = {
  default: defaultTheme
};
function getTheme(theme2) {
  return get(Themes, lowerCase(theme2), Themes.default);
}
function registerTheme(theme2, value2) {
  Themes[lowerCase(theme2)] = createTheme(value2);
}
function snapEqual(v1, v2, scale2) {
  var value1 = scale2.translate(v1);
  var value2 = scale2.translate(v2);
  return isNumberEqual$1(value1, value2);
}
function getXValueByPoint(point2, geometry2) {
  var coordinate2 = geometry2.coordinate;
  var xScale = geometry2.getXScale();
  var range = xScale.range;
  var rangeMax = range[range.length - 1];
  var rangeMin = range[0];
  var invertPoint = coordinate2.invert(point2);
  var xValue = invertPoint.x;
  if (coordinate2.isPolar && xValue > (1 + rangeMax) / 2) {
    xValue = rangeMin;
  }
  return xScale.translate(xScale.invert(xValue));
}
function filterYValue(data2, point2, geometry2) {
  var coordinate2 = geometry2.coordinate;
  var yScale = geometry2.getYScale();
  var yField = yScale.field;
  var invertPoint = coordinate2.invert(point2);
  var yValue = yScale.invert(invertPoint.y);
  var result = find$1(data2, function(obj) {
    var originData = obj[FIELD_ORIGIN];
    return originData[yField][0] <= yValue && originData[yField][1] >= yValue;
  });
  return result || data2[data2.length - 1];
}
var getXDistance = memoize(function(scale2) {
  if (scale2.isCategory) {
    return 1;
  }
  var scaleValues = scale2.values;
  var length2 = scaleValues.length;
  var min2 = scale2.translate(scaleValues[0]);
  var max2 = min2;
  for (var index2 = 0; index2 < length2; index2++) {
    var value2 = scaleValues[index2];
    var numericValue = scale2.translate(value2);
    if (numericValue < min2) {
      min2 = numericValue;
    }
    if (numericValue > max2) {
      max2 = numericValue;
    }
  }
  return (max2 - min2) / (length2 - 1);
});
function getTooltipTitle(originData, geometry2, title) {
  var positionAttr = geometry2.getAttribute("position");
  var fields = positionAttr.getFields();
  var scales = geometry2.scales;
  var titleField = isFunction(title) || !title ? fields[0] : title;
  var titleScale = scales[titleField];
  var tooltipTitle = titleScale ? titleScale.getText(originData[titleField]) : originData[titleField] || titleField;
  return isFunction(title) ? title(tooltipTitle, originData) : tooltipTitle;
}
function getAttributesForLegend(geometry2) {
  var attributes = values(geometry2.attributes);
  return filter(attributes, function(attribute) {
    return contains(GROUP_ATTRS, attribute.type);
  });
}
function getTooltipValueScale(geometry2) {
  var e_1, _a2;
  var attributes = getAttributesForLegend(geometry2);
  var scale2;
  try {
    for (var attributes_1 = __values(attributes), attributes_1_1 = attributes_1.next(); !attributes_1_1.done; attributes_1_1 = attributes_1.next()) {
      var attribute = attributes_1_1.value;
      var tmpScale = attribute.getScale(attribute.type);
      if (tmpScale && tmpScale.isLinear) {
        var tmpScaleDef = get(geometry2.scaleDefs, tmpScale.field);
        var inferedScaleType = inferScaleType(tmpScale, tmpScaleDef, attribute.type, geometry2.type);
        if (inferedScaleType !== "cat") {
          scale2 = tmpScale;
          break;
        }
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (attributes_1_1 && !attributes_1_1.done && (_a2 = attributes_1.return))
        _a2.call(attributes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var xScale = geometry2.getXScale();
  var yScale = geometry2.getYScale();
  return scale2 || yScale || xScale;
}
function getTooltipValue(originData, valueScale) {
  var field2 = valueScale.field;
  var value2 = originData[field2];
  if (isArray$1(value2)) {
    var texts = value2.map(function(eachValue) {
      return valueScale.getText(eachValue);
    });
    return texts.join("-");
  }
  return valueScale.getText(value2);
}
function getTooltipName(originData, geometry2) {
  var nameScale;
  var groupScales = geometry2.getGroupScales();
  if (groupScales.length) {
    nameScale = groupScales[0];
  }
  if (nameScale) {
    var field2 = nameScale.field;
    return nameScale.getText(originData[field2]);
  }
  var valueScale = getTooltipValueScale(geometry2);
  return getName(valueScale);
}
function findDataByPoint(point2, data2, geometry2) {
  if (data2.length === 0) {
    return null;
  }
  var geometryType = geometry2.type;
  var xScale = geometry2.getXScale();
  var yScale = geometry2.getYScale();
  var xField = xScale.field;
  var yField = yScale.field;
  var rst = null;
  if (geometryType === "heatmap" || geometryType === "point") {
    var coordinate2 = geometry2.coordinate;
    var invertPoint = coordinate2.invert(point2);
    var x = xScale.invert(invertPoint.x);
    var y = yScale.invert(invertPoint.y);
    var min2 = Infinity;
    for (var index2 = 0; index2 < data2.length; index2++) {
      var obj = data2[index2];
      var originData = obj[FIELD_ORIGIN];
      var range = Math.pow(originData[xField] - x, 2) + Math.pow(originData[yField] - y, 2);
      if (range < min2) {
        min2 = range;
        rst = obj;
      }
    }
    return rst;
  }
  var first = data2[0];
  var last2 = data2[data2.length - 1];
  var xValue = getXValueByPoint(point2, geometry2);
  var firstXValue = first[FIELD_ORIGIN][xField];
  var firstYValue = first[FIELD_ORIGIN][yField];
  var lastXValue = last2[FIELD_ORIGIN][xField];
  var isYArray = yScale.isLinear && isArray$1(firstYValue);
  if (isArray$1(firstXValue)) {
    for (var index2 = 0; index2 < data2.length; index2++) {
      var record = data2[index2];
      var originData = record[FIELD_ORIGIN];
      if (xScale.translate(originData[xField][0]) <= xValue && xScale.translate(originData[xField][1]) >= xValue) {
        if (isYArray) {
          if (!isArray$1(rst)) {
            rst = [];
          }
          rst.push(record);
        } else {
          rst = record;
          break;
        }
      }
    }
    if (isArray$1(rst)) {
      rst = filterYValue(rst, point2, geometry2);
    }
  } else {
    var next = void 0;
    if (!xScale.isLinear && xScale.type !== "timeCat") {
      for (var index2 = 0; index2 < data2.length; index2++) {
        var record = data2[index2];
        var originData = record[FIELD_ORIGIN];
        if (snapEqual(originData[xField], xValue, xScale)) {
          if (isYArray) {
            if (!isArray$1(rst)) {
              rst = [];
            }
            rst.push(record);
          } else {
            rst = record;
            break;
          }
        } else if (xScale.translate(originData[xField]) <= xValue) {
          last2 = record;
          next = data2[index2 + 1];
        }
      }
      if (isArray$1(rst)) {
        rst = filterYValue(rst, point2, geometry2);
      }
    } else {
      if ((xValue > xScale.translate(lastXValue) || xValue < xScale.translate(firstXValue)) && (xValue > xScale.max || xValue < xScale.min)) {
        return null;
      }
      var firstIdx = 0;
      var lastIdx = data2.length - 1;
      var middleIdx = void 0;
      while (firstIdx <= lastIdx) {
        middleIdx = Math.floor((firstIdx + lastIdx) / 2);
        var item = data2[middleIdx][FIELD_ORIGIN][xField];
        if (snapEqual(item, xValue, xScale)) {
          return data2[middleIdx];
        }
        if (xScale.translate(item) <= xScale.translate(xValue)) {
          firstIdx = middleIdx + 1;
          last2 = data2[middleIdx];
          next = data2[middleIdx + 1];
        } else {
          if (lastIdx === 0) {
            last2 = data2[0];
          }
          lastIdx = middleIdx - 1;
        }
      }
    }
    if (last2 && next) {
      if (Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) > Math.abs(xScale.translate(next[FIELD_ORIGIN][xField]) - xValue)) {
        last2 = next;
      }
    }
  }
  var distance2 = getXDistance(geometry2.getXScale());
  if (!rst && Math.abs(xScale.translate(last2[FIELD_ORIGIN][xField]) - xValue) <= distance2 / 2) {
    rst = last2;
  }
  return rst;
}
function getTooltipItems(data2, geometry2, title, showNil) {
  var e_2, _a2;
  if (title === void 0) {
    title = "";
  }
  if (showNil === void 0) {
    showNil = false;
  }
  var originData = data2[FIELD_ORIGIN];
  var tooltipTitle = getTooltipTitle(originData, geometry2, title);
  var tooltipOption = geometry2.tooltipOption;
  var defaultColor = geometry2.theme.defaultColor;
  var items = [];
  var name;
  var value2;
  function addItem(itemName, itemValue) {
    if (showNil || !isNil(itemValue) && itemValue !== "") {
      var item = {
        title: tooltipTitle,
        data: originData,
        mappingData: data2,
        name: itemName,
        value: itemValue,
        color: data2.color || defaultColor,
        marker: true
      };
      items.push(item);
    }
  }
  if (isObject(tooltipOption)) {
    var fields = tooltipOption.fields, callback = tooltipOption.callback;
    if (callback) {
      var callbackParams = fields.map(function(field3) {
        return data2[FIELD_ORIGIN][field3];
      });
      var cfg = callback.apply(void 0, __spreadArray$1([], __read(callbackParams), false));
      var itemCfg = __assign$1({ data: data2[FIELD_ORIGIN], mappingData: data2, title: tooltipTitle, color: data2.color || defaultColor, marker: true }, cfg);
      items.push(itemCfg);
    } else {
      var scales = geometry2.scales;
      try {
        for (var fields_1 = __values(fields), fields_1_1 = fields_1.next(); !fields_1_1.done; fields_1_1 = fields_1.next()) {
          var field2 = fields_1_1.value;
          if (!isNil(originData[field2])) {
            var scale2 = scales[field2];
            name = getName(scale2);
            value2 = scale2.getText(originData[field2]);
            addItem(name, value2);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (fields_1_1 && !fields_1_1.done && (_a2 = fields_1.return))
            _a2.call(fields_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
    }
  } else {
    var valueScale = getTooltipValueScale(geometry2);
    value2 = getTooltipValue(originData, valueScale);
    name = getTooltipName(originData, geometry2);
    addItem(name, value2);
  }
  return items;
}
function getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg) {
  var e_3, _a2;
  var showNil = tooltipCfg.showNil;
  var result = [];
  var dataArray = geometry2.dataArray;
  if (!isEmpty(dataArray)) {
    geometry2.sort(dataArray);
    try {
      for (var dataArray_1 = __values(dataArray), dataArray_1_1 = dataArray_1.next(); !dataArray_1_1.done; dataArray_1_1 = dataArray_1.next()) {
        var data2 = dataArray_1_1.value;
        var record = findDataByPoint(point2, data2, geometry2);
        if (record) {
          var elementId = geometry2.getElementId(record);
          var element = geometry2.elementsMap[elementId];
          if (geometry2.type === "heatmap" || element.visible) {
            var items = getTooltipItems(record, geometry2, title, showNil);
            if (items.length) {
              result.push(items);
            }
          }
        }
      }
    } catch (e_3_1) {
      e_3 = { error: e_3_1 };
    } finally {
      try {
        if (dataArray_1_1 && !dataArray_1_1.done && (_a2 = dataArray_1.return))
          _a2.call(dataArray_1);
      } finally {
        if (e_3)
          throw e_3.error;
      }
    }
  }
  return result;
}
function getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg) {
  var showNil = tooltipCfg.showNil;
  var result = [];
  var container = geometry2.container;
  var shape = container.getShape(point2.x, point2.y);
  if (shape && shape.get("visible") && shape.get("origin")) {
    var mappingData = shape.get("origin").mappingData;
    var items = getTooltipItems(mappingData, geometry2, title, showNil);
    if (items.length) {
      result.push(items);
    }
  }
  return result;
}
function findItemsFromView(view, point2, tooltipCfg) {
  var e_4, _a2;
  var result = [];
  var geometries = view.geometries;
  var shared = tooltipCfg.shared, title = tooltipCfg.title, reversed = tooltipCfg.reversed;
  try {
    for (var geometries_1 = __values(geometries), geometries_1_1 = geometries_1.next(); !geometries_1_1.done; geometries_1_1 = geometries_1.next()) {
      var geometry2 = geometries_1_1.value;
      if (geometry2.visible && geometry2.tooltipOption !== false) {
        var geometryType = geometry2.type;
        var tooltipItems = void 0;
        if (["point", "edge", "polygon"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg);
        } else if (["area", "line", "path", "heatmap"].includes(geometryType)) {
          tooltipItems = getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg);
        } else {
          if (shared !== false) {
            tooltipItems = getTooltipItemsByFindData(geometry2, point2, title, tooltipCfg);
          } else {
            tooltipItems = getTooltipItemsByHitShape(geometry2, point2, title, tooltipCfg);
          }
        }
        if (tooltipItems.length) {
          if (reversed) {
            tooltipItems.reverse();
          }
          result.push(tooltipItems);
        }
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (geometries_1_1 && !geometries_1_1.done && (_a2 = geometries_1.return))
        _a2.call(geometries_1);
    } finally {
      if (e_4)
        throw e_4.error;
    }
  }
  return result;
}
function findItemsFromViewRecurisive(view, point2, tooltipCfg) {
  var e_5, _a2;
  var result = findItemsFromView(view, point2, tooltipCfg);
  try {
    for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
      var childView = _c.value;
      result = result.concat(findItemsFromView(childView, point2, tooltipCfg));
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a2 = _b.return))
        _a2.call(_b);
    } finally {
      if (e_5)
        throw e_5.error;
    }
  }
  return result;
}
function isAutoPadding(padding2) {
  return !isNumber$1(padding2) && !isArray$1(padding2);
}
function parsePadding(padding2) {
  if (padding2 === void 0) {
    padding2 = 0;
  }
  var paddingArray = isArray$1(padding2) ? padding2 : [padding2];
  switch (paddingArray.length) {
    case 0:
      paddingArray = [0, 0, 0, 0];
      break;
    case 1:
      paddingArray = new Array(4).fill(paddingArray[0]);
      break;
    case 2:
      paddingArray = __spreadArray$1(__spreadArray$1([], __read(paddingArray), false), __read(paddingArray), false);
      break;
    case 3:
      paddingArray = __spreadArray$1(__spreadArray$1([], __read(paddingArray), false), [paddingArray[1]], false);
      break;
    default:
      paddingArray = paddingArray.slice(0, 4);
      break;
  }
  return paddingArray;
}
var LOAD_COMPONENT_CONTROLLERS = {};
function registerComponentController(name, plugin) {
  LOAD_COMPONENT_CONTROLLERS[name] = plugin;
}
function getComponentControllerNames() {
  return Object.keys(LOAD_COMPONENT_CONTROLLERS);
}
function getComponentController(name) {
  return LOAD_COMPONENT_CONTROLLERS[name];
}
var CoordinateController = (
  /** @class */
  function() {
    function CoordinateController2(option) {
      this.option = this.wrapperOption(option);
    }
    CoordinateController2.prototype.update = function(option) {
      this.option = this.wrapperOption(option);
      return this;
    };
    CoordinateController2.prototype.hasAction = function(actionName) {
      var actions = this.option.actions;
      return some(actions, function(action) {
        return action[0] === actionName;
      });
    };
    CoordinateController2.prototype.create = function(start, end) {
      var _a2 = this.option, type = _a2.type, cfg = _a2.cfg;
      var isTheta = type === "theta";
      var props = __assign$1({ start, end }, cfg);
      var C = getCoordinate(isTheta ? "polar" : type);
      this.coordinate = new C(props);
      this.coordinate.type = type;
      if (isTheta) {
        if (!this.hasAction("transpose")) {
          this.transpose();
        }
      }
      this.execActions();
      return this.coordinate;
    };
    CoordinateController2.prototype.adjust = function(start, end) {
      this.coordinate.update({
        start,
        end
      });
      this.coordinate.resetMatrix();
      this.execActions(["scale", "rotate", "translate"]);
      return this.coordinate;
    };
    CoordinateController2.prototype.rotate = function(angle2) {
      this.option.actions.push(["rotate", angle2]);
      return this;
    };
    CoordinateController2.prototype.reflect = function(dim) {
      this.option.actions.push(["reflect", dim]);
      return this;
    };
    CoordinateController2.prototype.scale = function(sx, sy) {
      this.option.actions.push(["scale", sx, sy]);
      return this;
    };
    CoordinateController2.prototype.transpose = function() {
      this.option.actions.push(["transpose"]);
      return this;
    };
    CoordinateController2.prototype.getOption = function() {
      return this.option;
    };
    CoordinateController2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    CoordinateController2.prototype.wrapperOption = function(option) {
      return __assign$1({ type: "rect", actions: [], cfg: {} }, option);
    };
    CoordinateController2.prototype.execActions = function(includeActions) {
      var _this = this;
      var actions = this.option.actions;
      each$1(actions, function(action) {
        var _a2;
        var _b = __read(action), actionName = _b[0], args = _b.slice(1);
        var shouldExec = isNil(includeActions) ? true : includeActions.includes(actionName);
        if (shouldExec) {
          (_a2 = _this.coordinate)[actionName].apply(_a2, __spreadArray$1([], __read(args), false));
        }
      });
    };
    return CoordinateController2;
  }()
);
var Event = (
  /** @class */
  function() {
    function Event2(view, gEvent, data2) {
      this.view = view;
      this.gEvent = gEvent;
      this.data = data2;
      this.type = gEvent.type;
    }
    Event2.fromData = function(view, type, data2) {
      return new Event2(view, new GraphEvent(type, {}), data2);
    };
    Object.defineProperty(Event2.prototype, "target", {
      // below props are proxy props of G.event convenient
      /** the real trigger shape of the event */
      get: function() {
        return this.gEvent.target;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "event", {
      /**  dom  */
      get: function() {
        return this.gEvent.originalEvent;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "x", {
      /** x  */
      get: function() {
        return this.gEvent.x;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "y", {
      /** y  */
      get: function() {
        return this.gEvent.y;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientX", {
      /** x  */
      get: function() {
        return this.gEvent.clientX;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Event2.prototype, "clientY", {
      /** y  */
      get: function() {
        return this.gEvent.clientY;
      },
      enumerable: false,
      configurable: true
    });
    Event2.prototype.toString = function() {
      return "[Event (type=".concat(this.type, ")]");
    };
    Event2.prototype.clone = function() {
      return new Event2(this.view, this.gEvent, this.data);
    };
    return Event2;
  }()
);
function defaultLayout(view) {
  var axis2 = view.getController("axis");
  var legend2 = view.getController("legend");
  var annotation2 = view.getController("annotation");
  var slider2 = view.getController("slider");
  var scrollbar2 = view.getController("scrollbar");
  [axis2, slider2, scrollbar2, legend2, annotation2].forEach(function(controller) {
    if (controller) {
      controller.layout();
    }
  });
}
var ScalePool = (
  /** @class */
  function() {
    function ScalePool2() {
      this.scales = /* @__PURE__ */ new Map();
      this.syncScales = /* @__PURE__ */ new Map();
    }
    ScalePool2.prototype.createScale = function(field2, data2, scaleDef, key) {
      var finalScaleDef = scaleDef;
      var cacheScaleMeta = this.getScaleMeta(key);
      if (data2.length === 0 && cacheScaleMeta) {
        var cacheScale = cacheScaleMeta.scale;
        var cacheScaleDef = {
          type: cacheScale.type
        };
        if (cacheScale.isCategory) {
          cacheScaleDef.values = cacheScale.values;
        }
        finalScaleDef = deepMix(cacheScaleDef, cacheScaleMeta.scaleDef, scaleDef);
      }
      var scale2 = createScaleByField(field2, data2, finalScaleDef);
      this.cacheScale(scale2, scaleDef, key);
      return scale2;
    };
    ScalePool2.prototype.sync = function(coordinate2, theme2) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var min2 = Number.MAX_SAFE_INTEGER;
        var max2 = Number.MIN_SAFE_INTEGER;
        var values2 = [];
        each$1(scaleKeys, function(key) {
          var scale2 = _this.getScale(key);
          max2 = isNumber$1(scale2.max) ? Math.max(max2, scale2.max) : max2;
          min2 = isNumber$1(scale2.min) ? Math.min(min2, scale2.min) : min2;
          each$1(scale2.values, function(v) {
            if (!values2.includes(v)) {
              values2.push(v);
            }
          });
        });
        each$1(scaleKeys, function(key) {
          var scale2 = _this.getScale(key);
          if (scale2.isContinuous) {
            scale2.change({
              min: min2,
              max: max2,
              values: values2
            });
          } else if (scale2.isCategory) {
            var range = scale2.range;
            var cacheScaleMeta = _this.getScaleMeta(key);
            if (values2 && !get(cacheScaleMeta, ["scaleDef", "range"])) {
              range = getDefaultCategoryScaleRange(deepMix({}, scale2, {
                values: values2
              }), coordinate2, theme2);
            }
            scale2.change({
              values: values2,
              range
            });
          }
        });
      });
    };
    ScalePool2.prototype.cacheScale = function(scale2, scaleDef, key) {
      var sm = this.getScaleMeta(key);
      if (sm && sm.scale.type === scale2.type) {
        syncScale(sm.scale, scale2);
        sm.scaleDef = scaleDef;
      } else {
        sm = {
          key,
          scale: scale2,
          scaleDef
        };
        this.scales.set(key, sm);
      }
      var syncKey = this.getSyncKey(sm);
      sm.syncKey = syncKey;
      this.removeFromSyncScales(key);
      if (syncKey) {
        var scaleKeys = this.syncScales.get(syncKey);
        if (!scaleKeys) {
          scaleKeys = [];
          this.syncScales.set(syncKey, scaleKeys);
        }
        scaleKeys.push(key);
      }
    };
    ScalePool2.prototype.getScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (!scaleMeta) {
        var field2 = last(key.split("-"));
        var scaleKeys = this.syncScales.get(field2);
        if (scaleKeys && scaleKeys.length) {
          scaleMeta = this.getScaleMeta(scaleKeys[0]);
        }
      }
      return scaleMeta && scaleMeta.scale;
    };
    ScalePool2.prototype.deleteScale = function(key) {
      var scaleMeta = this.getScaleMeta(key);
      if (scaleMeta) {
        var syncKey = scaleMeta.syncKey;
        var scaleKeys = this.syncScales.get(syncKey);
        if (scaleKeys && scaleKeys.length) {
          var idx = scaleKeys.indexOf(key);
          if (idx !== -1) {
            scaleKeys.splice(idx, 1);
          }
        }
      }
      this.scales.delete(key);
    };
    ScalePool2.prototype.clear = function() {
      this.scales.clear();
      this.syncScales.clear();
    };
    ScalePool2.prototype.removeFromSyncScales = function(key) {
      var _this = this;
      this.syncScales.forEach(function(scaleKeys, syncKey) {
        var idx = scaleKeys.indexOf(key);
        if (idx !== -1) {
          scaleKeys.splice(idx, 1);
          if (scaleKeys.length === 0) {
            _this.syncScales.delete(syncKey);
          }
          return false;
        }
      });
    };
    ScalePool2.prototype.getSyncKey = function(sm) {
      var scale2 = sm.scale, scaleDef = sm.scaleDef;
      var field2 = scale2.field;
      var sync = get(scaleDef, ["sync"]);
      return sync === true ? field2 : sync === false ? void 0 : sync;
    };
    ScalePool2.prototype.getScaleMeta = function(key) {
      return this.scales.get(key);
    };
    return ScalePool2;
  }()
);
var PaddingCal = (
  /** @class */
  function() {
    function PaddingCal2(top, right2, bottom, left2) {
      if (top === void 0) {
        top = 0;
      }
      if (right2 === void 0) {
        right2 = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left2 === void 0) {
        left2 = 0;
      }
      this.top = top;
      this.right = right2;
      this.bottom = bottom;
      this.left = left2;
    }
    PaddingCal2.instance = function(top, right2, bottom, left2) {
      if (top === void 0) {
        top = 0;
      }
      if (right2 === void 0) {
        right2 = 0;
      }
      if (bottom === void 0) {
        bottom = 0;
      }
      if (left2 === void 0) {
        left2 = 0;
      }
      return new PaddingCal2(top, right2, bottom, left2);
    };
    PaddingCal2.prototype.max = function(padding2) {
      var _a2 = __read(padding2, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      this.top = Math.max(this.top, top);
      this.right = Math.max(this.right, right2);
      this.bottom = Math.max(this.bottom, bottom);
      this.left = Math.max(this.left, left2);
      return this;
    };
    PaddingCal2.prototype.shrink = function(padding2) {
      var _a2 = __read(padding2, 4), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
      this.top += top;
      this.right += right2;
      this.bottom += bottom;
      this.left += left2;
      return this;
    };
    PaddingCal2.prototype.inc = function(bbox, direction2) {
      var width = bbox.width, height = bbox.height;
      switch (direction2) {
        case DIRECTION.TOP:
        case DIRECTION.TOP_LEFT:
        case DIRECTION.TOP_RIGHT:
          this.top += height;
          break;
        case DIRECTION.RIGHT:
        case DIRECTION.RIGHT_TOP:
        case DIRECTION.RIGHT_BOTTOM:
          this.right += width;
          break;
        case DIRECTION.BOTTOM:
        case DIRECTION.BOTTOM_LEFT:
        case DIRECTION.BOTTOM_RIGHT:
          this.bottom += height;
          break;
        case DIRECTION.LEFT:
        case DIRECTION.LEFT_TOP:
        case DIRECTION.LEFT_BOTTOM:
          this.left += width;
          break;
      }
      return this;
    };
    PaddingCal2.prototype.getPadding = function() {
      return [this.top, this.right, this.bottom, this.left];
    };
    PaddingCal2.prototype.clone = function() {
      return new (PaddingCal2.bind.apply(PaddingCal2, __spreadArray$1([void 0], __read(this.getPadding()), false)))();
    };
    return PaddingCal2;
  }()
);
function calculatePadding(view) {
  var padding2 = view.padding;
  if (!isAutoPadding(padding2)) {
    return new (PaddingCal.bind.apply(PaddingCal, __spreadArray$1([void 0], __read(parsePadding(padding2)), false)))();
  }
  var viewBBox = view.viewBBox;
  var paddingCal = new PaddingCal();
  var axisComponents = [];
  var paddingComponents = [];
  var otherComponents = [];
  each$1(view.getComponents(), function(co) {
    var type = co.type;
    if (type === COMPONENT_TYPE.AXIS) {
      axisComponents.push(co);
    } else if ([COMPONENT_TYPE.LEGEND, COMPONENT_TYPE.SLIDER, COMPONENT_TYPE.SCROLLBAR].includes(type)) {
      paddingComponents.push(co);
    } else if (type !== COMPONENT_TYPE.GRID && type !== COMPONENT_TYPE.TOOLTIP) {
      otherComponents.push(co);
    }
  });
  each$1(axisComponents, function(co) {
    var component2 = co.component;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    var exceed = componentBBox.exceed(viewBBox);
    paddingCal.max(exceed);
  });
  each$1(paddingComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentPadding = component2.get("padding");
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(componentPadding);
    paddingCal.inc(componentBBox, direction2);
  });
  each$1(otherComponents, function(co) {
    var component2 = co.component, direction2 = co.direction;
    var bboxObject = component2.getLayoutBBox();
    var componentBBox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height);
    paddingCal.inc(componentBBox, direction2);
  });
  return paddingCal;
}
function defaultSyncViewPadding(chart, views, PC) {
  var syncPadding = PC.instance();
  views.forEach(function(v) {
    v.autoPadding = syncPadding.max(v.autoPadding.getPadding());
  });
}
var View = (
  /** @class */
  function(_super) {
    __extends$1(View2, _super);
    function View2(props) {
      var _this = _super.call(this, { visible: props.visible }) || this;
      _this.views = [];
      _this.geometries = [];
      _this.controllers = [];
      _this.interactions = {};
      _this.limitInPlot = false;
      _this.options = {
        data: [],
        animate: true
        // 
      };
      _this.usedControllers = getComponentControllerNames();
      _this.scalePool = new ScalePool();
      _this.layoutFunc = defaultLayout;
      _this.isPreMouseInPlot = false;
      _this.isDataChanged = false;
      _this.isCoordinateChanged = false;
      _this.createdScaleKeys = /* @__PURE__ */ new Map();
      _this.onCanvasEvent = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          var e = _this.createViewEvent(evt);
          _this.doPlotEvent(e);
          _this.emit(name, e);
        }
      };
      _this.onDelegateEvents = function(evt) {
        var name = evt.name;
        if (!name.includes(":")) {
          return;
        }
        var e = _this.createViewEvent(evt);
        _this.emit(name, e);
      };
      var _a2 = props.id, id2 = _a2 === void 0 ? uniqueId("view") : _a2, parent = props.parent, canvas = props.canvas, backgroundGroup = props.backgroundGroup, middleGroup = props.middleGroup, foregroundGroup = props.foregroundGroup, _b = props.region, region = _b === void 0 ? { start: { x: 0, y: 0 }, end: { x: 1, y: 1 } } : _b, padding2 = props.padding, appendPadding = props.appendPadding, theme2 = props.theme, options = props.options, limitInPlot2 = props.limitInPlot, syncViewPadding2 = props.syncViewPadding;
      _this.parent = parent;
      _this.canvas = canvas;
      _this.backgroundGroup = backgroundGroup;
      _this.middleGroup = middleGroup;
      _this.foregroundGroup = foregroundGroup;
      _this.region = region;
      _this.padding = padding2;
      _this.appendPadding = appendPadding;
      _this.options = __assign$1(__assign$1({}, _this.options), options);
      _this.limitInPlot = limitInPlot2;
      _this.id = id2;
      _this.syncViewPadding = syncViewPadding2;
      _this.themeObject = isObject(theme2) ? deepMix({}, getTheme("default"), createTheme(theme2)) : getTheme(theme2);
      _this.init();
      return _this;
    }
    View2.prototype.setLayout = function(layout2) {
      this.layoutFunc = layout2;
    };
    View2.prototype.init = function() {
      this.calculateViewBBox();
      this.initEvents();
      this.initComponentController();
      this.initOptions();
    };
    View2.prototype.render = function(isUpdate, payload) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_RENDER, Event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_RENDER, payload));
      this.paint(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_RENDER, Event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_RENDER, payload));
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    View2.prototype.clear = function() {
      var _this = this;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CLEAR);
      this.filteredData = [];
      this.coordinateInstance = void 0;
      this.isDataChanged = false;
      this.isCoordinateChanged = false;
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        geometries[i].clear();
        geometries[i].container.remove(true);
        geometries[i].labelsContainer.remove(true);
      }
      this.geometries = [];
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        if (controllers[i].name === "annotation") {
          controllers[i].clear(true);
        } else {
          controllers[i].clear();
        }
      }
      this.createdScaleKeys.forEach(function(v, k) {
        _this.getRootView().scalePool.deleteScale(k);
      });
      this.createdScaleKeys.clear();
      var views = this.views;
      for (var i = 0; i < views.length; i++) {
        views[i].clear();
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CLEAR);
    };
    View2.prototype.destroy = function() {
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_DESTROY);
      var interactions = this.interactions;
      each$1(interactions, function(interaction2) {
        if (interaction2) {
          interaction2.destroy();
        }
      });
      this.clear();
      var controllers = this.controllers;
      for (var i = 0, len = controllers.length; i < len; i++) {
        var controller = controllers[i];
        controller.destroy();
      }
      this.backgroundGroup.remove(true);
      this.middleGroup.remove(true);
      this.foregroundGroup.remove(true);
      _super.prototype.destroy.call(this);
    };
    View2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var geometries = this.geometries;
      for (var i = 0, len = geometries.length; i < len; i++) {
        var geometry2 = geometries[i];
        geometry2.changeVisible(visible);
      }
      var controllers = this.controllers;
      for (var i = 0, len = controllers.length; i < len; i++) {
        var controller = controllers[i];
        controller.changeVisible(visible);
      }
      this.foregroundGroup.set("visible", visible);
      this.middleGroup.set("visible", visible);
      this.backgroundGroup.set("visible", visible);
      this.getCanvas().draw();
      return this;
    };
    View2.prototype.data = function(data2) {
      set(this.options, "data", data2);
      this.isDataChanged = true;
      return this;
    };
    View2.prototype.source = function(data2) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.data() instead.");
      return this.data(data2);
    };
    View2.prototype.filter = function(field2, condition) {
      if (isFunction(condition)) {
        set(this.options, ["filters", field2], condition);
        return this;
      }
      if (!condition && get(this.options, ["filters", field2])) {
        delete this.options.filters[field2];
      }
      return this;
    };
    View2.prototype.axis = function(field2, axisOption) {
      if (isBoolean(field2)) {
        set(this.options, ["axes"], field2);
      } else {
        set(this.options, ["axes", field2], axisOption);
      }
      return this;
    };
    View2.prototype.legend = function(field2, legendOption) {
      if (isBoolean(field2)) {
        set(this.options, ["legends"], field2);
      } else if (isString(field2)) {
        set(this.options, ["legends", field2], legendOption);
        if (isPlainObject$1(legendOption) && (legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected)) {
          set(this.options, ["filters", field2], function(name) {
            var _a2;
            return (_a2 = legendOption === null || legendOption === void 0 ? void 0 : legendOption.selected[name]) !== null && _a2 !== void 0 ? _a2 : true;
          });
        }
      } else {
        set(this.options, ["legends"], field2);
      }
      return this;
    };
    View2.prototype.scale = function(field2, scaleOption) {
      var _this = this;
      if (isString(field2)) {
        set(this.options, ["scales", field2], scaleOption);
      } else if (isObject(field2)) {
        each$1(field2, function(v, k) {
          set(_this.options, ["scales", k], v);
        });
      }
      return this;
    };
    View2.prototype.tooltip = function(cfg) {
      set(this.options, "tooltip", cfg);
      return this;
    };
    View2.prototype.annotation = function() {
      return this.getController("annotation");
    };
    View2.prototype.guide = function() {
      console.warn("This method will be removed at G2 V4.1. Please use chart.annotation() instead.");
      return this.annotation();
    };
    View2.prototype.coordinate = function(type, coordinateCfg) {
      if (isString(type)) {
        set(this.options, "coordinate", { type, cfg: coordinateCfg });
      } else {
        set(this.options, "coordinate", type);
      }
      this.coordinateController.update(this.options.coordinate);
      return this.coordinateController;
    };
    View2.prototype.coord = function(type, coordinateCfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.coordinate() instead.");
      return this.coordinate(type, coordinateCfg);
    };
    View2.prototype.facet = function(type, cfg) {
      if (this.facetInstance) {
        this.facetInstance.destroy();
      }
      var Ctor = getFacet(type);
      if (!Ctor) {
        throw new Error("facet '".concat(type, "' is not exist!"));
      }
      this.facetInstance = new Ctor(this, __assign$1(__assign$1({}, cfg), { type }));
      return this;
    };
    View2.prototype.animate = function(status) {
      set(this.options, "animate", status);
      return this;
    };
    View2.prototype.updateOptions = function(options) {
      this.clear();
      mix(this.options, options);
      this.views.forEach(function(view) {
        return view.destroy();
      });
      this.views = [];
      this.initOptions();
      this.coordinateBBox = this.viewBBox;
      return this;
    };
    View2.prototype.option = function(name, opt) {
      if (View2.prototype[name]) {
        throw new Error(`Can't use built in variable name "`.concat(name, '", please change another one.'));
      }
      set(this.options, name, opt);
      return this;
    };
    View2.prototype.theme = function(theme2) {
      this.themeObject = isObject(theme2) ? deepMix({}, this.themeObject, createTheme(theme2)) : getTheme(theme2);
      return this;
    };
    View2.prototype.interaction = function(name, cfg) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
      }
      var interaction2 = createInteraction(name, this, cfg);
      if (interaction2) {
        interaction2.init();
        this.interactions[name] = interaction2;
      }
      return this;
    };
    View2.prototype.removeInteraction = function(name) {
      var existInteraction = this.interactions[name];
      if (existInteraction) {
        existInteraction.destroy();
        this.interactions[name] = void 0;
      }
    };
    View2.prototype.changeData = function(data2) {
      this.isDataChanged = true;
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.data(data2);
      this.paint(true);
      var views = this.views;
      for (var i = 0, len = views.length; i < len; i++) {
        var view = views[i];
        view.changeData(data2);
      }
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    View2.prototype.createView = function(cfg) {
      if (this.parent && this.parent.parent) {
        console.warn("The view nesting recursive feature will be removed at G2 V4.1. Please avoid to use it.");
      }
      var sharedOptions = {
        data: this.options.data,
        scales: clone(this.options.scales),
        axes: clone(this.options.axes),
        coordinate: clone(this.coordinateController.getOption()),
        tooltip: clone(this.options.tooltip),
        legends: clone(this.options.legends),
        animate: this.options.animate,
        visible: this.visible
      };
      var v = new View2(__assign$1(__assign$1({
        parent: this,
        canvas: this.canvas,
        //  view  group
        backgroundGroup: this.backgroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: this.middleGroup.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: this.foregroundGroup.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        theme: this.themeObject,
        padding: this.padding
      }, cfg), { options: __assign$1(__assign$1({}, sharedOptions), get(cfg, "options", {})) }));
      this.views.push(v);
      return v;
    };
    View2.prototype.view = function(cfg) {
      console.warn("This method will be removed at G2 V4.1. Please use chart.createView() instead.");
      return this.createView(cfg);
    };
    View2.prototype.removeView = function(view) {
      var removedView = remove(this.views, function(v) {
        return v === view;
      })[0];
      if (removedView) {
        removedView.destroy();
      }
      return removedView;
    };
    View2.prototype.getCoordinate = function() {
      return this.coordinateInstance;
    };
    View2.prototype.getTheme = function() {
      return this.themeObject;
    };
    View2.prototype.getXScale = function() {
      var g = this.geometries[0];
      return g ? g.getXScale() : null;
    };
    View2.prototype.getYScales = function() {
      var tmpMap = {};
      var yScales = [];
      this.geometries.forEach(function(g) {
        var yScale = g.getYScale();
        var field2 = yScale.field;
        if (!tmpMap[field2]) {
          tmpMap[field2] = true;
          yScales.push(yScale);
        }
      });
      return yScales;
    };
    View2.prototype.getScalesByDim = function(dimType) {
      var geometries = this.geometries;
      var scales = {};
      for (var i = 0, len = geometries.length; i < len; i++) {
        var geometry2 = geometries[i];
        var scale2 = dimType === "x" ? geometry2.getXScale() : geometry2.getYScale();
        if (scale2 && !scales[scale2.field]) {
          scales[scale2.field] = scale2;
        }
      }
      return scales;
    };
    View2.prototype.getScale = function(field2, key) {
      var defaultKey = key ? key : this.getScaleKey(field2);
      return this.getRootView().scalePool.getScale(defaultKey);
    };
    View2.prototype.getScaleByField = function(field2, key) {
      return this.getScale(field2, key);
    };
    View2.prototype.getOptions = function() {
      return this.options;
    };
    View2.prototype.getData = function() {
      return this.filteredData;
    };
    View2.prototype.getOriginalData = function() {
      return this.options.data;
    };
    View2.prototype.getPadding = function() {
      return this.autoPadding.getPadding();
    };
    View2.prototype.getGeometries = function() {
      return this.geometries;
    };
    View2.prototype.getElements = function() {
      return reduce(this.geometries, function(elements, geometry2) {
        return elements.concat(geometry2.getElements());
      }, []);
    };
    View2.prototype.getElementsBy = function(condition) {
      return this.getElements().filter(function(el) {
        return condition(el);
      });
    };
    View2.prototype.getLayer = function(layer) {
      return layer === LAYER.BG ? this.backgroundGroup : layer === LAYER.MID ? this.middleGroup : layer === LAYER.FORE ? this.foregroundGroup : this.foregroundGroup;
    };
    View2.prototype.isPointInPlot = function(point2) {
      return isPointInCoordinate(this.getCoordinate(), point2);
    };
    View2.prototype.getLegendAttributes = function() {
      return flatten(this.geometries.map(function(g) {
        return g.getGroupAttributes();
      }));
    };
    View2.prototype.getGroupScales = function() {
      var scales = this.geometries.map(function(g) {
        return g.getGroupScales();
      });
      return uniq$1(flatten(scales));
    };
    View2.prototype.getCanvas = function() {
      return this.getRootView().canvas;
    };
    View2.prototype.getRootView = function() {
      var v = this;
      while (true) {
        if (v.parent) {
          v = v.parent;
          continue;
        }
        break;
      }
      return v;
    };
    View2.prototype.getXY = function(data2) {
      var coordinate2 = this.getCoordinate();
      var xScales = this.getScalesByDim("x");
      var yScales = this.getScalesByDim("y");
      var x;
      var y;
      each$1(data2, function(value2, key) {
        if (xScales[key]) {
          x = xScales[key].scale(value2);
        }
        if (yScales[key]) {
          y = yScales[key].scale(value2);
        }
      });
      if (!isNil(x) && !isNil(y)) {
        return coordinate2.convert({ x, y });
      }
    };
    View2.prototype.getController = function(name) {
      return find$1(this.controllers, function(c) {
        return c.name === name;
      });
    };
    View2.prototype.showTooltip = function(point2) {
      var tooltip2 = this.getController("tooltip");
      if (tooltip2) {
        tooltip2.showTooltip(point2);
      }
      return this;
    };
    View2.prototype.hideTooltip = function() {
      var tooltip2 = this.getController("tooltip");
      if (tooltip2) {
        tooltip2.hideTooltip();
      }
      return this;
    };
    View2.prototype.lockTooltip = function() {
      var tooltip2 = this.getController("tooltip");
      if (tooltip2) {
        tooltip2.lockTooltip();
      }
      return this;
    };
    View2.prototype.unlockTooltip = function() {
      var tooltip2 = this.getController("tooltip");
      if (tooltip2) {
        tooltip2.unlockTooltip();
      }
      return this;
    };
    View2.prototype.isTooltipLocked = function() {
      var tooltip2 = this.getController("tooltip");
      return tooltip2 && tooltip2.isTooltipLocked();
    };
    View2.prototype.getTooltipItems = function(point2) {
      var tooltip2 = this.getController("tooltip");
      return tooltip2 ? tooltip2.getTooltipItems(point2) : [];
    };
    View2.prototype.getSnapRecords = function(point2) {
      var geometries = this.geometries;
      var rst = [];
      for (var i = 0, len = geometries.length; i < len; i++) {
        var geom = geometries[i];
        var dataArray = geom.dataArray;
        geom.sort(dataArray);
        var record = void 0;
        for (var j = 0, dataLen = dataArray.length; j < dataLen; j++) {
          var data2 = dataArray[j];
          record = findDataByPoint(point2, data2, geom);
          if (record) {
            rst.push(record);
          }
        }
      }
      var views = this.views;
      for (var i = 0, len = views.length; i < len; i++) {
        var view = views[i];
        var snapRecords = view.getSnapRecords(point2);
        rst = rst.concat(snapRecords);
      }
      return rst;
    };
    View2.prototype.getComponents = function() {
      var components = [];
      var controllers = this.controllers;
      for (var i = 0, len = controllers.length; i < len; i++) {
        var controller = controllers[i];
        components = components.concat(controller.getComponents());
      }
      return components;
    };
    View2.prototype.filterData = function(data2) {
      var filters = this.options.filters;
      if (size(filters) === 0) {
        return data2;
      }
      return filter(data2, function(datum, idx) {
        var fields = Object.keys(filters);
        return fields.every(function(field2) {
          var condition = filters[field2];
          return condition(datum[field2], datum, idx);
        });
      });
    };
    View2.prototype.filterFieldData = function(field2, data2) {
      var filters = this.options.filters;
      var condition = get(filters, field2);
      if (isUndefined(condition)) {
        return data2;
      }
      return data2.filter(function(datum, idx) {
        return condition(datum[field2], datum, idx);
      });
    };
    View2.prototype.adjustCoordinate = function() {
      var _a2 = this.getCoordinate(), curStart = _a2.start, curEnd = _a2.end;
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      if (isEqual$1(curStart, start) && isEqual$1(curEnd, end)) {
        this.isCoordinateChanged = false;
        return;
      }
      this.isCoordinateChanged = true;
      this.coordinateInstance = this.coordinateController.adjust(start, end);
    };
    View2.prototype.paint = function(isUpdate) {
      this.renderDataRecursive(isUpdate);
      this.syncScale();
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_PAINT);
      this.renderPaddingRecursive(isUpdate);
      this.renderLayoutRecursive(isUpdate);
      this.renderBackgroundStyleShape();
      this.renderPaintRecursive(isUpdate);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_PAINT);
      this.isDataChanged = false;
    };
    View2.prototype.renderBackgroundStyleShape = function() {
      if (this.parent) {
        return;
      }
      var background = get(this.themeObject, "background");
      if (background) {
        if (!this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape = this.backgroundGroup.addShape("rect", {
            attrs: {},
            zIndex: -1,
            //  shape 
            capture: false
          });
          this.backgroundStyleRectShape.toBack();
        }
        var _a2 = this.viewBBox, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
        this.backgroundStyleRectShape.attr({
          fill: background,
          x,
          y,
          width,
          height
        });
      } else {
        if (this.backgroundStyleRectShape) {
          this.backgroundStyleRectShape.remove(true);
          this.backgroundStyleRectShape = void 0;
        }
      }
    };
    View2.prototype.renderPaddingRecursive = function(isUpdate) {
      this.calculateViewBBox();
      this.adjustCoordinate();
      this.initComponents(isUpdate);
      this.autoPadding = calculatePadding(this).shrink(parsePadding(this.appendPadding));
      this.coordinateBBox = this.viewBBox.shrink(this.autoPadding.getPadding());
      this.adjustCoordinate();
      var tooltipController = this.controllers.find(function(c) {
        return c.name === "tooltip";
      });
      tooltipController.update();
      var views = this.views;
      for (var i = 0, len = views.length; i < len; i++) {
        var view = views[i];
        view.renderPaddingRecursive(isUpdate);
      }
    };
    View2.prototype.renderLayoutRecursive = function(isUpdate) {
      var syncViewPaddingFn = this.syncViewPadding === true ? defaultSyncViewPadding : isFunction(this.syncViewPadding) ? this.syncViewPadding : void 0;
      if (syncViewPaddingFn) {
        syncViewPaddingFn(this, this.views, PaddingCal);
        this.views.forEach(function(v) {
          v.coordinateBBox = v.viewBBox.shrink(v.autoPadding.getPadding());
          v.adjustCoordinate();
        });
      }
      this.doLayout();
      var views = this.views;
      for (var i = 0, len = views.length; i < len; i++) {
        var view = views[i];
        view.renderLayoutRecursive(isUpdate);
      }
    };
    View2.prototype.renderPaintRecursive = function(isUpdate) {
      var middleGroup = this.middleGroup;
      if (this.limitInPlot) {
        var _a2 = getCoordinateClipCfg(this.coordinateInstance), type = _a2.type, attrs = _a2.attrs;
        middleGroup.setClip({
          type,
          attrs
        });
      } else {
        middleGroup.setClip(void 0);
      }
      this.paintGeometries(isUpdate);
      this.renderComponents(isUpdate);
      var views = this.views;
      for (var i = 0, len = views.length; i < len; i++) {
        var view = views[i];
        view.renderPaintRecursive(isUpdate);
      }
    };
    View2.prototype.createScale = function(field2, data2, scaleDef, key) {
      var currentScaleDef = get(this.options.scales, [field2]);
      var mergedScaleDef = __assign$1(__assign$1({}, currentScaleDef), scaleDef);
      if (this.parent) {
        return this.parent.createScale(field2, data2, mergedScaleDef, key);
      }
      return this.scalePool.createScale(field2, data2, mergedScaleDef, key);
    };
    View2.prototype.renderDataRecursive = function(isUpdate) {
      this.doFilterData();
      this.createCoordinate();
      this.initGeometries(isUpdate);
      this.renderFacet(isUpdate);
      var views = this.views;
      for (var i = 0, len = views.length; i < len; i++) {
        var view = views[i];
        view.renderDataRecursive(isUpdate);
      }
    };
    View2.prototype.calculateViewBBox = function() {
      var x;
      var y;
      var width;
      var height;
      if (this.parent) {
        var bbox = this.parent.coordinateBBox;
        x = bbox.x;
        y = bbox.y;
        width = bbox.width;
        height = bbox.height;
      } else {
        x = 0;
        y = 0;
        width = this.canvas.get("width");
        height = this.canvas.get("height");
      }
      var _a2 = this.region, start = _a2.start, end = _a2.end;
      var viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      if (!this.viewBBox || !this.viewBBox.isEqual(viewBBox)) {
        this.viewBBox = new BBox(x + width * start.x, y + height * start.y, width * (end.x - start.x), height * (end.y - start.y));
      }
      this.coordinateBBox = this.viewBBox;
    };
    View2.prototype.initEvents = function() {
      this.foregroundGroup.on("*", this.onDelegateEvents);
      this.middleGroup.on("*", this.onDelegateEvents);
      this.backgroundGroup.on("*", this.onDelegateEvents);
      this.canvas.on("*", this.onCanvasEvent);
    };
    View2.prototype.initComponentController = function() {
      var usedControllers = this.usedControllers;
      for (var i = 0, len = usedControllers.length; i < len; i++) {
        var controllerName = usedControllers[i];
        var Ctor = getComponentController(controllerName);
        if (Ctor) {
          this.controllers.push(new Ctor(this));
        }
      }
    };
    View2.prototype.createViewEvent = function(evt) {
      var shape = evt.shape, name = evt.name;
      var data2 = shape ? shape.get("origin") : null;
      var e = new Event(this, evt, data2);
      e.type = name;
      return e;
    };
    View2.prototype.doPlotEvent = function(e) {
      var type = e.type, x = e.x, y = e.y;
      var point2 = { x, y };
      var ALL_EVENTS = [
        "mousedown",
        "mouseup",
        "mousemove",
        "mouseleave",
        "mousewheel",
        "touchstart",
        "touchmove",
        "touchend",
        "touchcancel",
        "click",
        "dblclick",
        "contextmenu"
      ];
      if (ALL_EVENTS.includes(type)) {
        var currentInPlot = this.isPointInPlot(point2);
        var newEvent = e.clone();
        if (currentInPlot) {
          var TYPE = "plot:".concat(type);
          newEvent.type = TYPE;
          this.emit(TYPE, newEvent);
          if (type === "mouseleave" || type === "touchend") {
            this.isPreMouseInPlot = false;
          }
        }
        if (type === "mousemove" || type === "touchmove") {
          if (this.isPreMouseInPlot && !currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
          } else if (!this.isPreMouseInPlot && currentInPlot) {
            if (type === "mousemove") {
              newEvent.type = PLOT_EVENTS.MOUSE_ENTER;
              this.emit(PLOT_EVENTS.MOUSE_ENTER, newEvent);
            }
            newEvent.type = PLOT_EVENTS.ENTER;
            this.emit(PLOT_EVENTS.ENTER, newEvent);
          }
          this.isPreMouseInPlot = currentInPlot;
        } else if (type === "mouseleave" || type === "touchend") {
          if (this.isPreMouseInPlot) {
            if (type === "mouseleave") {
              newEvent.type = PLOT_EVENTS.MOUSE_LEAVE;
              this.emit(PLOT_EVENTS.MOUSE_LEAVE, newEvent);
            }
            newEvent.type = PLOT_EVENTS.LEAVE;
            this.emit(PLOT_EVENTS.LEAVE, newEvent);
            this.isPreMouseInPlot = false;
          }
        }
      }
    };
    View2.prototype.doFilterData = function() {
      var data2 = this.options.data;
      this.filteredData = this.filterData(data2);
    };
    View2.prototype.initGeometries = function(isUpdate) {
      this.createOrUpdateScales();
      var coordinate2 = this.getCoordinate();
      var scaleDefs = get(this.options, "scales", {});
      var geometries = this.geometries;
      for (var i = 0, len = geometries.length; i < len; i++) {
        var geometry2 = geometries[i];
        geometry2.scales = this.getGeometryScales();
        var cfg = {
          coordinate: coordinate2,
          scaleDefs,
          data: this.filteredData,
          theme: this.themeObject,
          isDataChanged: this.isDataChanged,
          isCoordinateChanged: this.isCoordinateChanged
        };
        if (isUpdate) {
          geometry2.update(cfg);
        } else {
          geometry2.init(cfg);
        }
      }
      this.adjustScales();
    };
    View2.prototype.createOrUpdateScales = function() {
      var fields = this.getScaleFields();
      var groupedFields = this.getGroupedFields();
      var _a2 = this.getOptions(), data2 = _a2.data, _b = _a2.scales, scales = _b === void 0 ? {} : _b;
      var filteredData = this.filteredData;
      for (var i = 0, len = fields.length; i < len; i++) {
        var field2 = fields[i];
        var scaleDef = scales[field2];
        var key = this.getScaleKey(field2);
        this.createScale(
          field2,
          //  scale 
          groupedFields.includes(field2) ? data2 : filteredData,
          scaleDef,
          key
        );
        this.createdScaleKeys.set(key, true);
      }
    };
    View2.prototype.syncScale = function() {
      this.getRootView().scalePool.sync(this.getCoordinate(), this.theme);
    };
    View2.prototype.getGeometryScales = function() {
      var fields = this.getScaleFields();
      var scales = {};
      for (var i = 0; i < fields.length; i++) {
        var field2 = fields[i];
        scales[field2] = this.getScaleByField(field2);
      }
      return scales;
    };
    View2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry2 = geometries[i];
        var geometryScales = geometry2.getScaleFields();
        uniq$1(geometryScales, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.getGroupedFields = function() {
      var fields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry2 = geometries[i];
        var groupFields = geometry2.getGroupFields();
        uniq$1(groupFields, fields, tmpMap);
      }
      return fields;
    };
    View2.prototype.adjustScales = function() {
      this.adjustCategoryScaleRange();
    };
    View2.prototype.adjustCategoryScaleRange = function() {
      var _this = this;
      var xyScales = __spreadArray$1([this.getXScale()], __read(this.getYScales()), false).filter(function(e) {
        return !!e;
      });
      var coordinate2 = this.getCoordinate();
      var scaleOptions = this.options.scales;
      each$1(xyScales, function(scale2) {
        var field2 = scale2.field, values2 = scale2.values, isCategory = scale2.isCategory, isIdentity = scale2.isIdentity;
        if (isCategory || isIdentity) {
          if (values2 && !get(scaleOptions, [field2, "range"])) {
            scale2.range = getDefaultCategoryScaleRange(scale2, coordinate2, _this.theme);
          }
        }
      });
    };
    View2.prototype.initComponents = function(isUpdate) {
      var controllers = this.controllers;
      for (var i = 0; i < controllers.length; i++) {
        var controller = controllers[i];
        if (isUpdate) {
          controller.update();
        } else {
          controller.clear();
          controller.render();
        }
      }
    };
    View2.prototype.doLayout = function() {
      this.layoutFunc(this);
    };
    View2.prototype.createCoordinate = function() {
      var start = this.coordinateBBox.bl;
      var end = this.coordinateBBox.tr;
      this.coordinateInstance = this.coordinateController.create(start, end);
    };
    View2.prototype.paintGeometries = function(isUpdate) {
      var doAnimation = this.options.animate;
      var coordinate2 = this.getCoordinate();
      var canvasRegion = {
        x: this.viewBBox.x,
        y: this.viewBBox.y,
        minX: this.viewBBox.minX,
        minY: this.viewBBox.minY,
        maxX: this.viewBBox.maxX,
        maxY: this.viewBBox.maxY,
        width: this.viewBBox.width,
        height: this.viewBBox.height
      };
      var geometries = this.geometries;
      for (var i = 0; i < geometries.length; i++) {
        var geometry2 = geometries[i];
        geometry2.coordinate = coordinate2;
        geometry2.canvasRegion = canvasRegion;
        if (!doAnimation) {
          geometry2.animate(false);
        }
        geometry2.paint(isUpdate);
      }
    };
    View2.prototype.renderComponents = function(isUpdate) {
      var components = this.getComponents();
      for (var i = 0; i < components.length; i++) {
        var co = components[i];
        co.component.render();
      }
    };
    View2.prototype.renderFacet = function(isUpdate) {
      if (this.facetInstance) {
        if (isUpdate) {
          this.facetInstance.update();
        } else {
          this.facetInstance.clear();
          this.facetInstance.init();
          this.facetInstance.render();
        }
      }
    };
    View2.prototype.initOptions = function() {
      var _this = this;
      var _a2 = this.options, _b = _a2.geometries, geometries = _b === void 0 ? [] : _b, _c = _a2.interactions, interactions = _c === void 0 ? [] : _c, _d = _a2.views, views = _d === void 0 ? [] : _d, _e = _a2.annotations, annotations = _e === void 0 ? [] : _e, coordinate2 = _a2.coordinate, events = _a2.events, facets = _a2.facets;
      if (this.coordinateController) {
        coordinate2 && this.coordinateController.update(coordinate2);
      } else {
        this.coordinateController = new CoordinateController(coordinate2);
      }
      for (var i = 0; i < geometries.length; i++) {
        var geometryOption = geometries[i];
        this.createGeometry(geometryOption);
      }
      for (var j = 0; j < interactions.length; j++) {
        var interactionOption = interactions[j];
        var type = interactionOption.type, cfg = interactionOption.cfg;
        this.interaction(type, cfg);
      }
      for (var k = 0; k < views.length; k++) {
        var viewOption = views[k];
        this.createView(viewOption);
      }
      var annotationComponent = this.getController("annotation");
      for (var l = 0; l < annotations.length; l++) {
        var annotationOption = annotations[l];
        annotationComponent.annotation(annotationOption);
      }
      if (events) {
        each$1(events, function(eventCallback, eventName) {
          _this.on(eventName, eventCallback);
        });
      }
      if (facets) {
        each$1(facets, function(facet) {
          var type2 = facet.type, rest = __rest(facet, ["type"]);
          _this.facet(type2, rest);
        });
      }
    };
    View2.prototype.createGeometry = function(geometryOption) {
      var type = geometryOption.type, _a2 = geometryOption.cfg, cfg = _a2 === void 0 ? {} : _a2;
      if (this[type]) {
        var geometry_1 = this[type](cfg);
        each$1(geometryOption, function(v, k) {
          if (isFunction(geometry_1[k])) {
            geometry_1[k](v);
          }
        });
      }
    };
    View2.prototype.getScaleKey = function(field2) {
      return "".concat(this.id, "-").concat(field2);
    };
    return View2;
  }(Base$1)
);
function registerGeometry(name, Ctor) {
  View.prototype[name.toLowerCase()] = function(cfg) {
    if (cfg === void 0) {
      cfg = {};
    }
    var props = __assign$1({
      /**  */
      container: this.middleGroup.addGroup(),
      labelsContainer: this.foregroundGroup.addGroup()
    }, cfg);
    var geometry2 = new Ctor(props);
    this.geometries.push(geometry2);
    return geometry2;
  };
}
var Chart = (
  /** @class */
  function(_super) {
    __extends$1(Chart2, _super);
    function Chart2(props) {
      var _this = this;
      var container = props.container, width = props.width, height = props.height, _a2 = props.autoFit, autoFit = _a2 === void 0 ? false : _a2, padding2 = props.padding, appendPadding = props.appendPadding, _b = props.renderer, renderer = _b === void 0 ? "canvas" : _b, pixelRatio = props.pixelRatio, _c = props.localRefresh, localRefresh = _c === void 0 ? true : _c, _d = props.visible, visible = _d === void 0 ? true : _d, _e = props.supportCSSTransform, supportCSSTransform = _e === void 0 ? false : _e, _f = props.defaultInteractions, defaultInteractions = _f === void 0 ? ["tooltip", "legend-filter", "legend-active", "continuous-filter", "ellipsis-text", "axis-description"] : _f, options = props.options, limitInPlot2 = props.limitInPlot, theme2 = props.theme, syncViewPadding2 = props.syncViewPadding;
      var ele = isString(container) ? document.getElementById(container) : container;
      var wrapperElement = createDom$1('<div style="position:relative;"></div>');
      ele.appendChild(wrapperElement);
      var size2 = getChartSize(ele, autoFit, width, height);
      var G = getEngine(renderer);
      var canvas = new G.Canvas(__assign$1({ container: wrapperElement, pixelRatio, localRefresh, supportCSSTransform }, size2));
      _this = _super.call(this, {
        parent: null,
        canvas,
        // create 3 group layers for views.
        backgroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.BG }),
        middleGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.MID }),
        foregroundGroup: canvas.addGroup({ zIndex: GROUP_Z_INDEX.FORE }),
        padding: padding2,
        appendPadding,
        visible,
        options,
        limitInPlot: limitInPlot2,
        theme: theme2,
        syncViewPadding: syncViewPadding2
      }) || this;
      _this.onResize = debounce$1(function() {
        _this.forceFit();
      }, 300);
      _this.ele = ele;
      _this.canvas = canvas;
      _this.width = size2.width;
      _this.height = size2.height;
      _this.autoFit = autoFit;
      _this.localRefresh = localRefresh;
      _this.renderer = renderer;
      _this.wrapperElement = wrapperElement;
      _this.updateCanvasStyle();
      _this.bindAutoFit();
      _this.initDefaultInteractions(defaultInteractions);
      return _this;
    }
    Chart2.prototype.initDefaultInteractions = function(interactions) {
      var _this = this;
      each$1(interactions, function(interaction2) {
        _this.interaction(interaction2);
      });
    };
    Chart2.prototype.aria = function(ariaOption) {
      var ATTR = "aria-label";
      if (ariaOption === false) {
        this.ele.removeAttribute(ATTR);
      } else {
        this.ele.setAttribute(ATTR, ariaOption.label);
      }
    };
    Chart2.prototype.changeSize = function(width, height) {
      if (this.width === width && this.height === height) {
        return this;
      }
      this.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE);
      this.width = width;
      this.height = height;
      this.canvas.changeSize(width, height);
      this.render(true);
      this.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_SIZE);
      return this;
    };
    Chart2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.aria(false);
    };
    Chart2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.unbindAutoFit();
      this.canvas.destroy();
      removeDom(this.wrapperElement);
      this.wrapperElement = null;
    };
    Chart2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      this.wrapperElement.style.display = visible ? "" : "none";
      return this;
    };
    Chart2.prototype.forceFit = function() {
      if (!this.destroyed) {
        var _a2 = getChartSize(this.ele, true, this.width, this.height), width = _a2.width, height = _a2.height;
        this.changeSize(width, height);
      }
    };
    Chart2.prototype.updateCanvasStyle = function() {
      modifyCSS(this.canvas.get("el"), {
        display: "inline-block",
        verticalAlign: "middle"
      });
    };
    Chart2.prototype.bindAutoFit = function() {
      if (this.autoFit) {
        window.addEventListener("resize", this.onResize);
      }
    };
    Chart2.prototype.unbindAutoFit = function() {
      if (this.autoFit) {
        window.removeEventListener("resize", this.onResize);
      }
    };
    return Chart2;
  }(View)
);
var Controller = (
  /** @class */
  function() {
    function Controller2(view) {
      this.visible = true;
      this.components = [];
      this.view = view;
    }
    Controller2.prototype.clear = function(includeOption) {
      each$1(this.components, function(co) {
        co.component.destroy();
      });
      this.components = [];
    };
    Controller2.prototype.destroy = function() {
      this.clear();
    };
    Controller2.prototype.getComponents = function() {
      return this.components;
    };
    Controller2.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      this.components.forEach(function(co) {
        if (visible) {
          co.component.show();
        } else {
          co.component.hide();
        }
      });
      this.visible = visible;
    };
    return Controller2;
  }()
);
function uniq(items) {
  var uniqItems = [];
  var _loop_1 = function(index3) {
    var item = items[index3];
    var result = find$1(uniqItems, function(subItem) {
      return subItem.color === item.color && subItem.name === item.name && subItem.value === item.value && subItem.title === item.title;
    });
    if (!result) {
      uniqItems.push(item);
    }
  };
  for (var index2 = 0; index2 < items.length; index2++) {
    _loop_1(index2);
  }
  return uniqItems;
}
var Tooltip = (
  /** @class */
  function(_super) {
    __extends$1(Tooltip2, _super);
    function Tooltip2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isLocked = false;
      return _this;
    }
    Object.defineProperty(Tooltip2.prototype, "name", {
      get: function() {
        return "tooltip";
      },
      enumerable: false,
      configurable: true
    });
    Tooltip2.prototype.init = function() {
    };
    Tooltip2.prototype.isVisible = function() {
      var option = this.view.getOptions().tooltip;
      return option !== false;
    };
    Tooltip2.prototype.render = function() {
    };
    Tooltip2.prototype.showTooltip = function(point2) {
      this.point = point2;
      if (!this.isVisible()) {
        return;
      }
      var view = this.view;
      var items = this.getTooltipItems(point2);
      if (!items.length) {
        this.hideTooltip();
        return;
      }
      var title = this.getTitle(items);
      var dataPoint = {
        x: items[0].x,
        y: items[0].y
      };
      view.emit("tooltip:show", Event.fromData(view, "tooltip:show", __assign$1({ items, title }, point2)));
      var cfg = this.getTooltipCfg();
      var follow = cfg.follow, showMarkers = cfg.showMarkers, showCrosshairs = cfg.showCrosshairs, showContent = cfg.showContent, marker = cfg.marker;
      var lastItems = this.items;
      var lastTitle = this.title;
      if (!isEqual$1(lastTitle, title) || !isEqual$1(lastItems, items)) {
        view.emit("tooltip:change", Event.fromData(view, "tooltip:change", __assign$1({ items, title }, point2)));
        if (isFunction(showContent) ? showContent(items) : showContent) {
          if (!this.tooltip) {
            this.renderTooltip();
          }
          this.tooltip.update(mix({}, cfg, {
            items: this.getItemsAfterProcess(items),
            title
          }, follow ? point2 : {}));
          this.tooltip.show();
        }
        if (showMarkers) {
          this.renderTooltipMarkers(items, marker);
        }
      } else {
        if (this.tooltip && follow) {
          this.tooltip.update(point2);
          this.tooltip.show();
        }
        if (this.tooltipMarkersGroup) {
          this.tooltipMarkersGroup.show();
        }
      }
      this.items = items;
      this.title = title;
      if (showCrosshairs) {
        var isCrosshairsFollowCursor = get(cfg, ["crosshairs", "follow"], false);
        this.renderCrosshairs(isCrosshairsFollowCursor ? point2 : dataPoint, cfg);
      }
    };
    Tooltip2.prototype.hideTooltip = function() {
      var follow = this.getTooltipCfg().follow;
      if (!follow) {
        this.point = null;
        return;
      }
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.hide();
      }
      var xCrosshair = this.xCrosshair;
      var yCrosshair = this.yCrosshair;
      if (xCrosshair) {
        xCrosshair.hide();
      }
      if (yCrosshair) {
        yCrosshair.hide();
      }
      var tooltip2 = this.tooltip;
      if (tooltip2) {
        tooltip2.hide();
      }
      this.view.emit("tooltip:hide", Event.fromData(this.view, "tooltip:hide", {}));
      this.point = null;
    };
    Tooltip2.prototype.lockTooltip = function() {
      this.isLocked = true;
      if (this.tooltip) {
        this.tooltip.setCapture(true);
      }
    };
    Tooltip2.prototype.unlockTooltip = function() {
      this.isLocked = false;
      var cfg = this.getTooltipCfg();
      if (this.tooltip) {
        this.tooltip.setCapture(cfg.capture);
      }
    };
    Tooltip2.prototype.isTooltipLocked = function() {
      return this.isLocked;
    };
    Tooltip2.prototype.clear = function() {
      var _a2 = this, tooltip2 = _a2.tooltip, xCrosshair = _a2.xCrosshair, yCrosshair = _a2.yCrosshair, tooltipMarkersGroup = _a2.tooltipMarkersGroup;
      if (tooltip2) {
        tooltip2.hide();
        tooltip2.clear();
      }
      if (xCrosshair) {
        xCrosshair.clear();
      }
      if (yCrosshair) {
        yCrosshair.clear();
      }
      if (tooltipMarkersGroup) {
        tooltipMarkersGroup.clear();
      }
      if (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.get("customContent")) {
        this.tooltip.destroy();
        this.tooltip = null;
      }
      this.title = null;
      this.items = null;
    };
    Tooltip2.prototype.destroy = function() {
      if (this.tooltip) {
        this.tooltip.destroy();
      }
      if (this.xCrosshair) {
        this.xCrosshair.destroy();
      }
      if (this.yCrosshair) {
        this.yCrosshair.destroy();
      }
      if (this.guideGroup) {
        this.guideGroup.remove(true);
      }
      this.reset();
    };
    Tooltip2.prototype.reset = function() {
      this.items = null;
      this.title = null;
      this.tooltipMarkersGroup = null;
      this.tooltipCrosshairsGroup = null;
      this.xCrosshair = null;
      this.yCrosshair = null;
      this.tooltip = null;
      this.guideGroup = null;
      this.isLocked = false;
      this.point = null;
    };
    Tooltip2.prototype.changeVisible = function(visible) {
      if (this.visible === visible) {
        return;
      }
      var _a2 = this, tooltip2 = _a2.tooltip, tooltipMarkersGroup = _a2.tooltipMarkersGroup, xCrosshair = _a2.xCrosshair, yCrosshair = _a2.yCrosshair;
      if (visible) {
        if (tooltip2) {
          tooltip2.show();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.show();
        }
        if (xCrosshair) {
          xCrosshair.show();
        }
        if (yCrosshair) {
          yCrosshair.show();
        }
      } else {
        if (tooltip2) {
          tooltip2.hide();
        }
        if (tooltipMarkersGroup) {
          tooltipMarkersGroup.hide();
        }
        if (xCrosshair) {
          xCrosshair.hide();
        }
        if (yCrosshair) {
          yCrosshair.hide();
        }
      }
      this.visible = visible;
    };
    Tooltip2.prototype.getTooltipItems = function(point2) {
      var e_1, _a2, e_2, _b, e_3, _c;
      var items = this.findItemsFromView(this.view, point2);
      if (items.length) {
        items = flatten(items);
        try {
          for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
            var itemArr = items_1_1.value;
            try {
              for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
                var item = itemArr_1_1.value;
                var _d = item.mappingData, x = _d.x, y = _d.y;
                item.x = isArray$1(x) ? x[x.length - 1] : x;
                item.y = isArray$1(y) ? y[y.length - 1] : y;
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
                  _b.call(itemArr_1);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
              _a2.call(items_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
        var shared = this.getTooltipCfg().shared;
        if (shared === false && items.length > 1) {
          var snapItem = items[0];
          var min2 = Math.abs(point2.y - snapItem[0].y);
          try {
            for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
              var aItem = items_2_1.value;
              var yDistance = Math.abs(point2.y - aItem[0].y);
              if (yDistance <= min2) {
                snapItem = aItem;
                min2 = yDistance;
              }
            }
          } catch (e_3_1) {
            e_3 = { error: e_3_1 };
          } finally {
            try {
              if (items_2_1 && !items_2_1.done && (_c = items_2.return))
                _c.call(items_2);
            } finally {
              if (e_3)
                throw e_3.error;
            }
          }
          items = [snapItem];
        }
        return uniq(flatten(items));
      }
      return [];
    };
    Tooltip2.prototype.layout = function() {
    };
    Tooltip2.prototype.update = function() {
      if (this.point) {
        this.showTooltip(this.point);
      }
      if (this.tooltip) {
        var canvas = this.view.getCanvas();
        this.tooltip.set("region", {
          start: { x: 0, y: 0 },
          end: { x: canvas.get("width"), y: canvas.get("height") }
        });
      }
    };
    Tooltip2.prototype.isCursorEntered = function(point2) {
      if (this.tooltip) {
        var el = this.tooltip.getContainer();
        var capture = this.tooltip.get("capture");
        if (el && capture) {
          var _a2 = el.getBoundingClientRect(), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
          return new BBox(x, y, width, height).isPointIn(point2);
        }
      }
      return false;
    };
    Tooltip2.prototype.getTooltipCfg = function() {
      var view = this.view;
      var option = view.getOptions().tooltip;
      var processOption = this.processCustomContent(option);
      var theme2 = view.getTheme();
      var defaultCfg = get(theme2, ["components", "tooltip"], {});
      var enterable = get(processOption, "enterable", defaultCfg.enterable);
      return deepMix({}, defaultCfg, processOption, {
        capture: enterable || this.isLocked ? true : false
      });
    };
    Tooltip2.prototype.processCustomContent = function(option) {
      if (isBoolean(option) || !get(option, "customContent")) {
        return option;
      }
      var currentCustomContent = option.customContent;
      var customContent = function(title, items) {
        var content = currentCustomContent(title, items) || "";
        return isString(content) ? '<div class="g2-tooltip">' + content + "</div>" : content;
      };
      return __assign$1(__assign$1({}, option), { customContent });
    };
    Tooltip2.prototype.getTitle = function(items) {
      var title = items[0].title || items[0].name;
      this.title = title;
      return title;
    };
    Tooltip2.prototype.renderTooltip = function() {
      var canvas = this.view.getCanvas();
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var cfg = this.getTooltipCfg();
      var tooltip2 = new HtmlTooltip(__assign$1(__assign$1({ parent: canvas.get("el").parentNode, region }, cfg), { visible: false, crosshairs: null }));
      tooltip2.init();
      this.tooltip = tooltip2;
    };
    Tooltip2.prototype.renderTooltipMarkers = function(items, marker) {
      var e_4, _a2;
      var tooltipMarkersGroup = this.getTooltipMarkersGroup();
      var rootView = this.view.getRootView();
      var limitInPlot2 = rootView.limitInPlot;
      try {
        for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
          var item = items_3_1.value;
          var x = item.x, y = item.y;
          if (limitInPlot2 || (tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.getClip())) {
            var _b = getCoordinateClipCfg(rootView.getCoordinate()), type = _b.type, attrs_1 = _b.attrs;
            tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip({
              type,
              attrs: attrs_1
            });
          } else {
            tooltipMarkersGroup === null || tooltipMarkersGroup === void 0 ? void 0 : tooltipMarkersGroup.setClip(void 0);
          }
          var theme2 = this.view.getTheme();
          var markerDefaultCfg = get(theme2, ["components", "tooltip", "marker"], {});
          var attrs = __assign$1(__assign$1({ fill: item.color, symbol: "circle", shadowColor: item.color }, isFunction(marker) ? __assign$1(__assign$1({}, markerDefaultCfg), marker(item)) : marker), { x, y });
          tooltipMarkersGroup.addShape("marker", {
            attrs
          });
        }
      } catch (e_4_1) {
        e_4 = { error: e_4_1 };
      } finally {
        try {
          if (items_3_1 && !items_3_1.done && (_a2 = items_3.return))
            _a2.call(items_3);
        } finally {
          if (e_4)
            throw e_4.error;
        }
      }
    };
    Tooltip2.prototype.renderCrosshairs = function(point2, cfg) {
      var crosshairsType = get(cfg, ["crosshairs", "type"], "x");
      if (crosshairsType === "x") {
        if (this.yCrosshair) {
          this.yCrosshair.hide();
        }
        this.renderXCrosshairs(point2, cfg);
      } else if (crosshairsType === "y") {
        if (this.xCrosshair) {
          this.xCrosshair.hide();
        }
        this.renderYCrosshairs(point2, cfg);
      } else if (crosshairsType === "xy") {
        this.renderXCrosshairs(point2, cfg);
        this.renderYCrosshairs(point2, cfg);
      }
    };
    Tooltip2.prototype.renderXCrosshairs = function(point2, tooltipCfg) {
      var coordinate2 = this.getViewWithGeometry(this.view).getCoordinate();
      var start;
      var end;
      if (coordinate2.isRect) {
        if (coordinate2.isTransposed) {
          start = {
            x: coordinate2.start.x,
            y: point2.y
          };
          end = {
            x: coordinate2.end.x,
            y: point2.y
          };
        } else {
          start = {
            x: point2.x,
            y: coordinate2.end.y
          };
          end = {
            x: point2.x,
            y: coordinate2.start.y
          };
        }
      } else {
        var angle2 = getAngleByPoint(coordinate2, point2);
        var center2 = coordinate2.getCenter();
        var radius = coordinate2.getRadius();
        end = polarToCartesian(center2.x, center2.y, radius, angle2);
        start = center2;
      }
      var cfg = deepMix({
        start,
        end,
        container: this.getTooltipCrosshairsGroup()
      }, get(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("x", point2, tooltipCfg));
      delete cfg.type;
      var xCrosshair = this.xCrosshair;
      if (xCrosshair) {
        xCrosshair.update(cfg);
      } else {
        xCrosshair = new LineCrosshair$1(cfg);
        xCrosshair.init();
      }
      xCrosshair.render();
      xCrosshair.show();
      this.xCrosshair = xCrosshair;
    };
    Tooltip2.prototype.renderYCrosshairs = function(point2, tooltipCfg) {
      var coordinate2 = this.getViewWithGeometry(this.view).getCoordinate();
      var cfg;
      var type;
      if (coordinate2.isRect) {
        var start = void 0;
        var end = void 0;
        if (coordinate2.isTransposed) {
          start = {
            x: point2.x,
            y: coordinate2.end.y
          };
          end = {
            x: point2.x,
            y: coordinate2.start.y
          };
        } else {
          start = {
            x: coordinate2.start.x,
            y: point2.y
          };
          end = {
            x: coordinate2.end.x,
            y: point2.y
          };
        }
        cfg = {
          start,
          end
        };
        type = "Line";
      } else {
        cfg = {
          center: coordinate2.getCenter(),
          // @ts-ignore
          radius: getDistanceToCenter(coordinate2, point2),
          startAngle: coordinate2.startAngle,
          endAngle: coordinate2.endAngle
        };
        type = "Circle";
      }
      cfg = deepMix({
        container: this.getTooltipCrosshairsGroup()
      }, cfg, get(tooltipCfg, "crosshairs", {}), this.getCrosshairsText("y", point2, tooltipCfg));
      delete cfg.type;
      var yCrosshair = this.yCrosshair;
      if (yCrosshair) {
        if (coordinate2.isRect && yCrosshair.get("type") === "circle" || !coordinate2.isRect && yCrosshair.get("type") === "line") {
          yCrosshair = new Crosshair[type](cfg);
          yCrosshair.init();
        } else {
          yCrosshair.update(cfg);
        }
      } else {
        yCrosshair = new Crosshair[type](cfg);
        yCrosshair.init();
      }
      yCrosshair.render();
      yCrosshair.show();
      this.yCrosshair = yCrosshair;
    };
    Tooltip2.prototype.getCrosshairsText = function(type, point2, tooltipCfg) {
      var textCfg = get(tooltipCfg, ["crosshairs", "text"]);
      var follow = get(tooltipCfg, ["crosshairs", "follow"]);
      var items = this.items;
      if (textCfg) {
        var view = this.getViewWithGeometry(this.view);
        var firstItem = items[0];
        var xScale = view.getXScale();
        var yScale = view.getYScales()[0];
        var xValue = void 0;
        var yValue = void 0;
        if (follow) {
          var invertPoint = this.view.getCoordinate().invert(point2);
          xValue = xScale.invert(invertPoint.x);
          yValue = yScale.invert(invertPoint.y);
        } else {
          xValue = firstItem.data[xScale.field];
          yValue = firstItem.data[yScale.field];
        }
        var content = type === "x" ? xValue : yValue;
        if (isFunction(textCfg)) {
          textCfg = textCfg(type, content, items, point2);
        } else {
          textCfg.content = content;
        }
        return {
          text: textCfg
        };
      }
    };
    Tooltip2.prototype.getGuideGroup = function() {
      if (!this.guideGroup) {
        var foregroundGroup = this.view.foregroundGroup;
        this.guideGroup = foregroundGroup.addGroup({
          name: "tooltipGuide",
          capture: false
        });
      }
      return this.guideGroup;
    };
    Tooltip2.prototype.getTooltipMarkersGroup = function() {
      var tooltipMarkersGroup = this.tooltipMarkersGroup;
      if (tooltipMarkersGroup && !tooltipMarkersGroup.destroyed) {
        tooltipMarkersGroup.clear();
        tooltipMarkersGroup.show();
      } else {
        tooltipMarkersGroup = this.getGuideGroup().addGroup({
          name: "tooltipMarkersGroup"
        });
        tooltipMarkersGroup.toFront();
        this.tooltipMarkersGroup = tooltipMarkersGroup;
      }
      return tooltipMarkersGroup;
    };
    Tooltip2.prototype.getTooltipCrosshairsGroup = function() {
      var tooltipCrosshairsGroup = this.tooltipCrosshairsGroup;
      if (!tooltipCrosshairsGroup) {
        tooltipCrosshairsGroup = this.getGuideGroup().addGroup({
          name: "tooltipCrosshairsGroup",
          capture: false
        });
        tooltipCrosshairsGroup.toBack();
        this.tooltipCrosshairsGroup = tooltipCrosshairsGroup;
      }
      return tooltipCrosshairsGroup;
    };
    Tooltip2.prototype.findItemsFromView = function(view, point2) {
      var e_5, _a2;
      if (view.getOptions().tooltip === false) {
        return [];
      }
      var tooltipCfg = this.getTooltipCfg();
      var result = findItemsFromView(view, point2, tooltipCfg);
      try {
        for (var _b = __values(view.views), _c = _b.next(); !_c.done; _c = _b.next()) {
          var childView = _c.value;
          result = result.concat(this.findItemsFromView(childView, point2));
        }
      } catch (e_5_1) {
        e_5 = { error: e_5_1 };
      } finally {
        try {
          if (_c && !_c.done && (_a2 = _b.return))
            _a2.call(_b);
        } finally {
          if (e_5)
            throw e_5.error;
        }
      }
      return result;
    };
    Tooltip2.prototype.getViewWithGeometry = function(view) {
      var _this = this;
      if (view.geometries.length) {
        return view;
      }
      return find$1(view.views, function(childView) {
        return _this.getViewWithGeometry(childView);
      });
    };
    Tooltip2.prototype.getItemsAfterProcess = function(originalItems) {
      var customItems = this.getTooltipCfg().customItems;
      var fn = customItems ? customItems : function(v) {
        return v;
      };
      return fn(originalItems);
    };
    return Tooltip2;
  }(Controller)
);
var ANIMATIONS_MAP = {};
function getAnimation(type) {
  return ANIMATIONS_MAP[type.toLowerCase()];
}
function registerAnimation(type, animation2) {
  ANIMATIONS_MAP[type.toLowerCase()] = animation2;
}
var DEFAULT_ANIMATE_CFG = {
  appear: {
    duration: 450,
    easing: "easeQuadOut"
  },
  update: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  enter: {
    duration: 400,
    easing: "easeQuadInOut"
  },
  leave: {
    duration: 350,
    easing: "easeQuadIn"
  }
  // 
};
var GEOMETRY_ANIMATE_CFG = {
  interval: function(coordinate2) {
    return {
      enter: {
        animation: coordinate2.isRect ? coordinate2.isTransposed ? "scale-in-x" : "scale-in-y" : "fade-in"
      },
      update: {
        animation: coordinate2.isPolar && coordinate2.isTransposed ? "sector-path-update" : null
      },
      leave: {
        animation: "fade-out"
      }
    };
  },
  line: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  path: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  point: {
    appear: {
      animation: "zoom-in"
    },
    enter: {
      animation: "zoom-in"
    },
    leave: {
      animation: "zoom-out"
    }
  },
  area: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  polygon: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  schema: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  edge: {
    enter: {
      animation: "fade-in"
    },
    leave: {
      animation: "fade-out"
    }
  },
  label: {
    appear: {
      animation: "fade-in",
      delay: 450
    },
    enter: {
      animation: "fade-in"
    },
    update: {
      animation: "position-update"
    },
    leave: {
      animation: "fade-out"
    }
  }
};
var GEOMETRY_GROUP_APPEAR_ANIMATION = {
  line: function() {
    return {
      animation: "wave-in"
    };
  },
  area: function() {
    return {
      animation: "wave-in"
    };
  },
  path: function() {
    return {
      animation: "fade-in"
    };
  },
  interval: function(coordinate2) {
    var animation2;
    if (coordinate2.isRect) {
      animation2 = coordinate2.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation2 = "grow-in-xy";
      if (coordinate2.isPolar && coordinate2.isTransposed) {
        animation2 = "wave-in";
      }
    }
    return {
      animation: animation2
    };
  },
  schema: function(coordinate2) {
    var animation2;
    if (coordinate2.isRect) {
      animation2 = coordinate2.isTransposed ? "grow-in-x" : "grow-in-y";
    } else {
      animation2 = "grow-in-xy";
    }
    return {
      animation: animation2
    };
  },
  polygon: function() {
    return {
      animation: "fade-in",
      duration: 500
    };
  },
  edge: function() {
    return {
      animation: "fade-in"
    };
  }
};
function parseAnimateConfig(animateCfg, data2) {
  return {
    delay: isFunction(animateCfg.delay) ? animateCfg.delay(data2) : animateCfg.delay,
    easing: isFunction(animateCfg.easing) ? animateCfg.easing(data2) : animateCfg.easing,
    duration: isFunction(animateCfg.duration) ? animateCfg.duration(data2) : animateCfg.duration,
    callback: animateCfg.callback,
    repeat: animateCfg.repeat
  };
}
function getDefaultAnimateCfg(elementName, coordinate2, animateType) {
  var animateCfg = GEOMETRY_ANIMATE_CFG[elementName];
  if (animateCfg) {
    if (isFunction(animateCfg)) {
      animateCfg = animateCfg(coordinate2);
    }
    animateCfg = deepMix({}, DEFAULT_ANIMATE_CFG, animateCfg);
    if (animateType) {
      return animateCfg[animateType];
    }
  }
  return animateCfg;
}
function doAnimate(shape, animateCfg, cfg) {
  var data2 = get(shape.get("origin"), "data", FIELD_ORIGIN);
  var animation2 = animateCfg.animation;
  var parsedAnimateCfg = parseAnimateConfig(animateCfg, data2);
  if (animation2) {
    var animateFunction = getAnimation(animation2);
    if (animateFunction) {
      animateFunction(shape, parsedAnimateCfg, cfg);
    }
  } else {
    shape.animate(cfg.toAttrs, parsedAnimateCfg);
  }
}
function doGroupAppearAnimate(container, animateCfg, geometryType, coordinate2, minYPoint) {
  if (GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType]) {
    var defaultCfg = GEOMETRY_GROUP_APPEAR_ANIMATION[geometryType](coordinate2);
    var animation2 = getAnimation(get(defaultCfg, "animation", ""));
    if (animation2) {
      var cfg = __assign$1(__assign$1(__assign$1({}, DEFAULT_ANIMATE_CFG.appear), defaultCfg), animateCfg);
      container.stopAnimate();
      animation2(container, cfg, {
        coordinate: coordinate2,
        minYPoint,
        toAttrs: null
      });
    }
  }
}
var BACKGROUND_SHAPE = "element-background";
var Element$1 = (
  /** @class */
  function(_super) {
    __extends$1(Element2, _super);
    function Element2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.labelShape = [];
      _this.states = [];
      var shapeFactory = cfg.shapeFactory, container = cfg.container, offscreenGroup = cfg.offscreenGroup, elementIndex = cfg.elementIndex, _a2 = cfg.visible, visible = _a2 === void 0 ? true : _a2;
      _this.shapeFactory = shapeFactory;
      _this.container = container;
      _this.offscreenGroup = offscreenGroup;
      _this.visible = visible;
      _this.elementIndex = elementIndex;
      return _this;
    }
    Element2.prototype.draw = function(model, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      this.model = model;
      this.data = model.data;
      this.shapeType = this.getShapeType(model);
      this.drawShape(model, isUpdate);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Element2.prototype.update = function(model) {
      var _a2 = this, shapeFactory = _a2.shapeFactory, shape = _a2.shape;
      if (!shape) {
        return;
      }
      this.model = model;
      this.data = model.data;
      this.shapeType = this.getShapeType(model);
      this.setShapeInfo(shape, model);
      var offscreenGroup = this.getOffscreenGroup();
      var newShape = shapeFactory.drawShape(this.shapeType, model, offscreenGroup);
      newShape.cfg.data = this.data;
      newShape.cfg.origin = model;
      newShape.cfg.element = this;
      this.syncShapeStyle(shape, newShape, this.getStates(), this.getAnimateCfg("update"));
    };
    Element2.prototype.destroy = function() {
      var _a2 = this, shapeFactory = _a2.shapeFactory, shape = _a2.shape;
      if (shape) {
        var animateCfg = this.getAnimateCfg("leave");
        if (animateCfg) {
          doAnimate(shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign$1({}, shape.attr())
          });
        } else {
          shape.remove(true);
        }
      }
      this.states = [];
      this.shapeFactory = void 0;
      this.container = void 0;
      this.shape = void 0;
      this.animate = void 0;
      this.geometry = void 0;
      this.labelShape = [];
      this.model = void 0;
      this.data = void 0;
      this.offscreenGroup = void 0;
      this.statesStyle = void 0;
      _super.prototype.destroy.call(this);
    };
    Element2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      if (visible) {
        if (this.shape) {
          this.shape.show();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label2) {
            label2.show();
          });
        }
      } else {
        if (this.shape) {
          this.shape.hide();
        }
        if (this.labelShape) {
          this.labelShape.forEach(function(label2) {
            label2.hide();
          });
        }
      }
    };
    Element2.prototype.setState = function(stateName, stateStatus) {
      var _a2 = this, states = _a2.states, shapeFactory = _a2.shapeFactory, model = _a2.model, shape = _a2.shape, shapeType = _a2.shapeType;
      var index2 = states.indexOf(stateName);
      if (stateStatus) {
        if (index2 > -1) {
          return;
        }
        states.push(stateName);
        if (stateName === "active" || stateName === "selected") {
          shape === null || shape === void 0 ? void 0 : shape.toFront();
        }
      } else {
        if (index2 === -1) {
          return;
        }
        states.splice(index2, 1);
        if (stateName === "active" || stateName === "selected") {
          var _b = this.geometry, sortZIndex = _b.sortZIndex, zIndexReversed = _b.zIndexReversed;
          var idx = zIndexReversed ? this.geometry.elements.length - this.elementIndex : this.elementIndex;
          sortZIndex ? shape.setZIndex(idx) : shape.set("zIndex", idx);
        }
      }
      var offscreenShape = shapeFactory.drawShape(shapeType, model, this.getOffscreenGroup());
      if (states.length) {
        this.syncShapeStyle(shape, offscreenShape, states, null);
      } else {
        this.syncShapeStyle(shape, offscreenShape, ["reset"], null);
      }
      offscreenShape.remove(true);
      var eventObject = {
        state: stateName,
        stateStatus,
        element: this,
        target: this.container
      };
      this.container.emit("statechange", eventObject);
      propagationDelegate(this.shape, "statechange", eventObject);
    };
    Element2.prototype.clearStates = function() {
      var _this = this;
      var states = this.states;
      each$1(states, function(state2) {
        _this.setState(state2, false);
      });
      this.states = [];
    };
    Element2.prototype.hasState = function(stateName) {
      return this.states.includes(stateName);
    };
    Element2.prototype.getStates = function() {
      return this.states;
    };
    Element2.prototype.getData = function() {
      return this.data;
    };
    Element2.prototype.getModel = function() {
      return this.model;
    };
    Element2.prototype.getBBox = function() {
      var _a2 = this, shape = _a2.shape, labelShape = _a2.labelShape;
      var bbox = {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
      if (shape) {
        bbox = shape.getCanvasBBox();
      }
      if (labelShape) {
        labelShape.forEach(function(label2) {
          var labelBBox = label2.getCanvasBBox();
          bbox.x = Math.min(labelBBox.x, bbox.x);
          bbox.y = Math.min(labelBBox.y, bbox.y);
          bbox.minX = Math.min(labelBBox.minX, bbox.minX);
          bbox.minY = Math.min(labelBBox.minY, bbox.minY);
          bbox.maxX = Math.max(labelBBox.maxX, bbox.maxX);
          bbox.maxY = Math.max(labelBBox.maxY, bbox.maxY);
        });
      }
      bbox.width = bbox.maxX - bbox.minX;
      bbox.height = bbox.maxY - bbox.minY;
      return bbox;
    };
    Element2.prototype.getStatesStyle = function() {
      if (!this.statesStyle) {
        var _a2 = this, shapeType = _a2.shapeType, geometry2 = _a2.geometry, shapeFactory = _a2.shapeFactory;
        var stateOption = geometry2.stateOption;
        var defaultShapeType = shapeFactory.defaultShapeType;
        var stateTheme = shapeFactory.theme[shapeType] || shapeFactory.theme[defaultShapeType];
        this.statesStyle = deepMix({}, stateTheme, stateOption);
      }
      return this.statesStyle;
    };
    Element2.prototype.getStateStyle = function(stateName, shapeKey) {
      var statesStyle = this.getStatesStyle();
      var stateCfg = get(statesStyle, [stateName, "style"], {});
      var shapeStyle = stateCfg[shapeKey] || stateCfg;
      if (isFunction(shapeStyle)) {
        return shapeStyle(this);
      }
      return shapeStyle;
    };
    Element2.prototype.getAnimateCfg = function(animateType) {
      var _this = this;
      var animate = this.animate;
      if (animate) {
        var cfg_1 = animate[animateType];
        if (cfg_1) {
          return __assign$1(__assign$1({}, cfg_1), { callback: function() {
            var _a2;
            isFunction(cfg_1.callback) && cfg_1.callback();
            (_a2 = _this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE);
          } });
        }
        return cfg_1;
      }
      return null;
    };
    Element2.prototype.drawShape = function(model, isUpdate) {
      var _a2;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var _b = this, shapeFactory = _b.shapeFactory, container = _b.container, shapeType = _b.shapeType;
      this.shape = shapeFactory.drawShape(shapeType, model, container);
      if (this.shape) {
        this.setShapeInfo(this.shape, model);
        var name_1 = this.shape.cfg.name;
        if (!name_1) {
          this.shape.cfg.name = ["element", this.shapeFactory.geometryType];
        } else if (isString(name_1)) {
          this.shape.cfg.name = ["element", name_1];
        }
        var animateType = isUpdate ? "enter" : "appear";
        var animateCfg = this.getAnimateCfg(animateType);
        if (animateCfg) {
          (_a2 = this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
          doAnimate(this.shape, animateCfg, {
            coordinate: shapeFactory.coordinate,
            toAttrs: __assign$1({}, this.shape.attr())
          });
        }
      }
    };
    Element2.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Element2.prototype.setShapeInfo = function(shape, data2) {
      var _this = this;
      shape.cfg.origin = data2;
      shape.cfg.element = this;
      if (shape.isGroup()) {
        var children = shape.get("children");
        children.forEach(function(child) {
          _this.setShapeInfo(child, data2);
        });
      }
    };
    Element2.prototype.syncShapeStyle = function(sourceShape, targetShape, states, animateCfg, index2) {
      var _this = this;
      var _a2;
      if (states === void 0) {
        states = [];
      }
      if (index2 === void 0) {
        index2 = 0;
      }
      if (!sourceShape || !targetShape) {
        return;
      }
      var clip = sourceShape.get("clipShape");
      var newClip = targetShape.get("clipShape");
      this.syncShapeStyle(clip, newClip, states, animateCfg);
      if (sourceShape.isGroup()) {
        var children = sourceShape.get("children");
        var newChildren = targetShape.get("children");
        for (var i = 0; i < children.length; i++) {
          this.syncShapeStyle(children[i], newChildren[i], states, animateCfg, index2 + i);
        }
      } else {
        if (!isEmpty(states) && !isEqual$1(states, ["reset"])) {
          var name_2 = sourceShape.get("name");
          if (isArray$1(name_2)) {
            name_2 = name_2[1];
          }
          each$1(states, function(state2) {
            if (targetShape.get("name") !== BACKGROUND_SHAPE) {
              var style = _this.getStateStyle(state2, name_2 || index2);
              targetShape.attr(style);
            }
          });
        }
        var newAttrs = getReplaceAttrs(sourceShape, targetShape);
        if (this.animate) {
          if (animateCfg) {
            (_a2 = this.geometry) === null || _a2 === void 0 ? void 0 : _a2.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_DRAW_ANIMATE);
            doAnimate(sourceShape, animateCfg, {
              coordinate: this.shapeFactory.coordinate,
              toAttrs: newAttrs,
              shapeModel: this.model
            });
          } else if (!isEmpty(states)) {
            sourceShape.stopAnimate();
            sourceShape.animate(newAttrs, {
              duration: 300
            });
          } else {
            sourceShape.attr(newAttrs);
          }
        } else {
          sourceShape.attr(newAttrs);
        }
      }
    };
    Element2.prototype.getShapeType = function(model) {
      var shape = get(model, "shape");
      return isArray$1(shape) ? shape[0] : shape;
    };
    return Element2;
  }(Base$1)
);
var GEOMETRY_LABELS_MAP = {};
var GEOMETRY_LABELS_LAYOUT_MAP = {};
function getGeometryLabel(type) {
  return GEOMETRY_LABELS_MAP[type.toLowerCase()];
}
function registerGeometryLabel(type, ctor) {
  GEOMETRY_LABELS_MAP[type.toLowerCase()] = ctor;
}
function getGeometryLabelLayout(type) {
  return GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()];
}
function registerGeometryLabelLayout(type, layoutFn) {
  GEOMETRY_LABELS_LAYOUT_MAP[type.toLowerCase()] = layoutFn;
}
var ShapeFactoryBase = {
  /**  */
  coordinate: null,
  /**  Shape  */
  defaultShapeType: null,
  /**  */
  theme: null,
  /**
   *  shape 
   * @param shapeType shape 
   * @param shapePoint  size 
   * @returns 
   */
  getShapePoints: function(shapeType, shapePoint) {
    var shape = this.getShape(shapeType);
    if (shape.getPoints) {
      return shape.getPoints(shapePoint);
    }
    return this.getDefaultPoints(shapePoint);
  },
  /**
   *  shape  shape 
   * @param shapeType string shape 
   * @returns
   */
  getShape: function(shapeType) {
    var shape = this[shapeType] || this[this.defaultShapeType];
    shape.coordinate = this.coordinate;
    return shape;
  },
  /**
   *  shape 
   * @override
   */
  getDefaultPoints: function() {
    return [];
  },
  /**
   *  shape  ( shapeFactory )
   */
  getDefaultStyle: function(geometryTheme) {
    return get(geometryTheme, [this.defaultShapeType, "default", "style"], {});
  },
  /**
   *  shape 
   * @param shapeType shape 
   * @param color 
   * @param isInPolar 
   * @returns  marker 
   */
  getMarker: function(shapeType, markerCfg) {
    var shape = this.getShape(shapeType);
    if (!shape.getMarker) {
      var defaultShapeType = this.defaultShapeType;
      shape = this.getShape(defaultShapeType);
    }
    var theme2 = this.theme;
    var shapeStyle = get(theme2, [shapeType, "default"], {});
    var markerStyle = shape.getMarker(markerCfg);
    return deepMix({}, shapeStyle, markerStyle);
  },
  /**
   *  shape
   * @override
   * @param shapeType  shape 
   * @param cfg  shape 
   * @param element Element 
   * @returns
   */
  drawShape: function(shapeType, cfg, container) {
    var shape = this.getShape(shapeType);
    return shape.draw(cfg, container);
  }
};
var ShapeBase$2 = {
  /**  */
  coordinate: null,
  /**
   *  path  path
   * @param path 
   * @returns
   */
  parsePath: function(path2) {
    var coordinate2 = this.coordinate;
    var parsedPath = parsePathString(path2);
    if (coordinate2.isPolar) {
      parsedPath = convertPolarPath(coordinate2, parsedPath);
    } else {
      parsedPath = convertNormalPath(coordinate2, parsedPath);
    }
    return parsedPath;
  },
  /**
   * 
   * @param point 
   * @returns
   */
  parsePoint: function(point2) {
    var coordinate2 = this.coordinate;
    return coordinate2.convert(point2);
  },
  /**
   * 01 points   points
   * @param points 
   * @returns
   */
  parsePoints: function(points2) {
    var coordinate2 = this.coordinate;
    return points2.map(function(point2) {
      return coordinate2.convert(point2);
    });
  },
  /**
   *  shape
   * @override
   */
  draw: function(cfg, container) {
  }
};
var ShapeFactoryMap = {};
function registerShapeFactory(factoryName, cfg) {
  var className = upperFirst(factoryName);
  var geomObj = __assign$1(__assign$1(__assign$1({}, ShapeFactoryBase), cfg), { geometryType: factoryName });
  ShapeFactoryMap[className] = geomObj;
  return geomObj;
}
function registerShape(factoryName, shapeType, cfg) {
  var className = upperFirst(factoryName);
  var factory = ShapeFactoryMap[className];
  var shapeObj = __assign$1(__assign$1({}, ShapeBase$2), cfg);
  factory[shapeType] = shapeObj;
  return shapeObj;
}
function getShapeFactory(factoryName) {
  var className = upperFirst(factoryName);
  return ShapeFactoryMap[className];
}
function group(data2, fields, appendConditions) {
  var e_1, _a2;
  if (appendConditions === void 0) {
    appendConditions = {};
  }
  if (!fields) {
    return [data2];
  }
  var groups = groupToMap(data2, fields);
  var array2 = [];
  if (fields.length === 1 && appendConditions[fields[0]]) {
    var values2 = appendConditions[fields[0]];
    try {
      for (var values_1 = __values(values2), values_1_1 = values_1.next(); !values_1_1.done; values_1_1 = values_1.next()) {
        var value2 = values_1_1.value;
        var arr = groups["_".concat(value2)];
        if (arr) {
          array2.push(arr);
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (values_1_1 && !values_1_1.done && (_a2 = values_1.return))
          _a2.call(values_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
  } else {
    for (var k in groups) {
      if (groups.hasOwnProperty(k)) {
        var eachGroup = groups[k];
        array2.push(eachGroup);
      }
    }
  }
  return array2;
}
function isModelChange(currentModel, preModel) {
  return some(["color", "shape", "size", "x", "y", "isInCircle", "data", "style", "defaultStyle", "points", "mappingData"], function(key) {
    return !isEqual$1(currentModel[key], preModel[key]);
  });
}
function parseFields(field2) {
  if (isArray$1(field2)) {
    return field2;
  }
  return field2.split("*");
}
function diff(keyItem, keys2) {
  var added = [];
  var updated = [];
  var removed = [];
  var keyIncluded = /* @__PURE__ */ new Map();
  for (var i = 0; i < keys2.length; i++) {
    var key = keys2[i];
    if (keyItem[key])
      updated.push(key);
    else
      added.push(key);
    keyIncluded.set(key, true);
  }
  Object.keys(keyItem).forEach(function(key2) {
    if (!keyIncluded.has(key2))
      removed.push(key2);
  });
  return {
    added,
    updated,
    removed
  };
}
var Geometry = (
  /** @class */
  function(_super) {
    __extends$1(Geometry2, _super);
    function Geometry2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "base";
      _this.attributes = {};
      _this.elements = [];
      _this.elementsMap = {};
      _this.animateOption = true;
      _this.attributeOption = {};
      _this.lastElementsMap = {};
      _this.generatePoints = false;
      _this.beforeMappingData = null;
      _this.adjusts = {};
      _this.idFields = [];
      _this.hasSorted = false;
      _this.isCoordinateChanged = false;
      var container = cfg.container, labelsContainer = cfg.labelsContainer, coordinate2 = cfg.coordinate, data2 = cfg.data, _a2 = cfg.sortable, sortable = _a2 === void 0 ? false : _a2, _b = cfg.visible, visible = _b === void 0 ? true : _b, theme2 = cfg.theme, _c = cfg.scales, scales = _c === void 0 ? {} : _c, _d = cfg.scaleDefs, scaleDefs = _d === void 0 ? {} : _d, intervalPadding = cfg.intervalPadding, dodgePadding = cfg.dodgePadding, maxColumnWidth = cfg.maxColumnWidth, minColumnWidth = cfg.minColumnWidth, columnWidthRatio = cfg.columnWidthRatio, roseWidthRatio = cfg.roseWidthRatio, multiplePieWidthRatio = cfg.multiplePieWidthRatio, zIndexReversed = cfg.zIndexReversed, sortZIndex = cfg.sortZIndex, useDeferredLabel = cfg.useDeferredLabel;
      _this.container = container;
      _this.labelsContainer = labelsContainer;
      _this.coordinate = coordinate2;
      _this.data = data2;
      _this.sortable = sortable;
      _this.visible = visible;
      _this.userTheme = theme2;
      _this.scales = scales;
      _this.scaleDefs = scaleDefs;
      _this.intervalPadding = intervalPadding;
      _this.dodgePadding = dodgePadding;
      _this.maxColumnWidth = maxColumnWidth;
      _this.minColumnWidth = minColumnWidth;
      _this.columnWidthRatio = columnWidthRatio;
      _this.roseWidthRatio = roseWidthRatio;
      _this.multiplePieWidthRatio = multiplePieWidthRatio;
      _this.zIndexReversed = zIndexReversed;
      _this.sortZIndex = sortZIndex;
      _this.useDeferredLabel = useDeferredLabel ? typeof useDeferredLabel === "number" ? useDeferredLabel : Infinity : null;
      return _this;
    }
    Geometry2.prototype.position = function(cfg) {
      var positionCfg = cfg;
      if (!isPlainObject$1(cfg)) {
        positionCfg = {
          fields: parseFields(cfg)
        };
      }
      var fields = get(positionCfg, "fields");
      if (fields.length === 1) {
        fields.unshift("1");
        set(positionCfg, "fields", fields);
      }
      set(this.attributeOption, "position", positionCfg);
      return this;
    };
    Geometry2.prototype.color = function(field2, cfg) {
      this.createAttrOption("color", field2, cfg);
      return this;
    };
    Geometry2.prototype.shape = function(field2, cfg) {
      this.createAttrOption("shape", field2, cfg);
      return this;
    };
    Geometry2.prototype.size = function(field2, cfg) {
      this.createAttrOption("size", field2, cfg);
      return this;
    };
    Geometry2.prototype.adjust = function(adjustCfg2) {
      var adjusts = adjustCfg2;
      if (isString(adjustCfg2) || isPlainObject$1(adjustCfg2)) {
        adjusts = [adjustCfg2];
      }
      each$1(adjusts, function(adjust2, index2) {
        if (!isObject(adjust2)) {
          adjusts[index2] = { type: adjust2 };
        }
      });
      this.adjustOption = adjusts;
      return this;
    };
    Geometry2.prototype.style = function(field2, styleFunc) {
      if (isString(field2)) {
        var fields = parseFields(field2);
        this.styleOption = {
          fields,
          callback: styleFunc
        };
      } else {
        var _a2 = field2, fields = _a2.fields, callback = _a2.callback, cfg = _a2.cfg;
        if (fields || callback || cfg) {
          this.styleOption = field2;
        } else {
          this.styleOption = {
            cfg: field2
          };
        }
      }
      return this;
    };
    Geometry2.prototype.tooltip = function(field2, cfg) {
      if (isString(field2)) {
        var fields = parseFields(field2);
        this.tooltipOption = {
          fields,
          callback: cfg
        };
      } else {
        this.tooltipOption = field2;
      }
      return this;
    };
    Geometry2.prototype.animate = function(cfg) {
      this.animateOption = cfg;
      return this;
    };
    Geometry2.prototype.label = function(field2, secondParam, thirdParam) {
      if (isString(field2)) {
        var labelOption = {};
        var fields = parseFields(field2);
        labelOption.fields = fields;
        if (isFunction(secondParam)) {
          labelOption.callback = secondParam;
        } else if (isPlainObject$1(secondParam)) {
          labelOption.cfg = secondParam;
        }
        if (thirdParam) {
          labelOption.cfg = thirdParam;
        }
        this.labelOption = labelOption;
      } else {
        this.labelOption = field2;
      }
      return this;
    };
    Geometry2.prototype.state = function(cfg) {
      this.stateOption = cfg;
      return this;
    };
    Geometry2.prototype.customInfo = function(cfg) {
      this.customOption = cfg;
      return this;
    };
    Geometry2.prototype.init = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.setCfg(cfg);
      this.initAttributes();
      this.processData(this.data);
      this.adjustScale();
    };
    Geometry2.prototype.update = function(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      var data2 = cfg.data, isDataChanged = cfg.isDataChanged, isCoordinateChanged = cfg.isCoordinateChanged;
      var _a2 = this, attributeOption = _a2.attributeOption, lastAttributeOption = _a2.lastAttributeOption;
      if (!isEqual$1(attributeOption, lastAttributeOption)) {
        this.init(cfg);
      } else if (data2 && (isDataChanged || !isEqual$1(data2, this.data))) {
        this.setCfg(cfg);
        this.initAttributes();
        this.processData(data2);
      } else {
        this.setCfg(cfg);
      }
      this.adjustScale();
      this.isCoordinateChanged = isCoordinateChanged;
    };
    Geometry2.prototype.paint = function(isUpdate) {
      var _this = this;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      if (this.animateOption) {
        this.animateOption = deepMix({}, getDefaultAnimateCfg(this.type, this.coordinate), this.animateOption);
      }
      this.defaultSize = void 0;
      this.elementsMap = {};
      this.elements = [];
      var offscreenGroup = this.getOffscreenGroup();
      offscreenGroup.clear();
      var beforeMappingData = this.beforeMappingData;
      var dataArray = this.beforeMapping(beforeMappingData);
      this.dataArray = new Array(dataArray.length);
      for (var i = 0; i < dataArray.length; i++) {
        var data2 = dataArray[i];
        this.dataArray[i] = this.mapping(data2);
      }
      this.updateElements(this.dataArray, isUpdate);
      this.lastElementsMap = this.elementsMap;
      if (this.canDoGroupAnimation(isUpdate)) {
        var container = this.container;
        var type = this.type;
        var coordinate2 = this.coordinate;
        var animateCfg = get(this.animateOption, "appear");
        var yScale = this.getYScale();
        var yMinPoint = coordinate2.convert({
          x: 0,
          y: yScale.scale(this.getYMinValue())
        });
        doGroupAppearAnimate(container, animateCfg, type, coordinate2, yMinPoint);
      }
      if (this.labelOption) {
        var deferred = this.useDeferredLabel;
        var callback = (function() {
          return _this.renderLabels(flatten(_this.dataArray), isUpdate);
        }).bind(this);
        if (typeof deferred === "number") {
          var timeout2 = typeof deferred === "number" && deferred !== Infinity ? deferred : 0;
          if (!window.requestIdleCallback) {
            setTimeout(callback, timeout2);
          } else {
            var options = timeout2 && timeout2 !== Infinity ? { timeout: timeout2 } : void 0;
            window.requestIdleCallback(callback, options);
          }
        } else {
          callback();
        }
      }
      this.lastAttributeOption = __assign$1({}, this.attributeOption);
      if (this.visible === false) {
        this.changeVisible(false);
      }
    };
    Geometry2.prototype.clear = function() {
      var _a2 = this, container = _a2.container, geometryLabel = _a2.geometryLabel, offscreenGroup = _a2.offscreenGroup;
      if (container) {
        container.clear();
      }
      if (geometryLabel) {
        geometryLabel.clear();
      }
      if (offscreenGroup) {
        offscreenGroup.clear();
      }
      this.scaleDefs = void 0;
      this.attributes = {};
      this.scales = {};
      this.elementsMap = {};
      this.lastElementsMap = {};
      this.elements = [];
      this.adjusts = {};
      this.dataArray = null;
      this.beforeMappingData = null;
      this.lastAttributeOption = void 0;
      this.defaultSize = void 0;
      this.idFields = [];
      this.groupScales = void 0;
      this.hasSorted = false;
      this.isCoordinateChanged = false;
    };
    Geometry2.prototype.destroy = function() {
      this.clear();
      var container = this.container;
      container.remove(true);
      if (this.offscreenGroup) {
        this.offscreenGroup.remove(true);
        this.offscreenGroup = null;
      }
      if (this.geometryLabel) {
        this.geometryLabel.destroy();
        this.geometryLabel = null;
      }
      this.theme = void 0;
      this.shapeFactory = void 0;
      _super.prototype.destroy.call(this);
    };
    Geometry2.prototype.getGroupScales = function() {
      return this.groupScales;
    };
    Geometry2.prototype.getAttribute = function(name) {
      return this.attributes[name];
    };
    Geometry2.prototype.getXScale = function() {
      return this.getAttribute("position").scales[0];
    };
    Geometry2.prototype.getYScale = function() {
      return this.getAttribute("position").scales[1];
    };
    Geometry2.prototype.getGroupAttributes = function() {
      var rst = [];
      each$1(this.attributes, function(attr) {
        if (GROUP_ATTRS.includes(attr.type)) {
          rst.push(attr);
        }
      });
      return rst;
    };
    Geometry2.prototype.getDefaultValue = function(attrName) {
      var value2;
      var attr = this.getAttribute(attrName);
      if (attr && isEmpty(attr.scales)) {
        value2 = attr.values[0];
      }
      return value2;
    };
    Geometry2.prototype.getAttributeValues = function(attr, obj) {
      var params = [];
      var scales = attr.scales;
      for (var index2 = 0, length_1 = scales.length; index2 < length_1; index2++) {
        var scale2 = scales[index2];
        var field2 = scale2.field;
        if (scale2.isIdentity) {
          params.push(scale2.values);
        } else {
          params.push(obj[field2]);
        }
      }
      return attr.mapping.apply(attr, __spreadArray$1([], __read(params), false));
    };
    Geometry2.prototype.getAdjust = function(adjustType) {
      return this.adjusts[adjustType];
    };
    Geometry2.prototype.getCoordinate = function() {
      return this.coordinate;
    };
    Geometry2.prototype.getData = function() {
      return this.data;
    };
    Geometry2.prototype.getShapeMarker = function(shapeName, cfg) {
      var shapeFactory = this.getShapeFactory();
      return shapeFactory.getMarker(shapeName, cfg);
    };
    Geometry2.prototype.getElementsBy = function(condition) {
      return this.elements.filter(function(element) {
        return condition(element);
      });
    };
    Geometry2.prototype.getElements = function() {
      return this.elements;
    };
    Geometry2.prototype.getElementId = function(data2) {
      data2 = isArray$1(data2) ? data2[0] : data2;
      var originData = data2[FIELD_ORIGIN];
      if (this.idFields.length) {
        var elementId = originData[this.idFields[0]];
        for (var index2 = 1; index2 < this.idFields.length; index2++) {
          elementId += "-" + originData[this.idFields[index2]];
        }
        return elementId;
      }
      var type = this.type;
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var xField = xScale.field || "x";
      var yField = yScale.field || "y";
      var yVal = originData[yField];
      var xVal;
      if (xScale.type === "identity") {
        xVal = xScale.values[0];
      } else {
        xVal = originData[xField];
      }
      var id2;
      if (type === "interval" || type === "schema") {
        id2 = "".concat(xVal);
      } else if (type === "line" || type === "area" || type === "path") {
        id2 = type;
      } else {
        id2 = "".concat(xVal, "-").concat(yVal);
      }
      var groupScales = this.groupScales;
      for (var index2 = 0, length_2 = groupScales.length; index2 < length_2; index2++) {
        var groupScale = groupScales[index2];
        var field2 = groupScale.field;
        id2 = "".concat(id2, "-").concat(originData[field2]);
      }
      var dodgeAdjust = this.getAdjust("dodge");
      if (dodgeAdjust) {
        var dodgeBy = dodgeAdjust.dodgeBy;
        if (dodgeBy) {
          id2 = "".concat(id2, "-").concat(originData[dodgeBy]);
        }
      }
      if (this.getAdjust("jitter")) {
        id2 = "".concat(id2, "-").concat(data2.x, "-").concat(data2.y);
      }
      return id2;
    };
    Geometry2.prototype.getScaleFields = function() {
      var fields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      var _a2 = this, attributeOption = _a2.attributeOption, labelOption = _a2.labelOption, tooltipOption = _a2.tooltipOption;
      for (var attributeType in attributeOption) {
        if (attributeOption.hasOwnProperty(attributeType)) {
          var eachOpt = attributeOption[attributeType];
          if (eachOpt.fields) {
            uniq$1(eachOpt.fields, fields, tmpMap);
          } else if (eachOpt.values) {
            uniq$1(eachOpt.values, fields, tmpMap);
          }
        }
      }
      if (labelOption && labelOption.fields) {
        uniq$1(labelOption.fields, fields, tmpMap);
      }
      if (isObject(tooltipOption) && tooltipOption.fields) {
        uniq$1(tooltipOption.fields, fields, tmpMap);
      }
      return fields;
    };
    Geometry2.prototype.changeVisible = function(visible) {
      _super.prototype.changeVisible.call(this, visible);
      var elements = this.elements;
      for (var index2 = 0, length_3 = elements.length; index2 < length_3; index2++) {
        var element = elements[index2];
        element.changeVisible(visible);
      }
      if (visible) {
        if (this.container) {
          this.container.show();
        }
        if (this.labelsContainer) {
          this.labelsContainer.show();
        }
      } else {
        if (this.container) {
          this.container.hide();
        }
        if (this.labelsContainer) {
          this.labelsContainer.hide();
        }
      }
    };
    Geometry2.prototype.getFields = function() {
      var uniqMap = /* @__PURE__ */ new Map();
      var fields = [];
      Object.values(this.attributeOption).forEach(function(cfg) {
        var fs = (cfg === null || cfg === void 0 ? void 0 : cfg.fields) || [];
        fs.forEach(function(f) {
          if (!uniqMap.has(f)) {
            fields.push(f);
          }
          uniqMap.set(f, true);
        });
      }, []);
      return fields;
    };
    Geometry2.prototype.getGroupFields = function() {
      var groupFields = [];
      var tmpMap = /* @__PURE__ */ new Map();
      for (var index2 = 0, length_4 = GROUP_ATTRS.length; index2 < length_4; index2++) {
        var attributeName = GROUP_ATTRS[index2];
        var cfg = this.attributeOption[attributeName];
        if (cfg && cfg.fields) {
          uniq$1(cfg.fields, groupFields, tmpMap);
        }
      }
      return groupFields;
    };
    Geometry2.prototype.getXYFields = function() {
      var _a2 = __read(this.attributeOption.position.fields, 2), x = _a2[0], y = _a2[1];
      return [x, y];
    };
    Geometry2.prototype.getXField = function() {
      return get(this.getXYFields(), [0]);
    };
    Geometry2.prototype.getYField = function() {
      return get(this.getXYFields(), [1]);
    };
    Geometry2.prototype.getShapes = function() {
      return this.elements.map(function(element) {
        return element.shape;
      });
    };
    Geometry2.prototype.getOffscreenGroup = function() {
      if (!this.offscreenGroup) {
        var GroupCtor = this.container.getGroupBase();
        this.offscreenGroup = new GroupCtor({});
      }
      return this.offscreenGroup;
    };
    Geometry2.prototype.sort = function(mappingArray) {
      if (!this.hasSorted) {
        var xScale_1 = this.getXScale();
        var xField_1 = xScale_1.field;
        for (var index2 = 0; index2 < mappingArray.length; index2++) {
          var itemArr = mappingArray[index2];
          itemArr.sort(function(obj1, obj2) {
            return xScale_1.translate(obj1[FIELD_ORIGIN][xField_1]) - xScale_1.translate(obj2[FIELD_ORIGIN][xField_1]);
          });
        }
      }
      this.hasSorted = true;
    };
    Geometry2.prototype.adjustScale = function() {
      var yScale = this.getYScale();
      if (yScale && this.getAdjust("stack")) {
        this.updateStackRange(yScale, this.beforeMappingData);
      }
    };
    Geometry2.prototype.getShapeFactory = function() {
      var shapeType = this.shapeType;
      if (!getShapeFactory(shapeType)) {
        return;
      }
      if (!this.shapeFactory) {
        this.shapeFactory = clone(getShapeFactory(shapeType));
      }
      this.shapeFactory.coordinate = this.coordinate;
      this.shapeFactory.theme = this.theme.geometries[shapeType] || {};
      return this.shapeFactory;
    };
    Geometry2.prototype.createShapePointsCfg = function(obj) {
      var xScale = this.getXScale();
      var yScale = this.getYScale();
      var x = this.normalizeValues(obj[xScale.field], xScale);
      var y;
      if (yScale) {
        y = this.normalizeValues(obj[yScale.field], yScale);
      } else {
        y = obj.y ? obj.y : 0.1;
      }
      return {
        x,
        y,
        y0: yScale ? yScale.scale(this.getYMinValue()) : void 0
      };
    };
    Geometry2.prototype.createElement = function(mappingDatum, index2, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var container = this.container;
      var shapeCfg = this.getDrawCfg(mappingDatum);
      var shapeFactory = this.getShapeFactory();
      var element = new Element$1({
        shapeFactory,
        container,
        offscreenGroup: this.getOffscreenGroup(),
        elementIndex: index2
      });
      element.animate = this.animateOption;
      element.geometry = this;
      element.draw(shapeCfg, isUpdate);
      return element;
    };
    Geometry2.prototype.getDrawCfg = function(mappingDatum) {
      var originData = mappingDatum[FIELD_ORIGIN];
      var cfg = {
        mappingData: mappingDatum,
        data: originData,
        x: mappingDatum.x,
        y: mappingDatum.y,
        color: mappingDatum.color,
        size: mappingDatum.size,
        isInCircle: this.coordinate.isPolar,
        customInfo: this.customOption
      };
      var shapeName = mappingDatum.shape;
      if (!shapeName && this.getShapeFactory()) {
        shapeName = this.getShapeFactory().defaultShapeType;
      }
      cfg.shape = shapeName;
      var theme2 = this.theme.geometries[this.shapeType];
      cfg.defaultStyle = get(theme2, [shapeName, "default"], {}).style;
      if (!cfg.defaultStyle && this.getShapeFactory()) {
        cfg.defaultStyle = this.getShapeFactory().getDefaultStyle(theme2);
      }
      var styleOption = this.styleOption;
      if (styleOption) {
        cfg.style = this.getStyleCfg(styleOption, originData);
      }
      if (this.generatePoints) {
        cfg.points = mappingDatum.points;
        cfg.nextPoints = mappingDatum.nextPoints;
      }
      return cfg;
    };
    Geometry2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      var e_1, _a2, e_2, _b, e_3, _c;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyDatum = /* @__PURE__ */ new Map();
      var keys2 = [];
      var keyIndex = /* @__PURE__ */ new Map();
      var index2 = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        for (var j = 0; j < mappingData.length; j++) {
          var mappingDatum = mappingData[j];
          var key = this.getElementId(mappingDatum);
          var finalKey = keyDatum.has(key) ? "".concat(key, "-").concat(i, "-").concat(j) : key;
          keys2.push(finalKey);
          keyDatum.set(finalKey, mappingDatum);
          keyIndex.set(finalKey, index2);
          index2++;
        }
      }
      this.elements = new Array(index2);
      var _d = diff(this.lastElementsMap, keys2), added = _d.added, updated = _d.updated, removed = _d.removed;
      try {
        for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
          var key = added_1_1.value;
          var mappingDatum = keyDatum.get(key);
          var i = keyIndex.get(key);
          var element = this.createElement(mappingDatum, i, isUpdate);
          this.elements[i] = element;
          this.elementsMap[key] = element;
          if (element.shape) {
            element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (added_1_1 && !added_1_1.done && (_a2 = added_1.return))
            _a2.call(added_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      try {
        for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
          var key = updated_1_1.value;
          var element = this.lastElementsMap[key];
          var mappingDatum = keyDatum.get(key);
          var currentShapeCfg = this.getDrawCfg(mappingDatum);
          var preShapeCfg = element.getModel();
          var i = keyIndex.get(key);
          if (this.isCoordinateChanged || isModelChange(currentShapeCfg, preShapeCfg)) {
            element.animate = this.animateOption;
            element.update(currentShapeCfg);
          }
          this.elements[i] = element;
          this.elementsMap[key] = element;
          if (element.shape) {
            element.shape.set("zIndex", this.zIndexReversed ? this.elements.length - i : i);
          }
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
            _b.call(updated_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      if (this.container) {
        this.container.sort();
      }
      try {
        for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
          var key = removed_1_1.value;
          var element = this.lastElementsMap[key];
          element.animate = this.animateOption;
          element.destroy();
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
            _c.call(removed_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    Geometry2.prototype.getLabelType = function() {
      var _a2 = this, labelOption = _a2.labelOption, coordinate2 = _a2.coordinate, type = _a2.type;
      var coordinateType = coordinate2.type, isTransposed = coordinate2.isTransposed;
      var labelType = get(labelOption, ["cfg", "type"]);
      if (!labelType) {
        if (coordinateType === "polar") {
          labelType = isTransposed ? "pie" : "polar";
        } else if (coordinateType === "theta") {
          labelType = "pie";
        } else if (type === "interval" || type === "polygon") {
          labelType = "interval";
        } else {
          labelType = "base";
        }
      }
      return labelType;
    };
    Geometry2.prototype.getYMinValue = function() {
      var yScale = this.getYScale();
      var min2 = yScale.min, max2 = yScale.max;
      var value2;
      if (min2 >= 0) {
        value2 = min2;
      } else if (max2 <= 0) {
        value2 = max2;
      } else {
        value2 = 0;
      }
      return value2;
    };
    Geometry2.prototype.createAttrOption = function(attrName, field2, cfg) {
      if (isNil(field2) || isObject(field2)) {
        if (isObject(field2) && isEqual$1(Object.keys(field2), ["values"])) {
          set(this.attributeOption, attrName, {
            fields: field2.values
          });
        } else {
          set(this.attributeOption, attrName, field2);
        }
      } else {
        var attrCfg = {};
        if (isNumber$1(field2)) {
          attrCfg.values = [field2];
        } else {
          attrCfg.fields = parseFields(field2);
        }
        if (cfg) {
          if (isFunction(cfg)) {
            attrCfg.callback = cfg;
          } else {
            attrCfg.values = cfg;
          }
        }
        set(this.attributeOption, attrName, attrCfg);
      }
    };
    Geometry2.prototype.initAttributes = function() {
      var _this = this;
      var _a2 = this, attributes = _a2.attributes, attributeOption = _a2.attributeOption, theme2 = _a2.theme, shapeType = _a2.shapeType;
      this.groupScales = [];
      var tmpMap = {};
      var _loop_1 = function(attrType2) {
        if (attributeOption.hasOwnProperty(attrType2)) {
          var option = attributeOption[attrType2];
          if (!option) {
            return { value: void 0 };
          }
          var attrCfg = __assign$1({}, option);
          var callback = attrCfg.callback, values2 = attrCfg.values, _b = attrCfg.fields, fields = _b === void 0 ? [] : _b;
          var scales = fields.map(function(field2) {
            var scale2 = _this.scales[field2];
            if (!tmpMap[field2] && GROUP_ATTRS.includes(attrType2)) {
              var inferedScaleType = inferScaleType(scale2, get(_this.scaleDefs, field2), attrType2, _this.type);
              if (inferedScaleType === "cat") {
                _this.groupScales.push(scale2);
                tmpMap[field2] = true;
              }
            }
            return scale2;
          });
          attrCfg.scales = scales;
          if (attrType2 !== "position" && scales.length === 1 && scales[0].type === "identity") {
            attrCfg.values = scales[0].values;
          } else if (!callback && !values2) {
            if (attrType2 === "size") {
              attrCfg.values = theme2.sizes;
            } else if (attrType2 === "shape") {
              attrCfg.values = theme2.shapes[shapeType] || [];
            } else if (attrType2 === "color") {
              if (scales.length) {
                attrCfg.values = scales[0].values.length <= 10 ? theme2.colors10 : theme2.colors20;
              } else {
                attrCfg.values = theme2.colors10;
              }
            }
          }
          var AttributeCtor = getAttribute(attrType2);
          attributes[attrType2] = new AttributeCtor(attrCfg);
        }
      };
      for (var attrType in attributeOption) {
        var state_1 = _loop_1(attrType);
        if (typeof state_1 === "object")
          return state_1.value;
      }
    };
    Geometry2.prototype.processData = function(data2) {
      var e_4, _a2;
      this.hasSorted = false;
      var scales = this.getAttribute("position").scales;
      var categoryScales = scales.filter(function(scale3) {
        return scale3.isCategory;
      });
      var groupedArray = this.groupData(data2);
      var beforeAdjust = [];
      for (var i = 0, len = groupedArray.length; i < len; i++) {
        var subData = groupedArray[i];
        var arr = [];
        for (var j = 0, subLen = subData.length; j < subLen; j++) {
          var originData = subData[j];
          var item = {};
          for (var k in originData) {
            item[k] = originData[k];
          }
          item[FIELD_ORIGIN] = originData;
          try {
            for (var categoryScales_1 = (e_4 = void 0, __values(categoryScales)), categoryScales_1_1 = categoryScales_1.next(); !categoryScales_1_1.done; categoryScales_1_1 = categoryScales_1.next()) {
              var scale2 = categoryScales_1_1.value;
              var field2 = scale2.field;
              item[field2] = scale2.translate(item[field2]);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (categoryScales_1_1 && !categoryScales_1_1.done && (_a2 = categoryScales_1.return))
                _a2.call(categoryScales_1);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
          arr.push(item);
        }
        beforeAdjust.push(arr);
      }
      var dataArray = this.adjustData(beforeAdjust);
      this.beforeMappingData = dataArray;
      return dataArray;
    };
    Geometry2.prototype.adjustData = function(dataArray) {
      var adjustOption = this.adjustOption;
      var _a2 = this, intervalPadding = _a2.intervalPadding, dodgePadding = _a2.dodgePadding, theme2 = _a2.theme;
      var maxColumnWidth = this.maxColumnWidth || theme2.maxColumnWidth;
      var minColumnWidth = this.minColumnWidth || theme2.minColumnWidth;
      var columnWidthRatio = this.columnWidthRatio || theme2.columnWidthRatio;
      var result = dataArray;
      if (adjustOption) {
        var xScale_2 = this.getXScale();
        var yScale = this.getYScale();
        var xField = xScale_2.field;
        var yField = yScale ? yScale.field : null;
        var xDimensionLength = getXDimensionLength(this.coordinate);
        var groupNum = xScale_2.values.length;
        var sizeAttr = this.getAttribute("size");
        var defaultSize = void 0;
        if (sizeAttr) {
          defaultSize = sizeAttr.values[0];
        }
        for (var i = 0, len = adjustOption.length; i < len; i++) {
          var adjust2 = adjustOption[i];
          var adjustCfg2 = __assign$1({ xField, yField, intervalPadding, dodgePadding, xDimensionLength, groupNum, defaultSize, maxColumnWidth, minColumnWidth, columnWidthRatio }, adjust2);
          var type = adjust2.type;
          if (type === "dodge") {
            var adjustNames = [];
            if (xScale_2.isCategory || xScale_2.type === "identity") {
              adjustNames.push("x");
            } else if (!yScale) {
              adjustNames.push("y");
            } else {
              throw new Error("dodge is not support linear attribute, please use category attribute!");
            }
            adjustCfg2.adjustNames = adjustNames;
            adjustCfg2.dodgeRatio = columnWidthRatio;
          } else if (type === "stack") {
            var coordinate2 = this.coordinate;
            if (!yScale) {
              adjustCfg2.height = coordinate2.getHeight();
              var size2 = this.getDefaultValue("size") || 3;
              adjustCfg2.size = size2;
            }
            if (!coordinate2.isTransposed && isNil(adjustCfg2.reverseOrder)) {
              adjustCfg2.reverseOrder = true;
            }
          }
          var adjustCtor = getAdjust(type);
          adjustCfg2.dimValuesMap = {};
          if (xScale_2 && xScale_2.values) {
            adjustCfg2.dimValuesMap[xScale_2.field] = xScale_2.values.map(function(v) {
              return xScale_2.translate(v);
            });
          }
          var adjustInstance = new adjustCtor(adjustCfg2);
          result = adjustInstance.process(result);
          this.adjusts[type] = adjustInstance;
        }
      }
      return result;
    };
    Geometry2.prototype.groupData = function(data2) {
      var groupScales = this.getGroupScales();
      var scaleDefs = this.scaleDefs;
      var appendConditions = {};
      var groupFields = [];
      for (var index2 = 0; index2 < groupScales.length; index2++) {
        var scale2 = groupScales[index2];
        var field2 = scale2.field;
        groupFields.push(field2);
        if (get(scaleDefs, [field2, "values"])) {
          appendConditions[field2] = scaleDefs[field2].values;
        }
      }
      return group(data2, groupFields, appendConditions);
    };
    Geometry2.prototype.updateStackRange = function(scale2, dataArray) {
      var mergeArray = flatten(dataArray);
      var field2 = scale2.field;
      var min2 = scale2.min;
      var max2 = scale2.max;
      for (var index2 = 0; index2 < mergeArray.length; index2++) {
        var obj = mergeArray[index2];
        var tmpMin = Math.min.apply(null, obj[field2]);
        var tmpMax = Math.max.apply(null, obj[field2]);
        if (tmpMin < min2) {
          min2 = tmpMin;
        }
        if (tmpMax > max2) {
          max2 = tmpMax;
        }
      }
      var scaleDefs = this.scaleDefs;
      var cfg = {};
      if (min2 < scale2.min && !get(scaleDefs, [field2, "min"])) {
        cfg.min = min2;
      }
      if (max2 > scale2.max && !get(scaleDefs, [field2, "max"])) {
        cfg.max = max2;
      }
      scale2.change(cfg);
    };
    Geometry2.prototype.beforeMapping = function(beforeMappingData) {
      var source = beforeMappingData;
      if (this.sortable) {
        this.sort(source);
      }
      if (this.generatePoints) {
        for (var index2 = 0, length_5 = source.length; index2 < length_5; index2++) {
          var currentData = source[index2];
          this.generateShapePoints(currentData);
          var nextData = source[index2 + 1];
          if (nextData) {
            this.generateShapePoints(nextData);
            currentData[0].nextPoints = nextData[0].points;
          }
        }
      }
      return source;
    };
    Geometry2.prototype.generateShapePoints = function(data2) {
      var shapeFactory = this.getShapeFactory();
      var shapeAttr = this.getAttribute("shape");
      for (var index2 = 0; index2 < data2.length; index2++) {
        var obj = data2[index2];
        var cfg = this.createShapePointsCfg(obj);
        var shape = shapeAttr ? this.getAttributeValues(shapeAttr, obj) : null;
        var points2 = shapeFactory.getShapePoints(shape, cfg);
        obj.points = points2;
      }
    };
    Geometry2.prototype.normalizeValues = function(values2, scale2) {
      var rst = [];
      if (isArray$1(values2)) {
        for (var index2 = 0; index2 < values2.length; index2++) {
          var value2 = values2[index2];
          rst.push(scale2.scale(value2));
        }
      } else {
        rst = scale2.scale(values2);
      }
      return rst;
    };
    Geometry2.prototype.mapping = function(data2) {
      var attributes = this.attributes;
      var mappingData = [];
      for (var index2 = 0; index2 < data2.length; index2++) {
        var record = data2[index2];
        var newRecord = {
          _origin: record[FIELD_ORIGIN],
          points: record.points,
          nextPoints: record.nextPoints
        };
        for (var k in attributes) {
          if (attributes.hasOwnProperty(k)) {
            var attr = attributes[k];
            var names = attr.names;
            var values2 = this.getAttributeValues(attr, record);
            if (names.length > 1) {
              for (var j = 0; j < values2.length; j += 1) {
                var val = values2[j];
                var name_1 = names[j];
                newRecord[name_1] = isArray$1(val) && val.length === 1 ? val[0] : val;
              }
            } else {
              newRecord[names[0]] = values2.length === 1 ? values2[0] : values2;
            }
          }
        }
        this.convertPoint(newRecord);
        mappingData.push(newRecord);
      }
      return mappingData;
    };
    Geometry2.prototype.convertPoint = function(mappingRecord) {
      var x = mappingRecord.x, y = mappingRecord.y;
      var rstX;
      var rstY;
      var obj;
      var coordinate2 = this.coordinate;
      if (isArray$1(x) && isArray$1(y)) {
        rstX = [];
        rstY = [];
        for (var i = 0, j = 0, xLen = x.length, yLen = y.length; i < xLen && j < yLen; i += 1, j += 1) {
          obj = coordinate2.convert({
            x: x[i],
            y: y[j]
          });
          rstX.push(obj.x);
          rstY.push(obj.y);
        }
      } else if (isArray$1(y)) {
        rstY = [];
        for (var index2 = 0; index2 < y.length; index2++) {
          var yVal = y[index2];
          obj = coordinate2.convert({
            x,
            y: yVal
          });
          if (rstX && rstX !== obj.x) {
            if (!isArray$1(rstX)) {
              rstX = [rstX];
            }
            rstX.push(obj.x);
          } else {
            rstX = obj.x;
          }
          rstY.push(obj.y);
        }
      } else if (isArray$1(x)) {
        rstX = [];
        for (var index2 = 0; index2 < x.length; index2++) {
          var xVal = x[index2];
          obj = coordinate2.convert({
            x: xVal,
            y
          });
          if (rstY && rstY !== obj.y) {
            if (!isArray$1(rstY)) {
              rstY = [rstY];
            }
            rstY.push(obj.y);
          } else {
            rstY = obj.y;
          }
          rstX.push(obj.x);
        }
      } else {
        var point2 = coordinate2.convert({
          x,
          y
        });
        rstX = point2.x;
        rstY = point2.y;
      }
      mappingRecord.x = rstX;
      mappingRecord.y = rstY;
    };
    Geometry2.prototype.getStyleCfg = function(styleOption, originData) {
      var _a2 = styleOption.fields, fields = _a2 === void 0 ? [] : _a2, callback = styleOption.callback, cfg = styleOption.cfg;
      if (cfg) {
        return cfg;
      }
      var params = fields.map(function(field2) {
        return originData[field2];
      });
      return callback.apply(void 0, __spreadArray$1([], __read(params), false));
    };
    Geometry2.prototype.setCfg = function(cfg) {
      var _this = this;
      var coordinate2 = cfg.coordinate, data2 = cfg.data, theme2 = cfg.theme, scaleDefs = cfg.scaleDefs;
      if (coordinate2) {
        this.coordinate = coordinate2;
      }
      if (data2) {
        this.data = data2;
      }
      if (scaleDefs) {
        this.scaleDefs = scaleDefs;
        this.idFields = [];
        each$1(scaleDefs, function(scaleDef, field2) {
          if (scaleDef && scaleDef.key) {
            _this.idFields.push(field2);
          }
        });
      }
      if (theme2) {
        this.theme = this.userTheme ? deepMix({}, theme2, this.userTheme) : theme2;
      }
    };
    Geometry2.prototype.renderLabels = function(mappingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var geometryLabel, labelType, GeometryLabelsCtor, labelsMap, elementLabels, _a2, _b, _c, element, labels;
        var e_5, _d;
        var _this = this;
        return __generator(this, function(_e) {
          switch (_e.label) {
            case 0:
              geometryLabel = this.geometryLabel;
              this.emit(GEOMETRY_LIFE_CIRCLE.BEFORE_RENDER_LABEL);
              if (!geometryLabel) {
                labelType = this.getLabelType();
                GeometryLabelsCtor = getGeometryLabel(labelType);
                geometryLabel = new GeometryLabelsCtor(this);
                this.geometryLabel = geometryLabel;
              }
              return [4, geometryLabel.render(mappingArray, isUpdate)];
            case 1:
              _e.sent();
              labelsMap = geometryLabel.labelsRenderer.shapesMap;
              elementLabels = /* @__PURE__ */ new Map();
              each$1(labelsMap, function(labelGroup, labelGroupId) {
                var labelChildren = labelGroup.getChildren() || [];
                for (var j = 0; j < labelChildren.length; j++) {
                  var labelShape = labelChildren[j];
                  var element2 = _this.elementsMap[labelShape.get("elementId") || labelGroupId.split(" ")[0]];
                  if (element2) {
                    labelShape.cfg.name = ["element", "label"];
                    labelShape.cfg.element = element2;
                    var labels2 = elementLabels.get(element2) || /* @__PURE__ */ new Set();
                    labels2.add(labelGroup);
                    elementLabels.set(element2, labels2);
                  }
                }
              });
              try {
                for (_a2 = __values(elementLabels.entries()), _b = _a2.next(); !_b.done; _b = _a2.next()) {
                  _c = __read(_b.value, 2), element = _c[0], labels = _c[1];
                  element.labelShape = __spreadArray$1([], __read(labels), false);
                }
              } catch (e_5_1) {
                e_5 = { error: e_5_1 };
              } finally {
                try {
                  if (_b && !_b.done && (_d = _a2.return))
                    _d.call(_a2);
                } finally {
                  if (e_5)
                    throw e_5.error;
                }
              }
              this.emit(GEOMETRY_LIFE_CIRCLE.AFTER_RENDER_LABEL);
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Geometry2.prototype.canDoGroupAnimation = function(isUpdate) {
      return !isUpdate && this.animateOption && (get(this.animateOption, "appear") === void 0 || get(this.animateOption, "appear") && get(this.animateOption, ["appear", "animation"]) === void 0);
    };
    return Geometry2;
  }(Base$1)
);
var transform$4 = transform$6;
function translate(element, x, y) {
  var matrix = transform$4(element.getMatrix(), [["t", x, y]]);
  element.setMatrix(matrix);
}
function getRotateMatrix(element, rotateRadian) {
  var _a2 = element.attr(), x = _a2.x, y = _a2.y;
  var matrix = transform$4(element.getMatrix(), [
    ["t", -x, -y],
    ["r", rotateRadian],
    ["t", x, y]
  ]);
  return matrix;
}
function rotate(element, rotateRadian) {
  var matrix = getRotateMatrix(element, rotateRadian);
  element.setMatrix(matrix);
}
function zoom(element, ratio) {
  var bbox = element.getBBox();
  var x = (bbox.minX + bbox.maxX) / 2;
  var y = (bbox.minY + bbox.maxY) / 2;
  element.applyToMatrix([x, y, 1]);
  var matrix = transform$4(element.getMatrix(), [
    ["t", -x, -y],
    ["s", ratio, ratio],
    ["t", x, y]
  ]);
  element.setMatrix(matrix);
}
function findLabelTextShape(label2) {
  return label2.find(function(el) {
    return el.get("type") === "text";
  });
}
function getLabelBackgroundInfo(labelGroup, labelItem, padding2) {
  if (padding2 === void 0) {
    padding2 = [0, 0, 0, 0];
  }
  var content = labelGroup && labelGroup.getChildren()[0];
  if (content) {
    var labelShape = content.clone();
    if (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) {
      rotate(labelShape, -labelItem.rotate);
    }
    var _a2 = labelShape.getCanvasBBox(), x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
    labelShape.destroy();
    var boxPadding = padding2;
    if (isNil(boxPadding)) {
      boxPadding = [2, 2, 2, 2];
    } else if (isNumber$1(boxPadding)) {
      boxPadding = new Array(4).fill(boxPadding);
    }
    return {
      x: x - boxPadding[3],
      y: y - boxPadding[0],
      width: width + boxPadding[1] + boxPadding[3],
      height: height + boxPadding[0] + boxPadding[2],
      rotation: (labelItem === null || labelItem === void 0 ? void 0 : labelItem.rotate) || 0
    };
  }
  return { x: 0, y: 0, width: 0, height: 0, rotation: 0 };
}
function getOverlapArea$2(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap$2(cur, dones) {
  var box2 = cur.getBBox();
  return some(dones, function(done) {
    var target2 = done.getBBox();
    return getOverlapArea$2(box2, target2, 2) > 0;
  });
}
function updateLabel(fromShape, toShape, cfg) {
  var data2 = cfg.data, origin = cfg.origin, animateCfg = cfg.animateCfg, coordinate2 = cfg.coordinate;
  var updateAnimateCfg = get(animateCfg, "update");
  fromShape.set("data", data2);
  fromShape.set("origin", origin);
  fromShape.set("animateCfg", animateCfg);
  fromShape.set("coordinate", coordinate2);
  fromShape.set("visible", toShape.get("visible"));
  (fromShape.getChildren() || []).forEach(function(fromChild, idx) {
    var toChild = toShape.getChildByIndex(idx);
    if (!toChild) {
      fromShape.removeChild(fromChild);
      fromChild.remove(true);
    } else {
      fromChild.set("data", data2);
      fromChild.set("origin", origin);
      fromChild.set("animateCfg", animateCfg);
      fromChild.set("coordinate", coordinate2);
      var newAttrs = getReplaceAttrs(fromChild, toChild);
      if (updateAnimateCfg) {
        doAnimate(fromChild, updateAnimateCfg, {
          toAttrs: newAttrs,
          coordinate: coordinate2
        });
      } else {
        fromChild.attr(newAttrs);
      }
      if (toChild.isGroup()) {
        updateLabel(fromChild, toChild, cfg);
      }
    }
  });
  each$1(toShape.getChildren(), function(child, idx) {
    if (idx >= fromShape.getCount()) {
      if (!child.destroyed) {
        fromShape.add(child);
      }
    }
  });
}
var Labels = (
  /** @class */
  function() {
    function Labels2(cfg) {
      this.shapesMap = {};
      var layout2 = cfg.layout, container = cfg.container;
      this.layout = layout2;
      this.container = container;
    }
    Labels2.prototype.render = function(items, shapes, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var shapesMap, offscreenGroup, items_1, items_1_1, item, lastShapesMap;
        var e_1, _a2;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              shapesMap = {};
              offscreenGroup = this.createOffscreenGroup();
              if (!items.length)
                return [3, 2];
              try {
                for (items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
                  item = items_1_1.value;
                  if (item) {
                    shapesMap[item.id] = this.renderLabel(item, offscreenGroup);
                  }
                }
              } catch (e_1_1) {
                e_1 = { error: e_1_1 };
              } finally {
                try {
                  if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
                    _a2.call(items_1);
                } finally {
                  if (e_1)
                    throw e_1.error;
                }
              }
              return [4, this.doLayout(items, shapes, shapesMap)];
            case 1:
              _b.sent();
              this.renderLabelLine(items, shapesMap);
              this.renderLabelBackground(items, shapesMap);
              this.adjustLabel(items, shapesMap);
              _b.label = 2;
            case 2:
              lastShapesMap = this.shapesMap;
              each$1(shapesMap, function(shape, id2) {
                if (shape.destroyed) {
                  delete shapesMap[id2];
                } else {
                  if (lastShapesMap[id2]) {
                    var data2 = shape.get("data");
                    var origin_1 = shape.get("origin");
                    var coordinate2 = shape.get("coordinate");
                    var currentAnimateCfg = shape.get("animateCfg");
                    var currentShape = lastShapesMap[id2];
                    updateLabel(currentShape, shapesMap[id2], {
                      data: data2,
                      origin: origin_1,
                      animateCfg: currentAnimateCfg,
                      coordinate: coordinate2
                    });
                    shapesMap[id2] = currentShape;
                  } else {
                    if (_this.container.destroyed)
                      return;
                    _this.container.add(shape);
                    var animateCfg = get(shape.get("animateCfg"), isUpdate ? "enter" : "appear");
                    if (animateCfg) {
                      doAnimate(shape, animateCfg, {
                        toAttrs: __assign$1({}, shape.attr()),
                        coordinate: shape.get("coordinate")
                      });
                    }
                  }
                  delete lastShapesMap[id2];
                }
              });
              each$1(lastShapesMap, function(deleteShape) {
                var animateCfg = get(deleteShape.get("animateCfg"), "leave");
                if (animateCfg) {
                  doAnimate(deleteShape, animateCfg, {
                    toAttrs: null,
                    coordinate: deleteShape.get("coordinate")
                  });
                } else {
                  deleteShape.remove(true);
                }
              });
              this.shapesMap = shapesMap;
              offscreenGroup.destroy();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Labels2.prototype.clear = function() {
      this.container.clear();
      this.shapesMap = {};
    };
    Labels2.prototype.destroy = function() {
      this.container.destroy();
      this.shapesMap = null;
    };
    Labels2.prototype.renderLabel = function(cfg, container) {
      var id2 = cfg.id, elementId = cfg.elementId, data2 = cfg.data, mappingData = cfg.mappingData, coordinate2 = cfg.coordinate, animate = cfg.animate, content = cfg.content, capture = cfg.capture;
      var shapeAppendCfg = {
        id: id2,
        elementId,
        capture,
        data: data2,
        origin: __assign$1(__assign$1({}, mappingData), { data: mappingData[FIELD_ORIGIN] }),
        coordinate: coordinate2
      };
      var labelGroup = container.addGroup(__assign$1({
        name: "label",
        //  this.animate === false  cfg.animate === false/null 
        animateCfg: this.animate === false || animate === null || animate === false ? false : deepMix({}, this.animate, animate)
      }, shapeAppendCfg));
      var labelShape;
      if (content.isGroup && content.isGroup() || content.isShape && content.isShape()) {
        var _a2 = content.getCanvasBBox(), width = _a2.width, height = _a2.height;
        var textAlign = get(cfg, "textAlign", "left");
        var x = cfg.x;
        var y = cfg.y - height / 2;
        if (textAlign === "center") {
          x = x - width / 2;
        } else if (textAlign === "right" || textAlign === "end") {
          x = x - width;
        }
        translate(content, x, y);
        labelShape = content;
        labelGroup.add(content);
      } else {
        var fill = get(cfg, ["style", "fill"]);
        labelShape = labelGroup.addShape("text", __assign$1({ attrs: __assign$1(__assign$1({ x: cfg.x, y: cfg.y, textAlign: cfg.textAlign, textBaseline: get(cfg, "textBaseline", "middle"), text: cfg.content }, cfg.style), { fill: isNull(fill) ? cfg.color : fill }) }, shapeAppendCfg));
      }
      if (cfg.rotate) {
        rotate(labelShape, cfg.rotate);
      }
      return labelGroup;
    };
    Labels2.prototype.doLayout = function(items, shapes, shapesMap) {
      return __awaiter(this, void 0, void 0, function() {
        var layouts;
        var _this = this;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              if (!this.layout)
                return [3, 2];
              layouts = isArray$1(this.layout) ? this.layout : [this.layout];
              return [4, Promise.all(layouts.map(function(layout2) {
                var layoutFn = getGeometryLabelLayout(get(layout2, "type", ""));
                if (!layoutFn)
                  return;
                var labelShapes = [];
                var geometryShapes = [];
                each$1(shapesMap, function(labelShape, id2) {
                  labelShapes.push(labelShape);
                  geometryShapes.push(shapes[labelShape.get("elementId")]);
                });
                return layoutFn(items, labelShapes, geometryShapes, _this.region, layout2.cfg);
              }))];
            case 1:
              _a2.sent();
              _a2.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Labels2.prototype.renderLabelLine = function(labelItems, shapesMap) {
      each$1(labelItems, function(labelItem) {
        var coordinate2 = get(labelItem, "coordinate");
        if (!labelItem || !coordinate2) {
          return;
        }
        var center2 = coordinate2.getCenter();
        var radius = coordinate2.getRadius();
        if (!labelItem.labelLine) {
          return;
        }
        var labelLineCfg = get(labelItem, "labelLine", {});
        var id2 = labelItem.id;
        var path2 = labelLineCfg.path;
        if (!path2) {
          var start = polarToCartesian(center2.x, center2.y, radius, labelItem.angle);
          path2 = [
            ["M", start.x, start.y],
            ["L", labelItem.x, labelItem.y]
          ];
        }
        var labelGroup = shapesMap[id2];
        if (!labelGroup.destroyed) {
          labelGroup.addShape("path", {
            capture: false,
            attrs: __assign$1({ path: path2, stroke: labelItem.color ? labelItem.color : get(labelItem, ["style", "fill"], "#000"), fill: null }, labelLineCfg.style),
            id: id2,
            origin: labelItem.mappingData,
            data: labelItem.data,
            coordinate: labelItem.coordinate
          });
        }
      });
    };
    Labels2.prototype.renderLabelBackground = function(labelItems, shapesMap) {
      each$1(labelItems, function(labelItem) {
        var coordinate2 = get(labelItem, "coordinate");
        var background = get(labelItem, "background");
        if (!background || !coordinate2) {
          return;
        }
        var id2 = labelItem.id;
        var labelGroup = shapesMap[id2];
        if (!labelGroup.destroyed) {
          var labelContentShape = labelGroup.getChildren()[0];
          if (labelContentShape) {
            var _a2 = getLabelBackgroundInfo(labelGroup, labelItem, background.padding), rotation = _a2.rotation, box2 = __rest(_a2, ["rotation"]);
            var backgroundShape = labelGroup.addShape("rect", {
              attrs: __assign$1(__assign$1({}, box2), background.style || {}),
              id: id2,
              origin: labelItem.mappingData,
              data: labelItem.data,
              coordinate: labelItem.coordinate
            });
            backgroundShape.setZIndex(-1);
            if (rotation) {
              var matrix = labelContentShape.getMatrix();
              backgroundShape.setMatrix(matrix);
            }
          }
        }
      });
    };
    Labels2.prototype.createOffscreenGroup = function() {
      var container = this.container;
      var GroupClass = container.getGroupBase();
      var newGroup = new GroupClass({});
      return newGroup;
    };
    Labels2.prototype.adjustLabel = function(items, shapesMap) {
      each$1(items, function(item) {
        if (item) {
          var id2 = item.id;
          var labelGroup = shapesMap[id2];
          if (!labelGroup.destroyed) {
            var labelShapes = labelGroup.findAll(function(ele) {
              return ele.get("type") !== "path";
            });
            each$1(labelShapes, function(labelShape) {
              if (labelShape) {
                if (item.offsetX) {
                  labelShape.attr("x", labelShape.attr("x") + item.offsetX);
                }
                if (item.offsetY) {
                  labelShape.attr("y", labelShape.attr("y") + item.offsetY);
                }
              }
            });
          }
        }
      });
    };
    return Labels2;
  }()
);
function avg(arr) {
  var sum = 0;
  each$1(arr, function(value2) {
    sum += value2;
  });
  return sum / arr.length;
}
var GeometryLabel = (
  /** @class */
  function() {
    function GeometryLabel2(geometry2) {
      this.geometry = geometry2;
    }
    GeometryLabel2.prototype.getLabelItems = function(mapppingArray) {
      var _this = this;
      var items = [];
      var labelCfgs = this.getLabelCfgs(mapppingArray);
      each$1(mapppingArray, function(mappingData, index2) {
        var labelCfg = labelCfgs[index2];
        if (!labelCfg || isNil(mappingData.x) || isNil(mappingData.y)) {
          items.push(null);
          return;
        }
        var labelContent = !isArray$1(labelCfg.content) ? [labelCfg.content] : labelCfg.content;
        labelCfg.content = labelContent;
        var total = labelContent.length;
        each$1(labelContent, function(content, subIndex) {
          if (isNil(content) || content === "") {
            items.push(null);
            return;
          }
          var item = __assign$1(__assign$1({}, labelCfg), _this.getLabelPoint(labelCfg, mappingData, subIndex));
          if (!item.textAlign) {
            item.textAlign = _this.getLabelAlign(item, subIndex, total);
          }
          if (item.offset <= 0) {
            item.labelLine = null;
          }
          items.push(item);
        });
      });
      return items;
    };
    GeometryLabel2.prototype.render = function(mappingArray, isUpdate) {
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      return __awaiter(this, void 0, void 0, function() {
        var labelItems, labelsRenderer, shapes;
        return __generator(this, function(_a2) {
          switch (_a2.label) {
            case 0:
              labelItems = this.getLabelItems(mappingArray);
              labelsRenderer = this.getLabelsRenderer();
              shapes = this.getGeometryShapes();
              return [4, labelsRenderer.render(labelItems, shapes, isUpdate)];
            case 1:
              _a2.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    GeometryLabel2.prototype.clear = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.clear();
      }
    };
    GeometryLabel2.prototype.destroy = function() {
      var labelsRenderer = this.labelsRenderer;
      if (labelsRenderer) {
        labelsRenderer.destroy();
      }
      this.labelsRenderer = null;
    };
    GeometryLabel2.prototype.getCoordinate = function() {
      return this.geometry.coordinate;
    };
    GeometryLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var geometry2 = this.geometry;
      var type = geometry2.type, theme2 = geometry2.theme;
      if (type === "polygon" || type === "interval" && position === "middle" || offset < 0 && !["line", "point", "path"].includes(type)) {
        return get(theme2, "innerLabels", {});
      }
      return get(theme2, "labels", {});
    };
    GeometryLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry2 = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var type = geometry2.type, theme2 = geometry2.theme;
      var themedLabelCfg;
      if (type === "polygon" || labelCfg.offset < 0 && !["line", "point", "path"].includes(type)) {
        themedLabelCfg = deepMix({}, defaultLabelCfg, theme2.innerLabels, labelCfg);
      } else {
        themedLabelCfg = deepMix({}, defaultLabelCfg, theme2.labels, labelCfg);
      }
      return themedLabelCfg;
    };
    GeometryLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index2, position) {
    };
    GeometryLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate2 = this.getCoordinate();
      var vector = this.getOffsetVector(offset);
      return coordinate2.isTransposed ? vector[0] : vector[1];
    };
    GeometryLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index2, total) {
      var offset = labelCfg.offset;
      var coordinate2 = this.getCoordinate();
      var transposed = coordinate2.isTransposed;
      var dim = transposed ? "x" : "y";
      var factor = transposed ? 1 : -1;
      var offsetPoint = {
        x: 0,
        y: 0
      };
      if (index2 > 0 || total === 1) {
        offsetPoint[dim] = offset * factor;
      } else {
        offsetPoint[dim] = offset * factor * -1;
      }
      return offsetPoint;
    };
    GeometryLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
      var coordinate2 = this.getCoordinate();
      var total = labelCfg.content.length;
      function getDimValue(value2, idx, isAvg) {
        if (isAvg === void 0) {
          isAvg = false;
        }
        var v = value2;
        if (isArray$1(v)) {
          if (labelCfg.content.length === 1) {
            if (isAvg) {
              v = avg(v);
            } else {
              if (v.length <= 2) {
                v = v[value2.length - 1];
              } else {
                v = avg(v);
              }
            }
          } else {
            v = v[idx];
          }
        }
        return v;
      }
      var label2 = {
        content: labelCfg.content[index2],
        x: 0,
        y: 0,
        start: { x: 0, y: 0 },
        color: "#fff"
      };
      var shape = isArray$1(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      var isFunnel = shape === "funnel" || shape === "pyramid";
      if (this.geometry.type === "polygon") {
        var centroid = getPolygonCentroid(mappingData.x, mappingData.y);
        label2.x = centroid[0];
        label2.y = centroid[1];
      } else if (this.geometry.type === "interval" && !isFunnel) {
        label2.x = getDimValue(mappingData.x, index2, true);
        label2.y = getDimValue(mappingData.y, index2);
      } else {
        label2.x = getDimValue(mappingData.x, index2);
        label2.y = getDimValue(mappingData.y, index2);
      }
      if (isFunnel) {
        var nextPoints = get(mappingData, "nextPoints");
        var points2 = get(mappingData, "points");
        if (nextPoints) {
          var point1 = coordinate2.convert(points2[1]);
          var point2 = coordinate2.convert(nextPoints[1]);
          label2.x = (point1.x + point2.x) / 2;
          label2.y = (point1.y + point2.y) / 2;
        } else if (shape === "pyramid") {
          var point1 = coordinate2.convert(points2[1]);
          var point2 = coordinate2.convert(points2[2]);
          label2.x = (point1.x + point2.x) / 2;
          label2.y = (point1.y + point2.y) / 2;
        }
      }
      if (labelCfg.position) {
        this.setLabelPosition(label2, mappingData, index2, labelCfg.position);
      }
      var offsetPoint = this.getLabelOffsetPoint(labelCfg, index2, total);
      label2.start = { x: label2.x, y: label2.y };
      label2.x += offsetPoint.x;
      label2.y += offsetPoint.y;
      label2.color = mappingData.color;
      return label2;
    };
    GeometryLabel2.prototype.getLabelAlign = function(item, index2, total) {
      var align = "center";
      var coordinate2 = this.getCoordinate();
      if (coordinate2.isTransposed) {
        var offset = item.offset;
        if (offset < 0) {
          align = "right";
        } else if (offset === 0) {
          align = "center";
        } else {
          align = "left";
        }
        if (total > 1 && index2 === 0) {
          if (align === "right") {
            align = "left";
          } else if (align === "left") {
            align = "right";
          }
        }
      }
      return align;
    };
    GeometryLabel2.prototype.getLabelId = function(mappingData) {
      var geometry2 = this.geometry;
      var type = geometry2.type;
      var xScale = geometry2.getXScale();
      var yScale = geometry2.getYScale();
      var origin = mappingData[FIELD_ORIGIN];
      var labelId = geometry2.getElementId(mappingData);
      if (type === "line" || type === "area") {
        labelId += " ".concat(origin[xScale.field]);
      } else if (type === "path") {
        labelId += " ".concat(origin[xScale.field], "-").concat(origin[yScale.field]);
      }
      return labelId;
    };
    GeometryLabel2.prototype.getLabelsRenderer = function() {
      var _a2 = this.geometry, labelsContainer = _a2.labelsContainer, labelOption = _a2.labelOption, canvasRegion = _a2.canvasRegion, animateOption = _a2.animateOption;
      var coordinate2 = this.geometry.coordinate;
      var labelsRenderer = this.labelsRenderer;
      if (!labelsRenderer) {
        labelsRenderer = new Labels({
          container: labelsContainer,
          layout: get(labelOption, ["cfg", "layout"], {
            type: this.defaultLayout
          })
        });
        this.labelsRenderer = labelsRenderer;
      }
      labelsRenderer.region = canvasRegion;
      labelsRenderer.animate = animateOption ? getDefaultAnimateCfg("label", coordinate2) : false;
      return labelsRenderer;
    };
    GeometryLabel2.prototype.getLabelCfgs = function(mapppingArray) {
      var _this = this;
      var geometry2 = this.geometry;
      var labelOption = geometry2.labelOption, scales = geometry2.scales, coordinate2 = geometry2.coordinate;
      var _a2 = labelOption, fields = _a2.fields, callback = _a2.callback, cfg = _a2.cfg;
      var labelScales = fields.map(function(field2) {
        return scales[field2];
      });
      var labelCfgs = [];
      each$1(mapppingArray, function(mappingData, index2) {
        var origin = mappingData[FIELD_ORIGIN];
        var originText = _this.getLabelText(origin, labelScales);
        var callbackCfg;
        if (callback) {
          var originValues = fields.map(function(field2) {
            return origin[field2];
          });
          callbackCfg = callback.apply(void 0, __spreadArray$1([], __read(originValues), false));
          if (isNil(callbackCfg)) {
            labelCfgs.push(null);
            return;
          }
        }
        var labelCfg = __assign$1(__assign$1({
          id: _this.getLabelId(mappingData),
          elementId: _this.geometry.getElementId(mappingData),
          data: origin,
          // 
          mappingData,
          // ,
          coordinate: coordinate2
        }, cfg), callbackCfg);
        if (isFunction(labelCfg.position)) {
          labelCfg.position = labelCfg.position(origin, mappingData, index2);
        }
        var offset = _this.getLabelOffset(labelCfg.offset || 0);
        var defaultLabelCfg = _this.getDefaultLabelCfg(offset, labelCfg.position);
        labelCfg = deepMix({}, defaultLabelCfg, labelCfg);
        labelCfg.offset = _this.getLabelOffset(labelCfg.offset || 0);
        var content = labelCfg.content;
        if (isFunction(content)) {
          labelCfg.content = content(origin, mappingData, index2);
        } else if (isUndefined(content)) {
          labelCfg.content = originText[0];
        }
        labelCfgs.push(labelCfg);
      });
      return labelCfgs;
    };
    GeometryLabel2.prototype.getLabelText = function(origin, scales) {
      var labelTexts = [];
      each$1(scales, function(scale2) {
        var value2 = origin[scale2.field];
        if (isArray$1(value2)) {
          value2 = value2.map(function(subVal) {
            return scale2.getText(subVal);
          });
        } else {
          value2 = scale2.getText(value2);
        }
        if (isNil(value2) || value2 === "") {
          labelTexts.push(null);
        } else {
          labelTexts.push(value2);
        }
      });
      return labelTexts;
    };
    GeometryLabel2.prototype.getOffsetVector = function(offset) {
      if (offset === void 0) {
        offset = 0;
      }
      var coordinate2 = this.getCoordinate();
      var actualOffset = 0;
      if (isNumber$1(offset)) {
        actualOffset = offset;
      }
      return coordinate2.isTransposed ? coordinate2.applyMatrix(actualOffset, 0) : coordinate2.applyMatrix(0, actualOffset);
    };
    GeometryLabel2.prototype.getGeometryShapes = function() {
      var geometry2 = this.geometry;
      var shapes = {};
      each$1(geometry2.elementsMap, function(element, id2) {
        shapes[id2] = element.shape;
      });
      each$1(geometry2.getOffscreenGroup().getChildren(), function(child) {
        var id2 = geometry2.getElementId(child.get("origin").mappingData);
        shapes[id2] = child;
      });
      return shapes;
    };
    return GeometryLabel2;
  }()
);
function getMappingValue(attr, value2, def) {
  if (!attr) {
    return def;
  }
  var r;
  if (attr.callback && attr.callback.length > 1) {
    var restArgs = Array(attr.callback.length - 1).fill("");
    r = attr.mapping.apply(attr, __spreadArray$1([value2], __read(restArgs), false)).join("");
  } else {
    r = attr.mapping(value2).join("");
  }
  return r || def;
}
var MarkerSymbols = {
  hexagon: function(x, y, r) {
    var diffX = r / 2 * Math.sqrt(3);
    return [
      ["M", x, y - r],
      ["L", x + diffX, y - r / 2],
      ["L", x + diffX, y + r / 2],
      ["L", x, y + r],
      ["L", x - diffX, y + r / 2],
      ["L", x - diffX, y - r / 2],
      ["Z"]
    ];
  },
  bowtie: function(x, y, r) {
    var diffY = r - 1.5;
    return [["M", x - r, y - diffY], ["L", x + r, y + diffY], ["L", x + r, y - diffY], ["L", x - r, y + diffY], ["Z"]];
  },
  cross: function(x, y, r) {
    return [
      ["M", x - r, y - r],
      ["L", x + r, y + r],
      ["M", x + r, y - r],
      ["L", x - r, y + r]
    ];
  },
  tick: function(x, y, r) {
    return [
      ["M", x - r / 2, y - r],
      ["L", x + r / 2, y - r],
      ["M", x, y - r],
      ["L", x, y + r],
      ["M", x - r / 2, y + r],
      ["L", x + r / 2, y + r]
    ];
  },
  plus: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y],
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  },
  hyphen: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  line: function(x, y, r) {
    return [
      ["M", x, y - r],
      ["L", x, y + r]
    ];
  }
};
var STROKES_SYMBOLS = ["line", "cross", "tick", "plus", "hyphen"];
function handleUserMarkerStyle(markerStyle, style) {
  if (isFunction(style)) {
    return style(markerStyle);
  }
  return deepMix({}, markerStyle, style);
}
function adpatorMarkerStyle(marker, color2) {
  var symbol = marker.symbol;
  if (isString(symbol) && STROKES_SYMBOLS.indexOf(symbol) !== -1) {
    var markerStyle = get(marker, "style", {});
    var lineWidth = get(markerStyle, "lineWidth", 1);
    var stroke = markerStyle.stroke || markerStyle.fill || color2;
    marker.style = deepMix({}, marker.style, { lineWidth, stroke, fill: null });
  }
}
function setMarkerSymbol(marker) {
  var symbol = marker.symbol;
  if (isString(symbol) && MarkerSymbols[symbol]) {
    marker.symbol = MarkerSymbols[symbol];
  }
}
function getLegendLayout(direction2) {
  return direction2.startsWith(DIRECTION.LEFT) || direction2.startsWith(DIRECTION.RIGHT) ? "vertical" : "horizontal";
}
function getLegendItems(view, geometry2, attr, themeMarker, userMarker) {
  var scale2 = attr.getScale(attr.type);
  if (scale2.isCategory) {
    var field_1 = scale2.field;
    var colorAttr_1 = geometry2.getAttribute("color");
    var shapeAttr_1 = geometry2.getAttribute("shape");
    var defaultColor_1 = view.getTheme().defaultColor;
    var isInPolar_1 = geometry2.coordinate.isPolar;
    return scale2.getTicks().map(function(tick, index2) {
      var _a2;
      var text2 = tick.text, scaleValue = tick.value;
      var name = text2;
      var value2 = scale2.invert(scaleValue);
      var unchecked = view.filterFieldData(field_1, [(_a2 = {}, _a2[field_1] = value2, _a2)]).length === 0;
      each$1(view.views, function(subView) {
        var _a3;
        if (!subView.filterFieldData(field_1, [(_a3 = {}, _a3[field_1] = value2, _a3)]).length) {
          unchecked = true;
        }
      });
      var color2 = getMappingValue(colorAttr_1, value2, defaultColor_1);
      var shape = getMappingValue(shapeAttr_1, value2, "point");
      var marker = geometry2.getShapeMarker(shape, {
        color: color2,
        isInPolar: isInPolar_1
      });
      var markerCfg = userMarker;
      if (isFunction(markerCfg)) {
        markerCfg = markerCfg(name, index2, __assign$1({ name, value: value2 }, deepMix({}, themeMarker, marker)));
      }
      marker = deepMix({}, themeMarker, marker, omit(__assign$1({}, markerCfg), ["style"]));
      adpatorMarkerStyle(marker, color2);
      if (markerCfg && markerCfg.style) {
        marker.style = handleUserMarkerStyle(marker.style, markerCfg.style);
      }
      setMarkerSymbol(marker);
      return { id: value2, name, value: value2, marker, unchecked };
    });
  }
  return [];
}
function getCustomLegendItems(themeMarker, userMarker, customItems) {
  return customItems.map(function(item, index2) {
    var markerCfg = userMarker;
    if (isFunction(markerCfg)) {
      markerCfg = markerCfg(item.name, index2, deepMix({}, themeMarker, item));
    }
    var itemMarker = isFunction(item.marker) ? item.marker(item.name, index2, deepMix({}, themeMarker, item)) : item.marker;
    var marker = deepMix({}, themeMarker, markerCfg, itemMarker);
    setMarkerSymbol(marker);
    item.marker = marker;
    return item;
  });
}
function getLegendThemeCfg(theme2, direction2) {
  var legendTheme = get(theme2, ["components", "legend"], {});
  return deepMix({}, get(legendTheme, ["common"], {}), deepMix({}, get(legendTheme, [direction2], {})));
}
function isValueEmpty(value2) {
  if (value2) {
    return false;
  }
  return value2 === null || value2 === void 0 || isNaN(value2);
}
function isYNil(point2) {
  if (isArray$1(point2)) {
    return isValueEmpty(point2[1].y);
  }
  var value2 = point2.y;
  return isArray$1(value2) ? isValueEmpty(value2[0]) : isValueEmpty(value2);
}
function getPathPoints(points2, connectNulls, showSinglePoint) {
  if (connectNulls === void 0) {
    connectNulls = false;
  }
  if (showSinglePoint === void 0) {
    showSinglePoint = true;
  }
  if (!points2.length || points2.length === 1 && !showSinglePoint) {
    return [];
  }
  if (connectNulls) {
    var filtered = [];
    for (var i = 0, len = points2.length; i < len; i++) {
      var point2 = points2[i];
      if (!isYNil(point2)) {
        filtered.push(point2);
      }
    }
    return [filtered];
  }
  var result = [];
  var tmp = [];
  for (var i = 0, len = points2.length; i < len; i++) {
    var point2 = points2[i];
    if (isYNil(point2)) {
      if (tmp.length) {
        if (!(tmp.length === 1 && !showSinglePoint)) {
          result.push(tmp);
        }
        tmp = [];
      }
    } else {
      tmp.push(point2);
    }
  }
  if (tmp.length) {
    result.push(tmp);
  }
  return result;
}
function getViolinPath(points2) {
  var path2 = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    if (point2) {
      var action = i === 0 ? "M" : "L";
      path2.push([action, point2.x, point2.y]);
    }
  }
  var first = points2[0];
  if (first) {
    path2.push(["L", first.x, first.y]);
    path2.push(["z"]);
  }
  return path2;
}
function getSmoothViolinPath(points2) {
  var half = points2.length / 2;
  var leftPoints = [];
  var rightPoints = [];
  for (var i = 0; i < points2.length; i++) {
    if (i < half) {
      leftPoints.push(points2[i]);
    } else {
      rightPoints.push(points2[i]);
    }
  }
  var leftPath = getSplinePath$1(leftPoints, false);
  var rightPath = getSplinePath$1(rightPoints, false);
  if (rightPoints.length) {
    leftPath.push(["L", rightPoints[0].x, rightPoints[0].y]);
  }
  rightPath.shift();
  var path2 = leftPath.concat(rightPath);
  if (leftPoints.length) {
    path2.push(["L", leftPoints[0].x, leftPoints[0].y]);
  }
  path2.push(["z"]);
  return path2;
}
function getStyle(cfg, isStroke, isFill, sizeName) {
  if (sizeName === void 0) {
    sizeName = "";
  }
  var _a2 = cfg.style, style = _a2 === void 0 ? {} : _a2, defaultStyle = cfg.defaultStyle, color2 = cfg.color, size2 = cfg.size;
  var attrs = __assign$1(__assign$1({}, defaultStyle), style);
  if (color2) {
    if (isStroke) {
      if (!style.stroke) {
        attrs.stroke = color2;
      }
    }
    if (isFill) {
      if (!style.fill) {
        attrs.fill = color2;
      }
    }
  }
  if (sizeName && isNil(style[sizeName]) && !isNil(size2)) {
    attrs[sizeName] = size2;
  }
  return attrs;
}
function getBackgroundRectStyle(cfg) {
  return deepMix({}, {
    // copy from active-region
    fill: "#CCD6EC",
    fillOpacity: 0.3
  }, get(cfg, ["background", "style"]));
}
function splitPoints(obj) {
  var x = obj.x;
  var y = isArray$1(obj.y) ? obj.y : [obj.y];
  return y.map(function(eachY, index2) {
    return {
      x: isArray$1(x) ? x[index2] : x,
      y: eachY
    };
  });
}
var LineSymbols = {
  line: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dot: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  dash: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["L", x + r, y]
    ];
  },
  smooth: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r / 2, r / 2, 0, 1, 1, x, y],
      ["A", r / 2, r / 2, 0, 1, 0, x + r, y]
    ];
  },
  hv: function(x, y, r) {
    return [
      ["M", x - r - 1, y - 2.5],
      ["L", x, y - 2.5],
      ["L", x, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vh: function(x, y, r) {
    return [
      ["M", x - r - 1, y + 2.5],
      ["L", x, y + 2.5],
      ["L", x, y - 2.5],
      ["L", x + r + 1, y - 2.5]
    ];
  },
  hvh: function(x, y, r) {
    return [
      ["M", x - (r + 1), y + 2.5],
      ["L", x - r / 2, y + 2.5],
      ["L", x - r / 2, y - 2.5],
      ["L", x + r / 2, y - 2.5],
      ["L", x + r / 2, y + 2.5],
      ["L", x + r + 1, y + 2.5]
    ];
  },
  vhv: function(x, y) {
    return [
      ["M", x - 5, y + 2.5],
      ["L", x - 5, y],
      ["L", x, y],
      ["L", x, y - 3],
      ["L", x, y + 3],
      ["L", x + 6.5, y + 3]
    ];
  }
};
function getLineMarker(markerCfg, shapeType) {
  var color2 = markerCfg.color;
  return {
    symbol: LineSymbols[shapeType],
    style: {
      lineWidth: 2,
      r: 6,
      stroke: color2
    }
  };
}
function getShapeAttrs$1(cfg, smooth, constraint) {
  var isStack = cfg.isStack, connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, showSinglePoint = cfg.showSinglePoint;
  var shapeAttrs = getStyle(cfg, true, false, "lineWidth");
  var points2 = getPathPoints(cfg.points, connectNulls, showSinglePoint);
  var path2 = [];
  for (var i = 0, len = points2.length; i < len; i++) {
    var eachLinePoints = points2[i];
    path2 = path2.concat(getPath$3(eachLinePoints, isInCircle, isStack, smooth, constraint, shapeAttrs));
  }
  shapeAttrs.path = path2;
  return shapeAttrs;
}
function getSinglePath(points2, isInCircle, smooth, constraint, style) {
  if (points2.length === 1) {
    return [
      ["M", points2[0].x, points2[0].y - style.lineWidth / 2],
      ["L", points2[0].x, points2[0].y],
      ["L", points2[0].x, points2[0].y + style.lineWidth / 2]
    ];
  }
  var path2;
  if (!smooth) {
    path2 = getLinePath(points2, false);
    if (isInCircle) {
      path2.push(["Z"]);
    }
  } else {
    if (isInCircle && points2.length) {
      points2.push({ x: points2[0].x, y: points2[0].y });
    }
    path2 = getSplinePath$1(points2, false, constraint);
  }
  return path2;
}
function getRangePath(points2, isInCircle, isStack, smooth, constraint, style) {
  var topPoints = [];
  var bottomPoints = [];
  each$1(points2, function(point2) {
    var result = splitPoints(point2);
    topPoints.push(result[1]);
    bottomPoints.push(result[0]);
  });
  var topPath = getSinglePath(topPoints, isInCircle, smooth, constraint, style);
  var bottomPath = getSinglePath(bottomPoints, isInCircle, smooth, constraint, style);
  if (isStack) {
    return topPath;
  }
  return topPath.concat(bottomPath);
}
function getPath$3(points2, isInCircle, isStack, smooth, constraint, style) {
  if (points2.length) {
    var first = points2[0];
    return isArray$1(first.y) ? getRangePath(points2, isInCircle, isStack, smooth, constraint, style) : getSinglePath(points2, isInCircle, smooth, constraint, style);
  }
  return [];
}
registerShapeFactory("line", {
  defaultShapeType: "line"
});
each$1(["line", "dot", "dash", "smooth"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var smooth = shapeType === "smooth";
      var constraint;
      if (smooth) {
        var _a2 = this.coordinate, start = _a2.start, end = _a2.end;
        constraint = [
          [start.x, end.y],
          [end.x, start.y]
        ];
      }
      var attrs = getShapeAttrs$1(cfg, smooth, constraint);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line",
        capture: !smooth
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});
var Util = {
  getLegendItems,
  translate,
  rotate,
  zoom,
  transform: transform$4,
  getAngle: getAngle$1,
  getSectorPath,
  polarToCartesian,
  getDelegationObject,
  getTooltipItems,
  getMappingValue,
  // shape 
  getPath: getPath$3,
  getPathPoints
};
var WHITE_COLORS = {
  100: "#000",
  95: "#0D0D0D",
  85: "#262626",
  65: "#595959",
  45: "#8C8C8C",
  25: "#BFBFBF",
  15: "#D9D9D9",
  6: "#F0F0F0"
};
var BLACK_COLORS = {
  100: "#FFFFFF",
  95: "#F2F2F2",
  85: "#D9D9D9",
  65: "#A6A6A6",
  45: "#737373",
  25: "#404040",
  15: "#262626",
  6: "#0F0F0F"
};
var QUALITATIVE_10 = [
  "#5B8FF9",
  "#5AD8A6",
  "#5D7092",
  "#F6BD16",
  "#E86452",
  "#6DC8EC",
  "#945FB9",
  "#FF9845",
  "#1E9493",
  "#FF99C3"
];
var QUALITATIVE_20 = [
  "#5B8FF9",
  "#CDDDFD",
  "#5AD8A6",
  "#CDF3E4",
  "#5D7092",
  "#CED4DE",
  "#F6BD16",
  "#FCEBB9",
  "#E86452",
  "#F8D0CB",
  "#6DC8EC",
  "#D3EEF9",
  "#945FB9",
  "#DECFEA",
  "#FF9845",
  "#FFE0C7",
  "#1E9493",
  "#BBDEDE",
  "#FF99C3",
  "#FFE0ED"
];
var SINGLE_SEQUENCE = [
  "#B8E1FF",
  "#9AC5FF",
  "#7DAAFF",
  "#5B8FF9",
  "#3D76DD",
  "#085EC0",
  "#0047A5",
  "#00318A",
  "#001D70"
];
var createDarkStyleSheet = function(cfg) {
  if (cfg === void 0) {
    cfg = {};
  }
  var _a2 = cfg.paletteQualitative10, paletteQualitative10 = _a2 === void 0 ? QUALITATIVE_10 : _a2, _b = cfg.paletteQualitative20, paletteQualitative20 = _b === void 0 ? QUALITATIVE_20 : _b;
  var _c = cfg.brandColor, brandColor = _c === void 0 ? paletteQualitative10[0] : _c;
  var token2 = {
    /**  */
    backgroundColor: "#141414",
    /**  */
    brandColor,
    /**  */
    subColor: "rgba(255,255,255,0.05)",
    /**  1 10  */
    paletteQualitative10,
    /**  2 10  */
    paletteQualitative20,
    /**  */
    paletteSemanticRed: "#F4664A",
    /**  */
    paletteSemanticGreen: "#30BF78",
    /**  */
    paletteSemanticYellow: "#FAAD14",
    /** () */
    paletteSequence: SINGLE_SEQUENCE,
    /**  */
    fontFamily: '"Segoe UI", Roboto, "Helvetica Neue", Arial,\n    "Noto Sans", sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol",\n    "Noto Color Emoji"',
    // --------------------  --------------------
    /**  */
    axisLineBorderColor: BLACK_COLORS[25],
    /**  */
    axisLineBorder: 1,
    /**  lineDash  */
    axisLineDash: null,
    /**  */
    axisTitleTextFillColor: BLACK_COLORS[65],
    /**  */
    axisTitleTextFontSize: 12,
    /**  */
    axisTitleTextLineHeight: 12,
    /**  */
    axisTitleTextFontWeight: "normal",
    /**  */
    axisTitleSpacing: 12,
    /** icon */
    axisDescriptionIconFillColor: WHITE_COLORS[85],
    /**  */
    axisTickLineBorderColor: BLACK_COLORS[25],
    /**  */
    axisTickLineLength: 4,
    /**  */
    axisTickLineBorder: 1,
    /**  */
    axisSubTickLineBorderColor: BLACK_COLORS[15],
    /**  */
    axisSubTickLineLength: 2,
    /**  */
    axisSubTickLineBorder: 1,
    /**  */
    axisLabelFillColor: BLACK_COLORS[45],
    /**  */
    axisLabelFontSize: 12,
    /**  */
    axisLabelLineHeight: 12,
    /**  */
    axisLabelFontWeight: "normal",
    /**  */
    axisLabelOffset: 8,
    /**  */
    axisGridBorderColor: BLACK_COLORS[15],
    /**  */
    axisGridBorder: 1,
    /**  */
    axisGridLineDash: null,
    // --------------------  --------------------
    /**  */
    legendTitleTextFillColor: BLACK_COLORS[45],
    /**  */
    legendTitleTextFontSize: 12,
    /**  */
    legendTitleTextLineHeight: 21,
    /**  */
    legendTitleTextFontWeight: "normal",
    /**  marker  */
    legendMarkerColor: QUALITATIVE_10[0],
    /**  marker  */
    legendMarkerSpacing: 8,
    /**  marker  */
    legendMarkerSize: 4,
    /**  'circle' marker  */
    legendCircleMarkerSize: 4,
    /**  'square' marker  */
    legendSquareMarkerSize: 4,
    /**  'line' marker  */
    legendLineMarkerSize: 5,
    /**  */
    legendItemNameFillColor: BLACK_COLORS[65],
    /**  */
    legendItemNameFontSize: 12,
    /**  */
    legendItemNameLineHeight: 12,
    /**  */
    legendItemNameFontWeight: "normal",
    /**  */
    legendItemSpacing: 24,
    /**  */
    legendItemMarginBottom: 12,
    /**   */
    legendSpacing: 16,
    /**   */
    legendPadding: [8, 8, 8, 8],
    /**  */
    legendHorizontalPadding: [8, 0, 8, 0],
    /**  */
    legendVerticalPadding: [0, 8, 0, 8],
    // 
    /**  marker  */
    legendPageNavigatorMarkerSize: 12,
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillColor: BLACK_COLORS[45],
    /**  marker  */
    legendPageNavigatorMarkerInactiveFillOpacity: 0.45,
    /**  marker  */
    legendPageNavigatorMarkerFillColor: BLACK_COLORS[45],
    /**  marker  */
    legendPageNavigatorMarkerFillOpacity: 1,
    /**  */
    legendPageNavigatorTextFillColor: BLACK_COLORS[65],
    /**  */
    legendPageNavigatorTextFontSize: 12,
    /**  */
    sliderRailFillColor: BLACK_COLORS[15],
    /**  */
    sliderRailBorder: 0,
    /**  */
    sliderRailBorderColor: null,
    /**  */
    sliderRailWidth: 100,
    /**  */
    sliderRailHeight: 12,
    /**  */
    sliderLabelTextFillColor: BLACK_COLORS[45],
    /**  */
    sliderLabelTextFontSize: 12,
    /**  */
    sliderLabelTextLineHeight: 12,
    /**  */
    sliderLabelTextFontWeight: "normal",
    /**  */
    sliderHandlerFillColor: WHITE_COLORS[6],
    /**  */
    sliderHandlerWidth: 10,
    /**  */
    sliderHandlerHeight: 14,
    /**  */
    sliderHandlerBorder: 1,
    /**  */
    sliderHandlerBorderColor: WHITE_COLORS[25],
    // -------------------- Annotation --------------------
    /** arc  */
    annotationArcBorderColor: BLACK_COLORS[15],
    /** arc  */
    annotationArcBorder: 1,
    /** line  */
    annotationLineBorderColor: BLACK_COLORS[25],
    /** line  */
    annotationLineBorder: 1,
    /** lube  */
    annotationLineDash: null,
    /** text  */
    annotationTextFillColor: BLACK_COLORS[65],
    /** text  */
    annotationTextFontSize: 12,
    /** text  */
    annotationTextLineHeight: 12,
    /** text  */
    annotationTextFontWeight: "normal",
    /** text  */
    annotationTextBorderColor: null,
    /** text  */
    annotationTextBorder: 0,
    /** region  */
    annotationRegionFillColor: BLACK_COLORS[100],
    /** region  */
    annotationRegionFillOpacity: 0.06,
    /** region  */
    annotationRegionBorder: 0,
    /** region  */
    annotationRegionBorderColor: null,
    /** dataMarker  */
    annotationDataMarkerLineLength: 16,
    // -------------------- Tooltip --------------------
    /** tooltip crosshairs  */
    tooltipCrosshairsBorderColor: BLACK_COLORS[25],
    /** tooltip crosshairs  */
    tooltipCrosshairsBorder: 1,
    /** tooltip crosshairs  */
    tooltipCrosshairsLineDash: null,
    /** tooltip  */
    tooltipContainerFillColor: "#1f1f1f",
    tooltipContainerFillOpacity: 0.95,
    /** tooltip  */
    tooltipContainerShadow: "0px 2px 4px rgba(0,0,0,.5)",
    /** tooltip  */
    tooltipContainerBorderRadius: 3,
    /** tooltip  */
    tooltipTextFillColor: BLACK_COLORS[65],
    /** tooltip  */
    tooltipTextFontSize: 12,
    /** tooltip  */
    tooltipTextLineHeight: 12,
    /** tooltip  */
    tooltipTextFontWeight: "bold",
    // -------------------- Geometry labels --------------------
    /** Geometry label  */
    labelFillColor: BLACK_COLORS[65],
    labelFillColorDark: "#2c3542",
    labelFillColorLight: "#ffffff",
    /** Geometry label  */
    labelFontSize: 12,
    /** Geometry label  */
    labelLineHeight: 12,
    /** Geometry label  */
    labelFontWeight: "normal",
    /** Geometry label  */
    labelBorderColor: null,
    /** Geometry label  */
    labelBorder: 0,
    /** Geometry innerLabel  */
    innerLabelFillColor: WHITE_COLORS[100],
    /** Geometry innerLabel  */
    innerLabelFontSize: 12,
    /** Geometry innerLabel  */
    innerLabelLineHeight: 12,
    /** Geometry innerLabel  */
    innerLabelFontWeight: "normal",
    /** Geometry innerLabel  */
    innerLabelBorderColor: null,
    /** Geometry innerLabel  */
    innerLabelBorder: 0,
    /** Geometry label  */
    overflowLabelFillColor: BLACK_COLORS[65],
    overflowLabelFillColorDark: "#2c3542",
    overflowLabelFillColorLight: "#ffffff",
    /** Geometry label  */
    overflowLabelFontSize: 12,
    /** Geometry label  */
    overflowLabelLineHeight: 12,
    /** Geometry label  */
    overflowLabelFontWeight: "normal",
    /** Geometry label  */
    overflowLabelBorderColor: WHITE_COLORS[100],
    /** Geometry label  */
    overflowLabelBorder: 1,
    /** Geometry label  */
    labelLineBorder: 1,
    /** Geometry label  */
    labelLineBorderColor: BLACK_COLORS[25],
    // -------------------- Slider --------------------
    /** slider  */
    cSliderRailHieght: 16,
    /** slider  */
    cSliderBackgroundFillColor: "#416180",
    /** slider  */
    cSliderBackgroundFillOpacity: 0.05,
    /** slider  */
    cSliderForegroundFillColor: "#5B8FF9",
    /** slider  */
    cSliderForegroundFillOpacity: 0.15,
    // slider handlerStyle 
    /** slider  */
    cSliderHandlerHeight: 24,
    /** Slider  */
    cSliderHandlerWidth: 10,
    /** Slider  */
    cSliderHandlerFillColor: "#F7F7F7",
    /** Slider  */
    cSliderHandlerFillOpacity: 1,
    /** Slider  */
    cSliderHandlerHighlightFillColor: "#FFF",
    /** Slider  */
    cSliderHandlerBorderColor: "#BFBFBF",
    /** Slider  */
    cSliderHandlerBorder: 1,
    /** Slider  */
    cSliderHandlerBorderRadius: 2,
    // slider textStyle 
    /** Slider  */
    cSliderTextFillColor: "#fff",
    /** Slider  */
    cSliderTextFillOpacity: 0.45,
    /** Slider  */
    cSliderTextFontSize: 12,
    /** Slider  */
    cSliderTextLineHeight: 12,
    /** Slider  */
    cSliderTextFontWeight: "normal",
    /** Slider  */
    cSliderTextBorderColor: null,
    /** Slider  */
    cSliderTextBorder: 0,
    // -------------------- Scrollbar --------------------
    /**   */
    scrollbarTrackFillColor: "rgba(255,255,255,0.65)",
    /**   */
    scrollbarThumbFillColor: "rgba(0,0,0,0.35)",
    /**   */
    scrollbarThumbHighlightFillColor: "rgba(0,0,0,0.45)",
    // -------------------- Geometry --------------------
    /**  */
    pointFillColor: QUALITATIVE_10[0],
    /**  */
    pointFillOpacity: 0.95,
    /**  */
    pointSize: 4,
    /**  */
    pointBorder: 1,
    /**  */
    pointBorderColor: WHITE_COLORS[100],
    /**  */
    pointBorderOpacity: 1,
    /**  active  */
    pointActiveBorderColor: BLACK_COLORS[100],
    /**  selected  */
    pointSelectedBorder: 2,
    /**  selected  */
    pointSelectedBorderColor: BLACK_COLORS[100],
    /**  inactive  */
    pointInactiveFillOpacity: 0.3,
    /**  inactive  */
    pointInactiveBorderOpacity: 0.3,
    /**  */
    hollowPointSize: 4,
    /**  */
    hollowPointBorder: 1,
    /**  */
    hollowPointBorderColor: QUALITATIVE_10[0],
    /**  */
    hollowPointBorderOpacity: 0.95,
    hollowPointFillColor: WHITE_COLORS[100],
    /**  active  */
    hollowPointActiveBorder: 1,
    /**  active  */
    hollowPointActiveBorderColor: BLACK_COLORS[100],
    /**  active  */
    hollowPointActiveBorderOpacity: 1,
    /**  selected  */
    hollowPointSelectedBorder: 2,
    /**  selected  */
    hollowPointSelectedBorderColor: BLACK_COLORS[100],
    /**  selected  */
    hollowPointSelectedBorderOpacity: 1,
    /**  inactive  */
    hollowPointInactiveBorderOpacity: 0.3,
    /**  */
    lineBorder: 2,
    /**  */
    lineBorderColor: QUALITATIVE_10[0],
    /**  */
    lineBorderOpacity: 1,
    /**  Active  */
    lineActiveBorder: 3,
    /**  selected  */
    lineSelectedBorder: 3,
    /**  inactive  */
    lineInactiveBorderOpacity: 0.3,
    /** area  */
    areaFillColor: QUALITATIVE_10[0],
    /** area  */
    areaFillOpacity: 0.25,
    /** area  active  */
    areaActiveFillColor: QUALITATIVE_10[0],
    areaActiveFillOpacity: 0.5,
    /** area  selected  */
    areaSelectedFillColor: QUALITATIVE_10[0],
    areaSelectedFillOpacity: 0.5,
    /** area inactive  */
    areaInactiveFillOpacity: 0.3,
    /** hollowArea  */
    hollowAreaBorderColor: QUALITATIVE_10[0],
    /** hollowArea  */
    hollowAreaBorder: 2,
    /** hollowArea  */
    hollowAreaBorderOpacity: 1,
    /** hollowArea active  */
    hollowAreaActiveBorder: 3,
    hollowAreaActiveBorderColor: BLACK_COLORS[100],
    /** hollowArea selected  */
    hollowAreaSelectedBorder: 3,
    hollowAreaSelectedBorderColor: BLACK_COLORS[100],
    /** hollowArea inactive  */
    hollowAreaInactiveBorderOpacity: 0.3,
    /** interval  */
    intervalFillColor: QUALITATIVE_10[0],
    /** interval  */
    intervalFillOpacity: 0.95,
    /** interval active  */
    intervalActiveBorder: 1,
    /** interval active  */
    intervalActiveBorderColor: BLACK_COLORS[100],
    intervalActiveBorderOpacity: 1,
    /** interval selected  */
    intervalSelectedBorder: 2,
    /** interval selected  */
    intervalSelectedBorderColor: BLACK_COLORS[100],
    /** interval selected  */
    intervalSelectedBorderOpacity: 1,
    /** interval inactive  */
    intervalInactiveBorderOpacity: 0.3,
    /** interval inactive  */
    intervalInactiveFillOpacity: 0.3,
    /** interval  */
    hollowIntervalBorder: 2,
    /** hollowInterval  */
    hollowIntervalBorderColor: QUALITATIVE_10[0],
    /** hollowInterval  */
    hollowIntervalBorderOpacity: 1,
    hollowIntervalFillColor: WHITE_COLORS[100],
    /** hollowInterval active  */
    hollowIntervalActiveBorder: 2,
    /** hollowInterval active  */
    hollowIntervalActiveBorderColor: BLACK_COLORS[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorder: 3,
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderColor: BLACK_COLORS[100],
    /** hollowInterval selected  */
    hollowIntervalSelectedBorderOpacity: 1,
    /** hollowInterval inactive  */
    hollowIntervalInactiveBorderOpacity: 0.3
  };
  return __assign$1(__assign$1({}, token2), cfg);
};
var antvDark = createDarkStyleSheet();
function getPixelRatio$1() {
  return window ? window.devicePixelRatio : 1;
}
function distance$1(x1, y1, x2, y2) {
  var dx = x1 - x2;
  var dy = y1 - y2;
  return Math.sqrt(dx * dx + dy * dy);
}
function inBox(minX, minY, width, height, x, y) {
  return x >= minX && x <= minX + width && y >= minY && y <= minY + height;
}
function intersectRect(box1, box2) {
  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);
}
function mergeRegion(region1, region2) {
  if (!region1 || !region2) {
    return region1 || region2;
  }
  return {
    minX: Math.min(region1.minX, region2.minX),
    minY: Math.min(region1.minY, region2.minY),
    maxX: Math.max(region1.maxX, region2.maxX),
    maxY: Math.max(region1.maxY, region2.maxY)
  };
}
function isSamePoint(point1, point2) {
  return point1[0] === point2[0] && point1[1] === point2[1];
}
var regexLG$1 = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG$1 = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexPR$1 = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var regexColorStop$1 = /[\d.]+:(#[^\s]+|[^\)]+\))/gi;
function addStop$1(steps, gradient2) {
  var arr = steps.match(regexColorStop$1);
  each$1(arr, function(item) {
    var itemArr = item.split(":");
    gradient2.addColorStop(itemArr[0], itemArr[1]);
  });
}
function parseLineGradient$1(context, element, gradientStr) {
  var arr = regexLG$1.exec(gradientStr);
  var angle2 = parseFloat(arr[1]) % 360 * (Math.PI / 180);
  var steps = arr[2];
  var box2 = element.getBBox();
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 1 / 2 * Math.PI) {
    start = {
      x: box2.minX,
      y: box2.minY
    };
    end = {
      x: box2.maxX,
      y: box2.maxY
    };
  } else if (1 / 2 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.minY
    };
    end = {
      x: box2.minX,
      y: box2.maxY
    };
  } else if (Math.PI <= angle2 && angle2 < 3 / 2 * Math.PI) {
    start = {
      x: box2.maxX,
      y: box2.maxY
    };
    end = {
      x: box2.minX,
      y: box2.minY
    };
  } else {
    start = {
      x: box2.minX,
      y: box2.maxY
    };
    end = {
      x: box2.maxX,
      y: box2.minY
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  var gradient2 = context.createLinearGradient(start.x, start.y, x, y);
  addStop$1(steps, gradient2);
  return gradient2;
}
function parseRadialGradient$1(context, element, gradientStr) {
  var arr = regexRG$1.exec(gradientStr);
  var fx = parseFloat(arr[1]);
  var fy = parseFloat(arr[2]);
  var fr = parseFloat(arr[3]);
  var steps = arr[4];
  if (fr === 0) {
    var colors = steps.match(regexColorStop$1);
    return colors[colors.length - 1].split(":")[1];
  }
  var box2 = element.getBBox();
  var width = box2.maxX - box2.minX;
  var height = box2.maxY - box2.minY;
  var r = Math.sqrt(width * width + height * height) / 2;
  var gradient2 = context.createRadialGradient(box2.minX + width * fx, box2.minY + height * fy, 0, box2.minX + width / 2, box2.minY + height / 2, fr * r);
  addStop$1(steps, gradient2);
  return gradient2;
}
function parsePattern(context, element, patternStr) {
  if (element.get("patternSource") && element.get("patternSource") === patternStr) {
    return element.get("pattern");
  }
  var pattern2;
  var img;
  var arr = regexPR$1.exec(patternStr);
  var repeat = arr[1];
  var source = arr[2];
  function onload() {
    pattern2 = context.createPattern(img, repeat);
    element.set("pattern", pattern2);
    element.set("patternSource", patternStr);
  }
  switch (repeat) {
    case "a":
      repeat = "repeat";
      break;
    case "x":
      repeat = "repeat-x";
      break;
    case "y":
      repeat = "repeat-y";
      break;
    case "n":
      repeat = "no-repeat";
      break;
    default:
      repeat = "no-repeat";
  }
  img = new Image();
  if (!source.match(/^data:/i)) {
    img.crossOrigin = "Anonymous";
  }
  img.src = source;
  if (img.complete) {
    onload();
  } else {
    img.onload = onload;
    img.src = img.src;
  }
  return pattern2;
}
function parseStyle(context, element, color2) {
  var bbox = element.getBBox();
  if (isNaN(bbox.x) || isNaN(bbox.y) || isNaN(bbox.width) || isNaN(bbox.height)) {
    return color2;
  }
  if (isString(color2)) {
    if (color2[1] === "(" || color2[2] === "(") {
      if (color2[0] === "l") {
        return parseLineGradient$1(context, element, color2);
      }
      if (color2[0] === "r") {
        return parseRadialGradient$1(context, element, color2);
      }
      if (color2[0] === "p") {
        return parsePattern(context, element, color2);
      }
    }
    return color2;
  }
  if (color2 instanceof CanvasPattern) {
    return color2;
  }
}
function parseRadius$2(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return [r1, r2, r3, r4];
}
function vMag(v) {
  return Math.sqrt(v[0] * v[0] + v[1] * v[1]);
}
function vRatio(u, v) {
  return vMag(u) * vMag(v) ? (u[0] * v[0] + u[1] * v[1]) / (vMag(u) * vMag(v)) : 1;
}
function vAngle(u, v) {
  return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(vRatio(u, v));
}
function getArcParams(startPoint, params) {
  var rx = params[1];
  var ry = params[2];
  var xRotation = mod$1(toRadian(params[3]), Math.PI * 2);
  var arcFlag = params[4];
  var sweepFlag = params[5];
  var x1 = startPoint[0];
  var y1 = startPoint[1];
  var x2 = params[6];
  var y2 = params[7];
  var xp = Math.cos(xRotation) * (x1 - x2) / 2 + Math.sin(xRotation) * (y1 - y2) / 2;
  var yp = -1 * Math.sin(xRotation) * (x1 - x2) / 2 + Math.cos(xRotation) * (y1 - y2) / 2;
  var lambda = xp * xp / (rx * rx) + yp * yp / (ry * ry);
  if (lambda > 1) {
    rx *= Math.sqrt(lambda);
    ry *= Math.sqrt(lambda);
  }
  var diff2 = rx * rx * (yp * yp) + ry * ry * (xp * xp);
  var f = diff2 ? Math.sqrt((rx * rx * (ry * ry) - diff2) / diff2) : 1;
  if (arcFlag === sweepFlag) {
    f *= -1;
  }
  if (isNaN(f)) {
    f = 0;
  }
  var cxp = ry ? f * rx * yp / ry : 0;
  var cyp = rx ? f * -ry * xp / rx : 0;
  var cx = (x1 + x2) / 2 + Math.cos(xRotation) * cxp - Math.sin(xRotation) * cyp;
  var cy = (y1 + y2) / 2 + Math.sin(xRotation) * cxp + Math.cos(xRotation) * cyp;
  var u = [(xp - cxp) / rx, (yp - cyp) / ry];
  var v = [(-1 * xp - cxp) / rx, (-1 * yp - cyp) / ry];
  var theta = vAngle([1, 0], u);
  var dTheta = vAngle(u, v);
  if (vRatio(u, v) <= -1) {
    dTheta = Math.PI;
  }
  if (vRatio(u, v) >= 1) {
    dTheta = 0;
  }
  if (sweepFlag === 0 && dTheta > 0) {
    dTheta = dTheta - 2 * Math.PI;
  }
  if (sweepFlag === 1 && dTheta < 0) {
    dTheta = dTheta + 2 * Math.PI;
  }
  return {
    cx,
    cy,
    //  0 
    rx: isSamePoint(startPoint, [x2, y2]) ? 0 : rx,
    ry: isSamePoint(startPoint, [x2, y2]) ? 0 : ry,
    startAngle: theta,
    endAngle: theta + dTheta,
    xRotation,
    arcFlag,
    sweepFlag
  };
}
var sin = Math.sin, cos = Math.cos, atan2 = Math.atan2, PI = Math.PI;
function _addDefaultArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  var arrowShape = new Path$2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: {
      //  10 60 
      path: "M" + 10 * cos(PI / 6) + "," + 10 * sin(PI / 6) + " L0,0 L" + 10 * cos(PI / 6) + ",-" + 10 * sin(PI / 6),
      //  shape stroke 
      stroke,
      lineWidth
    }
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, isStart) {
  var startArrow = attrs.startArrow, endArrow = attrs.endArrow, stroke = attrs.stroke, lineWidth = attrs.lineWidth;
  var arrowAttrs = isStart ? startArrow : endArrow;
  var d = arrowAttrs.d, arrowFill = arrowAttrs.fill, arrowStroke = arrowAttrs.stroke, arrowLineWidth = arrowAttrs.lineWidth, restAttrs = __rest(arrowAttrs, ["d", "fill", "stroke", "lineWidth"]);
  var x = x1 - x2;
  var y = y1 - y2;
  var rad = atan2(y, x);
  if (d) {
    x2 = x2 - cos(rad) * d;
    y2 = y2 - sin(rad) * d;
  }
  var arrowShape = new Path$2({
    type: "path",
    canvas: shape.get("canvas"),
    isArrowShape: true,
    attrs: __assign$1(__assign$1({}, restAttrs), {
      //  stroke  lineWidth shape 
      stroke: arrowStroke || stroke,
      lineWidth: arrowLineWidth || lineWidth,
      //  shape 
      fill: arrowFill
    })
  });
  arrowShape.translate(x2, y2);
  arrowShape.rotateAtPoint(x2, y2, rad);
  shape.set(isStart ? "startArrowShape" : "endArrowShape", arrowShape);
}
function getShortenOffset(x1, y1, x2, y2, d) {
  var rad = atan2(y2 - y1, x2 - x1);
  return {
    dx: cos(rad) * d,
    dy: sin(rad) * d
  };
}
function addStartArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.startArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, true);
  } else if (attrs.startArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, true);
  } else {
    shape.set("startArrowShape", null);
  }
}
function addEndArrow(shape, attrs, x1, y1, x2, y2) {
  if (typeof attrs.endArrow === "object") {
    _addCustomizedArrow(shape, attrs, x1, y1, x2, y2, false);
  } else if (attrs.endArrow) {
    _addDefaultArrow(shape, attrs, x1, y1, x2, y2, false);
  } else {
    shape.set("startArrowShape", null);
  }
}
var SHAPE_ATTRS_MAP = {
  fill: "fillStyle",
  stroke: "strokeStyle",
  opacity: "globalAlpha"
};
function applyAttrsToContext(context, element) {
  var attrs = element.attr();
  for (var k in attrs) {
    var v = attrs[k];
    var name_1 = SHAPE_ATTRS_MAP[k] ? SHAPE_ATTRS_MAP[k] : k;
    if (name_1 === "matrix" && v) {
      context.transform(v[0], v[1], v[3], v[4], v[6], v[7]);
    } else if (name_1 === "lineDash" && context.setLineDash) {
      isArray$1(v) && context.setLineDash(v);
    } else {
      if (name_1 === "strokeStyle" || name_1 === "fillStyle") {
        v = parseStyle(context, element, v);
      } else if (name_1 === "globalAlpha") {
        v = v * context.globalAlpha;
      }
      context[name_1] = v;
    }
  }
}
function drawChildren$1(context, children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      child.draw(context, region);
    } else {
      child.skipDraw();
    }
  }
}
function checkRefresh(canvas, children, region) {
  var refreshElements = canvas.get("refreshElements");
  each$1(refreshElements, function(el) {
    if (el !== canvas) {
      var parent_1 = el.cfg.parent;
      while (parent_1 && parent_1 !== canvas && !parent_1.cfg.refresh) {
        parent_1.cfg.refresh = true;
        parent_1 = parent_1.cfg.parent;
      }
    }
  });
  if (refreshElements[0] === canvas) {
    setChildrenRefresh(children);
  } else {
    checkChildrenRefresh(children, region);
  }
}
function checkChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    if (child.cfg.visible) {
      if (child.cfg.hasChanged) {
        child.cfg.refresh = true;
        if (child.isGroup()) {
          setChildrenRefresh(child.cfg.children);
        }
      } else if (child.cfg.refresh) {
        if (child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      } else {
        var refresh = checkElementRefresh(child, region);
        child.cfg.refresh = refresh;
        if (refresh && child.isGroup()) {
          checkChildrenRefresh(child.cfg.children, region);
        }
      }
    }
  }
}
function clearChanged(elements) {
  for (var i = 0; i < elements.length; i++) {
    var el = elements[i];
    el.cfg.hasChanged = false;
    if (el.isGroup() && !el.destroyed) {
      clearChanged(el.cfg.children);
    }
  }
}
function setChildrenRefresh(children, region) {
  for (var i = 0; i < children.length; i++) {
    var child = children[i];
    child.cfg.refresh = true;
    if (child.isGroup()) {
      setChildrenRefresh(child.get("children"));
    }
  }
}
function checkElementRefresh(shape, region) {
  var bbox = shape.cfg.cacheCanvasBBox;
  var isAllow = shape.cfg.isInView && bbox && intersectRect(bbox, region);
  return isAllow;
}
function drawPath(shape, context, attrs, arcParamsCache) {
  var path2 = attrs.path, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
  if (!path2) {
    return;
  }
  var currentPoint = [0, 0];
  var startMovePoint = [0, 0];
  var distance2 = {
    dx: 0,
    dy: 0
  };
  context.beginPath();
  for (var i = 0; i < path2.length; i++) {
    var params = path2[i];
    var command = params[0];
    if (i === 0 && startArrow && startArrow.d) {
      var tangent = shape.getStartTangent();
      distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], startArrow.d);
    } else if (i === path2.length - 2 && path2[i + 1][0] === "Z" && endArrow && endArrow.d) {
      var lastPath = path2[i + 1];
      if (lastPath[0] === "Z") {
        var tangent = shape.getEndTangent();
        distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    } else if (i === path2.length - 1 && endArrow && endArrow.d) {
      if (path2[0] !== "Z") {
        var tangent = shape.getEndTangent();
        distance2 = getShortenOffset(tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1], endArrow.d);
      }
    }
    var dx = distance2.dx, dy = distance2.dy;
    switch (command) {
      case "M":
        context.moveTo(params[1] - dx, params[2] - dy);
        startMovePoint = [params[1], params[2]];
        break;
      case "L":
        context.lineTo(params[1] - dx, params[2] - dy);
        break;
      case "Q":
        context.quadraticCurveTo(params[1], params[2], params[3] - dx, params[4] - dy);
        break;
      case "C":
        context.bezierCurveTo(params[1], params[2], params[3], params[4], params[5] - dx, params[6] - dy);
        break;
      case "A": {
        var arcParams = void 0;
        if (arcParamsCache) {
          arcParams = arcParamsCache[i];
          if (!arcParams) {
            arcParams = getArcParams(currentPoint, params);
            arcParamsCache[i] = arcParams;
          }
        } else {
          arcParams = getArcParams(currentPoint, params);
        }
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation, sweepFlag = arcParams.sweepFlag;
        if (context.ellipse) {
          context.ellipse(cx, cy, rx, ry, xRotation, startAngle, endAngle, 1 - sweepFlag);
        } else {
          var r = rx > ry ? rx : ry;
          var scaleX = rx > ry ? 1 : rx / ry;
          var scaleY = rx > ry ? ry / rx : 1;
          context.translate(cx, cy);
          context.rotate(xRotation);
          context.scale(scaleX, scaleY);
          context.arc(0, 0, r, startAngle, endAngle, 1 - sweepFlag);
          context.scale(1 / scaleX, 1 / scaleY);
          context.rotate(-xRotation);
          context.translate(-cx, -cy);
        }
        break;
      }
      case "Z":
        context.closePath();
        break;
    }
    if (command === "Z") {
      currentPoint = startMovePoint;
    } else {
      var len = params.length;
      currentPoint = [params[len - 2], params[len - 1]];
    }
  }
}
function refreshElement$1(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas) {
    if (changeType === "remove") {
      element._cacheCanvasBBox = element.get("cacheCanvasBBox");
    }
    if (!element.get("hasChanged")) {
      element.set("hasChanged", true);
      if (!(element.cfg.parent && element.cfg.parent.get("hasChanged"))) {
        canvas.refreshElement(element, changeType, canvas);
        if (canvas.get("autoDraw")) {
          canvas.draw();
        }
      }
    }
  }
}
function getRefreshRegion(element) {
  var region;
  if (!element.destroyed) {
    var cacheBox = element.get("cacheCanvasBBox");
    var validCache = cacheBox && !!(cacheBox.width && cacheBox.height);
    var bbox = element.getCanvasBBox();
    var validBBox = bbox && !!(bbox.width && bbox.height);
    if (validCache && validBBox) {
      region = mergeRegion(cacheBox, bbox);
    } else if (validCache) {
      region = cacheBox;
    } else if (validBBox) {
      region = bbox;
    }
  } else {
    region = element["_cacheCanvasBBox"];
  }
  return region;
}
function getMergedRegion(elements) {
  if (!elements.length) {
    return null;
  }
  var minXArr = [];
  var minYArr = [];
  var maxXArr = [];
  var maxYArr = [];
  each$1(elements, function(el) {
    var region = getRefreshRegion(el);
    if (region) {
      minXArr.push(region.minX);
      minYArr.push(region.minY);
      maxXArr.push(region.maxX);
      maxYArr.push(region.maxY);
    }
  });
  return {
    minX: min$2(minXArr),
    minY: min$2(minYArr),
    maxX: max$2(maxXArr),
    maxY: max$2(maxYArr)
  };
}
function mergeView(region, viewRegion) {
  if (!region || !viewRegion) {
    return null;
  }
  if (!intersectRect(region, viewRegion)) {
    return null;
  }
  return {
    minX: Math.max(region.minX, viewRegion.minX),
    minY: Math.max(region.minY, viewRegion.minY),
    maxX: Math.min(region.maxX, viewRegion.maxX),
    maxY: Math.min(region.maxY, viewRegion.maxY)
  };
}
var Group$1 = (
  /** @class */
  function(_super) {
    __extends$1(Group2, _super);
    function Group2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group2.prototype.onCanvasChange = function(changeType) {
      refreshElement$1(this, changeType);
    };
    Group2.prototype.getShapeBase = function() {
      return Shape$1;
    };
    Group2.prototype.getGroupBase = function() {
      return Group2;
    };
    Group2.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    Group2.prototype.cacheCanvasBBox = function() {
      var children = this.cfg.children;
      var xArr = [];
      var yArr = [];
      each$1(children, function(child) {
        var bbox2 = child.cfg.cacheCanvasBBox;
        if (bbox2 && child.cfg.isInView) {
          xArr.push(bbox2.minX, bbox2.maxX);
          yArr.push(bbox2.minY, bbox2.maxY);
        }
      });
      var bbox = null;
      if (xArr.length) {
        var minX = min$2(xArr);
        var maxX = max$2(xArr);
        var minY = min$2(yArr);
        var maxY2 = max$2(yArr);
        bbox = {
          minX,
          minY,
          x: minX,
          y: minY,
          maxX,
          maxY: maxY2,
          width: maxX - minX,
          height: maxY2 - minY
        };
        var canvas = this.cfg.canvas;
        if (canvas) {
          var viewRange = canvas.getViewRange();
          this.set("isInView", intersectRect(bbox, viewRange));
        }
      } else {
        this.set("isInView", false);
      }
      this.set("cacheCanvasBBox", bbox);
    };
    Group2.prototype.draw = function(context, region) {
      var children = this.cfg.children;
      var allowDraw = region ? this.cfg.refresh : true;
      if (children.length && allowDraw) {
        context.save();
        applyAttrsToContext(context, this);
        this._applyClip(context, this.getClip());
        drawChildren$1(context, children, region);
        context.restore();
        this.cacheCanvasBBox();
      }
      this.cfg.refresh = null;
      this.set("hasChanged", false);
    };
    Group2.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("hasChanged", false);
    };
    return Group2;
  }(AbstractGroup)
);
var ShapeBase$1 = (
  /** @class */
  function(_super) {
    __extends$1(ShapeBase2, _super);
    function ShapeBase2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ShapeBase2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase2.prototype.getShapeBase = function() {
      return Shape$1;
    };
    ShapeBase2.prototype.getGroupBase = function() {
      return Group$1;
    };
    ShapeBase2.prototype.onCanvasChange = function(changeType) {
      refreshElement$1(this, changeType);
    };
    ShapeBase2.prototype.calculateBBox = function() {
      var type = this.get("type");
      var lineWidth = this.getHitLineWidth();
      var bboxMethod = getMethod(type);
      var box2 = bboxMethod(this);
      var halfLineWidth = lineWidth / 2;
      var minX = box2.x - halfLineWidth;
      var minY = box2.y - halfLineWidth;
      var maxX = box2.x + box2.width + halfLineWidth;
      var maxY2 = box2.y + box2.height + halfLineWidth;
      return {
        x: minX,
        minX,
        y: minY,
        minY,
        width: box2.width + lineWidth,
        height: box2.height + lineWidth,
        maxX,
        maxY: maxY2
      };
    };
    ShapeBase2.prototype.isFill = function() {
      return !!this.attrs["fill"] || this.isClipShape();
    };
    ShapeBase2.prototype.isStroke = function() {
      return !!this.attrs["stroke"];
    };
    ShapeBase2.prototype._applyClip = function(context, clip) {
      if (clip) {
        context.save();
        applyAttrsToContext(context, clip);
        clip.createPath(context);
        context.restore();
        context.clip();
        clip._afterDraw();
      }
    };
    ShapeBase2.prototype.draw = function(context, region) {
      var clip = this.cfg.clipShape;
      if (region) {
        if (this.cfg.refresh === false) {
          this.set("hasChanged", false);
          return;
        }
        var bbox = this.getCanvasBBox();
        if (!intersectRect(region, bbox)) {
          this.set("hasChanged", false);
          if (this.cfg.isInView) {
            this._afterDraw();
          }
          return;
        }
      }
      context.save();
      applyAttrsToContext(context, this);
      this._applyClip(context, clip);
      this.drawPath(context);
      context.restore();
      this._afterDraw();
    };
    ShapeBase2.prototype.getCanvasViewBox = function() {
      var canvas = this.cfg.canvas;
      if (canvas) {
        return canvas.getViewRange();
      }
      return null;
    };
    ShapeBase2.prototype.cacheCanvasBBox = function() {
      var canvasBBox = this.getCanvasViewBox();
      if (canvasBBox) {
        var bbox = this.getCanvasBBox();
        var isInView = intersectRect(bbox, canvasBBox);
        this.set("isInView", isInView);
        if (isInView) {
          this.set("cacheCanvasBBox", bbox);
        } else {
          this.set("cacheCanvasBBox", null);
        }
      }
    };
    ShapeBase2.prototype._afterDraw = function() {
      this.cacheCanvasBBox();
      this.set("hasChanged", false);
      this.set("refresh", null);
    };
    ShapeBase2.prototype.skipDraw = function() {
      this.set("cacheCanvasBBox", null);
      this.set("isInView", null);
      this.set("hasChanged", false);
    };
    ShapeBase2.prototype.drawPath = function(context) {
      this.createPath(context);
      this.strokeAndFill(context);
      this.afterDrawPath(context);
    };
    ShapeBase2.prototype.fill = function(context) {
      context.fill();
    };
    ShapeBase2.prototype.stroke = function(context) {
      context.stroke();
    };
    ShapeBase2.prototype.strokeAndFill = function(context) {
      var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
      if (this.isFill()) {
        if (!isNil(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!isNil(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = strokeOpacity;
          }
          this.stroke(context);
        }
      }
      this.afterDrawPath(context);
    };
    ShapeBase2.prototype.createPath = function(context) {
    };
    ShapeBase2.prototype.afterDrawPath = function(context) {
    };
    ShapeBase2.prototype.isInShape = function(refX, refY) {
      var isStroke = this.isStroke();
      var isFill = this.isFill();
      var lineWidth = this.getHitLineWidth();
      return this.isInStrokeOrPath(refX, refY, isStroke, isFill, lineWidth);
    };
    ShapeBase2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      return false;
    };
    ShapeBase2.prototype.getHitLineWidth = function() {
      if (!this.isStroke()) {
        return 0;
      }
      var attrs = this.attrs;
      return attrs["lineWidth"] + attrs["lineAppendWidth"];
    };
    return ShapeBase2;
  }(AbstractShape)
);
var Circle$2 = (
  /** @class */
  function(_super) {
    __extends$1(Circle2, _super);
    function Circle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      var halfLineWidth = lineWidth / 2;
      var absDistance = distance$1(cx, cy, x, y);
      if (isFill && isStroke) {
        return absDistance <= r + halfLineWidth;
      }
      if (isFill) {
        return absDistance <= r;
      }
      if (isStroke) {
        return absDistance >= r - halfLineWidth && absDistance <= r + halfLineWidth;
      }
      return false;
    };
    Circle2.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var r = attrs.r;
      context.beginPath();
      context.arc(cx, cy, r, 0, Math.PI * 2, false);
      context.closePath();
    };
    return Circle2;
  }(ShapeBase$1)
);
function ellipseDistance(squareX, squareY, rx, ry) {
  return squareX / (rx * rx) + squareY / (ry * ry);
}
var Ellipse$1 = (
  /** @class */
  function(_super) {
    __extends$1(Ellipse2, _super);
    function Ellipse2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Ellipse2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var halfLineWith = lineWidth / 2;
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx, ry = attrs.ry;
      var squareX = (x - cx) * (x - cx);
      var squareY = (y - cy) * (y - cy);
      if (isFill && isStroke) {
        return ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      if (isFill) {
        return ellipseDistance(squareX, squareY, rx, ry) <= 1;
      }
      if (isStroke) {
        return ellipseDistance(squareX, squareY, rx - halfLineWith, ry - halfLineWith) >= 1 && ellipseDistance(squareX, squareY, rx + halfLineWith, ry + halfLineWith) <= 1;
      }
      return false;
    };
    Ellipse2.prototype.createPath = function(context) {
      var attrs = this.attr();
      var cx = attrs.x;
      var cy = attrs.y;
      var rx = attrs.rx;
      var ry = attrs.ry;
      context.beginPath();
      if (context.ellipse) {
        context.ellipse(cx, cy, rx, ry, 0, 0, Math.PI * 2, false);
      } else {
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        context.save();
        context.translate(cx, cy);
        context.scale(scaleX, scaleY);
        context.arc(0, 0, r, 0, Math.PI * 2);
        context.restore();
        context.closePath();
      }
    };
    return Ellipse2;
  }(ShapeBase$1)
);
function isCanvas(dom) {
  return dom instanceof HTMLElement && isString(dom.nodeName) && dom.nodeName.toUpperCase() === "CANVAS";
}
var ImageShape = (
  /** @class */
  function(_super) {
    __extends$1(ImageShape2, _super);
    function ImageShape2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ImageShape2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    ImageShape2.prototype.initAttrs = function(attrs) {
      this._setImage(attrs.img);
    };
    ImageShape2.prototype.isStroke = function() {
      return false;
    };
    ImageShape2.prototype.isOnlyHitBox = function() {
      return true;
    };
    ImageShape2.prototype._afterLoading = function() {
      if (this.get("toDraw") === true) {
        var canvas = this.get("canvas");
        if (canvas) {
          canvas.draw();
        } else {
          this.createPath(this.get("context"));
        }
      }
    };
    ImageShape2.prototype._setImage = function(img) {
      var _this = this;
      var attrs = this.attrs;
      if (isString(img)) {
        var image_1 = new Image();
        image_1.onload = function() {
          if (_this.destroyed) {
            return false;
          }
          _this.attr("img", image_1);
          _this.set("loading", false);
          _this._afterLoading();
          var callback = _this.get("callback");
          if (callback) {
            callback.call(_this);
          }
        };
        image_1.crossOrigin = "Anonymous";
        image_1.src = img;
        this.set("loading", true);
      } else if (img instanceof Image) {
        if (!attrs.width) {
          attrs.width = img.width;
        }
        if (!attrs.height) {
          attrs.height = img.height;
        }
      } else if (isCanvas(img)) {
        if (!attrs.width) {
          attrs.width = Number(img.getAttribute("width"));
        }
        if (!attrs.height) {
          attrs.height, Number(img.getAttribute("height"));
        }
      }
    };
    ImageShape2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name === "img") {
        this._setImage(value2);
      }
    };
    ImageShape2.prototype.createPath = function(context) {
      if (this.get("loading")) {
        this.set("toDraw", true);
        this.set("context", context);
        return;
      }
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y, width = attrs.width, height = attrs.height, sx = attrs.sx, sy = attrs.sy, swidth = attrs.swidth, sheight = attrs.sheight;
      var img = attrs.img;
      if (img instanceof Image || isCanvas(img)) {
        if (!isNil(sx) && !isNil(sy) && !isNil(swidth) && !isNil(sheight)) {
          context.drawImage(img, sx, sy, swidth, sheight, x, y, width, height);
        } else {
          context.drawImage(img, x, y, width, height);
        }
      }
    };
    return ImageShape2;
  }(ShapeBase$1)
);
function inLine(x1, y1, x2, y2, lineWidth, x, y) {
  var minX = Math.min(x1, x2);
  var maxX = Math.max(x1, x2);
  var minY = Math.min(y1, y2);
  var maxY2 = Math.max(y1, y2);
  var halfWidth = lineWidth / 2;
  if (!(x >= minX - halfWidth && x <= maxX + halfWidth && y >= minY - halfWidth && y <= maxY2 + halfWidth)) {
    return false;
  }
  return LineUtil.pointToLine(x1, y1, x2, y2, x, y) <= lineWidth / 2;
}
var Line$3 = (
  /** @class */
  function(_super) {
    __extends$1(Line2, _super);
    function Line2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Line2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    Line2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      this.setArrow();
    };
    Line2.prototype.setArrow = function() {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        addStartArrow(this, attrs, x2, y2, x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, x1, y1, x2, y2);
      }
    };
    Line2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
      return inLine(x1, y1, x2, y2, lineWidth, x, y);
    };
    Line2.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x1 = attrs.x1, y1 = attrs.y1, x2 = attrs.x2, y2 = attrs.y2, startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      var startArrowDistance = {
        dx: 0,
        dy: 0
      };
      var endArrowDistance = {
        dx: 0,
        dy: 0
      };
      if (startArrow && startArrow.d) {
        startArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.startArrow.d);
      }
      if (endArrow && endArrow.d) {
        endArrowDistance = getShortenOffset(x1, y1, x2, y2, attrs.endArrow.d);
      }
      context.beginPath();
      context.moveTo(x1 + startArrowDistance.dx, y1 + startArrowDistance.dy);
      context.lineTo(x2 - endArrowDistance.dx, y2 - endArrowDistance.dy);
    };
    Line2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Line2.prototype.getTotalLength = function() {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
      return LineUtil.length(x1, y1, x2, y2);
    };
    Line2.prototype.getPoint = function(ratio) {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
      return LineUtil.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line2;
  }(ShapeBase$1)
);
var Symbols$1 = {
  // 
  circle: function(x, y, r) {
    return [
      ["M", x - r, y],
      ["A", r, r, 0, 1, 0, x + r, y],
      ["A", r, r, 0, 1, 0, x - r, y]
    ];
  },
  // 
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  // 
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  // 
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["Z"]];
  },
  // 
  "triangle-down": function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
var Marker$1 = (
  /** @class */
  function(_super) {
    __extends$1(Marker2, _super);
    function Marker2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Marker2.prototype.initAttrs = function(attrs) {
      this._resetParamsCache();
    };
    Marker2.prototype._resetParamsCache = function() {
      this.set("paramsCache", {});
    };
    Marker2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (["symbol", "x", "y", "r", "radius"].indexOf(name) !== -1) {
        this._resetParamsCache();
      }
    };
    Marker2.prototype.isOnlyHitBox = function() {
      return true;
    };
    Marker2.prototype._getR = function(attrs) {
      return isNil(attrs.r) ? attrs.radius : attrs.r;
    };
    Marker2.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var symbol = attrs.symbol || "circle";
      var r = this._getR(attrs);
      var method;
      var path2;
      if (isFunction(symbol)) {
        method = symbol;
        path2 = method(x, y, r);
        path2 = pathToAbsolute(path2);
      } else {
        method = Marker2.Symbols[symbol];
        if (!method) {
          console.warn(symbol + " marker is not supported.");
          return null;
        }
        path2 = method(x, y, r);
      }
      return path2;
    };
    Marker2.prototype.createPath = function(context) {
      var path2 = this._getPath();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, { path: path2 }, paramsCache);
    };
    Marker2.Symbols = Symbols$1;
    return Marker2;
  }(ShapeBase$1)
);
function isPointInPath(shape, x, y) {
  var ctx2 = getOffScreenContext();
  shape.createPath(ctx2);
  return ctx2.isPointInPath(x, y);
}
var tolerance = 1e-6;
function dcmp(x) {
  if (Math.abs(x) < tolerance) {
    return 0;
  }
  return x < 0 ? -1 : 1;
}
function onSegment(p1, p2, q) {
  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {
    return true;
  }
  return false;
}
function isInPolygon(points2, x, y) {
  var isHit = false;
  var n = points2.length;
  if (n <= 2) {
    return false;
  }
  for (var i = 0; i < n; i++) {
    var p1 = points2[i];
    var p2 = points2[(i + 1) % n];
    if (onSegment(p1, p2, [x, y])) {
      return true;
    }
    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {
      isHit = !isHit;
    }
  }
  return isHit;
}
function arc(cx, cy, r, startAngle, endAngle, lineWidth, x, y) {
  var angle2 = (Math.atan2(y - cy, x - cx) + Math.PI * 2) % (Math.PI * 2);
  if (angle2 < startAngle || angle2 > endAngle) {
    return false;
  }
  var point2 = {
    x: cx + r * Math.cos(angle2),
    y: cy + r * Math.sin(angle2)
  };
  return distance$1(point2.x, point2.y, x, y) <= lineWidth / 2;
}
var transform$3 = transform$6;
function hasArc(path2) {
  var hasArc2 = false;
  var count2 = path2.length;
  for (var i = 0; i < count2; i++) {
    var params = path2[i];
    var cmd = params[0];
    if (cmd === "C" || cmd === "A" || cmd === "Q") {
      hasArc2 = true;
      break;
    }
  }
  return hasArc2;
}
function isPointInStroke(segments, lineWidth, x, y, length2) {
  var isHit = false;
  var halfWidth = lineWidth / 2;
  for (var i = 0; i < segments.length; i++) {
    var segment = segments[i];
    var currentPoint = segment.currentPoint, params = segment.params, prePoint = segment.prePoint, box2 = segment.box;
    if (box2 && !inBox(box2.x - halfWidth, box2.y - halfWidth, box2.width + lineWidth, box2.height + lineWidth, x, y)) {
      continue;
    }
    switch (segment.command) {
      case "L":
      case "Z":
        isHit = inLine(prePoint[0], prePoint[1], currentPoint[0], currentPoint[1], lineWidth, x, y);
        break;
      case "Q":
        var qDistance = QuadUtil.pointDistance(prePoint[0], prePoint[1], params[1], params[2], params[3], params[4], x, y);
        isHit = qDistance <= lineWidth / 2;
        break;
      case "C":
        var cDistance = CubicUtil.pointDistance(
          prePoint[0],
          // ,  C 
          prePoint[1],
          params[1],
          // 'C' 12 34 56 
          params[2],
          params[3],
          params[4],
          params[5],
          params[6],
          x,
          y,
          length2
        );
        isHit = cDistance <= lineWidth / 2;
        break;
      case "A":
        var arcParams = segment.arcParams;
        var cx = arcParams.cx, cy = arcParams.cy, rx = arcParams.rx, ry = arcParams.ry, startAngle = arcParams.startAngle, endAngle = arcParams.endAngle, xRotation = arcParams.xRotation;
        var p = [x, y, 1];
        var r = rx > ry ? rx : ry;
        var scaleX = rx > ry ? 1 : rx / ry;
        var scaleY = rx > ry ? ry / rx : 1;
        var m = transform$3(null, [
          ["t", -cx, -cy],
          ["r", -xRotation],
          ["s", 1 / scaleX, 1 / scaleY]
        ]);
        transformMat3$1(p, p, m);
        isHit = arc(0, 0, r, startAngle, endAngle, lineWidth, p[0], p[1]);
        break;
    }
    if (isHit) {
      break;
    }
  }
  return isHit;
}
function extractPolygons(path2) {
  var count2 = path2.length;
  var polygons = [];
  var polylines = [];
  var points2 = [];
  for (var i = 0; i < count2; i++) {
    var params = path2[i];
    var cmd = params[0];
    if (cmd === "M") {
      if (points2.length) {
        polylines.push(points2);
        points2 = [];
      }
      points2.push([params[1], params[2]]);
    } else if (cmd === "Z") {
      if (points2.length) {
        polygons.push(points2);
        points2 = [];
      }
    } else {
      points2.push([params[1], params[2]]);
    }
  }
  if (points2.length > 0) {
    polylines.push(points2);
  }
  return {
    polygons,
    polylines
  };
}
const PathUtil = __assign$1({
  hasArc,
  extractPolygons,
  isPointInStroke
}, PathUtil$1);
function isInPolygons(polygons, x, y) {
  var isHit = false;
  for (var i = 0; i < polygons.length; i++) {
    var points2 = polygons[i];
    isHit = isInPolygon(points2, x, y);
    if (isHit) {
      break;
    }
  }
  return isHit;
}
var Path$2 = (
  /** @class */
  function(_super) {
    __extends$1(Path2, _super);
    function Path2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Path2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
    };
    Path2.prototype.initAttrs = function(attrs) {
      this._setPathArr(attrs.path);
      this.setArrow();
    };
    Path2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name === "path") {
        this._setPathArr(value2);
      }
      this.setArrow();
    };
    Path2.prototype._setPathArr = function(path2) {
      this.attrs.path = pathToAbsolute(path2);
      var hasArc2 = PathUtil.hasArc(path2);
      this.set("hasArc", hasArc2);
      this.set("paramsCache", {});
      this.set("segments", null);
      this.set("curve", null);
      this.set("tCache", null);
      this.set("totalLength", null);
    };
    Path2.prototype.getSegments = function() {
      var segments = this.get("segements");
      if (!segments) {
        segments = getSegments(this.attr("path"));
        this.set("segments", segments);
      }
      return segments;
    };
    Path2.prototype.setArrow = function() {
      var attrs = this.attr();
      var startArrow = attrs.startArrow, endArrow = attrs.endArrow;
      if (startArrow) {
        var tangent = this.getStartTangent();
        addStartArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
      if (endArrow) {
        var tangent = this.getEndTangent();
        addEndArrow(this, attrs, tangent[0][0], tangent[0][1], tangent[1][0], tangent[1][1]);
      }
    };
    Path2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var segments = this.getSegments();
      var hasArc2 = this.get("hasArc");
      var isHit = false;
      if (isStroke) {
        var length_1 = this.getTotalLength();
        isHit = PathUtil.isPointInStroke(segments, lineWidth, x, y, length_1);
      }
      if (!isHit && isFill) {
        if (hasArc2) {
          isHit = isPointInPath(this, x, y);
        } else {
          var path2 = this.attr("path");
          var extractResutl = PathUtil.extractPolygons(path2);
          isHit = isInPolygons(extractResutl.polygons, x, y) || isInPolygons(extractResutl.polylines, x, y);
        }
      }
      return isHit;
    };
    Path2.prototype.createPath = function(context) {
      var attrs = this.attr();
      var paramsCache = this.get("paramsCache");
      drawPath(this, context, attrs, paramsCache);
    };
    Path2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    Path2.prototype.getTotalLength = function() {
      var totalLength = this.get("totalLength");
      if (!isNil(totalLength)) {
        return totalLength;
      }
      this._calculateCurve();
      this._setTcache();
      return this.get("totalLength");
    };
    Path2.prototype.getPoint = function(ratio) {
      var tCache = this.get("tCache");
      if (!tCache) {
        this._calculateCurve();
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      var curve = this.get("curve");
      if (!tCache || tCache.length === 0) {
        if (curve) {
          return {
            x: curve[0][1],
            y: curve[0][2]
          };
        }
        return null;
      }
      each$1(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index2 = i;
        }
      });
      var seg = curve[index2];
      if (isNil(seg) || isNil(index2)) {
        return null;
      }
      var l = seg.length;
      var nextSeg = curve[index2 + 1];
      return CubicUtil.pointAt(seg[l - 2], seg[l - 1], nextSeg[1], nextSeg[2], nextSeg[3], nextSeg[4], nextSeg[5], nextSeg[6], subt);
    };
    Path2.prototype._calculateCurve = function() {
      var path2 = this.attr().path;
      this.set("curve", PathUtil.pathToCurve(path2));
    };
    Path2.prototype._setTcache = function() {
      var totalLength = 0;
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      var segmentN;
      var l;
      var curve = this.get("curve");
      if (!curve) {
        return;
      }
      each$1(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          totalLength += CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]) || 0;
        }
      });
      this.set("totalLength", totalLength);
      if (totalLength === 0) {
        this.set("tCache", []);
        return;
      }
      each$1(curve, function(segment, i) {
        segmentN = curve[i + 1];
        l = segment.length;
        if (segmentN) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = CubicUtil.length(segment[l - 2], segment[l - 1], segmentN[1], segmentN[2], segmentN[3], segmentN[4], segmentN[5], segmentN[6]);
          tempLength += segmentL || 0;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Path2.prototype.getStartTangent = function() {
      var segments = this.getSegments();
      var result;
      if (segments.length > 1) {
        var startPoint = segments[0].currentPoint;
        var endPoint = segments[1].currentPoint;
        var tangent = segments[1].startTangent;
        result = [];
        if (tangent) {
          result.push([startPoint[0] - tangent[0], startPoint[1] - tangent[1]]);
          result.push([startPoint[0], startPoint[1]]);
        } else {
          result.push([endPoint[0], endPoint[1]]);
          result.push([startPoint[0], startPoint[1]]);
        }
      }
      return result;
    };
    Path2.prototype.getEndTangent = function() {
      var segments = this.getSegments();
      var length2 = segments.length;
      var result;
      if (length2 > 1) {
        var startPoint = segments[length2 - 2].currentPoint;
        var endPoint = segments[length2 - 1].currentPoint;
        var tangent = segments[length2 - 1].endTangent;
        result = [];
        if (tangent) {
          result.push([endPoint[0] - tangent[0], endPoint[1] - tangent[1]]);
          result.push([endPoint[0], endPoint[1]]);
        } else {
          result.push([startPoint[0], startPoint[1]]);
          result.push([endPoint[0], endPoint[1]]);
        }
      }
      return result;
    };
    return Path2;
  }(ShapeBase$1)
);
function inPolyline(points2, lineWidth, x, y, isClose) {
  var count2 = points2.length;
  if (count2 < 2) {
    return false;
  }
  for (var i = 0; i < count2 - 1; i++) {
    var x1 = points2[i][0];
    var y1 = points2[i][1];
    var x2 = points2[i + 1][0];
    var y2 = points2[i + 1][1];
    if (inLine(x1, y1, x2, y2, lineWidth, x, y)) {
      return true;
    }
  }
  if (isClose) {
    var first = points2[0];
    var last2 = points2[count2 - 1];
    if (inLine(first[0], first[1], last2[0], last2[1], lineWidth, x, y)) {
      return true;
    }
  }
  return false;
}
var Polygon$2 = (
  /** @class */
  function(_super) {
    __extends$1(Polygon2, _super);
    function Polygon2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Polygon2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var points2 = this.attr().points;
      var isHit = false;
      if (isStroke) {
        isHit = inPolyline(points2, lineWidth, x, y, true);
      }
      if (!isHit && isFill) {
        isHit = isInPolygon(points2, x, y);
      }
      return isHit;
    };
    Polygon2.prototype.createPath = function(context) {
      var attrs = this.attr();
      var points2 = attrs.points;
      if (points2.length < 2) {
        return;
      }
      context.beginPath();
      for (var i = 0; i < points2.length; i++) {
        var point2 = points2[i];
        if (i === 0) {
          context.moveTo(point2[0], point2[1]);
        } else {
          context.lineTo(point2[0], point2[1]);
        }
      }
      context.closePath();
    };
    return Polygon2;
  }(ShapeBase$1)
);
var PolyLine = (
  /** @class */
  function(_super) {
    __extends$1(PolyLine2, _super);
    function PolyLine2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolyLine2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
    };
    PolyLine2.prototype.initAttrs = function(attrs) {
      this.setArrow();
    };
    PolyLine2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      this.setArrow();
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    PolyLine2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    PolyLine2.prototype.setArrow = function() {
      var attrs = this.attr();
      var _a2 = this.attrs, points2 = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
      var length2 = points2.length;
      var x1 = points2[0][0];
      var y1 = points2[0][1];
      var x2 = points2[length2 - 1][0];
      var y2 = points2[length2 - 1][1];
      if (startArrow) {
        addStartArrow(this, attrs, points2[1][0], points2[1][1], x1, y1);
      }
      if (endArrow) {
        addEndArrow(this, attrs, points2[length2 - 2][0], points2[length2 - 2][1], x2, y2);
      }
    };
    PolyLine2.prototype.isFill = function() {
      return false;
    };
    PolyLine2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      if (!isStroke || !lineWidth) {
        return false;
      }
      var points2 = this.attr().points;
      return inPolyline(points2, lineWidth, x, y, false);
    };
    PolyLine2.prototype.isStroke = function() {
      return true;
    };
    PolyLine2.prototype.createPath = function(context) {
      var _a2 = this.attr(), points2 = _a2.points, startArrow = _a2.startArrow, endArrow = _a2.endArrow;
      var length2 = points2.length;
      if (points2.length < 2) {
        return;
      }
      var x1 = points2[0][0];
      var y1 = points2[0][1];
      var x2 = points2[length2 - 1][0];
      var y2 = points2[length2 - 1][1];
      if (startArrow && startArrow.d) {
        var distance2 = getShortenOffset(x1, y1, points2[1][0], points2[1][1], startArrow.d);
        x1 += distance2.dx;
        y1 += distance2.dy;
      }
      if (endArrow && endArrow.d) {
        var distance2 = getShortenOffset(points2[length2 - 2][0], points2[length2 - 2][1], x2, y2, endArrow.d);
        x2 -= distance2.dx;
        y2 -= distance2.dy;
      }
      context.beginPath();
      context.moveTo(x1, y1);
      for (var i = 0; i < length2 - 1; i++) {
        var point2 = points2[i];
        context.lineTo(point2[0], point2[1]);
      }
      context.lineTo(x2, y2);
    };
    PolyLine2.prototype.afterDrawPath = function(context) {
      var startArrowShape = this.get("startArrowShape");
      var endArrowShape = this.get("endArrowShape");
      if (startArrowShape) {
        startArrowShape.draw(context);
      }
      if (endArrowShape) {
        endArrowShape.draw(context);
      }
    };
    PolyLine2.prototype.getTotalLength = function() {
      var points2 = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!isNil(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", PolylineUtil.length(points2));
      return this.get("totalLength");
    };
    PolyLine2.prototype.getPoint = function(ratio) {
      var points2 = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      each$1(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index2 = i;
        }
      });
      return LineUtil.pointAt(points2[index2][0], points2[index2][1], points2[index2 + 1][0], points2[index2 + 1][1], subt);
    };
    PolyLine2.prototype._setTcache = function() {
      var points2 = this.attr().points;
      if (!points2 || points2.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each$1(points2, function(p, i) {
        if (points2[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = LineUtil.length(p[0], p[1], points2[i + 1][0], points2[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    PolyLine2.prototype.getStartTangent = function() {
      var points2 = this.attr().points;
      var result = [];
      result.push([points2[1][0], points2[1][1]]);
      result.push([points2[0][0], points2[0][1]]);
      return result;
    };
    PolyLine2.prototype.getEndTangent = function() {
      var points2 = this.attr().points;
      var l = points2.length - 1;
      var result = [];
      result.push([points2[l - 1][0], points2[l - 1][1]]);
      result.push([points2[l][0], points2[l][1]]);
      return result;
    };
    return PolyLine2;
  }(ShapeBase$1)
);
function inRect(minX, minY, width, height, lineWidth, x, y) {
  var halfWidth = lineWidth / 2;
  return inBox(minX - halfWidth, minY - halfWidth, width, lineWidth, x, y) || // 
  inBox(minX + width - halfWidth, minY - halfWidth, lineWidth, height, x, y) || // 
  inBox(minX + halfWidth, minY + height - halfWidth, width, lineWidth, x, y) || // 
  inBox(minX - halfWidth, minY + halfWidth, lineWidth, height, x, y);
}
function rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y) {
  return inLine(minX + radius, minY, minX + width - radius, minY, lineWidth, x, y) || inLine(minX + width, minY + radius, minX + width, minY + height - radius, lineWidth, x, y) || inLine(minX + width - radius, minY + height, minX + radius, minY + height, lineWidth, x, y) || inLine(minX, minY + height - radius, minX, minY + radius, lineWidth, x, y) || arc(minX + width - radius, minY + radius, radius, 1.5 * Math.PI, 2 * Math.PI, lineWidth, x, y) || arc(minX + width - radius, minY + height - radius, radius, 0, 0.5 * Math.PI, lineWidth, x, y) || arc(minX + radius, minY + height - radius, radius, 0.5 * Math.PI, Math.PI, lineWidth, x, y) || arc(minX + radius, minY + radius, radius, Math.PI, 1.5 * Math.PI, lineWidth, x, y);
}
var Rect$2 = (
  /** @class */
  function(_super) {
    __extends$1(Rect2, _super);
    function Rect2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect2.prototype.isInStrokeOrPath = function(x, y, isStroke, isFill, lineWidth) {
      var attrs = this.attr();
      var minX = attrs.x;
      var minY = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        var halfWidth = lineWidth / 2;
        if (isFill && isStroke) {
          return inBox(minX - halfWidth, minY - halfWidth, width + halfWidth, height + halfWidth, x, y);
        }
        if (isFill) {
          return inBox(minX, minY, width, height, x, y);
        }
        if (isStroke) {
          return inRect(minX, minY, width, height, lineWidth, x, y);
        }
      } else {
        var isHit = false;
        if (isStroke) {
          isHit = rectWithRadius(minX, minY, width, height, radius, lineWidth, x, y);
        }
        if (!isHit && isFill) {
          isHit = isPointInPath(this, x, y);
        }
        return isHit;
      }
    };
    Rect2.prototype.createPath = function(context) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var width = attrs.width;
      var height = attrs.height;
      var radius = attrs.radius;
      context.beginPath();
      if (radius === 0) {
        context.rect(x, y, width, height);
      } else {
        var _a2 = parseRadius$2(radius), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
        context.moveTo(x + r1, y);
        context.lineTo(x + width - r2, y);
        r2 !== 0 && context.arc(x + width - r2, y + r2, r2, -Math.PI / 2, 0);
        context.lineTo(x + width, y + height - r3);
        r3 !== 0 && context.arc(x + width - r3, y + height - r3, r3, 0, Math.PI / 2);
        context.lineTo(x + r4, y + height);
        r4 !== 0 && context.arc(x + r4, y + height - r4, r4, Math.PI / 2, Math.PI);
        context.lineTo(x, y + r1);
        r1 !== 0 && context.arc(x + r1, y + r1, r1, Math.PI, Math.PI * 1.5);
        context.closePath();
      }
    };
    return Rect2;
  }(ShapeBase$1)
);
var Text$1 = (
  /** @class */
  function(_super) {
    __extends$1(Text2, _super);
    function Text2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Text2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text2.prototype.isOnlyHitBox = function() {
      return true;
    };
    Text2.prototype.initAttrs = function(attrs) {
      this._assembleFont();
      if (attrs.text) {
        this._setText(attrs.text);
      }
    };
    Text2.prototype._assembleFont = function() {
      var attrs = this.attrs;
      attrs.font = assembleFont(attrs);
    };
    Text2.prototype._setText = function(text2) {
      var textArr = null;
      if (isString(text2) && text2.indexOf("\n") !== -1) {
        textArr = text2.split("\n");
      }
      this.set("textArr", textArr);
    };
    Text2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (name.startsWith("font")) {
        this._assembleFont();
      }
      if (name === "text") {
        this._setText(value2);
      }
    };
    Text2.prototype._getSpaceingY = function() {
      var attrs = this.attrs;
      var lineHeight = attrs.lineHeight;
      var fontSize = attrs.fontSize * 1;
      return lineHeight ? lineHeight - fontSize : fontSize * 0.14;
    };
    Text2.prototype._drawTextArr = function(context, textArr, isFill) {
      var attrs = this.attrs;
      var textBaseline = attrs.textBaseline;
      var x = attrs.x;
      var y = attrs.y;
      var fontSize = attrs.fontSize * 1;
      var spaceingY = this._getSpaceingY();
      var height = getTextHeight(attrs.text, attrs.fontSize, attrs.lineHeight);
      var subY;
      each$1(textArr, function(subText, index2) {
        subY = y + index2 * (spaceingY + fontSize) - height + fontSize;
        if (textBaseline === "middle")
          subY += height - fontSize - (height - fontSize) / 2;
        if (textBaseline === "top")
          subY += height - fontSize;
        if (!isNil(subText)) {
          if (isFill) {
            context.fillText(subText, x, subY);
          } else {
            context.strokeText(subText, x, subY);
          }
        }
      });
    };
    Text2.prototype._drawText = function(context, isFill) {
      var attrs = this.attr();
      var x = attrs.x;
      var y = attrs.y;
      var textArr = this.get("textArr");
      if (textArr) {
        this._drawTextArr(context, textArr, isFill);
      } else {
        var text2 = attrs.text;
        if (!isNil(text2)) {
          if (isFill) {
            context.fillText(text2, x, y);
          } else {
            context.strokeText(text2, x, y);
          }
        }
      }
    };
    Text2.prototype.strokeAndFill = function(context) {
      var _a2 = this.attrs, lineWidth = _a2.lineWidth, opacity = _a2.opacity, strokeOpacity = _a2.strokeOpacity, fillOpacity = _a2.fillOpacity;
      if (this.isStroke()) {
        if (lineWidth > 0) {
          if (!isNil(strokeOpacity) && strokeOpacity !== 1) {
            context.globalAlpha = opacity;
          }
          this.stroke(context);
        }
      }
      if (this.isFill()) {
        if (!isNil(fillOpacity) && fillOpacity !== 1) {
          context.globalAlpha = fillOpacity;
          this.fill(context);
          context.globalAlpha = opacity;
        } else {
          this.fill(context);
        }
      }
      this.afterDrawPath(context);
    };
    Text2.prototype.fill = function(context) {
      this._drawText(context, true);
    };
    Text2.prototype.stroke = function(context) {
      this._drawText(context, false);
    };
    return Text2;
  }(ShapeBase$1)
);
function invertFromMatrix(v, matrix) {
  if (matrix) {
    var invertMatrix = invert(matrix);
    return multiplyVec2$1(invertMatrix, v);
  }
  return v;
}
function getRefXY(element, x, y) {
  var totalMatrix = element.getTotalMatrix();
  if (totalMatrix) {
    var _a2 = invertFromMatrix([x, y, 1], totalMatrix), refX = _a2[0], refY = _a2[1];
    return [refX, refY];
  }
  return [x, y];
}
function preTest(element, x, y) {
  if (element.isCanvas && element.isCanvas()) {
    return true;
  }
  if (!isAllowCapture(element) || element.cfg.isInView === false) {
    return false;
  }
  if (element.cfg.clipShape) {
    var _a2 = getRefXY(element, x, y), refX = _a2[0], refY = _a2[1];
    if (element.isClipped(refX, refY)) {
      return false;
    }
  }
  var bbox = element.cfg.cacheCanvasBBox || element.getCanvasBBox();
  if (!(x >= bbox.minX && x <= bbox.maxX && y >= bbox.minY && y <= bbox.maxY)) {
    return false;
  }
  return true;
}
function getShape(container, x, y) {
  if (!preTest(container, x, y)) {
    return null;
  }
  var shape = null;
  var children = container.getChildren();
  var count2 = children.length;
  for (var i = count2 - 1; i >= 0; i--) {
    var child = children[i];
    if (child.isGroup()) {
      shape = getShape(child, x, y);
    } else if (preTest(child, x, y)) {
      var curShape = child;
      var _a2 = getRefXY(child, x, y), refX = _a2[0], refY = _a2[1];
      if (curShape.isInShape(refX, refY)) {
        shape = child;
      }
    }
    if (shape) {
      break;
    }
  }
  return shape;
}
var Canvas$1 = (
  /** @class */
  function(_super) {
    __extends$1(Canvas2, _super);
    function Canvas2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Canvas2.prototype.getDefaultCfg = function() {
      var cfg = _super.prototype.getDefaultCfg.call(this);
      cfg["renderer"] = "canvas";
      cfg["autoDraw"] = true;
      cfg["localRefresh"] = true;
      cfg["refreshElements"] = [];
      cfg["clipView"] = true;
      cfg["quickHit"] = false;
      return cfg;
    };
    Canvas2.prototype.onCanvasChange = function(changeType) {
      if (changeType === "attr" || changeType === "sort" || changeType === "changeSize") {
        this.set("refreshElements", [this]);
        this.draw();
      }
    };
    Canvas2.prototype.getShapeBase = function() {
      return Shape$1;
    };
    Canvas2.prototype.getGroupBase = function() {
      return Group$1;
    };
    Canvas2.prototype.getPixelRatio = function() {
      var pixelRatio = this.get("pixelRatio") || getPixelRatio$1();
      return pixelRatio >= 1 ? Math.ceil(pixelRatio) : 1;
    };
    Canvas2.prototype.getViewRange = function() {
      return {
        minX: 0,
        minY: 0,
        maxX: this.cfg.width,
        maxY: this.cfg.height
      };
    };
    Canvas2.prototype.createDom = function() {
      var element = document.createElement("canvas");
      var context = element.getContext("2d");
      this.set("context", context);
      return element;
    };
    Canvas2.prototype.setDOMSize = function(width, height) {
      _super.prototype.setDOMSize.call(this, width, height);
      var context = this.get("context");
      var el = this.get("el");
      var pixelRatio = this.getPixelRatio();
      el.width = pixelRatio * width;
      el.height = pixelRatio * height;
      if (pixelRatio > 1) {
        context.scale(pixelRatio, pixelRatio);
      }
    };
    Canvas2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this._clearFrame();
      var context = this.get("context");
      var element = this.get("el");
      context.clearRect(0, 0, element.width, element.height);
    };
    Canvas2.prototype.getShape = function(x, y) {
      var shape;
      if (this.get("quickHit")) {
        shape = getShape(this, x, y);
      } else {
        shape = _super.prototype.getShape.call(this, x, y, null);
      }
      return shape;
    };
    Canvas2.prototype._getRefreshRegion = function() {
      var elements = this.get("refreshElements");
      var viewRegion = this.getViewRange();
      var region;
      if (elements.length && elements[0] === this) {
        region = viewRegion;
      } else {
        region = getMergedRegion(elements);
        if (region) {
          region.minX = Math.floor(region.minX);
          region.minY = Math.floor(region.minY);
          region.maxX = Math.ceil(region.maxX);
          region.maxY = Math.ceil(region.maxY);
          region.maxY += 1;
          var clipView = this.get("clipView");
          if (clipView) {
            region = mergeView(region, viewRegion);
          }
        }
      }
      return region;
    };
    Canvas2.prototype.refreshElement = function(element) {
      var refreshElements = this.get("refreshElements");
      refreshElements.push(element);
    };
    Canvas2.prototype._clearFrame = function() {
      var drawFrame = this.get("drawFrame");
      if (drawFrame) {
        cancelAnimationFrame(drawFrame);
        this.set("drawFrame", null);
        this.set("refreshElements", []);
      }
    };
    Canvas2.prototype.draw = function() {
      var drawFrame = this.get("drawFrame");
      if (this.get("autoDraw") && drawFrame) {
        return;
      }
      this._startDraw();
    };
    Canvas2.prototype._drawAll = function() {
      var context = this.get("context");
      var element = this.get("el");
      var children = this.getChildren();
      context.clearRect(0, 0, element.width, element.height);
      applyAttrsToContext(context, this);
      drawChildren$1(context, children);
      this.set("refreshElements", []);
    };
    Canvas2.prototype._drawRegion = function() {
      var context = this.get("context");
      var refreshElements = this.get("refreshElements");
      var children = this.getChildren();
      var region = this._getRefreshRegion();
      if (region) {
        context.clearRect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.save();
        context.beginPath();
        context.rect(region.minX, region.minY, region.maxX - region.minX, region.maxY - region.minY);
        context.clip();
        applyAttrsToContext(context, this);
        checkRefresh(this, children, region);
        drawChildren$1(context, children, region);
        context.restore();
      } else if (refreshElements.length) {
        clearChanged(refreshElements);
      }
      each$1(refreshElements, function(element) {
        if (element.get("hasChanged")) {
          element.set("hasChanged", false);
        }
      });
      this.set("refreshElements", []);
    };
    Canvas2.prototype._startDraw = function() {
      var _this = this;
      var drawFrame = this.get("drawFrame");
      if (!drawFrame) {
        drawFrame = requestAnimationFrame(function() {
          if (_this.get("localRefresh")) {
            _this._drawRegion();
          } else {
            _this._drawAll();
          }
          _this.set("drawFrame", null);
        });
        this.set("drawFrame", drawFrame);
      }
    };
    Canvas2.prototype.skipDraw = function() {
    };
    Canvas2.prototype.removeDom = function() {
      var el = this.get("el");
      el.width = 0;
      el.height = 0;
      el.parentNode.removeChild(el);
    };
    return Canvas2;
  }(Canvas$2)
);
var version$1 = "0.5.12";
const CanvasEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractCanvas: Canvas$2,
  AbstractGroup,
  AbstractShape,
  Base,
  Canvas: Canvas$1,
  Event: GraphEvent,
  Group: Group$1,
  PathUtil: PathUtil$1,
  Shape: Shape$1,
  assembleFont,
  getArcParams,
  getBBoxMethod: getMethod,
  getOffScreenContext,
  getTextHeight,
  invert,
  isAllowCapture,
  multiplyVec2: multiplyVec2$1,
  registerBBox: register,
  registerEasing,
  version: version$1
}, Symbol.toStringTag, { value: "Module" }));
var SHAPE_TO_TAGS = {
  rect: "path",
  circle: "circle",
  line: "line",
  path: "path",
  marker: "path",
  text: "text",
  polyline: "polyline",
  polygon: "polygon",
  image: "image",
  ellipse: "ellipse",
  dom: "foreignObject"
};
var SVG_ATTR_MAP = {
  opacity: "opacity",
  fillStyle: "fill",
  fill: "fill",
  fillOpacity: "fill-opacity",
  strokeStyle: "stroke",
  strokeOpacity: "stroke-opacity",
  stroke: "stroke",
  x: "x",
  y: "y",
  r: "r",
  rx: "rx",
  ry: "ry",
  width: "width",
  height: "height",
  x1: "x1",
  x2: "x2",
  y1: "y1",
  y2: "y2",
  lineCap: "stroke-linecap",
  lineJoin: "stroke-linejoin",
  lineWidth: "stroke-width",
  lineDash: "stroke-dasharray",
  lineDashOffset: "stroke-dashoffset",
  miterLimit: "stroke-miterlimit",
  font: "font",
  fontSize: "font-size",
  fontStyle: "font-style",
  fontVariant: "font-variant",
  fontWeight: "font-weight",
  fontFamily: "font-family",
  startArrow: "marker-start",
  endArrow: "marker-end",
  path: "d",
  class: "class",
  id: "id",
  style: "style",
  preserveAspectRatio: "preserveAspectRatio"
};
function createSVGElement(type) {
  return document.createElementNS("http://www.w3.org/2000/svg", type);
}
function createDom(shape) {
  var type = SHAPE_TO_TAGS[shape.type];
  var parent = shape.getParent();
  if (!type) {
    throw new Error("the type " + shape.type + " is not supported by svg");
  }
  var element = createSVGElement(type);
  if (shape.get("id")) {
    element.id = shape.get("id");
  }
  shape.set("el", element);
  shape.set("attrs", {});
  if (parent) {
    var parentNode = parent.get("el");
    if (parentNode) {
      parentNode.appendChild(element);
    } else {
      parentNode = parent.createDom();
      parent.set("el", parentNode);
      parentNode.appendChild(element);
    }
  }
  return element;
}
function sortDom(element, sorter) {
  var el = element.get("el");
  var childList = toArray(el.children).sort(sorter);
  var fragment = document.createDocumentFragment();
  childList.forEach(function(child) {
    fragment.appendChild(child);
  });
  el.appendChild(fragment);
}
function moveTo(element, targetIndex) {
  var parentNode = element.parentNode;
  var siblings2 = Array.from(parentNode.childNodes).filter(
    //  defs 
    function(node) {
      return node.nodeType === 1 && node.nodeName.toLowerCase() !== "defs";
    }
  );
  var target2 = siblings2[targetIndex];
  var currentIndex = siblings2.indexOf(element);
  if (target2) {
    if (currentIndex > targetIndex) {
      parentNode.insertBefore(element, target2);
    } else if (currentIndex < targetIndex) {
      var targetNext = siblings2[targetIndex + 1];
      if (targetNext) {
        parentNode.insertBefore(element, targetNext);
      } else {
        parentNode.appendChild(element);
      }
    }
  } else {
    parentNode.appendChild(element);
  }
}
function setShadow(model, context) {
  var el = model.cfg.el;
  var attrs = model.attr();
  var cfg = {
    dx: attrs.shadowOffsetX,
    dy: attrs.shadowOffsetY,
    blur: attrs.shadowBlur,
    color: attrs.shadowColor
  };
  if (!cfg.dx && !cfg.dy && !cfg.blur && !cfg.color) {
    el.removeAttribute("filter");
  } else {
    var id2 = context.find("filter", cfg);
    if (!id2) {
      id2 = context.addShadow(cfg);
    }
    el.setAttribute("filter", "url(#" + id2 + ")");
  }
}
function setTransform(model) {
  var matrix = model.attr().matrix;
  if (matrix) {
    var el = model.cfg.el;
    var transform2 = [];
    for (var i = 0; i < 9; i += 3) {
      transform2.push(matrix[i] + "," + matrix[i + 1]);
    }
    transform2 = transform2.join(",");
    if (transform2.indexOf("NaN") === -1) {
      el.setAttribute("transform", "matrix(" + transform2 + ")");
    } else {
      console.warn("invalid matrix:", matrix);
    }
  }
}
function setClip(model, context) {
  var clip = model.getClip();
  var el = model.get("el");
  if (!clip) {
    el.removeAttribute("clip-path");
  } else if (clip && !el.hasAttribute("clip-path")) {
    createDom(clip);
    clip.createPath(context);
    var id2 = context.addClip(clip);
    el.setAttribute("clip-path", "url(#" + id2 + ")");
  }
}
function drawChildren(context, children) {
  children.forEach(function(child) {
    child.draw(context);
  });
}
function refreshElement(element, changeType) {
  var canvas = element.get("canvas");
  if (canvas && canvas.get("autoDraw")) {
    var context = canvas.get("context");
    var parent_1 = element.getParent();
    var parentChildren = parent_1 ? parent_1.getChildren() : [canvas];
    var el = element.get("el");
    if (changeType === "remove") {
      var isClipShape = element.get("isClipShape");
      if (isClipShape) {
        var clipPathEl = el && el.parentNode;
        var defsEl = clipPathEl && clipPathEl.parentNode;
        if (clipPathEl && defsEl) {
          defsEl.removeChild(clipPathEl);
        }
      } else if (el && el.parentNode) {
        el.parentNode.removeChild(el);
      }
    } else if (changeType === "show") {
      el.setAttribute("visibility", "visible");
    } else if (changeType === "hide") {
      el.setAttribute("visibility", "hidden");
    } else if (changeType === "zIndex") {
      moveTo(el, parentChildren.indexOf(element));
    } else if (changeType === "sort") {
      var children_1 = element.get("children");
      if (children_1 && children_1.length) {
        sortDom(element, function(a, b) {
          return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
        });
      }
    } else if (changeType === "clear") {
      if (el) {
        el.innerHTML = "";
      }
    } else if (changeType === "matrix") {
      setTransform(element);
    } else if (changeType === "clip") {
      setClip(element, context);
    } else if (changeType === "attr")
      ;
    else if (changeType === "add") {
      element.draw(context);
    }
  }
}
var Group = (
  /** @class */
  function(_super) {
    __extends$1(Group2, _super);
    function Group2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Group2.prototype.isEntityGroup = function() {
      return true;
    };
    Group2.prototype.createDom = function() {
      var element = createSVGElement("g");
      this.set("el", element);
      var parent = this.getParent();
      if (parent) {
        var parentNode = parent.get("el");
        if (parentNode) {
          parentNode.appendChild(element);
        } else {
          parentNode = parent.createDom();
          parent.set("el", parentNode);
          parentNode.appendChild(element);
        }
      }
      return element;
    };
    Group2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.createPath(context, targetAttrs);
      }
    };
    Group2.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    Group2.prototype.getShapeBase = function() {
      return Shape;
    };
    Group2.prototype.getGroupBase = function() {
      return Group2;
    };
    Group2.prototype.draw = function(context) {
      var children = this.getChildren();
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          this.createDom();
        }
        setClip(this, context);
        this.createPath(context);
        if (children.length) {
          drawChildren(context, children);
        }
      }
    };
    Group2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
      setTransform(this);
    };
    return Group2;
  }(AbstractGroup)
);
var ShapeBase = (
  /** @class */
  function(_super) {
    __extends$1(ShapeBase2, _super);
    function ShapeBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "svg";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    ShapeBase2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { lineWidth: 1, lineAppendWidth: 0, strokeOpacity: 1, fillOpacity: 1 });
    };
    ShapeBase2.prototype.afterAttrsChange = function(targetAttrs) {
      _super.prototype.afterAttrsChange.call(this, targetAttrs);
      var canvas = this.get("canvas");
      if (canvas && canvas.get("autoDraw")) {
        var context = canvas.get("context");
        this.draw(context, targetAttrs);
      }
    };
    ShapeBase2.prototype.getShapeBase = function() {
      return Shape;
    };
    ShapeBase2.prototype.getGroupBase = function() {
      return Group;
    };
    ShapeBase2.prototype.onCanvasChange = function(changeType) {
      refreshElement(this, changeType);
    };
    ShapeBase2.prototype.calculateBBox = function() {
      var el = this.get("el");
      var bbox = null;
      if (el) {
        bbox = el.getBBox();
      } else {
        var bboxMethod = getMethod(this.get("type"));
        if (bboxMethod) {
          bbox = bboxMethod(this);
        }
      }
      if (bbox) {
        var x = bbox.x, y = bbox.y, width = bbox.width, height = bbox.height;
        var lineWidth = this.getHitLineWidth();
        var halfWidth = lineWidth / 2;
        var minX = x - halfWidth;
        var minY = y - halfWidth;
        var maxX = x + width + halfWidth;
        var maxY2 = y + height + halfWidth;
        return {
          x: minX,
          y: minY,
          minX,
          minY,
          maxX,
          maxY: maxY2,
          width: width + lineWidth,
          height: height + lineWidth
        };
      }
      return {
        x: 0,
        y: 0,
        minX: 0,
        minY: 0,
        maxX: 0,
        maxY: 0,
        width: 0,
        height: 0
      };
    };
    ShapeBase2.prototype.isFill = function() {
      var _a2 = this.attr(), fill = _a2.fill, fillStyle = _a2.fillStyle;
      return (fill || fillStyle || this.isClipShape()) && this.canFill;
    };
    ShapeBase2.prototype.isStroke = function() {
      var _a2 = this.attr(), stroke = _a2.stroke, strokeStyle = _a2.strokeStyle;
      return (stroke || strokeStyle) && this.canStroke;
    };
    ShapeBase2.prototype.draw = function(context, targetAttrs) {
      var el = this.get("el");
      if (this.get("destroyed")) {
        if (el) {
          el.parentNode.removeChild(el);
        }
      } else {
        if (!el) {
          createDom(this);
        }
        setClip(this, context);
        this.createPath(context, targetAttrs);
        this.shadow(context, targetAttrs);
        this.strokeAndFill(context, targetAttrs);
        this.transform(targetAttrs);
      }
    };
    ShapeBase2.prototype.createPath = function(context, targetAttrs) {
    };
    ShapeBase2.prototype.strokeAndFill = function(context, targetAttrs) {
      var attrs = targetAttrs || this.attr();
      var fill = attrs.fill, fillStyle = attrs.fillStyle, stroke = attrs.stroke, strokeStyle = attrs.strokeStyle, fillOpacity = attrs.fillOpacity, strokeOpacity = attrs.strokeOpacity, lineWidth = attrs.lineWidth;
      var el = this.get("el");
      if (this.canFill) {
        if (!targetAttrs) {
          this._setColor(context, "fill", fill || fillStyle);
        } else if ("fill" in attrs) {
          this._setColor(context, "fill", fill);
        } else if ("fillStyle" in attrs) {
          this._setColor(context, "fill", fillStyle);
        }
        if (fillOpacity) {
          el.setAttribute(SVG_ATTR_MAP["fillOpacity"], fillOpacity);
        }
      }
      if (this.canStroke && lineWidth > 0) {
        if (!targetAttrs) {
          this._setColor(context, "stroke", stroke || strokeStyle);
        } else if ("stroke" in attrs) {
          this._setColor(context, "stroke", stroke);
        } else if ("strokeStyle" in attrs) {
          this._setColor(context, "stroke", strokeStyle);
        }
        if (strokeOpacity) {
          el.setAttribute(SVG_ATTR_MAP["strokeOpacity"], strokeOpacity);
        }
        if (lineWidth) {
          el.setAttribute(SVG_ATTR_MAP["lineWidth"], lineWidth);
        }
      }
    };
    ShapeBase2.prototype._setColor = function(context, attr, value2) {
      var el = this.get("el");
      if (!value2) {
        el.setAttribute(SVG_ATTR_MAP[attr], "none");
        return;
      }
      value2 = value2.trim();
      if (/^[r,R,L,l]{1}[\s]*\(/.test(value2)) {
        var id2 = context.find("gradient", value2);
        if (!id2) {
          id2 = context.addGradient(value2);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
      } else if (/^[p,P]{1}[\s]*\(/.test(value2)) {
        var id2 = context.find("pattern", value2);
        if (!id2) {
          id2 = context.addPattern(value2);
        }
        el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
      } else {
        el.setAttribute(SVG_ATTR_MAP[attr], value2);
      }
    };
    ShapeBase2.prototype.shadow = function(context, targetAttrs) {
      var attrs = this.attr();
      var _a2 = targetAttrs || attrs, shadowOffsetX = _a2.shadowOffsetX, shadowOffsetY = _a2.shadowOffsetY, shadowBlur = _a2.shadowBlur, shadowColor = _a2.shadowColor;
      if (shadowOffsetX || shadowOffsetY || shadowBlur || shadowColor) {
        setShadow(this, context);
      }
    };
    ShapeBase2.prototype.transform = function(targetAttrs) {
      var attrs = this.attr();
      var matrix = (targetAttrs || attrs).matrix;
      if (matrix) {
        setTransform(this);
      }
    };
    ShapeBase2.prototype.isInShape = function(refX, refY) {
      return this.isPointInPath(refX, refY);
    };
    ShapeBase2.prototype.isPointInPath = function(refX, refY) {
      var el = this.get("el");
      var canvas = this.get("canvas");
      var bbox = canvas.get("el").getBoundingClientRect();
      var clientX = refX + bbox.left;
      var clientY = refY + bbox.top;
      var element = document.elementFromPoint(clientX, clientY);
      if (element && element.isEqualNode(el)) {
        return true;
      }
      return false;
    };
    ShapeBase2.prototype.getHitLineWidth = function() {
      var _a2 = this.attrs, lineWidth = _a2.lineWidth, lineAppendWidth = _a2.lineAppendWidth;
      if (this.isStroke()) {
        return lineWidth + lineAppendWidth;
      }
      return 0;
    };
    return ShapeBase2;
  }(AbstractShape)
);
var Circle$1 = (
  /** @class */
  function(_super) {
    __extends$1(Circle2, _super);
    function Circle2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "circle";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Circle2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, r: 0 });
    };
    Circle2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value2);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    return Circle2;
  }(ShapeBase)
);
var Dom = (
  /** @class */
  function(_super) {
    __extends$1(Dom2, _super);
    function Dom2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "dom";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Dom2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
      if (typeof attrs["html"] === "function") {
        var element = attrs["html"].call(this, attrs);
        if (element instanceof Element || element instanceof HTMLDocument) {
          var children = el.childNodes;
          for (var i = children.length - 1; i >= 0; i--) {
            el.removeChild(children[i]);
          }
          el.appendChild(element);
        } else {
          el.innerHTML = element;
        }
      } else {
        el.innerHTML = attrs["html"];
      }
    };
    return Dom2;
  }(ShapeBase)
);
var Ellipse = (
  /** @class */
  function(_super) {
    __extends$1(Ellipse2, _super);
    function Ellipse2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ellipse";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Ellipse2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, rx: 0, ry: 0 });
    };
    Ellipse2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "x" || attr === "y") {
          el.setAttribute("c" + attr, value2);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    return Ellipse2;
  }(ShapeBase)
);
var Image$1 = (
  /** @class */
  function(_super) {
    __extends$1(Image2, _super);
    function Image2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "image";
      _this.canFill = false;
      _this.canStroke = false;
      return _this;
    }
    Image2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0 });
    };
    Image2.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "img") {
          _this._setImage(attrs.img);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Image2.prototype.setAttr = function(name, value2) {
      this.attrs[name] = value2;
      if (name === "img") {
        this._setImage(value2);
      }
    };
    Image2.prototype._setImage = function(img) {
      var attrs = this.attr();
      var el = this.get("el");
      if (isString(img)) {
        el.setAttribute("href", img);
      } else if (img instanceof window.Image) {
        if (!attrs.width) {
          el.setAttribute("width", img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", img.src);
      } else if (img instanceof HTMLElement && isString(img.nodeName) && img.nodeName.toUpperCase() === "CANVAS") {
        el.setAttribute("href", img.toDataURL());
      } else if (img instanceof ImageData) {
        var canvas = document.createElement("canvas");
        canvas.setAttribute("width", "" + img.width);
        canvas.setAttribute("height", "" + img.height);
        canvas.getContext("2d").putImageData(img, 0, 0);
        if (!attrs.width) {
          el.setAttribute("width", "" + img.width);
          this.attr("width", img.width);
        }
        if (!attrs.height) {
          el.setAttribute("height", "" + img.height);
          this.attr("height", img.height);
        }
        el.setAttribute("href", canvas.toDataURL());
      }
    };
    return Image2;
  }(ShapeBase)
);
var Line$2 = (
  /** @class */
  function(_super) {
    __extends$1(Line2, _super);
    function Line2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      _this.canFill = false;
      _this.canStroke = true;
      return _this;
    }
    Line2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x1: 0, y1: 0, x2: 0, y2: 0, startArrow: false, endArrow: false });
    };
    Line2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "startArrow" || attr === "endArrow") {
          if (value2) {
            var id2 = isObject(value2) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Line2.prototype.getTotalLength = function() {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
      return LineUtil.length(x1, y1, x2, y2);
    };
    Line2.prototype.getPoint = function(ratio) {
      var _a2 = this.attr(), x1 = _a2.x1, y1 = _a2.y1, x2 = _a2.x2, y2 = _a2.y2;
      return LineUtil.pointAt(x1, y1, x2, y2, ratio);
    };
    return Line2;
  }(ShapeBase)
);
var Symbols = {
  // 
  circle: function(x, y, r) {
    return [
      ["M", x, y],
      ["m", -r, 0],
      ["a", r, r, 0, 1, 0, r * 2, 0],
      ["a", r, r, 0, 1, 0, -r * 2, 0]
    ];
  },
  // 
  square: function(x, y, r) {
    return [["M", x - r, y - r], ["L", x + r, y - r], ["L", x + r, y + r], ["L", x - r, y + r], ["Z"]];
  },
  // 
  diamond: function(x, y, r) {
    return [["M", x - r, y], ["L", x, y - r], ["L", x + r, y], ["L", x, y + r], ["Z"]];
  },
  // 
  triangle: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y + diffY], ["L", x, y - diffY], ["L", x + r, y + diffY], ["z"]];
  },
  // 
  triangleDown: function(x, y, r) {
    var diffY = r * Math.sin(1 / 3 * Math.PI);
    return [["M", x - r, y - diffY], ["L", x + r, y - diffY], ["L", x, y + diffY], ["Z"]];
  }
};
const symbolsFactory = {
  get: function(type) {
    return Symbols[type];
  },
  register: function(type, func) {
    Symbols[type] = func;
  },
  remove: function(type) {
    delete Symbols[type];
  },
  getAll: function() {
    return Symbols;
  }
};
var Marker = (
  /** @class */
  function(_super) {
    __extends$1(Marker2, _super);
    function Marker2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "marker";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Marker2.prototype.createPath = function(context) {
      var el = this.get("el");
      el.setAttribute("d", this._assembleMarker());
    };
    Marker2.prototype._assembleMarker = function() {
      var d = this._getPath();
      if (isArray$1(d)) {
        return d.map(function(path2) {
          return path2.join(" ");
        }).join("");
      }
      return d;
    };
    Marker2.prototype._getPath = function() {
      var attrs = this.attr();
      var x = attrs.x, y = attrs.y;
      var r = attrs.r || attrs.radius;
      var symbol = attrs.symbol || "circle";
      var method;
      if (isFunction(symbol)) {
        method = symbol;
      } else {
        method = symbolsFactory.get(symbol);
      }
      if (!method) {
        console.warn(method + " symbol is not exist.");
        return null;
      }
      return method(x, y, r);
    };
    Marker2.symbolsFactory = symbolsFactory;
    return Marker2;
  }(ShapeBase)
);
var Path$1 = (
  /** @class */
  function(_super) {
    __extends$1(Path2, _super);
    function Path2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "path";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Path2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
    };
    Path2.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "path" && isArray$1(value2)) {
          el.setAttribute("d", _this._formatPath(value2));
        } else if (attr === "startArrow" || attr === "endArrow") {
          if (value2) {
            var id2 = isObject(value2) ? context.addArrow(attrs, SVG_ATTR_MAP[attr]) : context.getDefaultArrow(attrs, SVG_ATTR_MAP[attr]);
            el.setAttribute(SVG_ATTR_MAP[attr], "url(#" + id2 + ")");
          } else {
            el.removeAttribute(SVG_ATTR_MAP[attr]);
          }
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Path2.prototype._formatPath = function(value2) {
      var newValue = value2.map(function(path2) {
        return path2.join(" ");
      }).join("");
      if (~newValue.indexOf("NaN")) {
        return "";
      }
      return newValue;
    };
    Path2.prototype.getTotalLength = function() {
      var el = this.get("el");
      return el ? el.getTotalLength() : null;
    };
    Path2.prototype.getPoint = function(ratio) {
      var el = this.get("el");
      var totalLength = this.getTotalLength();
      if (totalLength === 0) {
        return null;
      }
      var point2 = el ? el.getPointAtLength(ratio * totalLength) : null;
      return point2 ? {
        x: point2.x,
        y: point2.y
      } : null;
    };
    return Path2;
  }(ShapeBase)
);
var Polygon$1 = (
  /** @class */
  function(_super) {
    __extends$1(Polygon2, _super);
    function Polygon2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polygon2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "points" && isArray$1(value2) && value2.length >= 2) {
          el.setAttribute("points", value2.map(function(point2) {
            return point2[0] + "," + point2[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    return Polygon2;
  }(ShapeBase)
);
var Polyline = (
  /** @class */
  function(_super) {
    __extends$1(Polyline2, _super);
    function Polyline2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polyline";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Polyline2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { startArrow: false, endArrow: false });
    };
    Polyline2.prototype.onAttrChange = function(name, value2, originValue) {
      _super.prototype.onAttrChange.call(this, name, value2, originValue);
      if (["points"].indexOf(name) !== -1) {
        this._resetCache();
      }
    };
    Polyline2.prototype._resetCache = function() {
      this.set("totalLength", null);
      this.set("tCache", null);
    };
    Polyline2.prototype.createPath = function(context, targetAttrs) {
      var attrs = this.attr();
      var el = this.get("el");
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "points" && isArray$1(value2) && value2.length >= 2) {
          el.setAttribute("points", value2.map(function(point2) {
            return point2[0] + "," + point2[1];
          }).join(" "));
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Polyline2.prototype.getTotalLength = function() {
      var points2 = this.attr().points;
      var totalLength = this.get("totalLength");
      if (!isNil(totalLength)) {
        return totalLength;
      }
      this.set("totalLength", PolylineUtil.length(points2));
      return this.get("totalLength");
    };
    Polyline2.prototype.getPoint = function(ratio) {
      var points2 = this.attr().points;
      var tCache = this.get("tCache");
      if (!tCache) {
        this._setTcache();
        tCache = this.get("tCache");
      }
      var subt;
      var index2;
      each$1(tCache, function(v, i) {
        if (ratio >= v[0] && ratio <= v[1]) {
          subt = (ratio - v[0]) / (v[1] - v[0]);
          index2 = i;
        }
      });
      return LineUtil.pointAt(points2[index2][0], points2[index2][1], points2[index2 + 1][0], points2[index2 + 1][1], subt);
    };
    Polyline2.prototype._setTcache = function() {
      var points2 = this.attr().points;
      if (!points2 || points2.length === 0) {
        return;
      }
      var totalLength = this.getTotalLength();
      if (totalLength <= 0) {
        return;
      }
      var tempLength = 0;
      var tCache = [];
      var segmentT;
      var segmentL;
      each$1(points2, function(p, i) {
        if (points2[i + 1]) {
          segmentT = [];
          segmentT[0] = tempLength / totalLength;
          segmentL = LineUtil.length(p[0], p[1], points2[i + 1][0], points2[i + 1][1]);
          tempLength += segmentL;
          segmentT[1] = tempLength / totalLength;
          tCache.push(segmentT);
        }
      });
      this.set("tCache", tCache);
    };
    Polyline2.prototype.getStartTangent = function() {
      var points2 = this.attr().points;
      var result = [];
      result.push([points2[1][0], points2[1][1]]);
      result.push([points2[0][0], points2[0][1]]);
      return result;
    };
    Polyline2.prototype.getEndTangent = function() {
      var points2 = this.attr().points;
      var l = points2.length - 1;
      var result = [];
      result.push([points2[l - 1][0], points2[l - 1][1]]);
      result.push([points2[l][0], points2[l][1]]);
      return result;
    };
    return Polyline2;
  }(ShapeBase)
);
function parseRadius$1(radius) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  return {
    r1,
    r2,
    r3,
    r4
  };
}
var Rect$1 = (
  /** @class */
  function(_super) {
    __extends$1(Rect2, _super);
    function Rect2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "rect";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Rect2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, width: 0, height: 0, radius: 0 });
    };
    Rect2.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      var completed = false;
      var pathRelatedAttrs = ["x", "y", "width", "height", "radius"];
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (pathRelatedAttrs.indexOf(attr) !== -1 && !completed) {
          el.setAttribute("d", _this._assembleRect(attrs));
          completed = true;
        } else if (pathRelatedAttrs.indexOf(attr) === -1 && SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
    };
    Rect2.prototype._assembleRect = function(attrs) {
      var x = attrs.x;
      var y = attrs.y;
      var w = attrs.width;
      var h = attrs.height;
      var radius = attrs.radius;
      if (!radius) {
        return "M " + x + "," + y + " l " + w + ",0 l 0," + h + " l" + -w + " 0 z";
      }
      var r = parseRadius$1(radius);
      if (isArray$1(radius)) {
        if (radius.length === 1) {
          r.r1 = r.r2 = r.r3 = r.r4 = radius[0];
        } else if (radius.length === 2) {
          r.r1 = r.r3 = radius[0];
          r.r2 = r.r4 = radius[1];
        } else if (radius.length === 3) {
          r.r1 = radius[0];
          r.r2 = r.r4 = radius[1];
          r.r3 = radius[2];
        } else {
          r.r1 = radius[0];
          r.r2 = radius[1];
          r.r3 = radius[2];
          r.r4 = radius[3];
        }
      } else {
        r.r1 = r.r2 = r.r3 = r.r4 = radius;
      }
      var d = [
        ["M " + (x + r.r1) + "," + y],
        ["l " + (w - r.r1 - r.r2) + ",0"],
        ["a " + r.r2 + "," + r.r2 + ",0,0,1," + r.r2 + "," + r.r2],
        ["l 0," + (h - r.r2 - r.r3)],
        ["a " + r.r3 + "," + r.r3 + ",0,0,1," + -r.r3 + "," + r.r3],
        ["l " + (r.r3 + r.r4 - w) + ",0"],
        ["a " + r.r4 + "," + r.r4 + ",0,0,1," + -r.r4 + "," + -r.r4],
        ["l 0," + (r.r4 + r.r1 - h)],
        ["a " + r.r1 + "," + r.r1 + ",0,0,1," + r.r1 + "," + -r.r1],
        ["z"]
      ];
      return d.join(" ");
    };
    return Rect2;
  }(ShapeBase)
);
var LETTER_SPACING = 0.3;
var BASELINE_MAP = {
  top: "before-edge",
  middle: "central",
  bottom: "after-edge",
  alphabetic: "baseline",
  hanging: "hanging"
};
var BASELINE_MAP_FOR_FIREFOX = {
  top: "text-before-edge",
  middle: "central",
  bottom: "text-after-edge",
  alphabetic: "alphabetic",
  hanging: "hanging"
};
var ANCHOR_MAP = {
  left: "left",
  start: "left",
  center: "middle",
  right: "end",
  end: "end"
};
var Text = (
  /** @class */
  function(_super) {
    __extends$1(Text2, _super);
    function Text2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "text";
      _this.canFill = true;
      _this.canStroke = true;
      return _this;
    }
    Text2.prototype.getDefaultAttrs = function() {
      var attrs = _super.prototype.getDefaultAttrs.call(this);
      return __assign$1(__assign$1({}, attrs), { x: 0, y: 0, text: null, fontSize: 12, fontFamily: "sans-serif", fontStyle: "normal", fontWeight: "normal", fontVariant: "normal", textAlign: "start", textBaseline: "bottom" });
    };
    Text2.prototype.createPath = function(context, targetAttrs) {
      var _this = this;
      var attrs = this.attr();
      var el = this.get("el");
      this._setFont();
      each$1(targetAttrs || attrs, function(value2, attr) {
        if (attr === "text") {
          _this._setText("" + value2);
        } else if (attr === "matrix" && value2) {
          setTransform(_this);
        } else if (SVG_ATTR_MAP[attr]) {
          el.setAttribute(SVG_ATTR_MAP[attr], value2);
        }
      });
      el.setAttribute("paint-order", "stroke");
      el.setAttribute("style", "stroke-linecap:butt; stroke-linejoin:miter;");
    };
    Text2.prototype._setFont = function() {
      var el = this.get("el");
      var _a2 = this.attr(), textBaseline = _a2.textBaseline, textAlign = _a2.textAlign;
      var browser2 = detect();
      if (browser2 && browser2.name === "firefox") {
        el.setAttribute("dominant-baseline", BASELINE_MAP_FOR_FIREFOX[textBaseline] || "alphabetic");
      } else {
        el.setAttribute("alignment-baseline", BASELINE_MAP[textBaseline] || "baseline");
      }
      el.setAttribute("text-anchor", ANCHOR_MAP[textAlign] || "left");
    };
    Text2.prototype._setText = function(text2) {
      var el = this.get("el");
      var _a2 = this.attr(), x = _a2.x, _b = _a2.textBaseline, baseline = _b === void 0 ? "bottom" : _b;
      if (!text2) {
        el.innerHTML = "";
      } else if (~text2.indexOf("\n")) {
        var textArr = text2.split("\n");
        var textLen_1 = textArr.length - 1;
        var arr_1 = "";
        each$1(textArr, function(segment, i) {
          if (i === 0) {
            if (baseline === "alphabetic") {
              arr_1 += '<tspan x="' + x + '" dy="' + -textLen_1 + 'em">' + segment + "</tspan>";
            } else if (baseline === "top") {
              arr_1 += '<tspan x="' + x + '" dy="0.9em">' + segment + "</tspan>";
            } else if (baseline === "middle") {
              arr_1 += '<tspan x="' + x + '" dy="' + -(textLen_1 - 1) / 2 + 'em">' + segment + "</tspan>";
            } else if (baseline === "bottom") {
              arr_1 += '<tspan x="' + x + '" dy="-' + (textLen_1 + LETTER_SPACING) + 'em">' + segment + "</tspan>";
            } else if (baseline === "hanging") {
              arr_1 += '<tspan x="' + x + '" dy="' + (-(textLen_1 - 1) - LETTER_SPACING) + 'em">' + segment + "</tspan>";
            }
          } else {
            arr_1 += '<tspan x="' + x + '" dy="1em">' + segment + "</tspan>";
          }
        });
        el.innerHTML = arr_1;
      } else {
        el.innerHTML = text2;
      }
    };
    return Text2;
  }(ShapeBase)
);
var regexLG = /^l\s*\(\s*([\d.]+)\s*\)\s*(.*)/i;
var regexRG = /^r\s*\(\s*([\d.]+)\s*,\s*([\d.]+)\s*,\s*([\d.]+)\s*\)\s*(.*)/i;
var regexColorStop = /[\d.]+:(#[^\s]+|[^)]+\))/gi;
function addStop(steps) {
  var arr = steps.match(regexColorStop);
  if (!arr) {
    return "";
  }
  var stops = "";
  arr.sort(function(a, b) {
    a = a.split(":");
    b = b.split(":");
    return Number(a[0]) - Number(b[0]);
  });
  each$1(arr, function(item) {
    item = item.split(":");
    stops += '<stop offset="' + item[0] + '" stop-color="' + item[1] + '"></stop>';
  });
  return stops;
}
function parseLineGradient(color2, el) {
  var arr = regexLG.exec(color2);
  var angle2 = mod$1(toRadian(parseFloat(arr[1])), Math.PI * 2);
  var steps = arr[2];
  var start;
  var end;
  if (angle2 >= 0 && angle2 < 0.5 * Math.PI) {
    start = {
      x: 0,
      y: 0
    };
    end = {
      x: 1,
      y: 1
    };
  } else if (0.5 * Math.PI <= angle2 && angle2 < Math.PI) {
    start = {
      x: 1,
      y: 0
    };
    end = {
      x: 0,
      y: 1
    };
  } else if (Math.PI <= angle2 && angle2 < 1.5 * Math.PI) {
    start = {
      x: 1,
      y: 1
    };
    end = {
      x: 0,
      y: 0
    };
  } else {
    start = {
      x: 0,
      y: 1
    };
    end = {
      x: 1,
      y: 0
    };
  }
  var tanTheta = Math.tan(angle2);
  var tanTheta2 = tanTheta * tanTheta;
  var x = (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.x;
  var y = tanTheta * (end.x - start.x + tanTheta * (end.y - start.y)) / (tanTheta2 + 1) + start.y;
  el.setAttribute("x1", start.x);
  el.setAttribute("y1", start.y);
  el.setAttribute("x2", x);
  el.setAttribute("y2", y);
  el.innerHTML = addStop(steps);
}
function parseRadialGradient(color2, self2) {
  var arr = regexRG.exec(color2);
  var cx = parseFloat(arr[1]);
  var cy = parseFloat(arr[2]);
  var r = parseFloat(arr[3]);
  var steps = arr[4];
  self2.setAttribute("cx", cx);
  self2.setAttribute("cy", cy);
  self2.setAttribute("r", r);
  self2.innerHTML = addStop(steps);
}
var Gradient = (
  /** @class */
  function() {
    function Gradient2(cfg) {
      this.cfg = {};
      var el = null;
      var id2 = uniqueId("gradient_");
      if (cfg.toLowerCase()[0] === "l") {
        el = createSVGElement("linearGradient");
        parseLineGradient(cfg, el);
      } else {
        el = createSVGElement("radialGradient");
        parseRadialGradient(cfg, el);
      }
      el.setAttribute("id", id2);
      this.el = el;
      this.id = id2;
      this.cfg = cfg;
      return this;
    }
    Gradient2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Gradient2;
  }()
);
var ATTR_MAP = {
  shadowColor: "color",
  shadowOpacity: "opacity",
  shadowBlur: "blur",
  shadowOffsetX: "dx",
  shadowOffsetY: "dy"
};
var SHADOW_DIMENSION = {
  x: "-40%",
  y: "-40%",
  width: "200%",
  height: "200%"
};
var Shadow = (
  /** @class */
  function() {
    function Shadow2(cfg) {
      this.type = "filter";
      this.cfg = {};
      this.type = "filter";
      var el = createSVGElement("filter");
      each$1(SHADOW_DIMENSION, function(v, k) {
        el.setAttribute(k, v);
      });
      this.el = el;
      this.id = uniqueId("filter_");
      this.el.id = this.id;
      this.cfg = cfg;
      this._parseShadow(cfg, el);
      return this;
    }
    Shadow2.prototype.match = function(type, cfg) {
      if (this.type !== type) {
        return false;
      }
      var flag = true;
      var config = this.cfg;
      each$1(Object.keys(config), function(attr) {
        if (config[attr] !== cfg[attr]) {
          flag = false;
          return false;
        }
      });
      return flag;
    };
    Shadow2.prototype.update = function(name, value2) {
      var config = this.cfg;
      config[ATTR_MAP[name]] = value2;
      this._parseShadow(config, this.el);
      return this;
    };
    Shadow2.prototype._parseShadow = function(config, el) {
      var child = '<feDropShadow\n      dx="' + (config.dx || 0) + '"\n      dy="' + (config.dy || 0) + '"\n      stdDeviation="' + (config.blur ? config.blur / 10 : 0) + '"\n      flood-color="' + (config.color ? config.color : "#000") + '"\n      flood-opacity="' + (config.opacity ? config.opacity : 1) + '"\n      />';
      el.innerHTML = child;
    };
    return Shadow2;
  }()
);
var Arrow = (
  /** @class */
  function() {
    function Arrow2(attrs, type) {
      this.cfg = {};
      var el = createSVGElement("marker");
      var id2 = uniqueId("marker_");
      el.setAttribute("id", id2);
      var shape = createSVGElement("path");
      shape.setAttribute("stroke", attrs.stroke || "none");
      shape.setAttribute("fill", attrs.fill || "none");
      el.appendChild(shape);
      el.setAttribute("overflow", "visible");
      el.setAttribute("orient", "auto-start-reverse");
      this.el = el;
      this.child = shape;
      this.id = id2;
      var cfg = attrs[type === "marker-start" ? "startArrow" : "endArrow"];
      this.stroke = attrs.stroke || "#000";
      if (cfg === true) {
        this._setDefaultPath(type, shape);
      } else {
        this.cfg = cfg;
        this._setMarker(attrs.lineWidth, shape);
      }
      return this;
    }
    Arrow2.prototype.match = function() {
      return false;
    };
    Arrow2.prototype._setDefaultPath = function(type, el) {
      var parent = this.el;
      el.setAttribute("d", "M0,0 L" + 10 * Math.cos(Math.PI / 6) + ",5 L0,10");
      parent.setAttribute("refX", "" + 10 * Math.cos(Math.PI / 6));
      parent.setAttribute("refY", "5");
    };
    Arrow2.prototype._setMarker = function(r, el) {
      var parent = this.el;
      var path2 = this.cfg.path;
      var d = this.cfg.d;
      if (isArray$1(path2)) {
        path2 = path2.map(function(segment) {
          return segment.join(" ");
        }).join("");
      }
      el.setAttribute("d", path2);
      parent.appendChild(el);
      if (d) {
        parent.setAttribute("refX", "" + d / r);
      }
    };
    Arrow2.prototype.update = function(fill) {
      var child = this.child;
      if (child.attr) {
        child.attr("fill", fill);
      } else {
        child.setAttribute("fill", fill);
      }
    };
    return Arrow2;
  }()
);
var Clip = (
  /** @class */
  function() {
    function Clip2(cfg) {
      this.type = "clip";
      this.cfg = {};
      var el = createSVGElement("clipPath");
      this.el = el;
      this.id = uniqueId("clip_");
      el.id = this.id;
      var shapeEl = cfg.cfg.el;
      el.appendChild(shapeEl);
      this.cfg = cfg;
      return this;
    }
    Clip2.prototype.match = function() {
      return false;
    };
    Clip2.prototype.remove = function() {
      var el = this.el;
      el.parentNode.removeChild(el);
    };
    return Clip2;
  }()
);
var regexPR = /^p\s*\(\s*([axyn])\s*\)\s*(.*)/i;
var Pattern = (
  /** @class */
  function() {
    function Pattern2(cfg) {
      this.cfg = {};
      var el = createSVGElement("pattern");
      el.setAttribute("patternUnits", "userSpaceOnUse");
      var child = createSVGElement("image");
      el.appendChild(child);
      var id2 = uniqueId("pattern_");
      el.id = id2;
      this.el = el;
      this.id = id2;
      this.cfg = cfg;
      var arr = regexPR.exec(cfg);
      var source = arr[2];
      child.setAttribute("href", source);
      var img = new Image();
      if (!source.match(/^data:/i)) {
        img.crossOrigin = "Anonymous";
      }
      img.src = source;
      function onload() {
        el.setAttribute("width", "" + img.width);
        el.setAttribute("height", "" + img.height);
      }
      if (img.complete) {
        onload();
      } else {
        img.onload = onload;
        img.src = img.src;
      }
      return this;
    }
    Pattern2.prototype.match = function(type, attr) {
      return this.cfg === attr;
    };
    return Pattern2;
  }()
);
var Defs = (
  /** @class */
  function() {
    function Defs2(canvas) {
      var el = createSVGElement("defs");
      var id2 = uniqueId("defs_");
      el.id = id2;
      canvas.appendChild(el);
      this.children = [];
      this.defaultArrow = {};
      this.el = el;
      this.canvas = canvas;
    }
    Defs2.prototype.find = function(type, attr) {
      var children = this.children;
      var result = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].match(type, attr)) {
          result = children[i].id;
          break;
        }
      }
      return result;
    };
    Defs2.prototype.findById = function(id2) {
      var children = this.children;
      var flag = null;
      for (var i = 0; i < children.length; i++) {
        if (children[i].id === id2) {
          flag = children[i];
          break;
        }
      }
      return flag;
    };
    Defs2.prototype.add = function(item) {
      this.children.push(item);
      item.canvas = this.canvas;
      item.parent = this;
    };
    Defs2.prototype.getDefaultArrow = function(attrs, name) {
      var stroke = attrs.stroke || attrs.strokeStyle;
      if (this.defaultArrow[stroke]) {
        return this.defaultArrow[stroke].id;
      }
      var arrow = new Arrow(attrs, name);
      this.defaultArrow[stroke] = arrow;
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addGradient = function(cfg) {
      var gradient2 = new Gradient(cfg);
      this.el.appendChild(gradient2.el);
      this.add(gradient2);
      return gradient2.id;
    };
    Defs2.prototype.addArrow = function(attrs, name) {
      var arrow = new Arrow(attrs, name);
      this.el.appendChild(arrow.el);
      this.add(arrow);
      return arrow.id;
    };
    Defs2.prototype.addShadow = function(cfg) {
      var shadow = new Shadow(cfg);
      this.el.appendChild(shadow.el);
      this.add(shadow);
      return shadow.id;
    };
    Defs2.prototype.addPattern = function(cfg) {
      var pattern2 = new Pattern(cfg);
      this.el.appendChild(pattern2.el);
      this.add(pattern2);
      return pattern2.id;
    };
    Defs2.prototype.addClip = function(cfg) {
      var clip = new Clip(cfg);
      this.el.appendChild(clip.el);
      this.add(clip);
      return clip.id;
    };
    return Defs2;
  }()
);
var Canvas = (
  /** @class */
  function(_super) {
    __extends$1(Canvas2, _super);
    function Canvas2(cfg) {
      return _super.call(this, __assign$1(__assign$1({}, cfg), {
        autoDraw: true,
        //  canvas
        renderer: "svg"
      })) || this;
    }
    Canvas2.prototype.getShapeBase = function() {
      return Shape;
    };
    Canvas2.prototype.getGroupBase = function() {
      return Group;
    };
    Canvas2.prototype.getShape = function(x, y, ev) {
      var target2 = ev.target || ev.srcElement;
      if (!SHAPE_TO_TAGS[target2.tagName]) {
        var parent_1 = target2.parentNode;
        while (parent_1 && !SHAPE_TO_TAGS[parent_1.tagName]) {
          parent_1 = parent_1.parentNode;
        }
        target2 = parent_1;
      }
      return this.find(function(child) {
        return child.get("el") === target2;
      });
    };
    Canvas2.prototype.createDom = function() {
      var element = createSVGElement("svg");
      var context = new Defs(element);
      element.setAttribute("width", "" + this.get("width"));
      element.setAttribute("height", "" + this.get("height"));
      this.set("context", context);
      return element;
    };
    Canvas2.prototype.onCanvasChange = function(changeType) {
      var context = this.get("context");
      var el = this.get("el");
      if (changeType === "sort") {
        var children_1 = this.get("children");
        if (children_1 && children_1.length) {
          sortDom(this, function(a, b) {
            return children_1.indexOf(a) - children_1.indexOf(b) ? 1 : 0;
          });
        }
      } else if (changeType === "clear") {
        if (el) {
          el.innerHTML = "";
          var defsEl = context.el;
          defsEl.innerHTML = "";
          el.appendChild(defsEl);
        }
      } else if (changeType === "matrix") {
        setTransform(this);
      } else if (changeType === "clip") {
        setClip(this, context);
      } else if (changeType === "changeSize") {
        el.setAttribute("width", "" + this.get("width"));
        el.setAttribute("height", "" + this.get("height"));
      }
    };
    Canvas2.prototype.draw = function() {
      var context = this.get("context");
      var children = this.getChildren();
      setClip(this, context);
      if (children.length) {
        drawChildren(context, children);
      }
    };
    return Canvas2;
  }(Canvas$2)
);
var version = "0.5.6";
const SVGEngine = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  AbstractCanvas: Canvas$2,
  AbstractGroup,
  AbstractShape,
  Base,
  Canvas,
  Event: GraphEvent,
  Group,
  PathUtil: PathUtil$1,
  Shape,
  assembleFont,
  getBBoxMethod: getMethod,
  getOffScreenContext,
  getTextHeight,
  invert,
  isAllowCapture,
  multiplyVec2: multiplyVec2$1,
  registerBBox: register,
  registerEasing,
  version
}, Symbol.toStringTag, { value: "Module" }));
var Path = (
  /** @class */
  function(_super) {
    __extends$1(Path2, _super);
    function Path2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "path";
      _this.shapeType = "line";
      var _a2 = cfg.connectNulls, connectNulls = _a2 === void 0 ? false : _a2, _b = cfg.showSinglePoint, showSinglePoint = _b === void 0 ? true : _b;
      _this.connectNulls = connectNulls;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Path2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      var e_1, _a2, e_2, _b, e_3, _c;
      if (isUpdate === void 0) {
        isUpdate = false;
      }
      var keyData = /* @__PURE__ */ new Map();
      var keyIndex = /* @__PURE__ */ new Map();
      var keys2 = [];
      var index2 = 0;
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var key = this.getElementId(mappingData);
        keys2.push(key);
        keyData.set(key, mappingData);
        keyIndex.set(key, index2);
        index2++;
      }
      this.elements = new Array(index2);
      var _d = diff(this.lastElementsMap, keys2), added = _d.added, updated = _d.updated, removed = _d.removed;
      try {
        for (var added_1 = __values(added), added_1_1 = added_1.next(); !added_1_1.done; added_1_1 = added_1.next()) {
          var key = added_1_1.value;
          var mappingData = keyData.get(key);
          var shapeFactory = this.getShapeFactory();
          var shapeCfg = this.getShapeInfo(mappingData);
          var i = keyIndex.get(key);
          var element = new Element$1({
            shapeFactory,
            container: this.container,
            offscreenGroup: this.getOffscreenGroup(),
            elementIndex: i
          });
          element.geometry = this;
          element.animate = this.animateOption;
          element.draw(shapeCfg, isUpdate);
          this.elementsMap[key] = element;
          this.elements[i] = element;
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (added_1_1 && !added_1_1.done && (_a2 = added_1.return))
            _a2.call(added_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      try {
        for (var updated_1 = __values(updated), updated_1_1 = updated_1.next(); !updated_1_1.done; updated_1_1 = updated_1.next()) {
          var key = updated_1_1.value;
          var mappingData = keyData.get(key);
          var element = this.lastElementsMap[key];
          var i = keyIndex.get(key);
          var shapeCfg = this.getShapeInfo(mappingData);
          var preShapeCfg = element.getModel();
          if (this.isCoordinateChanged || isModelChange(preShapeCfg, shapeCfg)) {
            element.animate = this.animateOption;
            element.update(shapeCfg);
          }
          this.elementsMap[key] = element;
          this.elements[i] = element;
        }
      } catch (e_2_1) {
        e_2 = { error: e_2_1 };
      } finally {
        try {
          if (updated_1_1 && !updated_1_1.done && (_b = updated_1.return))
            _b.call(updated_1);
        } finally {
          if (e_2)
            throw e_2.error;
        }
      }
      try {
        for (var removed_1 = __values(removed), removed_1_1 = removed_1.next(); !removed_1_1.done; removed_1_1 = removed_1.next()) {
          var key = removed_1_1.value;
          var element = this.lastElementsMap[key];
          element.animate = this.animateOption;
          element.destroy();
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (removed_1_1 && !removed_1_1.done && (_c = removed_1.return))
            _c.call(removed_1);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
    };
    Path2.prototype.getPointsAndData = function(mappingData) {
      var points2 = [];
      var data2 = [];
      for (var i = 0, len = mappingData.length; i < len; i++) {
        var obj = mappingData[i];
        points2.push({
          x: obj.x,
          y: obj.y
        });
        data2.push(obj[FIELD_ORIGIN]);
      }
      return {
        points: points2,
        data: data2
      };
    };
    Path2.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var _a2 = this.getPointsAndData(mappingData), points2 = _a2.points, data2 = _a2.data;
      shapeCfg.mappingData = mappingData;
      shapeCfg.data = data2;
      shapeCfg.isStack = !!this.getAdjust("stack");
      shapeCfg.points = points2;
      shapeCfg.connectNulls = this.connectNulls;
      shapeCfg.showSinglePoint = this.showSinglePoint;
      return shapeCfg;
    };
    return Path2;
  }(Geometry)
);
function getPath$2(points2, isInCircle, smooth, registeredShape, constraint) {
  var path2 = [];
  if (points2.length) {
    var topLinePoints_1 = [];
    var bottomLinePoints_1 = [];
    for (var i = 0, len = points2.length; i < len; i++) {
      var point2 = points2[i];
      topLinePoints_1.push(point2[1]);
      bottomLinePoints_1.push(point2[0]);
    }
    bottomLinePoints_1 = bottomLinePoints_1.reverse();
    each$1([topLinePoints_1, bottomLinePoints_1], function(pointsData, index2) {
      var subPath = [];
      var parsedPoints = registeredShape.parsePoints(pointsData);
      var p1 = parsedPoints[0];
      if (topLinePoints_1.length === 1 && bottomLinePoints_1.length === 1) {
        subPath = index2 === 0 ? [
          ["M", p1.x - 0.5, p1.y],
          ["L", p1.x + 0.5, p1.y]
        ] : [
          ["L", p1.x + 0.5, p1.y],
          ["L", p1.x - 0.5, p1.y]
        ];
      } else {
        if (isInCircle) {
          parsedPoints.push({ x: p1.x, y: p1.y });
        }
        if (smooth) {
          subPath = getSplinePath$1(parsedPoints, false, constraint);
        } else {
          subPath = getLinePath(parsedPoints, false);
        }
        if (index2 > 0) {
          subPath[0][0] = "L";
        }
      }
      path2 = path2.concat(subPath);
    });
    path2.push(["Z"]);
  }
  return path2;
}
function getShapeAttrs(cfg, isStroke, smooth, registeredShape, constraint) {
  var attrs = getStyle(cfg, isStroke, !isStroke, "lineWidth");
  var connectNulls = cfg.connectNulls, isInCircle = cfg.isInCircle, points2 = cfg.points, showSinglePoint = cfg.showSinglePoint;
  var pathPoints = getPathPoints(points2, connectNulls, showSinglePoint);
  var path2 = [];
  for (var i = 0, len = pathPoints.length; i < len; i++) {
    var eachPoints = pathPoints[i];
    path2 = path2.concat(getPath$2(eachPoints, isInCircle, smooth, registeredShape, constraint));
  }
  attrs.path = path2;
  return attrs;
}
function getConstraint(coordinate2) {
  var start = coordinate2.start, end = coordinate2.end;
  return [
    [start.x, end.y],
    [end.x, start.y]
  ];
}
registerShapeFactory("area", {
  defaultShapeType: "area",
  getDefaultPoints: function(pointInfo) {
    var x = pointInfo.x, y0 = pointInfo.y0;
    var y = isArray$1(pointInfo.y) ? pointInfo.y : [y0, pointInfo.y];
    return y.map(function(yItem) {
      return {
        x,
        y: yItem
      };
    });
  }
});
registerShape("area", "area", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs(cfg, false, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2,
        fillOpacity: 1
      }
    };
  }
});
var Area$1 = (
  /** @class */
  function(_super) {
    __extends$1(Area2, _super);
    function Area2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "area";
      _this.shapeType = "area";
      _this.generatePoints = true;
      _this.startOnZero = true;
      var _a2 = cfg.startOnZero, startOnZero = _a2 === void 0 ? true : _a2, _b = cfg.sortable, sortable = _b === void 0 ? false : _b, _c = cfg.showSinglePoint, showSinglePoint = _c === void 0 ? false : _c;
      _this.startOnZero = startOnZero;
      _this.sortable = sortable;
      _this.showSinglePoint = showSinglePoint;
      return _this;
    }
    Area2.prototype.getPointsAndData = function(mappingData) {
      var points2 = [];
      var data2 = [];
      for (var i = 0, len = mappingData.length; i < len; i++) {
        var obj = mappingData[i];
        points2.push(obj.points);
        data2.push(obj[FIELD_ORIGIN]);
      }
      return {
        points: points2,
        data: data2
      };
    };
    Area2.prototype.getYMinValue = function() {
      if (this.startOnZero) {
        return _super.prototype.getYMinValue.call(this);
      }
      var yScale = this.getYScale();
      return yScale.min;
    };
    return Area2;
  }(Path)
);
registerShapeFactory("edge", {
  defaultShapeType: "line",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
registerShape("edge", "line", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var path2 = getLinePath(this.parsePoints(cfg.points), this.coordinate.isPolar);
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
var Edge = (
  /** @class */
  function(_super) {
    __extends$1(Edge2, _super);
    function Edge2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "edge";
      _this.shapeType = "edge";
      _this.generatePoints = true;
      return _this;
    }
    return Edge2;
  }(Geometry)
);
var Heatmap = (
  /** @class */
  function(_super) {
    __extends$1(Heatmap2, _super);
    function Heatmap2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "heatmap";
      _this.paletteCache = {};
      return _this;
    }
    Heatmap2.prototype.updateElements = function(mappingDataArray, isUpdate) {
      for (var i = 0; i < mappingDataArray.length; i++) {
        var mappingData = mappingDataArray[i];
        var range = this.prepareRange(mappingData);
        var radius = this.prepareSize();
        var blur_1 = get(this.styleOption, ["cfg", "shadowBlur"]);
        if (!isNumber$1(blur_1)) {
          blur_1 = radius / 2;
        }
        this.prepareGreyScaleBlurredCircle(radius, blur_1);
        this.drawWithRange(mappingData, range, radius, blur_1);
      }
    };
    Heatmap2.prototype.color = function(field2, cfg) {
      this.createAttrOption("color", field2, typeof cfg !== "function" ? cfg : "");
      return this;
    };
    Heatmap2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.clearShadowCanvasCtx();
      this.paletteCache = {};
    };
    Heatmap2.prototype.prepareRange = function(data2) {
      var colorAttr = this.getAttribute("color");
      var colorField = colorAttr.getFields()[0];
      var min2 = Infinity;
      var max2 = -Infinity;
      data2.forEach(function(row) {
        var value2 = row[FIELD_ORIGIN][colorField];
        if (value2 > max2) {
          max2 = value2;
        }
        if (value2 < min2) {
          min2 = value2;
        }
      });
      if (min2 === max2) {
        min2 = max2 - 1;
      }
      return [min2, max2];
    };
    Heatmap2.prototype.prepareSize = function() {
      var radius = this.getDefaultValue("size");
      if (!isNumber$1(radius)) {
        radius = this.getDefaultSize();
      }
      return radius;
    };
    Heatmap2.prototype.prepareGreyScaleBlurredCircle = function(radius, blur) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      var r2 = radius + blur;
      var ctx2 = grayScaleBlurredCanvas.getContext("2d");
      grayScaleBlurredCanvas.width = grayScaleBlurredCanvas.height = r2 * 2;
      ctx2.clearRect(0, 0, grayScaleBlurredCanvas.width, grayScaleBlurredCanvas.height);
      ctx2.shadowOffsetX = ctx2.shadowOffsetY = r2 * 2;
      ctx2.shadowBlur = blur;
      ctx2.shadowColor = "black";
      ctx2.beginPath();
      ctx2.arc(-r2, -r2, radius, 0, Math.PI * 2, true);
      ctx2.closePath();
      ctx2.fill();
    };
    Heatmap2.prototype.drawWithRange = function(data2, range, radius, blur) {
      var e_1, _a2;
      var _b = this.coordinate, start = _b.start, end = _b.end;
      var width = this.coordinate.getWidth();
      var height = this.coordinate.getHeight();
      var colorAttr = this.getAttribute("color");
      var valueField = colorAttr.getFields()[0];
      this.clearShadowCanvasCtx();
      var ctx2 = this.getShadowCanvasCtx();
      if (range) {
        data2 = data2.filter(function(row) {
          return row[FIELD_ORIGIN][valueField] <= range[1] && row[FIELD_ORIGIN][valueField] >= range[0];
        });
      }
      var scale2 = this.scales[valueField];
      try {
        for (var data_1 = __values(data2), data_1_1 = data_1.next(); !data_1_1.done; data_1_1 = data_1.next()) {
          var obj = data_1_1.value;
          var _c = this.getDrawCfg(obj), x = _c.x, y = _c.y;
          var alpha = scale2.scale(obj[FIELD_ORIGIN][valueField]);
          this.drawGrayScaleBlurredCircle(x - start.x, y - end.y, radius + blur, alpha, ctx2);
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (data_1_1 && !data_1_1.done && (_a2 = data_1.return))
            _a2.call(data_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      var colored = ctx2.getImageData(0, 0, width, height);
      this.clearShadowCanvasCtx();
      this.colorize(colored);
      ctx2.putImageData(colored, 0, 0);
      var imageShape = this.getImageShape();
      imageShape.attr("x", start.x);
      imageShape.attr("y", end.y);
      imageShape.attr("width", width);
      imageShape.attr("height", height);
      imageShape.attr("img", ctx2.canvas);
      imageShape.set("origin", this.getShapeInfo(data2));
    };
    Heatmap2.prototype.getDefaultSize = function() {
      var position = this.getAttribute("position");
      var coordinate2 = this.coordinate;
      return Math.min(coordinate2.getWidth() / (position.scales[0].ticks.length * 4), coordinate2.getHeight() / (position.scales[1].ticks.length * 4));
    };
    Heatmap2.prototype.clearShadowCanvasCtx = function() {
      var ctx2 = this.getShadowCanvasCtx();
      ctx2.clearRect(0, 0, ctx2.canvas.width, ctx2.canvas.height);
    };
    Heatmap2.prototype.getShadowCanvasCtx = function() {
      var canvas = this.shadowCanvas;
      if (!canvas) {
        canvas = document.createElement("canvas");
        this.shadowCanvas = canvas;
      }
      canvas.width = this.coordinate.getWidth();
      canvas.height = this.coordinate.getHeight();
      return canvas.getContext("2d");
    };
    Heatmap2.prototype.getGrayScaleBlurredCanvas = function() {
      if (!this.grayScaleBlurredCanvas) {
        this.grayScaleBlurredCanvas = document.createElement("canvas");
      }
      return this.grayScaleBlurredCanvas;
    };
    Heatmap2.prototype.drawGrayScaleBlurredCircle = function(x, y, r, alpha, ctx2) {
      var grayScaleBlurredCanvas = this.getGrayScaleBlurredCanvas();
      ctx2.globalAlpha = alpha;
      ctx2.drawImage(grayScaleBlurredCanvas, x - r, y - r);
    };
    Heatmap2.prototype.colorize = function(img) {
      var colorAttr = this.getAttribute("color");
      var pixels = img.data;
      var paletteCache = this.paletteCache;
      for (var i = 3; i < pixels.length; i += 4) {
        var alpha = pixels[i];
        if (isNumber$1(alpha)) {
          var palette = paletteCache[alpha] ? paletteCache[alpha] : colorUtil.rgb2arr(colorAttr.gradient(alpha / 256));
          pixels[i - 3] = palette[0];
          pixels[i - 2] = palette[1];
          pixels[i - 1] = palette[2];
          pixels[i] = alpha;
        }
      }
    };
    Heatmap2.prototype.getImageShape = function() {
      var imageShape = this.imageShape;
      if (imageShape) {
        return imageShape;
      }
      var container = this.container;
      imageShape = container.addShape({
        type: "image",
        attrs: {}
      });
      this.imageShape = imageShape;
      return imageShape;
    };
    Heatmap2.prototype.getShapeInfo = function(mappingData) {
      var shapeCfg = this.getDrawCfg(mappingData[0]);
      var data2 = mappingData.map(function(obj) {
        return obj[FIELD_ORIGIN];
      });
      return __assign$1(__assign$1({}, shapeCfg), { mappingData, data: data2 });
    };
    return Heatmap2;
  }(Geometry)
);
function getRectPoints$1(pointInfo) {
  var _a2, _b;
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (isArray$1(y)) {
    _a2 = __read(y, 2), yMin = _a2[0], yMax = _a2[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMin;
  var xMax;
  if (isArray$1(x)) {
    _b = __read(x, 2), xMin = _b[0], xMax = _b[1];
  } else {
    xMin = x - size2 / 2;
    xMax = x + size2 / 2;
  }
  var points2 = [
    { x: xMin, y: yMin },
    { x: xMin, y: yMax }
  ];
  points2.push({ x: xMax, y: yMax }, { x: xMax, y: yMin });
  return points2;
}
function getRectPath$1(points2, isClosed) {
  if (isClosed === void 0) {
    isClosed = true;
  }
  var path2 = [];
  var firstPoint = points2[0];
  path2.push(["M", firstPoint.x, firstPoint.y]);
  for (var i = 1, len = points2.length; i < len; i++) {
    path2.push(["L", points2[i].x, points2[i].y]);
  }
  if (isClosed) {
    path2.push(["L", firstPoint.x, firstPoint.y]);
    path2.push(["z"]);
  }
  return path2;
}
function parseRadius(radius, minLength) {
  var r1 = 0;
  var r2 = 0;
  var r3 = 0;
  var r4 = 0;
  if (isArray$1(radius)) {
    if (radius.length === 1) {
      r1 = r2 = r3 = r4 = radius[0];
    } else if (radius.length === 2) {
      r1 = r3 = radius[0];
      r2 = r4 = radius[1];
    } else if (radius.length === 3) {
      r1 = radius[0];
      r2 = r4 = radius[1];
      r3 = radius[2];
    } else {
      r1 = radius[0];
      r2 = radius[1];
      r3 = radius[2];
      r4 = radius[3];
    }
  } else {
    r1 = r2 = r3 = r4 = radius;
  }
  if (r1 + r2 > minLength) {
    r1 = r1 ? minLength / (1 + r2 / r1) : 0;
    r2 = minLength - r1;
  }
  if (r3 + r4 > minLength) {
    r3 = r3 ? minLength / (1 + r4 / r3) : 0;
    r4 = minLength - r3;
  }
  return [r1 || 0, r2 || 0, r3 || 0, r4 || 0];
}
function getBackgroundRectPath(cfg, points2, coordinate2) {
  var path2 = [];
  if (coordinate2.isRect) {
    var p0 = coordinate2.isTransposed ? { x: coordinate2.start.x, y: points2[0].y } : { x: points2[0].x, y: coordinate2.start.y };
    var p1 = coordinate2.isTransposed ? { x: coordinate2.end.x, y: points2[2].y } : { x: points2[3].x, y: coordinate2.end.y };
    var radius = get(cfg, ["background", "style", "radius"]);
    if (radius) {
      var width = coordinate2.isTransposed ? Math.abs(points2[0].y - points2[2].y) : points2[2].x - points2[1].x;
      var height = coordinate2.isTransposed ? coordinate2.getWidth() : coordinate2.getHeight();
      var _a2 = __read(parseRadius(radius, Math.min(width, height)), 4), r1 = _a2[0], r2 = _a2[1], r3 = _a2[2], r4 = _a2[3];
      var isReflectYTransposed_1 = coordinate2.isTransposed && coordinate2.isReflect("y");
      var bump = isReflectYTransposed_1 ? 0 : 1;
      var opposite = function(r) {
        return isReflectYTransposed_1 ? -r : r;
      };
      path2.push(["M", p0.x, p1.y + opposite(r1)]);
      r1 !== 0 && path2.push(["A", r1, r1, 0, 0, bump, p0.x + r1, p1.y]);
      path2.push(["L", p1.x - r2, p1.y]);
      r2 !== 0 && path2.push(["A", r2, r2, 0, 0, bump, p1.x, p1.y + opposite(r2)]);
      path2.push(["L", p1.x, p0.y - opposite(r3)]);
      r3 !== 0 && path2.push(["A", r3, r3, 0, 0, bump, p1.x - r3, p0.y]);
      path2.push(["L", p0.x + r4, p0.y]);
      r4 !== 0 && path2.push(["A", r4, r4, 0, 0, bump, p0.x, p0.y - opposite(r4)]);
    } else {
      path2.push(["M", p0.x, p0.y]);
      path2.push(["L", p1.x, p0.y]);
      path2.push(["L", p1.x, p1.y]);
      path2.push(["L", p0.x, p1.y]);
      path2.push(["L", p0.x, p0.y]);
    }
    path2.push(["z"]);
  }
  if (coordinate2.isPolar) {
    var center2 = coordinate2.getCenter();
    var _b = getAngle$1(cfg, coordinate2), startAngle = _b.startAngle, endAngle = _b.endAngle;
    if (coordinate2.type !== "theta" && !coordinate2.isTransposed) {
      path2 = getSectorPath(center2.x, center2.y, coordinate2.getRadius(), startAngle, endAngle);
    } else {
      var pow = function(v) {
        return Math.pow(v, 2);
      };
      var r1 = Math.sqrt(pow(center2.x - points2[0].x) + pow(center2.y - points2[0].y));
      var r2 = Math.sqrt(pow(center2.x - points2[2].x) + pow(center2.y - points2[2].y));
      path2 = getSectorPath(center2.x, center2.y, r1, coordinate2.startAngle, coordinate2.endAngle, r2);
    }
  }
  return path2;
}
function getIntervalRectPath(points2, lineCap, coor) {
  var width = coor.getWidth();
  var height = coor.getHeight();
  var isRect = coor.type === "rect";
  var path2 = [];
  var r = (points2[2].x - points2[1].x) / 2;
  var ry = coor.isTransposed ? r * height / width : r * width / height;
  if (lineCap === "round") {
    if (isRect) {
      path2.push(["M", points2[0].x, points2[0].y + ry]);
      path2.push(["L", points2[1].x, points2[1].y - ry]);
      path2.push(["A", r, r, 0, 0, 1, points2[2].x, points2[2].y - ry]);
      path2.push(["L", points2[3].x, points2[3].y + ry]);
      path2.push(["A", r, r, 0, 0, 1, points2[0].x, points2[0].y + ry]);
    } else {
      path2.push(["M", points2[0].x, points2[0].y]);
      path2.push(["L", points2[1].x, points2[1].y]);
      path2.push(["A", r, r, 0, 0, 1, points2[2].x, points2[2].y]);
      path2.push(["L", points2[3].x, points2[3].y]);
      path2.push(["A", r, r, 0, 0, 1, points2[0].x, points2[0].y]);
    }
    path2.push(["z"]);
  } else {
    path2 = getRectPath$1(points2);
  }
  return path2;
}
function getFunnelPath(points2, nextPoints, isPyramid) {
  var path2 = [];
  if (!isNil(nextPoints)) {
    path2.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", nextPoints[1].x, nextPoints[1].y], ["L", nextPoints[0].x, nextPoints[0].y], ["Z"]);
  } else if (isPyramid) {
    path2.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", (points2[2].x + points2[3].x) / 2, (points2[2].y + points2[3].y) / 2], ["Z"]);
  } else {
    path2.push(["M", points2[0].x, points2[0].y], ["L", points2[1].x, points2[1].y], ["L", points2[2].x, points2[2].y], ["L", points2[3].x, points2[3].y], ["Z"]);
  }
  return path2;
}
function swap$1(p0, p1) {
  return [p1, p0];
}
function getRectWithCornerRadius(points2, coordinate2, radius) {
  var _a2, _b, _c, _d, _e, _f, _g;
  var _h = __read(__spreadArray$1([], __read(points2), false), 4), p0 = _h[0], p1 = _h[1], p2 = _h[2], p3 = _h[3];
  var _j = __read(typeof radius === "number" ? Array(4).fill(radius) : radius, 4), r1 = _j[0], r2 = _j[1], r3 = _j[2], r4 = _j[3];
  if (coordinate2.isTransposed) {
    _a2 = __read(swap$1(p1, p3), 2), p1 = _a2[0], p3 = _a2[1];
  }
  if (coordinate2.isReflect("y")) {
    _b = __read(swap$1(p0, p1), 2), p0 = _b[0], p1 = _b[1];
    _c = __read(swap$1(p2, p3), 2), p2 = _c[0], p3 = _c[1];
  }
  if (coordinate2.isReflect("x")) {
    _d = __read(swap$1(p0, p3), 2), p0 = _d[0], p3 = _d[1];
    _e = __read(swap$1(p1, p2), 2), p1 = _e[0], p2 = _e[1];
  }
  var path2 = [];
  var abs = function(v) {
    return Math.abs(v);
  };
  _f = __read(parseRadius([r1, r2, r3, r4], Math.min(abs(p3.x - p0.x), abs(p1.y - p0.y))).map(function(d) {
    return abs(d);
  }), 4), r1 = _f[0], r2 = _f[1], r3 = _f[2], r4 = _f[3];
  if (coordinate2.isTransposed) {
    _g = __read([r4, r1, r2, r3], 4), r1 = _g[0], r2 = _g[1], r3 = _g[2], r4 = _g[3];
  }
  if (p0.y < p1.y) {
    path2.push(["M", p3.x, p3.y + r3]);
    r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 0, p3.x - r3, p3.y]);
    path2.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y + r4]);
    path2.push(["L", p1.x, p1.y - r1]);
    r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 0, p1.x + r1, p1.y]);
    path2.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y - r2]);
    path2.push(["L", p3.x, p3.y + r3]);
    path2.push(["z"]);
  } else if (p3.x < p0.x) {
    path2.push(["M", p2.x + r2, p2.y]);
    r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 0, p2.x, p2.y + r2]);
    path2.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 0, p3.x + r3, p3.y]);
    path2.push(["L", p0.x - r4, p0.y]);
    r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 0, p0.x, p0.y - r4]);
    path2.push(["L", p1.x, p1.y + r1]);
    r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 0, p1.x - r1, p1.y]);
    path2.push(["L", p2.x + r2, p2.y]);
    path2.push(["z"]);
  } else {
    path2.push(["M", p1.x, p1.y + r1]);
    r1 !== 0 && path2.push(["A", r1, r1, 0, 0, 1, p1.x + r1, p1.y]);
    path2.push(["L", p2.x - r2, p2.y]);
    r2 !== 0 && path2.push(["A", r2, r2, 0, 0, 1, p2.x, p2.y + r2]);
    path2.push(["L", p3.x, p3.y - r3]);
    r3 !== 0 && path2.push(["A", r3, r3, 0, 0, 1, p3.x - r3, p3.y]);
    path2.push(["L", p0.x + r4, p0.y]);
    r4 !== 0 && path2.push(["A", r4, r4, 0, 0, 1, p0.x, p0.y - r4]);
    path2.push(["L", p1.x, p1.y + r1]);
    path2.push(["z"]);
  }
  return path2;
}
registerShapeFactory("interval", {
  defaultShapeType: "rect",
  getDefaultPoints: function(pointInfo) {
    return getRectPoints$1(pointInfo);
  }
});
registerShape("interval", "rect", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, false, true);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup({
        name: "interval-group"
      });
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign$1(__assign$1({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path2;
    if (style.radius && this.coordinate.isRect) {
      path2 = getRectWithCornerRadius(this.parsePoints(cfg.points), this.coordinate, style.radius);
    } else {
      path2 = this.parsePath(getIntervalRectPath(cfg.points, style.lineCap, this.coordinate));
    }
    var shape = group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
function findMinDistance(arr, scale2) {
  var count2 = arr.length;
  var sourceArr = arr;
  if (isString(sourceArr[0])) {
    sourceArr = arr.map(function(v) {
      return scale2.translate(v);
    });
  }
  var distance2 = sourceArr[1] - sourceArr[0];
  for (var i = 2; i < count2; i++) {
    var tmp = sourceArr[i] - sourceArr[i - 1];
    if (distance2 > tmp) {
      distance2 = tmp;
    }
  }
  return distance2;
}
function getDodgeCount(dataArray, dodgeBy) {
  if (dodgeBy) {
    var mergeData = flatten(dataArray);
    var values2 = valuesOfKey(mergeData, dodgeBy);
    return values2.length;
  }
  return dataArray.length;
}
function getDefaultSize(geometry2) {
  var theme2 = geometry2.theme;
  var coordinate2 = geometry2.coordinate;
  var xScale = geometry2.getXScale();
  var xValues = xScale.values;
  var dataArray = geometry2.beforeMappingData;
  var count2 = xValues.length;
  var xDimensionLength = getXDimensionLength(geometry2.coordinate);
  var intervalPadding = geometry2.intervalPadding, dodgePadding = geometry2.dodgePadding;
  var maxColumnWidth = geometry2.maxColumnWidth || theme2.maxColumnWidth;
  var minColumnWidth = geometry2.minColumnWidth || theme2.minColumnWidth;
  var columnWidthRatio = geometry2.columnWidthRatio || theme2.columnWidthRatio;
  var multiplePieWidthRatio = geometry2.multiplePieWidthRatio || theme2.multiplePieWidthRatio;
  var roseWidthRatio = geometry2.roseWidthRatio || theme2.roseWidthRatio;
  if (xScale.isLinear && xValues.length > 1) {
    xValues.sort();
    var interval2 = findMinDistance(xValues, xScale);
    count2 = (xScale.max - xScale.min) / interval2;
    if (xValues.length > count2) {
      count2 = xValues.length;
    }
  }
  var range = xScale.range;
  var normalizedSize = 1 / count2;
  var wr = 1;
  if (coordinate2.isPolar) {
    if (coordinate2.isTransposed && count2 > 1) {
      wr = multiplePieWidthRatio;
    } else {
      wr = roseWidthRatio;
    }
  } else {
    if (xScale.isLinear) {
      normalizedSize *= range[1] - range[0];
    }
    wr = columnWidthRatio;
  }
  if (!isNil(intervalPadding) && intervalPadding >= 0) {
    var normalizedIntervalPadding = intervalPadding / xDimensionLength;
    normalizedSize = (1 - (count2 - 1) * normalizedIntervalPadding) / count2;
  } else {
    normalizedSize *= wr;
  }
  if (geometry2.getAdjust("dodge")) {
    var dodgeAdjust = geometry2.getAdjust("dodge");
    var dodgeBy = dodgeAdjust.dodgeBy;
    var dodgeCount = getDodgeCount(dataArray, dodgeBy);
    if (!isNil(dodgePadding) && dodgePadding >= 0) {
      var normalizedDodgePadding = dodgePadding / xDimensionLength;
      normalizedSize = (normalizedSize - normalizedDodgePadding * (dodgeCount - 1)) / dodgeCount;
    } else if (!isNil(intervalPadding) && intervalPadding >= 0) {
      normalizedSize *= wr;
      normalizedSize = normalizedSize / dodgeCount;
    } else {
      normalizedSize = normalizedSize / dodgeCount;
    }
    normalizedSize = normalizedSize >= 0 ? normalizedSize : 0;
  }
  if (!isNil(maxColumnWidth) && maxColumnWidth >= 0) {
    var normalizedMaxColumnWidth = maxColumnWidth / xDimensionLength;
    if (normalizedSize > normalizedMaxColumnWidth) {
      normalizedSize = normalizedMaxColumnWidth;
    }
  }
  if (!isNil(minColumnWidth) && minColumnWidth >= 0) {
    var normalizedMinColumnWidth = minColumnWidth / xDimensionLength;
    if (normalizedSize < normalizedMinColumnWidth) {
      normalizedSize = normalizedMinColumnWidth;
    }
  }
  return normalizedSize;
}
var Interval = (
  /** @class */
  function(_super) {
    __extends$1(Interval2, _super);
    function Interval2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "interval";
      _this.shapeType = "interval";
      _this.generatePoints = true;
      var background = cfg.background;
      _this.background = background;
      return _this;
    }
    Interval2.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var size2;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size2 = this.getAttributeValues(sizeAttr, obj)[0];
        var coordinate2 = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate2);
        size2 = size2 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size2 = this.defaultSize;
      }
      cfg.size = size2;
      return cfg;
    };
    Interval2.prototype.adjustScale = function() {
      _super.prototype.adjustScale.call(this);
      var yScale = this.getYScale();
      if (this.coordinate.type === "theta") {
        yScale.change({
          nice: false,
          min: 0,
          //  stack yScale  max this.updateStackRange()
          max: getMaxScale(yScale)
        });
      } else {
        var scaleDefs = this.scaleDefs;
        var field2 = yScale.field, min2 = yScale.min, max2 = yScale.max, type = yScale.type;
        if (type !== "time") {
          if (min2 > 0 && !get(scaleDefs, [field2, "min"])) {
            yScale.change({
              min: 0
            });
          }
          if (max2 <= 0 && !get(scaleDefs, [field2, "max"])) {
            yScale.change({
              max: 0
            });
          }
        }
      }
    };
    Interval2.prototype.getDrawCfg = function(mappingData) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingData);
      shapeCfg.background = this.background;
      return shapeCfg;
    };
    return Interval2;
  }(Geometry)
);
var Line$1 = (
  /** @class */
  function(_super) {
    __extends$1(Line2, _super);
    function Line2(cfg) {
      var _this = _super.call(this, cfg) || this;
      _this.type = "line";
      var _a2 = cfg.sortable, sortable = _a2 === void 0 ? false : _a2;
      _this.sortable = sortable;
      return _this;
    }
    return Line2;
  }(Path)
);
var SHAPES = ["circle", "square", "bowtie", "diamond", "hexagon", "triangle", "triangle-down"];
var HOLLOW_SHAPES = ["cross", "tick", "plus", "hyphen", "line"];
function drawPoints(shape, cfg, container, shapeName, isStroke) {
  var e_1, _a2;
  var style = getStyle(cfg, isStroke, !isStroke, "r");
  var points2 = shape.parsePoints(cfg.points);
  var pointPosition = points2[0];
  if (cfg.isStack) {
    pointPosition = points2[1];
  } else if (points2.length > 1) {
    var group2 = container.addGroup();
    try {
      for (var points_1 = __values(points2), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
        var point2 = points_1_1.value;
        group2.addShape({
          type: "marker",
          attrs: __assign$1(__assign$1(__assign$1({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), point2)
        });
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (points_1_1 && !points_1_1.done && (_a2 = points_1.return))
          _a2.call(points_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    return group2;
  }
  return container.addShape({
    type: "marker",
    attrs: __assign$1(__assign$1(__assign$1({}, style), { symbol: MarkerSymbols[shapeName] || shapeName }), pointPosition)
  });
}
registerShapeFactory("point", {
  defaultShapeType: "hollow-circle",
  getDefaultPoints: function(pointInfo) {
    return splitPoints(pointInfo);
  }
});
each$1(SHAPES, function(shapeName) {
  registerShape("point", "hollow-".concat(shapeName), {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});
var Point = (
  /** @class */
  function(_super) {
    __extends$1(Point2, _super);
    function Point2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "point";
      _this.shapeType = "point";
      _this.generatePoints = true;
      return _this;
    }
    Point2.prototype.getDrawCfg = function(mappingDatum) {
      var shapeCfg = _super.prototype.getDrawCfg.call(this, mappingDatum);
      return __assign$1(__assign$1({}, shapeCfg), { isStack: !!this.getAdjust("stack") });
    };
    return Point2;
  }(Geometry)
);
function getPath$1(points2) {
  var flag = points2[0];
  var i = 1;
  var path2 = [["M", flag.x, flag.y]];
  while (i < points2.length) {
    var c = points2[i];
    if (c.x !== points2[i - 1].x || c.y !== points2[i - 1].y) {
      path2.push(["L", c.x, c.y]);
      if (c.x === flag.x && c.y === flag.y && i < points2.length - 1) {
        flag = points2[i + 1];
        path2.push(["Z"]);
        path2.push(["M", flag.x, flag.y]);
        i++;
      }
    }
    i++;
  }
  if (!isEqual$1(last(path2), flag)) {
    path2.push(["L", flag.x, flag.y]);
  }
  path2.push(["Z"]);
  return path2;
}
registerShapeFactory("polygon", {
  defaultShapeType: "polygon",
  getDefaultPoints: function(pointInfo) {
    var points2 = [];
    each$1(pointInfo.x, function(subX, index2) {
      var subY = pointInfo.y[index2];
      points2.push({
        x: subX,
        y: subY
      });
    });
    return points2;
  }
});
registerShape("polygon", "polygon", {
  draw: function(cfg, container) {
    if (!isEmpty(cfg.points)) {
      var shapeAttrs = getStyle(cfg, true, true);
      var path2 = this.parsePath(getPath$1(cfg.points));
      return container.addShape("path", {
        attrs: __assign$1(__assign$1({}, shapeAttrs), { path: path2 }),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
var Polygon = (
  /** @class */
  function(_super) {
    __extends$1(Polygon2, _super);
    function Polygon2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "polygon";
      _this.shapeType = "polygon";
      _this.generatePoints = true;
      return _this;
    }
    Polygon2.prototype.createShapePointsCfg = function(obj) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, obj);
      var x = cfg.x;
      var y = cfg.y;
      var temp;
      if (!(isArray$1(x) && isArray$1(y))) {
        var xScale = this.getXScale();
        var yScale = this.getYScale();
        var xCount = xScale.values.length;
        var yCount = yScale.values.length;
        var xOffset = 0.5 * 1 / xCount;
        var yOffset = 0.5 * 1 / yCount;
        if (xScale.isCategory && yScale.isCategory) {
          x = [x - xOffset, x - xOffset, x + xOffset, x + xOffset];
          y = [y - yOffset, y + yOffset, y + yOffset, y - yOffset];
        } else if (isArray$1(x)) {
          temp = x;
          x = [temp[0], temp[0], temp[1], temp[1]];
          y = [y - yOffset / 2, y + yOffset / 2, y + yOffset / 2, y - yOffset / 2];
        } else if (isArray$1(y)) {
          temp = y;
          y = [temp[0], temp[1], temp[1], temp[0]];
          x = [x - xOffset / 2, x - xOffset / 2, x + xOffset / 2, x + xOffset / 2];
        }
        cfg.x = x;
        cfg.y = y;
      }
      return cfg;
    };
    return Polygon2;
  }(Geometry)
);
registerShapeFactory("schema", {
  defaultShapeType: ""
  // 'schema' is for some custom shapes, so will not specify defaultShapeType
});
var Schema = (
  /** @class */
  function(_super) {
    __extends$1(Schema2, _super);
    function Schema2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "schema";
      _this.shapeType = "schema";
      _this.generatePoints = true;
      return _this;
    }
    Schema2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size2;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size2 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate2 = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate2);
        size2 = size2 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size2 = this.defaultSize;
      }
      cfg.size = size2;
      return cfg;
    };
    return Schema2;
  }(Geometry)
);
function normalizeSize(arr) {
  if (!isArray$1(arr)) {
    return [];
  }
  var maxValue = max$2(arr);
  return map$2(arr, function(num) {
    return num / maxValue;
  });
}
registerShapeFactory("violin", {
  defaultShapeType: "violin",
  getDefaultPoints: function(pointInfo) {
    var radius = pointInfo.size / 2;
    var points2 = [];
    var sizeArr = normalizeSize(pointInfo._size);
    each$1(pointInfo.y, function(y, index2) {
      var offset = sizeArr[index2] * radius;
      var isMin = index2 === 0;
      var isMax = index2 === pointInfo.y.length - 1;
      points2.push({
        isMin,
        isMax,
        x: pointInfo.x - offset,
        y
      });
      points2.unshift({
        isMin,
        isMax,
        x: pointInfo.x + offset,
        y
      });
    });
    return points2;
  }
});
registerShape("violin", "violin", {
  draw: function(cfg, container) {
    var shapeAttrs = getStyle(cfg, true, true);
    var path2 = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, shapeAttrs), { path: path2 }),
      name: "violin"
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
var Violin = (
  /** @class */
  function(_super) {
    __extends$1(Violin2, _super);
    function Violin2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "violin";
      _this.shapeType = "violin";
      _this.generatePoints = true;
      return _this;
    }
    Violin2.prototype.createShapePointsCfg = function(record) {
      var cfg = _super.prototype.createShapePointsCfg.call(this, record);
      var size2;
      var sizeAttr = this.getAttribute("size");
      if (sizeAttr) {
        size2 = this.getAttributeValues(sizeAttr, record)[0];
        var coordinate2 = this.coordinate;
        var coordinateWidth = getXDimensionLength(coordinate2);
        size2 = size2 / coordinateWidth;
      } else {
        if (!this.defaultSize) {
          this.defaultSize = getDefaultSize(this);
        }
        size2 = this.defaultSize;
      }
      cfg.size = size2;
      cfg._size = get(record[FIELD_ORIGIN], [this._sizeField]);
      return cfg;
    };
    Violin2.prototype.initAttributes = function() {
      var attributeOption = this.attributeOption;
      var sizeField = attributeOption.size ? attributeOption.size.fields[0] : this._sizeField ? this._sizeField : "size";
      this._sizeField = sizeField;
      delete attributeOption.size;
      _super.prototype.initAttributes.call(this);
    };
    return Violin2;
  }(Geometry)
);
registerShape("area", "line", {
  draw: function(cfg, container) {
    var attrs = getShapeAttrs(cfg, true, false, this);
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});
registerShape("area", "smooth", {
  draw: function(cfg, container) {
    var coordinate2 = this.coordinate;
    var attrs = getShapeAttrs(cfg, false, true, this, getConstraint(coordinate2));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        fill: color2,
        fillOpacity: 1
      }
    };
  }
});
registerShape("area", "smooth-line", {
  draw: function(cfg, container) {
    var coordinate2 = this.coordinate;
    var attrs = getShapeAttrs(cfg, true, true, this, getConstraint(coordinate2));
    var shape = container.addShape({
      type: "path",
      attrs,
      name: "area"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        if (r === void 0) {
          r = 5.5;
        }
        return [["M", x - r, y - 4], ["L", x + r, y - 4], ["L", x + r, y + 4], ["L", x - r, y + 4], ["Z"]];
      },
      style: {
        r: 5,
        stroke: color2,
        fill: null
      }
    };
  }
});
function getCPath(from, to) {
  return ["C", from.x * 1 / 2 + to.x * 1 / 2, from.y, from.x * 1 / 2 + to.x * 1 / 2, to.y, to.x, to.y];
}
function getQPath(to, center2) {
  var points2 = [];
  points2.push({
    x: center2.x,
    y: center2.y
  });
  points2.push(to);
  var sub2 = ["Q"];
  each$1(points2, function(point2) {
    sub2.push(point2.x, point2.y);
  });
  return sub2;
}
function getArcShapePath(from, to, center2) {
  var sub2 = getQPath(to, center2);
  var path2 = [["M", from.x, from.y]];
  path2.push(sub2);
  return path2;
}
function getArcShapeWeightPath(points2, center2) {
  var arc1 = getQPath(points2[1], center2);
  var arc2 = getQPath(points2[3], center2);
  var path2 = [["M", points2[0].x, points2[0].y]];
  path2.push(arc2);
  path2.push(["L", points2[3].x, points2[3].y]);
  path2.push(["L", points2[2].x, points2[2].y]);
  path2.push(arc1);
  path2.push(["L", points2[1].x, points2[1].y]);
  path2.push(["L", points2[0].x, points2[0].y]);
  path2.push(["Z"]);
  return path2;
}
registerShape("edge", "arc", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var type = points2.length > 2 ? "weight" : "normal";
    var path2;
    if (cfg.isInCircle) {
      var center2 = { x: 0, y: 1 };
      if (type === "normal") {
        path2 = getArcShapePath(points2[0], points2[1], center2);
      } else {
        style.fill = style.stroke;
        path2 = getArcShapeWeightPath(points2, center2);
      }
      path2 = this.parsePath(path2);
      return container.addShape("path", {
        attrs: __assign$1(__assign$1({}, style), { path: path2 })
      });
    } else {
      if (type === "normal") {
        points2 = this.parsePoints(points2);
        path2 = getArcPath((points2[1].x + points2[0].x) / 2, points2[0].y, Math.abs(points2[1].x - points2[0].x) / 2, Math.PI, Math.PI * 2);
        return container.addShape("path", {
          attrs: __assign$1(__assign$1({}, style), { path: path2 })
        });
      } else {
        var c1 = getCPath(points2[1], points2[3]);
        var c2 = getCPath(points2[2], points2[0]);
        path2 = [
          ["M", points2[0].x, points2[0].y],
          ["L", points2[1].x, points2[1].y],
          c1,
          ["L", points2[3].x, points2[3].y],
          ["L", points2[2].x, points2[2].y],
          c2,
          ["Z"]
        ];
        path2 = this.parsePath(path2);
        style.fill = style.stroke;
        return container.addShape("path", {
          attrs: __assign$1(__assign$1({}, style), { path: path2 })
        });
      }
    }
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
function getSmoothPath(from, to) {
  var sub2 = getCPath(from, to);
  var path2 = [["M", from.x, from.y]];
  path2.push(sub2);
  return path2;
}
registerShape("edge", "smooth", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var path2 = this.parsePath(getSmoothPath(points2[0], points2[1]));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
var CORNER_PERCENT = 1 / 3;
function getVHVPath(from, to) {
  var points2 = [];
  points2.push({
    x: from.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points2.push({
    x: to.x,
    y: from.y * (1 - CORNER_PERCENT) + to.y * CORNER_PERCENT
  });
  points2.push(to);
  var path2 = [["M", from.x, from.y]];
  each$1(points2, function(point2) {
    path2.push(["L", point2.x, point2.y]);
  });
  return path2;
}
registerShape("edge", "vhv", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var points2 = cfg.points;
    var path2 = this.parsePath(getVHVPath(points2[0], points2[1]));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: markerCfg.color
      }
    };
  }
});
registerShape("interval", "funnel", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints$1(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, false, true);
    var path2 = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, false));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("interval", "hollow-rect", {
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false);
    var group2 = container;
    var backgroundCfg = cfg === null || cfg === void 0 ? void 0 : cfg.background;
    if (backgroundCfg) {
      group2 = container.addGroup();
      var backgroundStyle = getBackgroundRectStyle(cfg);
      var backgroundPath = getBackgroundRectPath(cfg, this.parsePoints(cfg.points), this.coordinate);
      group2.addShape("path", {
        attrs: __assign$1(__assign$1({}, backgroundStyle), { path: backgroundPath }),
        zIndex: -1,
        name: BACKGROUND_SHAPE
      });
    }
    var path2 = this.parsePath(getRectPath$1(cfg.points));
    var shape = group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return backgroundCfg ? group2 : shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color, isInPolar = markerCfg.isInPolar;
    if (isInPolar) {
      return {
        symbol: "circle",
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
    return {
      symbol: "square",
      style: {
        r: 4,
        stroke: color2,
        fill: null
      }
    };
  }
});
function getLinePoints(pointInfo) {
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0;
  if (isArray$1(y)) {
    return y.map(function(yItem, idx) {
      return {
        x: isArray$1(x) ? x[idx] : x,
        y: yItem
      };
    });
  }
  return [
    { x, y: y0 },
    { x, y }
  ];
}
registerShape("interval", "line", {
  getPoints: function(shapePoint) {
    return getLinePoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false, "lineWidth");
    var newStyle = omit(__assign$1({}, style), ["fill"]);
    var path2 = this.parsePath(getRectPath$1(cfg.points, false));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, newStyle), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x, y - r],
          ["L", x, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});
registerShape("interval", "pyramid", {
  getPoints: function(shapePoint) {
    shapePoint.size = shapePoint.size * 2;
    return getRectPoints$1(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, false, true);
    var path2 = this.parsePath(getFunnelPath(cfg.points, cfg.nextPoints, true));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
function getTickPoints(pointInfo) {
  var _a2;
  var x = pointInfo.x, y = pointInfo.y, y0 = pointInfo.y0, size2 = pointInfo.size;
  var yMin;
  var yMax;
  if (isArray$1(y)) {
    _a2 = __read(y, 2), yMin = _a2[0], yMax = _a2[1];
  } else {
    yMin = y0;
    yMax = y;
  }
  var xMax = x + size2 / 2;
  var xMin = x - size2 / 2;
  return [
    { x, y: yMin },
    { x, y: yMax },
    { x: xMin, y: yMin },
    { x: xMax, y: yMin },
    { x: xMin, y: yMax },
    { x: xMax, y: yMax }
  ];
}
function getTickPath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["M", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y]
  ];
}
registerShape("interval", "tick", {
  getPoints: function(shapePoint) {
    return getTickPoints(shapePoint);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false);
    var path2 = this.parsePath(getTickPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2 }),
      name: "interval"
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        return [
          ["M", x - r / 2, y - r],
          ["L", x + r / 2, y - r],
          ["M", x, y - r],
          ["L", x, y + r],
          ["M", x - r / 2, y + r],
          ["L", x + r / 2, y + r]
        ];
      },
      style: {
        r: 5,
        stroke: color2
      }
    };
  }
});
var interpolateCallback = function(point2, nextPoint, shapeType) {
  var x = point2.x;
  var y = point2.y;
  var nextX = nextPoint.x;
  var nextY = nextPoint.y;
  var result;
  switch (shapeType) {
    case "hv":
      result = [{ x: nextX, y }];
      break;
    case "vh":
      result = [{ x, y: nextY }];
      break;
    case "hvh":
      var middleX = (nextX + x) / 2;
      result = [
        { x: middleX, y },
        { x: middleX, y: nextY }
      ];
      break;
    case "vhv":
      var middleY = (y + nextY) / 2;
      result = [
        { x, y: middleY },
        { x: nextX, y: middleY }
      ];
      break;
  }
  return result;
};
function getInterpolatePoints(points2, shapeType) {
  var result = [];
  each$1(points2, function(point2, index2) {
    var nextPoint = points2[index2 + 1];
    result.push(point2);
    if (nextPoint) {
      var interpolatePoint = interpolateCallback(point2, nextPoint, shapeType);
      result = result.concat(interpolatePoint);
    }
  });
  return result;
}
function getInterpolatePath(points2) {
  return points2.map(function(point2, index2) {
    return index2 === 0 ? ["M", point2.x, point2.y] : ["L", point2.x, point2.y];
  });
}
function getInterpolateShapeAttrs(cfg, shapeType) {
  var points2 = getPathPoints(cfg.points, cfg.connectNulls, cfg.showSinglePoint);
  var path2 = [];
  each$1(points2, function(eachLinePoints) {
    var interpolatePoints = getInterpolatePoints(eachLinePoints, shapeType);
    path2 = path2.concat(getInterpolatePath(interpolatePoints));
  });
  return __assign$1(__assign$1({}, getStyle(cfg, true, false, "lineWidth")), { path: path2 });
}
each$1(["hv", "vh", "hvh", "vhv"], function(shapeType) {
  registerShape("line", shapeType, {
    draw: function(cfg, container) {
      var attrs = getInterpolateShapeAttrs(cfg, shapeType);
      var shape = container.addShape({
        type: "path",
        attrs,
        name: "line"
      });
      return shape;
    },
    getMarker: function(markerCfg) {
      return getLineMarker(markerCfg, shapeType);
    }
  });
});
each$1(HOLLOW_SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, true);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName],
        style: {
          r: 4.5,
          stroke: color2,
          fill: null
        }
      };
    }
  });
});
registerShape("point", "image", {
  draw: function(cfg, container) {
    var e_1, _a2;
    var size2 = getStyle(cfg, false, false, "r").r;
    var points2 = this.parsePoints(cfg.points);
    var pointPosition = points2[0];
    if (cfg.isStack) {
      pointPosition = points2[1];
    } else if (points2.length > 1) {
      var group2 = container.addGroup();
      try {
        for (var points_1 = __values(points2), points_1_1 = points_1.next(); !points_1_1.done; points_1_1 = points_1.next()) {
          var point2 = points_1_1.value;
          group2.addShape("image", {
            attrs: {
              x: point2.x - size2 / 2,
              y: point2.y - size2,
              width: size2,
              height: size2,
              img: cfg.shape[1]
            }
          });
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (points_1_1 && !points_1_1.done && (_a2 = points_1.return))
            _a2.call(points_1);
        } finally {
          if (e_1)
            throw e_1.error;
        }
      }
      return group2;
    }
    return container.addShape("image", {
      attrs: {
        x: pointPosition.x - size2 / 2,
        y: pointPosition.y - size2,
        width: size2,
        height: size2,
        img: cfg.shape[1]
      }
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4.5,
        fill: color2
      }
    };
  }
});
each$1(SHAPES, function(shapeName) {
  registerShape("point", shapeName, {
    draw: function(cfg, container) {
      return drawPoints(this, cfg, container, shapeName, false);
    },
    getMarker: function(markerCfg) {
      var color2 = markerCfg.color;
      return {
        symbol: MarkerSymbols[shapeName] || shapeName,
        style: {
          r: 4.5,
          fill: color2
        }
      };
    }
  });
});
function parseValue(value2) {
  var array2 = !isArray$1(value2) ? [value2] : value2;
  var min2 = array2[0];
  var max2 = array2[array2.length - 1];
  var min1 = array2.length > 1 ? array2[1] : min2;
  var max1 = array2.length > 3 ? array2[3] : max2;
  var median2 = array2.length > 2 ? array2[2] : min1;
  return {
    min: min2,
    max: max2,
    min1,
    max1,
    median: median2
  };
}
function getBoxPoints(x, y, size2) {
  var halfSize = size2 / 2;
  var pointsArray;
  if (isArray$1(y)) {
    var _a2 = parseValue(y), min2 = _a2.min, max2 = _a2.max, median2 = _a2.median, min1 = _a2.min1, max1 = _a2.max1;
    var minX = x - halfSize;
    var maxX = x + halfSize;
    pointsArray = [
      [minX, max2],
      [maxX, max2],
      [x, max2],
      [x, max1],
      [minX, min1],
      [minX, max1],
      [maxX, max1],
      [maxX, min1],
      [x, min1],
      [x, min2],
      [minX, min2],
      [maxX, min2],
      [minX, median2],
      [maxX, median2]
    ];
  } else {
    y = isNil(y) ? 0.5 : y;
    var _b = parseValue(x), min2 = _b.min, max2 = _b.max, median2 = _b.median, min1 = _b.min1, max1 = _b.max1;
    var minY = y - halfSize;
    var maxY2 = y + halfSize;
    pointsArray = [
      [min2, minY],
      [min2, maxY2],
      [min2, y],
      [min1, y],
      [min1, minY],
      [min1, maxY2],
      [max1, maxY2],
      [max1, minY],
      [max1, y],
      [max2, y],
      [max2, minY],
      [max2, maxY2],
      [median2, minY],
      [median2, maxY2]
    ];
  }
  return pointsArray.map(function(arr) {
    return {
      x: arr[0],
      y: arr[1]
    };
  });
}
function getBoxPath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["M", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y],
    ["L", points2[6].x, points2[6].y],
    ["L", points2[7].x, points2[7].y],
    ["L", points2[4].x, points2[4].y],
    ["Z"],
    ["M", points2[8].x, points2[8].y],
    ["L", points2[9].x, points2[9].y],
    ["M", points2[10].x, points2[10].y],
    ["L", points2[11].x, points2[11].y],
    ["M", points2[12].x, points2[12].y],
    ["L", points2[13].x, points2[13].y]
  ];
}
registerShape("schema", "box", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size2 = shapePoint.size;
    return getBoxPoints(x, y, size2);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, false);
    var path2 = this.parsePath(getBoxPath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y - 6, y - 3, y, y + 3, y + 6];
        var points2 = getBoxPoints(x, yValues, r);
        return [
          ["M", points2[0].x + 1, points2[0].y],
          ["L", points2[1].x - 1, points2[1].y],
          ["M", points2[2].x, points2[2].y],
          ["L", points2[3].x, points2[3].y],
          ["M", points2[4].x, points2[4].y],
          ["L", points2[5].x, points2[5].y],
          ["L", points2[6].x, points2[6].y],
          ["L", points2[7].x, points2[7].y],
          ["L", points2[4].x, points2[4].y],
          ["Z"],
          ["M", points2[8].x, points2[8].y],
          ["L", points2[9].x, points2[9].y],
          ["M", points2[10].x + 1, points2[10].y],
          ["L", points2[11].x - 1, points2[11].y],
          ["M", points2[12].x, points2[12].y],
          ["L", points2[13].x, points2[13].y]
        ];
      },
      style: {
        r: 6,
        lineWidth: 1,
        stroke: color2
      }
    };
  }
});
function getCandleYValues(value2) {
  var array2 = !isArray$1(value2) ? [value2] : value2;
  var sorted = array2.sort(function(a, b) {
    return b - a;
  });
  return padEnd(sorted, 4, sorted[sorted.length - 1]);
}
function getCandlePoints(x, y, size2) {
  var yValues = getCandleYValues(y);
  return [
    { x, y: yValues[0] },
    { x, y: yValues[1] },
    { x: x - size2 / 2, y: yValues[2] },
    { x: x - size2 / 2, y: yValues[1] },
    { x: x + size2 / 2, y: yValues[1] },
    { x: x + size2 / 2, y: yValues[2] },
    { x, y: yValues[2] },
    { x, y: yValues[3] }
  ];
}
function getCandlePath(points2) {
  return [
    ["M", points2[0].x, points2[0].y],
    ["L", points2[1].x, points2[1].y],
    ["M", points2[2].x, points2[2].y],
    ["L", points2[3].x, points2[3].y],
    ["L", points2[4].x, points2[4].y],
    ["L", points2[5].x, points2[5].y],
    ["Z"],
    ["M", points2[6].x, points2[6].y],
    ["L", points2[7].x, points2[7].y]
  ];
}
registerShape("schema", "candle", {
  getPoints: function(shapePoint) {
    var x = shapePoint.x, y = shapePoint.y, size2 = shapePoint.size;
    return getCandlePoints(x, y, size2);
  },
  draw: function(cfg, container) {
    var style = getStyle(cfg, true, true);
    var path2 = this.parsePath(getCandlePath(cfg.points));
    var shape = container.addShape("path", {
      attrs: __assign$1(__assign$1({}, style), { path: path2, name: "schema" })
    });
    return shape;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: function(x, y, r) {
        var yValues = [y + 7.5, y + 3, y - 3, y - 7.5];
        var points2 = getCandlePoints(x, yValues, r);
        return [
          ["M", points2[0].x, points2[0].y],
          ["L", points2[1].x, points2[1].y],
          ["M", points2[2].x, points2[2].y],
          ["L", points2[3].x, points2[3].y],
          ["L", points2[4].x, points2[4].y],
          ["L", points2[5].x, points2[5].y],
          ["Z"],
          ["M", points2[6].x, points2[6].y],
          ["L", points2[7].x, points2[7].y]
        ];
      },
      style: {
        lineWidth: 1,
        stroke: color2,
        fill: color2,
        r: 6
      }
    };
  }
});
function getRectAttrs(points2, size2) {
  var width = Math.abs(points2[0].x - points2[2].x);
  var height = Math.abs(points2[0].y - points2[2].y);
  var len = Math.min(width, height);
  if (size2) {
    len = clamp(size2, 0, Math.min(width, height));
  }
  len = len / 2;
  var centerX = (points2[0].x + points2[2].x) / 2;
  var centerY = (points2[0].y + points2[2].y) / 2;
  return {
    x: centerX - len,
    y: centerY - len,
    width: len * 2,
    height: len * 2
  };
}
registerShape("polygon", "square", {
  draw: function(cfg, container) {
    if (!isEmpty(cfg.points)) {
      var shapeAttrs = getStyle(cfg, true, true);
      var points2 = this.parsePoints(cfg.points);
      return container.addShape("rect", {
        attrs: __assign$1(__assign$1({}, shapeAttrs), getRectAttrs(points2, cfg.size)),
        name: "polygon"
      });
    }
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "square",
      style: {
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("violin", "smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, true);
    var path2 = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        stroke: null,
        r: 4,
        fill: color2
      }
    };
  }
});
registerShape("violin", "hollow", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, false);
    var path2 = this.parsePath(getViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
registerShape("violin", "hollow-smooth", {
  draw: function(cfg, container) {
    var attrs = getStyle(cfg, true, false);
    var path2 = this.parsePath(getSmoothViolinPath(cfg.points));
    return container.addShape("path", {
      attrs: __assign$1(__assign$1({}, attrs), { path: path2 })
    });
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        r: 4,
        fill: null,
        stroke: color2
      }
    };
  }
});
var IntervalLabel = (
  /** @class */
  function(_super) {
    __extends$1(IntervalLabel2, _super);
    function IntervalLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    IntervalLabel2.prototype.getLabelValueDir = function(mappingData) {
      var dim = "y";
      var points2 = mappingData.points;
      return points2[0][dim] <= points2[2][dim] ? 1 : -1;
    };
    IntervalLabel2.prototype.getLabelOffsetPoint = function(labelCfg, index2, total, position) {
      var _a2;
      var point2 = _super.prototype.getLabelOffsetPoint.call(this, labelCfg, index2, total);
      var coordinate2 = this.getCoordinate();
      var transposed = coordinate2.isTransposed;
      var dim = transposed ? "x" : "y";
      var dir = this.getLabelValueDir(labelCfg.mappingData);
      point2 = __assign$1(__assign$1({}, point2), (_a2 = {}, _a2[dim] = point2[dim] * dir, _a2));
      if (coordinate2.isReflect("x")) {
        point2 = __assign$1(__assign$1({}, point2), { x: point2.x * -1 });
      }
      if (coordinate2.isReflect("y")) {
        point2 = __assign$1(__assign$1({}, point2), { y: point2.y * -1 });
      }
      return point2;
    };
    IntervalLabel2.prototype.getThemedLabelCfg = function(labelCfg) {
      var geometry2 = this.geometry;
      var defaultLabelCfg = this.getDefaultLabelCfg();
      var theme2 = geometry2.theme;
      return deepMix({}, defaultLabelCfg, theme2.labels, labelCfg.position === "middle" ? { offset: 0 } : {}, labelCfg);
    };
    IntervalLabel2.prototype.setLabelPosition = function(labelPointCfg, mappingData, index2, position) {
      var coordinate2 = this.getCoordinate();
      var transposed = coordinate2.isTransposed;
      var shapePoints = mappingData.points;
      var point0 = coordinate2.convert(shapePoints[0]);
      var point2 = coordinate2.convert(shapePoints[2]);
      var dir = this.getLabelValueDir(mappingData);
      var top;
      var right2;
      var bottom;
      var left2;
      var shape = isArray$1(mappingData.shape) ? mappingData.shape[0] : mappingData.shape;
      if (shape === "funnel" || shape === "pyramid") {
        var nextPoints = get(mappingData, "nextPoints");
        var points2 = get(mappingData, "points");
        if (nextPoints) {
          var p0 = coordinate2.convert(points2[0]);
          var p1 = coordinate2.convert(points2[1]);
          var nextP0 = coordinate2.convert(nextPoints[0]);
          var nextP1 = coordinate2.convert(nextPoints[1]);
          if (transposed) {
            top = Math.min(nextP0.y, p0.y);
            bottom = Math.max(nextP0.y, p0.y);
            right2 = (p1.x + nextP1.x) / 2;
            left2 = (p0.x + nextP0.x) / 2;
          } else {
            top = Math.min((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            bottom = Math.max((p1.y + nextP1.y) / 2, (p0.y + nextP0.y) / 2);
            right2 = nextP1.x;
            left2 = p0.x;
          }
        } else {
          top = Math.min(point2.y, point0.y);
          bottom = Math.max(point2.y, point0.y);
          right2 = point2.x;
          left2 = point0.x;
        }
      } else {
        top = Math.min(point2.y, point0.y);
        bottom = Math.max(point2.y, point0.y);
        right2 = point2.x;
        left2 = point0.x;
      }
      switch (position) {
        case "right":
          labelPointCfg.x = right2;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "left":
          labelPointCfg.x = left2;
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get(labelPointCfg, "textAlign", dir > 0 ? "left" : "right");
          break;
        case "bottom":
          if (transposed) {
            labelPointCfg.x = (right2 + left2) / 2;
          }
          labelPointCfg.y = bottom;
          labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
        case "middle":
          if (transposed) {
            labelPointCfg.x = (right2 + left2) / 2;
          }
          labelPointCfg.y = (top + bottom) / 2;
          labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", "middle");
          break;
        case "top":
          if (transposed) {
            labelPointCfg.x = (right2 + left2) / 2;
          }
          labelPointCfg.y = top;
          labelPointCfg.textAlign = get(labelPointCfg, "textAlign", "center");
          labelPointCfg.textBaseline = get(labelPointCfg, "textBaseline", dir > 0 ? "bottom" : "top");
          break;
      }
    };
    return IntervalLabel2;
  }(GeometryLabel)
);
var HALF_PI = Math.PI / 2;
var PolarLabel = (
  /** @class */
  function(_super) {
    __extends$1(PolarLabel2, _super);
    function PolarLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PolarLabel2.prototype.getLabelOffset = function(offset) {
      var coordinate2 = this.getCoordinate();
      var actualOffset = 0;
      if (isNumber$1(offset)) {
        actualOffset = offset;
      } else if (isString(offset) && offset.indexOf("%") !== -1) {
        var r = coordinate2.getRadius();
        if (coordinate2.innerRadius > 0) {
          r = r * (1 - coordinate2.innerRadius);
        }
        actualOffset = parseFloat(offset) * 0.01 * r;
      }
      return actualOffset;
    };
    PolarLabel2.prototype.getLabelItems = function(mapppingArray) {
      var items = _super.prototype.getLabelItems.call(this, mapppingArray);
      var yScale = this.geometry.getYScale();
      return map$2(items, function(item) {
        if (item && yScale) {
          var percent2 = yScale.scale(get(item.data, yScale.field));
          return __assign$1(__assign$1({}, item), { percent: percent2 });
        }
        return item;
      });
    };
    PolarLabel2.prototype.getLabelAlign = function(point2) {
      var coordinate2 = this.getCoordinate();
      var align;
      if (point2.labelEmit) {
        align = point2.angle <= Math.PI / 2 && point2.angle >= -Math.PI / 2 ? "left" : "right";
      } else if (!coordinate2.isTransposed) {
        align = "center";
      } else {
        var center2 = coordinate2.getCenter();
        var offset = point2.offset;
        if (Math.abs(point2.x - center2.x) < 1) {
          align = "center";
        } else if (point2.angle > Math.PI || point2.angle <= 0) {
          align = offset > 0 ? "left" : "right";
        } else {
          align = offset > 0 ? "right" : "left";
        }
      }
      return align;
    };
    PolarLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
      var factor = 1;
      var arcPoint;
      var content = labelCfg.content[index2];
      if (this.isToMiddle(mappingData)) {
        arcPoint = this.getMiddlePoint(mappingData.points);
      } else {
        if (labelCfg.content.length === 1 && index2 === 0) {
          index2 = 1;
        } else if (index2 === 0) {
          factor = -1;
        }
        arcPoint = this.getArcPoint(mappingData, index2);
      }
      var offset = labelCfg.offset * factor;
      var middleAngle = this.getPointAngle(arcPoint);
      var isLabelEmit = labelCfg.labelEmit;
      var labelPositionCfg = this.getCirclePoint(middleAngle, offset, arcPoint, isLabelEmit);
      if (labelPositionCfg.r === 0) {
        labelPositionCfg.content = "";
      } else {
        labelPositionCfg.content = content;
        labelPositionCfg.angle = middleAngle;
        labelPositionCfg.color = mappingData.color;
      }
      labelPositionCfg.rotate = labelCfg.autoRotate ? this.getLabelRotate(middleAngle, offset, isLabelEmit) : labelCfg.rotate;
      labelPositionCfg.start = {
        x: arcPoint.x,
        y: arcPoint.y
      };
      return labelPositionCfg;
    };
    PolarLabel2.prototype.getArcPoint = function(mappingData, index2) {
      if (index2 === void 0) {
        index2 = 0;
      }
      if (!isArray$1(mappingData.x) && !isArray$1(mappingData.y)) {
        return {
          x: mappingData.x,
          y: mappingData.y
        };
      }
      return {
        x: isArray$1(mappingData.x) ? mappingData.x[index2] : mappingData.x,
        y: isArray$1(mappingData.y) ? mappingData.y[index2] : mappingData.y
      };
    };
    PolarLabel2.prototype.getPointAngle = function(point2) {
      return getAngleByPoint(this.getCoordinate(), point2);
    };
    PolarLabel2.prototype.getCirclePoint = function(angle2, offset, point2, isLabelEmit) {
      var coordinate2 = this.getCoordinate();
      var center2 = coordinate2.getCenter();
      var r = getDistanceToCenter(coordinate2, point2);
      if (r === 0) {
        return __assign$1(__assign$1({}, center2), { r });
      }
      var labelAngle = angle2;
      if (coordinate2.isTransposed && r > offset && !isLabelEmit) {
        var appendAngle = Math.asin(offset / (2 * r));
        labelAngle = angle2 + appendAngle * 2;
      } else {
        r = r + offset;
      }
      return {
        x: center2.x + r * Math.cos(labelAngle),
        y: center2.y + r * Math.sin(labelAngle),
        r
      };
    };
    PolarLabel2.prototype.getLabelRotate = function(angle2, offset, isLabelEmit) {
      var rotate2 = angle2 + HALF_PI;
      if (isLabelEmit) {
        rotate2 -= HALF_PI;
      }
      if (rotate2) {
        if (rotate2 > HALF_PI) {
          rotate2 = rotate2 - Math.PI;
        } else if (rotate2 < -HALF_PI) {
          rotate2 = rotate2 + Math.PI;
        }
      }
      return rotate2;
    };
    PolarLabel2.prototype.getMiddlePoint = function(points2) {
      var coordinate2 = this.getCoordinate();
      var count2 = points2.length;
      var middlePoint = {
        x: 0,
        y: 0
      };
      each$1(points2, function(point2) {
        middlePoint.x += point2.x;
        middlePoint.y += point2.y;
      });
      middlePoint.x /= count2;
      middlePoint.y /= count2;
      middlePoint = coordinate2.convert(middlePoint);
      return middlePoint;
    };
    PolarLabel2.prototype.isToMiddle = function(mappingData) {
      return mappingData.x.length > 2;
    };
    return PolarLabel2;
  }(GeometryLabel)
);
var PieLabel = (
  /** @class */
  function(_super) {
    __extends$1(PieLabel2, _super);
    function PieLabel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.defaultLayout = "distribute";
      return _this;
    }
    PieLabel2.prototype.getDefaultLabelCfg = function(offset, position) {
      var cfg = _super.prototype.getDefaultLabelCfg.call(this, offset, position);
      return deepMix({}, cfg, get(this.geometry.theme, "pieLabels", {}));
    };
    PieLabel2.prototype.getLabelOffset = function(offset) {
      return _super.prototype.getLabelOffset.call(this, offset) || 0;
    };
    PieLabel2.prototype.getLabelRotate = function(angle2, offset, isLabelLimit) {
      var rotate2;
      if (offset < 0) {
        rotate2 = angle2;
        if (rotate2 > Math.PI / 2) {
          rotate2 = rotate2 - Math.PI;
        }
        if (rotate2 < -Math.PI / 2) {
          rotate2 = rotate2 + Math.PI;
        }
      }
      return rotate2;
    };
    PieLabel2.prototype.getLabelAlign = function(point2) {
      var coordinate2 = this.getCoordinate();
      var center2 = coordinate2.getCenter();
      var align;
      if (point2.angle <= Math.PI / 2 && point2.x >= center2.x) {
        align = "left";
      } else {
        align = "right";
      }
      if (point2.offset <= 0) {
        if (align === "right") {
          align = "left";
        } else {
          align = "right";
        }
      }
      return align;
    };
    PieLabel2.prototype.getArcPoint = function(point2) {
      return point2;
    };
    PieLabel2.prototype.getPointAngle = function(point2) {
      var coordinate2 = this.getCoordinate();
      var startPoint = {
        x: isArray$1(point2.x) ? point2.x[0] : point2.x,
        y: point2.y[0]
      };
      var endPoint = {
        x: isArray$1(point2.x) ? point2.x[1] : point2.x,
        y: point2.y[1]
      };
      var angle2;
      var startAngle = getAngleByPoint(coordinate2, startPoint);
      if (point2.points && point2.points[0].y === point2.points[1].y) {
        angle2 = startAngle;
      } else {
        var endAngle = getAngleByPoint(coordinate2, endPoint);
        if (startAngle >= endAngle) {
          endAngle = endAngle + Math.PI * 2;
        }
        angle2 = startAngle + (endAngle - startAngle) / 2;
      }
      return angle2;
    };
    PieLabel2.prototype.getCirclePoint = function(angle2, offset) {
      var coordinate2 = this.getCoordinate();
      var center2 = coordinate2.getCenter();
      var r = coordinate2.getRadius() + offset;
      return __assign$1(__assign$1({}, polarToCartesian(center2.x, center2.y, r, angle2)), { angle: angle2, r });
    };
    return PieLabel2;
  }(PolarLabel)
);
var MARGIN$1 = 4;
function antiCollision$1(labelShapes, labels, lineHeight, plotRange, center2, isRight) {
  var e_1, _a2;
  var overlapping = true;
  var start = plotRange.start;
  var end = plotRange.end;
  var startY = Math.min(start.y, end.y);
  var totalHeight = Math.abs(start.y - end.y);
  var i;
  var maxY2 = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label2) {
    if (label2.y > maxY2) {
      maxY2 = label2.y;
    }
    if (label2.y < minY) {
      minY = label2.y;
    }
    return {
      size: lineHeight,
      targets: [label2.y - startY]
    };
  });
  minY -= startY;
  if (maxY2 - startY > totalHeight) {
    totalHeight = maxY2 - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target2 = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target2 - box3.size / 2), totalHeight - box3.size);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + lineHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += lineHeight;
      i++;
    });
  });
  var labelsMap = {};
  try {
    for (var labelShapes_1 = __values(labelShapes), labelShapes_1_1 = labelShapes_1.next(); !labelShapes_1_1.done; labelShapes_1_1 = labelShapes_1.next()) {
      var labelShape = labelShapes_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labelShapes_1_1 && !labelShapes_1_1.done && (_a2 = labelShapes_1.return))
        _a2.call(labelShapes_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  labels.forEach(function(label2) {
    var rPow2 = label2.r * label2.r;
    var dyPow2 = Math.pow(Math.abs(label2.y - center2.y), 2);
    if (rPow2 < dyPow2) {
      label2.x = center2.x;
    } else {
      var dx = Math.sqrt(rPow2 - dyPow2);
      if (!isRight) {
        label2.x = center2.x - dx;
      } else {
        label2.x = center2.x + dx;
      }
    }
    var labelShape2 = labelsMap[label2.id];
    labelShape2.attr("x", label2.x);
    labelShape2.attr("y", label2.y);
    var textShape = find$1(labelShape2.getChildren(), function(ele) {
      return ele.get("type") === "text";
    });
    if (textShape) {
      textShape.attr("y", label2.y);
      textShape.attr("x", label2.x);
    }
  });
}
function distribute(items, labels, shapes, region) {
  if (!items.length || !labels.length) {
    return;
  }
  var offset = items[0] ? items[0].offset : 0;
  var coordinate2 = labels[0].get("coordinate");
  var radius = coordinate2.getRadius();
  var center2 = coordinate2.getCenter();
  if (offset > 0) {
    var lineHeight_1 = 14;
    var totalR = radius + offset;
    var totalHeight_1 = totalR * 2 + lineHeight_1 * 2;
    var plotRange_1 = {
      start: coordinate2.start,
      end: coordinate2.end
    };
    var halves_1 = [
      [],
      []
      // right
    ];
    items.forEach(function(labelItem) {
      if (!labelItem) {
        return;
      }
      if (labelItem.textAlign === "right") {
        halves_1[0].push(labelItem);
      } else {
        halves_1[1].push(labelItem);
      }
    });
    halves_1.forEach(function(half, index2) {
      var maxLabelsCountForOneSide = totalHeight_1 / lineHeight_1;
      if (half.length > maxLabelsCountForOneSide) {
        half.sort(function(a, b) {
          return b["..percent"] - a["..percent"];
        });
        half.splice(maxLabelsCountForOneSide, half.length - maxLabelsCountForOneSide);
      }
      half.sort(function(a, b) {
        return a.y - b.y;
      });
      antiCollision$1(labels, half, lineHeight_1, plotRange_1, center2, index2);
    });
  }
  each$1(items, function(item) {
    if (item && item.labelLine) {
      var distance2 = item.offset;
      var angle2 = item.angle;
      var startPoint = polarToCartesian(center2.x, center2.y, radius, angle2);
      var innerPoint = polarToCartesian(center2.x, center2.y, radius + distance2 / 2, angle2);
      var itemX = item.x + get(item, "offsetX", 0);
      var itemY = item.y + get(item, "offsetY", 0);
      var endPoint = {
        x: itemX - Math.cos(angle2) * MARGIN$1,
        y: itemY - Math.sin(angle2) * MARGIN$1
      };
      if (!isObject(item.labelLine)) {
        item.labelLine = {};
      }
      item.labelLine.path = [
        "M ".concat(startPoint.x),
        "".concat(startPoint.y, " Q").concat(innerPoint.x),
        "".concat(innerPoint.y, " ").concat(endPoint.x),
        endPoint.y
      ].join(",");
    }
  });
}
function antiCollision(items, labelHeight, plotRange) {
  var labels = items.filter(function(item) {
    return !item.invisible;
  });
  labels.sort(function(a, b) {
    return a.y - b.y;
  });
  var overlapping = true;
  var startY = plotRange.minY;
  var endY = plotRange.maxY;
  var totalHeight = Math.abs(startY - endY);
  var i;
  var maxY2 = 0;
  var minY = Number.MIN_VALUE;
  var boxes = labels.map(function(label2) {
    if (label2.y > maxY2) {
      maxY2 = label2.y;
    }
    if (label2.y < minY) {
      minY = label2.y;
    }
    return {
      content: label2.content,
      size: labelHeight,
      targets: [label2.y - startY],
      pos: null
    };
  });
  minY -= startY;
  if (maxY2 - startY > totalHeight) {
    totalHeight = maxY2 - startY;
  }
  while (overlapping) {
    boxes.forEach(function(box3) {
      var target2 = (Math.min.apply(minY, box3.targets) + Math.max.apply(minY, box3.targets)) / 2;
      box3.pos = Math.min(Math.max(minY, target2 - box3.size / 2), totalHeight - box3.size);
      box3.pos = Math.max(0, box3.pos);
    });
    overlapping = false;
    i = boxes.length;
    while (i--) {
      if (i > 0) {
        var previousBox = boxes[i - 1];
        var box2 = boxes[i];
        if (previousBox.pos + previousBox.size > box2.pos) {
          previousBox.size += box2.size;
          previousBox.targets = previousBox.targets.concat(box2.targets);
          if (previousBox.pos + previousBox.size > totalHeight) {
            previousBox.pos = totalHeight - previousBox.size;
          }
          boxes.splice(i, 1);
          overlapping = true;
        }
      }
    }
  }
  i = 0;
  boxes.forEach(function(b) {
    var posInCompositeBox = startY + labelHeight / 2;
    b.targets.forEach(function() {
      labels[i].y = b.pos + posInCompositeBox;
      posInCompositeBox += labelHeight;
      i++;
    });
  });
}
var MARGIN = 4;
function drawLabelline$1(item, coordinate2) {
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  if (item && item.labelLine) {
    var angle2 = item.angle, labelOffset = item.offset;
    var startPoint = polarToCartesian(center2.x, center2.y, radius, angle2);
    var itemX = item.x + get(item, "offsetX", 0) * (Math.cos(angle2) > 0 ? 1 : -1);
    var itemY = item.y + get(item, "offsetY", 0) * (Math.sin(angle2) > 0 ? 1 : -1);
    var endPoint = {
      x: itemX - Math.cos(angle2) * MARGIN,
      y: itemY - Math.sin(angle2) * MARGIN
    };
    var smoothConnector = item.labelLine.smooth;
    var path2 = [];
    var dx = endPoint.x - center2.x;
    var dy = endPoint.y - center2.y;
    var endAngle = Math.atan(dy / dx);
    if (dx < 0) {
      endAngle += Math.PI;
    }
    if (smoothConnector === false) {
      if (!isObject(item.labelLine)) {
        item.labelLine = {};
      }
      var sweepFlag = 0;
      if (angle2 < 0 && angle2 > -Math.PI / 2 || angle2 > Math.PI * 1.5) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 >= 0 && angle2 < Math.PI / 2) {
        if (endPoint.y > startPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 >= Math.PI / 2 && angle2 < Math.PI) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      if (angle2 < -Math.PI / 2 || angle2 >= Math.PI && angle2 < Math.PI * 1.5) {
        if (startPoint.y > endPoint.y) {
          sweepFlag = 1;
        }
      }
      var distance2 = labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0);
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + distance2, angle2);
      var breakPoint3 = polarToCartesian(center2.x, center2.y, radius + labelOffset / 2, endAngle);
      var largeArcFlag = 0;
      path2.push("M ".concat(startPoint.x, " ").concat(startPoint.y));
      path2.push("L ".concat(breakPoint.x, " ").concat(breakPoint.y));
      path2.push("A ".concat(center2.x, " ").concat(center2.y, " 0 ").concat(largeArcFlag, " ").concat(sweepFlag, " ").concat(breakPoint3.x, " ").concat(breakPoint3.y));
      path2.push("L ".concat(endPoint.x, " ").concat(endPoint.y));
    } else {
      var breakPoint = polarToCartesian(center2.x, center2.y, radius + (labelOffset / 2 > 4 ? 4 : Math.max(labelOffset / 2 - 1, 0)), angle2);
      var xSign = startPoint.x < center2.x ? 1 : -1;
      path2.push("M ".concat(endPoint.x, " ").concat(endPoint.y));
      var slope1 = (startPoint.y - center2.y) / (startPoint.x - center2.x);
      var slope2 = (endPoint.y - center2.y) / (endPoint.x - center2.x);
      if (Math.abs(slope1 - slope2) > Math.pow(Math.E, -16)) {
        path2.push.apply(path2, [
          "C",
          endPoint.x + xSign * 4,
          endPoint.y,
          2 * breakPoint.x - startPoint.x,
          2 * breakPoint.y - startPoint.y,
          startPoint.x,
          startPoint.y
        ]);
      }
      path2.push("L ".concat(startPoint.x, " ").concat(startPoint.y));
    }
    item.labelLine.path = path2.join(" ");
  }
}
function pieOuterLabelLayout(originalItems, labels, shapes, region) {
  var e_1, _a2;
  var items = filter(originalItems, function(item) {
    return !isNil(item);
  });
  var coordinate2 = labels[0] && labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a2 = labels_1.return))
        _a2.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get(items[0], "labelHeight", 14);
  var labelOffset = get(items[0], "offset", 0);
  if (labelOffset <= 0) {
    return;
  }
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = groupBy(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var start = coordinate2.start, end = coordinate2.end;
  var totalHeight = Math.min((radius + labelOffset + labelHeight) * 2, coordinate2.getHeight());
  var totalR = totalHeight / 2;
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalR,
    maxY: center2.y + totalR
  };
  each$1(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = Math.floor(totalHeight / labelHeight);
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each$1(half, function(labelItem, idx) {
        if (idx + 1 > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision(half, labelHeight, labelsContainerRange);
  });
  each$1(separateLabels, function(half, key) {
    each$1(half, function(item) {
      var isRight = key === RIGHT_HALF_KEY;
      var labelShape2 = labelsMap[item.id];
      var content = labelShape2.getChildByIndex(0);
      if (content) {
        var r = radius + labelOffset;
        var dy = item.y - center2.y;
        var rPow2 = Math.pow(r, 2);
        var dyPow2 = Math.pow(dy, 2);
        var dxPow2 = rPow2 - dyPow2 > 0 ? rPow2 - dyPow2 : 0;
        var dx = Math.sqrt(dxPow2);
        var dx_offset = Math.abs(Math.cos(item.angle) * r);
        if (!isRight) {
          item.x = center2.x - Math.max(dx, dx_offset);
        } else {
          item.x = center2.x + Math.max(dx, dx_offset);
        }
      }
      if (content) {
        content.attr("y", item.y);
        content.attr("x", item.x);
      }
      drawLabelline$1(item, coordinate2);
    });
  });
}
var INFLECTION_OFFSET = 4;
var LABEL_OFFSET_X = 4;
var LABEL_TEXT_LINE_OFFSET = 4;
function drawLabelline(item, coordinate2, inRight) {
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var startPoint = {
    x: item.x - (inRight ? LABEL_TEXT_LINE_OFFSET : -LABEL_TEXT_LINE_OFFSET),
    y: item.y
  };
  var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
  var p1 = { x: startPoint.x, y: startPoint.y };
  var p2 = { x: inflectionPoint.x, y: inflectionPoint.y };
  var endPoint = polarToCartesian(center2.x, center2.y, radius, item.angle);
  var path2 = "";
  if (startPoint.y !== inflectionPoint.y) {
    var offset = inRight ? 4 : -4;
    p1.y = startPoint.y;
    if (item.angle < 0 && item.angle >= -Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > 0 && item.angle < Math.PI / 2) {
      p1.x = Math.max(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.max(p2.x, p1.x - offset);
      }
    }
    if (item.angle > Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y > inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
    if (item.angle < -Math.PI / 2) {
      p1.x = Math.min(inflectionPoint.x, startPoint.x - offset);
      if (startPoint.y < inflectionPoint.y) {
        p2.y = p1.y;
      } else {
        p2.y = inflectionPoint.y;
        p2.x = Math.min(p2.x, p1.x - offset);
      }
    }
  }
  path2 = [
    "M ".concat(startPoint.x, ",").concat(startPoint.y),
    "L ".concat(p1.x, ",").concat(p1.y),
    "L ".concat(p2.x, ",").concat(p2.y),
    "L ".concat(inflectionPoint.x, ",").concat(inflectionPoint.y),
    "L ".concat(endPoint.x, ",").concat(endPoint.y)
  ].join(" ");
  item.labelLine = deepMix({}, item.labelLine, { path: path2 });
}
function pieSpiderLabelLayout(items, labels, shapes, region) {
  var e_1, _a2;
  var coordinate2 = labels[0] && labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var center2 = coordinate2.getCenter();
  var radius = coordinate2.getRadius();
  var labelsMap = {};
  try {
    for (var labels_1 = __values(labels), labels_1_1 = labels_1.next(); !labels_1_1.done; labels_1_1 = labels_1.next()) {
      var labelShape = labels_1_1.value;
      labelsMap[labelShape.get("id")] = labelShape;
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (labels_1_1 && !labels_1_1.done && (_a2 = labels_1.return))
        _a2.call(labels_1);
    } finally {
      if (e_1)
        throw e_1.error;
    }
  }
  var labelHeight = get(items[0], "labelHeight", 14);
  var labelOffset = Math.max(get(items[0], "offset", 0), INFLECTION_OFFSET);
  each$1(items, function(item) {
    if (!item)
      return;
    var label2 = get(labelsMap, [item.id]);
    if (!label2)
      return;
    var inRight = item.x > center2.x || item.x === center2.x && item.y > center2.y;
    var offsetX = !isNil(item.offsetX) ? item.offsetX : LABEL_OFFSET_X;
    var inflectionPoint = polarToCartesian(center2.x, center2.y, radius + INFLECTION_OFFSET, item.angle);
    var totalOffset = labelOffset + offsetX;
    item.x = center2.x + (inRight ? 1 : -1) * (radius + totalOffset);
    item.y = inflectionPoint.y;
  });
  var start = coordinate2.start, end = coordinate2.end;
  var LEFT_HALF_KEY = "left";
  var RIGHT_HALF_KEY = "right";
  var separateLabels = groupBy(items, function(item) {
    return item.x < center2.x ? LEFT_HALF_KEY : RIGHT_HALF_KEY;
  });
  var totalHeight = (radius + labelOffset) * 2 + labelHeight;
  each$1(separateLabels, function(half) {
    var halfHeight = half.length * labelHeight;
    if (halfHeight > totalHeight) {
      totalHeight = Math.min(halfHeight, Math.abs(start.y - end.y));
    }
  });
  var labelsContainerRange = {
    minX: start.x,
    maxX: end.x,
    minY: center2.y - totalHeight / 2,
    maxY: center2.y + totalHeight / 2
  };
  each$1(separateLabels, function(half, key) {
    var maxLabelsCountForOneSide = totalHeight / labelHeight;
    if (half.length > maxLabelsCountForOneSide) {
      half.sort(function(a, b) {
        return b.percent - a.percent;
      });
      each$1(half, function(labelItem, idx) {
        if (idx > maxLabelsCountForOneSide) {
          labelsMap[labelItem.id].set("visible", false);
          labelItem.invisible = true;
        }
      });
    }
    antiCollision(half, labelHeight, labelsContainerRange);
  });
  var startY = labelsContainerRange.minY;
  var endY = labelsContainerRange.maxY;
  each$1(separateLabels, function(half, key) {
    var inRight = key === RIGHT_HALF_KEY;
    each$1(half, function(item) {
      var label2 = get(labelsMap, item && [item.id]);
      if (!label2) {
        return;
      }
      if (item.y < startY || item.y > endY) {
        label2.set("visible", false);
        return;
      }
      var labelContent = label2.getChildByIndex(0);
      var box2 = labelContent.getCanvasBBox();
      var originalPos = {
        x: inRight ? box2.x : box2.maxX,
        y: box2.y + box2.height / 2
        /** vertical-align: middle */
      };
      translate(labelContent, item.x - originalPos.x, item.y - originalPos.y);
      if (item.labelLine) {
        drawLabelline(item, coordinate2, inRight);
      }
    });
  });
}
function limitInCanvas(items, labels, shapes, region) {
  each$1(labels, function(label2) {
    var regionMinX = region.minX, regionMinY = region.minY, regionMaxX = region.maxX, regionMaxY = region.maxY;
    var _a2 = label2.getCanvasBBox(), minX = _a2.minX, minY = _a2.minY, maxX = _a2.maxX, maxY2 = _a2.maxY, x = _a2.x, y = _a2.y, width = _a2.width, height = _a2.height;
    var finalX = x;
    var finalY = y;
    if (minX < regionMinX || maxX < regionMinX) {
      finalX = regionMinX;
    }
    if (minY < regionMinY || maxY2 < regionMinY) {
      finalY = regionMinY;
    }
    if (minX > regionMaxX) {
      finalX = regionMaxX - width;
    } else if (maxX > regionMaxX) {
      finalX = finalX - (maxX - regionMaxX);
    }
    if (minY > regionMaxY) {
      finalY = regionMaxY - height;
    } else if (maxY2 > regionMaxY) {
      finalY = finalY - (maxY2 - regionMaxY);
    }
    if (finalX !== x || finalY !== y) {
      translate(label2, finalX - x, finalY - y);
    }
  });
}
function limitInShape(items, labels, shapes, region) {
  each$1(labels, function(label2, index2) {
    var labelBBox = label2.getCanvasBBox();
    var shapeBBox = shapes[index2].getBBox();
    if (labelBBox.minX < shapeBBox.minX || labelBBox.minY < shapeBBox.minY || labelBBox.maxX > shapeBBox.maxX || labelBBox.maxY > shapeBBox.maxY) {
      label2.remove(true);
    }
  });
}
var MAX_TIMES = 100;
var Greedy = (
  /** @class */
  function() {
    function Greedy2(cfg) {
      if (cfg === void 0) {
        cfg = {};
      }
      this.bitmap = {};
      var _a2 = cfg.xGap, xGap = _a2 === void 0 ? 1 : _a2, _b = cfg.yGap, yGap = _b === void 0 ? 8 : _b;
      this.xGap = xGap;
      this.yGap = yGap;
    }
    Greedy2.prototype.hasGap = function(bbox) {
      var hasGap = true;
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY2 = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
          continue;
        }
        if (i === minX || i === maxX) {
          for (var j = minY; j <= maxY2; j++) {
            if (bitmap[i][j]) {
              hasGap = false;
              break;
            }
          }
        } else {
          if (bitmap[i][minY] || bitmap[i][maxY2]) {
            hasGap = false;
            break;
          }
        }
      }
      return hasGap;
    };
    Greedy2.prototype.fillGap = function(bbox) {
      var bitmap = this.bitmap;
      var minX = Math.round(bbox.minX);
      var maxX = Math.round(bbox.maxX);
      var minY = Math.round(bbox.minY);
      var maxY2 = Math.round(bbox.maxY);
      for (var i = minX; i <= maxX; i += 1) {
        if (!bitmap[i]) {
          bitmap[i] = {};
        }
      }
      for (var i = minX; i <= maxX; i += this.xGap) {
        for (var j = minY; j <= maxY2; j += this.yGap) {
          bitmap[i][j] = true;
        }
        bitmap[i][maxY2] = true;
      }
      if (this.yGap !== 1) {
        for (var i = minY; i <= maxY2; i += 1) {
          bitmap[minX][i] = true;
          bitmap[maxX][i] = true;
        }
      }
      if (this.xGap !== 1) {
        for (var i = minX; i <= maxX; i += 1) {
          bitmap[i][minY] = true;
          bitmap[i][maxY2] = true;
        }
      }
    };
    Greedy2.prototype.destroy = function() {
      this.bitmap = {};
    };
    return Greedy2;
  }()
);
function spiralFill(label2, greedy, maxTimes) {
  if (maxTimes === void 0) {
    maxTimes = MAX_TIMES;
  }
  var dt = -1;
  var _a2 = label2.attr(), x = _a2.x, y = _a2.y;
  var bbox = label2.getCanvasBBox();
  var maxDelta = Math.sqrt(bbox.width * bbox.width + bbox.height * bbox.height);
  var dxdy;
  var t = -dt;
  var dx = 0;
  var dy = 0;
  var f = function(param) {
    var nt = param * 0.1;
    return [nt * Math.cos(nt), nt * Math.sin(nt)];
  };
  if (greedy.hasGap(bbox)) {
    greedy.fillGap(bbox);
    return true;
  }
  var canFill = false;
  var times2 = 0;
  var accessedCache = {};
  while (Math.min(Math.abs(dx), Math.abs(dy)) < maxDelta && times2 < maxTimes) {
    dxdy = f(t += dt);
    dx = ~~dxdy[0];
    dy = ~~dxdy[1];
    if (!dx && !dy || accessedCache["".concat(dx, "-").concat(dy)]) {
      continue;
    }
    label2.attr({ x: x + dx, y: y + dy });
    if (dx + dy < 0) {
      label2.attr("textAlign", "right");
    }
    times2++;
    if (greedy.hasGap(label2.getCanvasBBox())) {
      greedy.fillGap(label2.getCanvasBBox());
      canFill = true;
      accessedCache["".concat(dx, "-").concat(dy)] = true;
      break;
    }
  }
  return canFill;
}
function adjustLabelPosition(label2, x, y, index2) {
  var _a2 = label2.getCanvasBBox(), width = _a2.width, height = _a2.height;
  var attrs = {
    x,
    y,
    textAlign: "center"
  };
  switch (index2) {
    case 0:
      attrs.y -= height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 1:
      attrs.y -= height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 2:
      attrs.y += height + 1;
      attrs.x -= 1;
      attrs.textAlign = "right";
      break;
    case 3:
      attrs.y += height + 1;
      attrs.x += 1;
      attrs.textAlign = "left";
      break;
    case 5:
      attrs.y -= height * 2 + 2;
      break;
    case 6:
      attrs.y += height * 2 + 2;
      break;
    case 7:
      attrs.x += width + 1;
      attrs.textAlign = "left";
      break;
    case 8:
      attrs.x -= width + 1;
      attrs.textAlign = "right";
      break;
  }
  label2.attr(attrs);
  return label2.getCanvasBBox();
}
function fixedOverlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each$1(labels, function(label2) {
    var labelShape = label2.find(function(shape) {
      return shape.get("type") === "text";
    });
    if (!spiralFill(labelShape, greedy)) {
      label2.remove(true);
    }
  });
  greedy.destroy();
}
function overlap(items, labels, shapes, region) {
  var greedy = new Greedy();
  each$1(labels, function(label2) {
    var labelShape = label2.find(function(shape) {
      return shape.get("type") === "text";
    });
    var _a2 = labelShape.attr(), x = _a2.x, y = _a2.y;
    var canFill = false;
    for (var i = 0; i <= 8; i++) {
      var bbox = adjustLabelPosition(labelShape, x, y, i);
      if (greedy.hasGap(bbox)) {
        greedy.fillGap(bbox);
        canFill = true;
        break;
      }
    }
    if (!canFill) {
      label2.remove(true);
    }
  });
  greedy.destroy();
}
function dot$1(a, b) {
  return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
}
function getAxes(points2) {
  if (points2.length > 4) {
    return [];
  }
  var vector = function(start, end) {
    return [end.x - start.x, end.y - start.y];
  };
  var AB = vector(points2[0], points2[1]);
  var BC = vector(points2[1], points2[2]);
  return [AB, BC];
}
function rotateAtPoint(point2, deg, origin) {
  if (deg === void 0) {
    deg = 0;
  }
  if (origin === void 0) {
    origin = { x: 0, y: 0 };
  }
  var x = point2.x, y = point2.y;
  return {
    x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
    y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
  };
}
function getRectPoints(box2) {
  var points2 = [
    { x: box2.x, y: box2.y },
    { x: box2.x + box2.width, y: box2.y },
    { x: box2.x + box2.width, y: box2.y + box2.height },
    { x: box2.x, y: box2.y + box2.height }
  ];
  var rotation = box2.rotation;
  if (rotation) {
    return [
      rotateAtPoint(points2[0], rotation, points2[0]),
      rotateAtPoint(points2[1], rotation, points2[0]),
      rotateAtPoint(points2[2], rotation, points2[0]),
      rotateAtPoint(points2[3], rotation, points2[0])
    ];
  }
  return points2;
}
function getProjection(points2, axis2) {
  if (points2.length > 4) {
    return { min: 0, max: 0 };
  }
  var scalars = [];
  points2.forEach(function(point2) {
    scalars.push(dot$1([point2.x, point2.y], axis2));
  });
  return { min: Math.min.apply(Math, __spreadArray$1([], __read(scalars), false)), max: Math.max.apply(Math, __spreadArray$1([], __read(scalars), false)) };
}
function isProjectionOverlap(projection1, projection2) {
  return projection1.max > projection2.min && projection1.min < projection2.max;
}
function isValidNumber(d) {
  return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
}
function isValidBox(box2) {
  return ["x", "y", "width", "height"].every(function(attr) {
    return isValidNumber(box2[attr]);
  });
}
function isIntersectRect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
}
function intersect(box1, box2, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  if (!isValidBox(box1) || !isValidBox(box2))
    return false;
  if (!box1.rotation && !box2.rotation) {
    return isIntersectRect(box1, box2, margin);
  }
  var rect1Points = getRectPoints(box1);
  var rect2Points = getRectPoints(box2);
  var axes = getAxes(rect1Points).concat(getAxes(rect2Points));
  for (var i = 0; i < axes.length; i++) {
    var axis2 = axes[i];
    var projection1 = getProjection(rect1Points, axis2);
    var projection2 = getProjection(rect2Points, axis2);
    if (!isProjectionOverlap(projection1, projection2)) {
      return false;
    }
  }
  return true;
}
var MyWorker = (
  /** @class */
  function() {
    function MyWorker2(url) {
      var _this = this;
      this.queue = [];
      this.worker = new Worker(url);
      this.worker.onmessage = function(e) {
        var _a2;
        (_a2 = _this.queue.shift()) === null || _a2 === void 0 ? void 0 : _a2.resolve(e);
      };
      this.worker.onmessageerror = function(e) {
        var _a2;
        console.warn("[AntV G2] Web worker is not available");
        (_a2 = _this.queue.shift()) === null || _a2 === void 0 ? void 0 : _a2.reject(e);
      };
    }
    MyWorker2.prototype.post = function(params, onError) {
      var _this = this;
      return new Promise(function(resolve, reject) {
        _this.queue.push({ resolve, reject });
        try {
          _this.worker.postMessage(params);
        } catch (e) {
          console.warn("[AntV G2] Web worker is not available");
          isFunction(onError) && onError();
        }
      });
    };
    MyWorker2.prototype.destroy = function() {
      this.worker.terminate();
    };
    return MyWorker2;
  }()
);
function createWorker(f) {
  if (typeof window === "undefined")
    return;
  var blob;
  try {
    blob = new Blob([f.toString()], { type: "application/javascript" });
  } catch (e) {
    blob = new window.BlobBuilder();
    blob.append(f.toString());
    blob = blob.getBlob();
  }
  return new MyWorker(URL.createObjectURL(blob));
}
var onmessage = function(e) {
  function generateUtils() {
    function dot2(a, b) {
      return (a[0] || 0) * (b[0] || 0) + (a[1] || 0) * (b[1] || 0) + (a[2] || 0) * (b[2] || 0);
    }
    function getAxes2(points2) {
      if (points2.length > 4) {
        return [];
      }
      var vector = function(start, end) {
        return [end.x - start.x, end.y - start.y];
      };
      var AB = vector(points2[0], points2[1]);
      var BC = vector(points2[1], points2[2]);
      return [AB, BC];
    }
    function rotateAtPoint2(point2, deg, origin) {
      if (deg === void 0) {
        deg = 0;
      }
      if (origin === void 0) {
        origin = { x: 0, y: 0 };
      }
      var x = point2.x, y = point2.y;
      return {
        x: (x - origin.x) * Math.cos(-deg) + (y - origin.y) * Math.sin(-deg) + origin.x,
        y: (origin.x - x) * Math.sin(-deg) + (y - origin.y) * Math.cos(-deg) + origin.y
      };
    }
    function getRectPoints2(box2) {
      var points2 = [
        { x: box2.x, y: box2.y },
        { x: box2.x + box2.width, y: box2.y },
        { x: box2.x + box2.width, y: box2.y + box2.height },
        { x: box2.x, y: box2.y + box2.height }
      ];
      var rotation = box2.rotation;
      if (rotation) {
        return [
          rotateAtPoint2(points2[0], rotation, points2[0]),
          rotateAtPoint2(points2[1], rotation, points2[0]),
          rotateAtPoint2(points2[2], rotation, points2[0]),
          rotateAtPoint2(points2[3], rotation, points2[0])
        ];
      }
      return points2;
    }
    function getProjection2(points2, axis2) {
      if (points2.length > 4) {
        return { min: 0, max: 0 };
      }
      var scalars = [];
      points2.forEach(function(point2) {
        scalars.push(dot2([point2.x, point2.y], axis2));
      });
      return { min: Math.min.apply(null, scalars), max: Math.max.apply(null, scalars) };
    }
    function isProjectionOverlap2(projection1, projection2) {
      return projection1.max > projection2.min && projection1.min < projection2.max;
    }
    function isValidNumber2(d) {
      return typeof d === "number" && !Number.isNaN(d) && d !== Infinity && d !== -Infinity;
    }
    function isValidBox2(box2) {
      return ["x", "y", "width", "height"].every(function(attr) {
        return isValidNumber2(box2[attr]);
      });
    }
    function isIntersectRect2(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      return !(box2.x > box1.x + box1.width + margin || box2.x + box2.width < box1.x - margin || box2.y > box1.y + box1.height + margin || box2.y + box2.height < box1.y - margin);
    }
    function intersect3(box1, box2, margin) {
      if (margin === void 0) {
        margin = 0;
      }
      if (!isValidBox2(box1) || !isValidBox2(box2))
        return false;
      if (!box1.rotation && !box2.rotation) {
        return isIntersectRect2(box1, box2, margin);
      }
      var rect1Points = getRectPoints2(box1);
      var rect2Points = getRectPoints2(box2);
      var axes = getAxes2(rect1Points).concat(getAxes2(rect2Points));
      for (var i = 0; i < axes.length; i++) {
        var axis2 = axes[i];
        var projection1 = getProjection2(rect1Points, axis2);
        var projection2 = getProjection2(rect2Points, axis2);
        if (!isProjectionOverlap2(projection1, projection2))
          return false;
      }
      return true;
    }
    return { intersect: intersect3 };
  }
  var intersect2 = generateUtils().intersect;
  function hideOverlap2(items2) {
    var boxes = items2.slice();
    for (var i = 0; i < boxes.length; i++) {
      var box1 = boxes[i];
      if (box1.visible) {
        for (var j = i + 1; j < boxes.length; j++) {
          var box2 = boxes[j];
          if (box1 !== box2 && box2.visible) {
            if (intersect2(box1, box2)) {
              box2.visible = false;
            }
          }
        }
      }
    }
    return boxes;
  }
  var methods = {
    "hide-overlap": hideOverlap2
  };
  try {
    var eventData = JSON.parse(e.data);
    if (!eventData || !eventData.type || !methods[eventData.type])
      return;
    var type = eventData.type, items = eventData.items;
    var result = methods[type](items);
    self.postMessage(result);
  } catch (e3) {
    throw e3;
  }
};
var code = "\n   self.onmessage = ".concat(onmessage.toString(), "\n");
var layout = function(items) {
  var boxes = items.slice();
  for (var i = 0; i < boxes.length; i++) {
    var box1 = boxes[i];
    if (box1.visible) {
      for (var j = i + 1; j < boxes.length; j++) {
        var box2 = boxes[j];
        if (box1 !== box2 && box2.visible) {
          if (intersect(box1, box2)) {
            box2.visible = false;
          }
        }
      }
    }
  }
  return boxes;
};
var cache = /* @__PURE__ */ new Map();
var worker = createWorker(code);
function hideOverlap(labelItems, labels, shapes, region) {
  return __awaiter(this, void 0, void 0, function() {
    var boxes, memoKey, cb, params, res, e_1;
    return __generator(this, function(_a2) {
      switch (_a2.label) {
        case 0:
          boxes = labels.map(function(d, idx) {
            return __assign$1(__assign$1({}, getLabelBackgroundInfo(d, labelItems[idx], get(labelItems[idx], "background.padding"))), { visible: true });
          });
          memoKey = JSON.stringify(boxes);
          cb = function(items) {
            cache.set(memoKey, items);
            each$1(items, function(_a3, idx) {
              var visible = _a3.visible;
              var labelShape = labels[idx];
              if (visible) {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.show();
              } else {
                labelShape === null || labelShape === void 0 ? void 0 : labelShape.hide();
              }
            });
            return items;
          };
          if (!cache.get(memoKey))
            return [3, 1];
          cb(cache.get(memoKey));
          return [3, 7];
        case 1:
          if (!worker)
            return [3, 6];
          _a2.label = 2;
        case 2:
          _a2.trys.push([2, 4, , 5]);
          params = JSON.stringify({ type: "hide-overlap", items: boxes });
          return [4, worker.post(params, function() {
            return cb(layout(boxes));
          })];
        case 3:
          res = _a2.sent();
          cb(Array.isArray(res.data) ? res.data : []);
          return [3, 5];
        case 4:
          e_1 = _a2.sent();
          console.error(e_1);
          cb(layout(boxes));
          return [3, 5];
        case 5:
          return [3, 7];
        case 6:
          cb(layout(boxes));
          _a2.label = 7;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
var preset = {
  "#5B8FF9": true
};
var isContrastColorWhite = function(color2) {
  var rgb2 = colorUtil.toRGB(color2).toUpperCase();
  if (preset[rgb2]) {
    return preset[rgb2];
  }
  var _a2 = __read(colorUtil.rgb2arr(rgb2), 3), r = _a2[0], g = _a2[1], b = _a2[2];
  var isDark = (r * 299 + g * 587 + b * 114) / 1e3 < 128;
  return isDark;
};
function adjustColor(items, labels, shapes) {
  if (shapes.length === 0) {
    return;
  }
  var element = shapes[0].get("element");
  var theme2 = element.geometry.theme;
  var _a2 = theme2.labels || {}, fillColorLight = _a2.fillColorLight, fillColorDark = _a2.fillColorDark;
  shapes.forEach(function(shape, index2) {
    var label2 = labels[index2];
    var textShape = label2.find(function(el) {
      return el.get("type") === "text";
    });
    var shapeBBox = BBox.fromObject(shape.getBBox());
    var textBBox = BBox.fromObject(textShape.getCanvasBBox());
    var overflow = !shapeBBox.contains(textBBox);
    var bgColor = shape.attr("fill");
    var fillWhite = isContrastColorWhite(bgColor);
    if (!overflow) {
      if (fillWhite) {
        if (fillColorLight) {
          textShape.attr("fill", fillColorLight);
        }
      } else {
        if (fillColorDark) {
          textShape.attr("fill", fillColorDark);
        }
      }
    } else {
      textShape.attr(theme2.overflowLabels.style);
    }
  });
}
function shouldInShapeSingle(geometry2, label2, shape) {
  var coordinate2 = geometry2.coordinate;
  var textShape = findLabelTextShape(label2);
  var textBBox = BBox.fromObject(textShape.getCanvasBBox());
  var shapeBBox = BBox.fromObject(shape.getBBox());
  return coordinate2.isTransposed ? shapeBBox.height >= textBBox.height : shapeBBox.width >= textBBox.width;
}
function shouldInShape(geometry2, labels, shapes) {
  var isStack = !!geometry2.getAdjust("stack");
  return isStack || labels.every(function(label2, index2) {
    var shape = shapes[index2];
    return shouldInShapeSingle(geometry2, label2, shape);
  });
}
function moveInShape(geometry2, label2, shape) {
  var coordinate2 = geometry2.coordinate;
  var shapeBBox = BBox.fromObject(shape.getBBox());
  var textShape = findLabelTextShape(label2);
  if (coordinate2.isTransposed) {
    textShape.attr({
      x: shapeBBox.minX + shapeBBox.width / 2,
      textAlign: "center"
    });
  } else {
    textShape.attr({
      y: shapeBBox.minY + shapeBBox.height / 2,
      textBaseline: "middle"
    });
  }
}
function intervalAdjustPosition(items, labels, shapes) {
  var _a2;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "interval") {
    return;
  }
  var inShape = shouldInShape(geometry2, labels, shapes);
  if (inShape) {
    shapes.forEach(function(shape, index2) {
      var label2 = labels[index2];
      moveInShape(geometry2, label2, shape);
    });
  }
}
function filterLabel(labels) {
  var MAX_CNT = 500;
  var filteredLabels = [];
  var pages = Math.max(Math.floor(labels.length / MAX_CNT), 1);
  each$1(labels, function(label2, idx) {
    if (idx % pages === 0) {
      filteredLabels.push(label2);
    } else {
      label2.set("visible", false);
    }
  });
  return filteredLabels;
}
function intervalHideOverlap(items, labels, shapes) {
  var _a2;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "interval") {
    return;
  }
  var filteredLabels = filterLabel(labels);
  var _b = __read(geometry2.getXYFields(), 1), xField = _b[0];
  var dones = [];
  var todo = [];
  var groupedLabels = groupBy(filteredLabels, function(label2) {
    return label2.get("data")[xField];
  });
  var xValues = uniq$2(map$2(filteredLabels, function(label2) {
    return label2.get("data")[xField];
  }));
  var xValue;
  filteredLabels.forEach(function(label2) {
    label2.set("visible", true);
  });
  var addCurrentGroup = function(curItems) {
    if (curItems) {
      if (curItems.length) {
        todo.push(curItems.pop());
      }
      todo.push.apply(todo, __spreadArray$1([], __read(curItems), false));
    }
  };
  if (size(xValues) > 0) {
    xValue = xValues.shift();
    addCurrentGroup(groupedLabels[xValue]);
  }
  if (size(xValues) > 0) {
    xValue = xValues.pop();
    addCurrentGroup(groupedLabels[xValue]);
  }
  each$1(xValues.reverse(), function(val) {
    addCurrentGroup(groupedLabels[val]);
  });
  while (todo.length > 0) {
    var cur = todo.shift();
    if (cur.get("visible")) {
      if (checkShapeOverlap$2(cur, dones)) {
        cur.set("visible", false);
      } else {
        dones.push(cur);
      }
    }
  }
}
function sortLabels$1(geometry2, labels) {
  var yField = geometry2.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, __spreadArray$1([], __read(sortedLabels), false));
  return result;
}
function hasSome$1(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea$1(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap$1(dones, current) {
  return hasSome$1(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea$1(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pointAdjustPosition(items, labels, shapes, region, cfg) {
  var _a2, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || geometry2.type !== "point") {
    return;
  }
  var _c = __read(geometry2.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = groupBy(labels, function(label2) {
    return label2.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map$2(keys(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels$1(geometry2, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome$1(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap$1(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap$1(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}
function sortLabels(geometry2, labels) {
  var yField = geometry2.getXYFields()[1];
  var result = [];
  var sortedLabels = labels.sort(function(left2, right2) {
    return left2.get("data")[yField] - left2.get("data")[yField];
  });
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.shift());
  }
  if (sortedLabels.length > 0) {
    result.push(sortedLabels.pop());
  }
  result.push.apply(result, __spreadArray$1([], __read(sortedLabels), false));
  return result;
}
function hasSome(dones, current, compare2) {
  return dones.some(function(done) {
    return compare2(done, current);
  });
}
function getOverlapArea(a, b, margin) {
  if (margin === void 0) {
    margin = 0;
  }
  var xOverlap = Math.max(0, Math.min(a.x + a.width + margin, b.x + b.width + margin) - Math.max(a.x - margin, b.x - margin));
  var yOverlap = Math.max(0, Math.min(a.y + a.height + margin, b.y + b.height + margin) - Math.max(a.y - margin, b.y - margin));
  return xOverlap * yOverlap;
}
function checkShapeOverlap(dones, current) {
  return hasSome(dones, current, function(left2, right2) {
    var leftText = findLabelTextShape(left2);
    var rightText = findLabelTextShape(right2);
    return getOverlapArea(leftText.getCanvasBBox(), rightText.getCanvasBBox(), 2) > 0;
  });
}
function pathAdjustPosition(items, labels, shapes, region, cfg) {
  var _a2, _b;
  if (shapes.length === 0) {
    return;
  }
  var element = (_a2 = shapes[0]) === null || _a2 === void 0 ? void 0 : _a2.get("element");
  var geometry2 = element === null || element === void 0 ? void 0 : element.geometry;
  if (!geometry2 || ["path", "line", "area"].indexOf(geometry2.type) < 0) {
    return;
  }
  var _c = __read(geometry2.getXYFields(), 2), xField = _c[0], yField = _c[1];
  var groupedLabels = groupBy(labels, function(label2) {
    return label2.get("data")[xField];
  });
  var dones = [];
  var offset = cfg && cfg.offset || ((_b = items[0]) === null || _b === void 0 ? void 0 : _b.offset) || 12;
  map$2(keys(groupedLabels).reverse(), function(xValue) {
    var sortedCollections = sortLabels(geometry2, groupedLabels[xValue]);
    while (sortedCollections.length) {
      var current = sortedCollections.shift();
      var textShape = findLabelTextShape(current);
      if (hasSome(dones, current, function(left2, right2) {
        return left2.get("data")[xField] === right2.get("data")[xField] && left2.get("data")[yField] === right2.get("data")[yField];
      })) {
        textShape.set("visible", false);
        continue;
      }
      var upFail = checkShapeOverlap(dones, current);
      var downFail = false;
      if (upFail) {
        textShape.attr("y", textShape.attr("y") + 2 * offset);
        downFail = checkShapeOverlap(dones, current);
      }
      if (downFail) {
        textShape.set("visible", false);
        continue;
      }
      dones.push(current);
    }
  });
}
var ctx$1;
function getCanvasContext$1() {
  if (!ctx$1) {
    ctx$1 = document.createElement("canvas").getContext("2d");
  }
  return ctx$1;
}
var measureTextWidth = memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, fontFamily = font.fontFamily, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx2 = getCanvasContext$1();
  ctx2.font = [fontStyle, fontVariant, fontWeight, "".concat(fontSize, "px"), fontFamily].join(" ");
  return ctx2.measureText(isString(text2) ? text2 : "").width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray$1([text2], __read(values(font)), false).join("");
});
var getEllipsisText = function(text2, maxWidth, font) {
  var STEP = 16;
  var DOT_WIDTH = measureTextWidth("...", font);
  var leftText;
  if (!isString(text2)) {
    leftText = toString$2(text2);
  } else {
    leftText = text2;
  }
  var leftWidth = maxWidth;
  var r = [];
  var currentText;
  var currentWidth;
  if (measureTextWidth(text2, font) <= maxWidth) {
    return text2;
  }
  while (true) {
    currentText = leftText.substr(0, STEP);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      if (currentWidth > leftWidth) {
        break;
      }
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(STEP);
    if (!leftText) {
      return r.join("");
    }
  }
  while (true) {
    currentText = leftText.substr(0, 1);
    currentWidth = measureTextWidth(currentText, font);
    if (currentWidth + DOT_WIDTH > leftWidth) {
      break;
    }
    r.push(currentText);
    leftWidth -= currentWidth;
    leftText = leftText.substr(1);
    if (!leftText) {
      return r.join("");
    }
  }
  return "".concat(r.join(""), "...");
};
function limitInPlot$3(items, labels, shapes, region, cfg) {
  if (labels.length <= 0) {
    return;
  }
  var direction2 = (cfg === null || cfg === void 0 ? void 0 : cfg.direction) || ["top", "right", "bottom", "left"];
  var action = (cfg === null || cfg === void 0 ? void 0 : cfg.action) || "translate";
  var margin = (cfg === null || cfg === void 0 ? void 0 : cfg.margin) || 0;
  var coordinate2 = labels[0].get("coordinate");
  if (!coordinate2) {
    return;
  }
  var _a2 = getCoordinateBBox(coordinate2, margin), regionMinX = _a2.minX, regionMinY = _a2.minY, regionMaxX = _a2.maxX, regionMaxY = _a2.maxY;
  each$1(labels, function(label2) {
    var _a3 = label2.getCanvasBBox(), minX = _a3.minX, minY = _a3.minY, maxX = _a3.maxX, maxY2 = _a3.maxY, x = _a3.x, y = _a3.y, width = _a3.width, height = _a3.height;
    var finalX = x;
    var finalY = y;
    if (direction2.indexOf("left") >= 0 && (minX < regionMinX || maxX < regionMinX)) {
      finalX = regionMinX;
    }
    if (direction2.indexOf("top") >= 0 && (minY < regionMinY || maxY2 < regionMinY)) {
      finalY = regionMinY;
    }
    if (direction2.indexOf("right") >= 0) {
      if (minX > regionMaxX) {
        finalX = regionMaxX - width;
      } else if (maxX > regionMaxX) {
        finalX = finalX - (maxX - regionMaxX);
      }
    }
    if (direction2.indexOf("bottom") >= 0) {
      if (minY > regionMaxY) {
        finalY = regionMaxY - height;
      } else if (maxY2 > regionMaxY) {
        finalY = finalY - (maxY2 - regionMaxY);
      }
    }
    if (finalX !== x || finalY !== y) {
      var translateX_1 = finalX - x;
      if (action === "translate") {
        translate(label2, translateX_1, finalY - y);
      } else if (action === "ellipsis") {
        var textShapes = label2.findAll(function(shape) {
          return shape.get("type") === "text";
        });
        textShapes.forEach(function(textShape) {
          var style = pick$1(textShape.attr(), ["fontSize", "fontFamily", "fontWeight", "fontStyle", "fontVariant"]);
          var textBox = textShape.getCanvasBBox();
          var text2 = getEllipsisText(textShape.attr("text"), textBox.width - Math.abs(translateX_1), style);
          textShape.attr("text", text2);
        });
      } else {
        label2.hide();
      }
    }
  });
}
function fadeIn(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: isNil(shape.attr("fillOpacity")) ? 1 : shape.attr("fillOpacity"),
    strokeOpacity: isNil(shape.attr("strokeOpacity")) ? 1 : shape.attr("strokeOpacity"),
    opacity: isNil(shape.attr("opacity")) ? 1 : shape.attr("opacity")
  };
  shape.attr({
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  });
  shape.animate(endState, animateCfg);
}
function fadeOut(shape, animateCfg, cfg) {
  var endState = {
    fillOpacity: 0,
    strokeOpacity: 0,
    opacity: 0
  };
  var easing = animateCfg.easing, duration = animateCfg.duration, delay = animateCfg.delay;
  shape.animate(endState, duration, easing, function() {
    shape.remove(true);
  }, delay);
}
function transformShape(shape, vector, direct) {
  var scaledMatrix;
  var _a2 = __read(vector, 2), x = _a2[0], y = _a2[1];
  shape.applyToMatrix([x, y, 1]);
  if (direct === "x") {
    shape.setMatrix(transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 1],
      ["t", x, y]
    ]));
    scaledMatrix = transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ]);
  } else if (direct === "y") {
    shape.setMatrix(transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ]);
  } else if (direct === "xy") {
    shape.setMatrix(transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 0.01, 0.01],
      ["t", x, y]
    ]));
    scaledMatrix = transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 100],
      ["t", x, y]
    ]);
  }
  return scaledMatrix;
}
function doScaleAnimate(element, animateCfg, coordinate2, yMinPoint, type) {
  var start = coordinate2.start, end = coordinate2.end;
  var width = coordinate2.getWidth();
  var height = coordinate2.getHeight();
  var x;
  var y;
  if (type === "y") {
    x = start.x + width / 2;
    y = yMinPoint.y < start.y ? yMinPoint.y : start.y;
  } else if (type === "x") {
    x = yMinPoint.x > start.x ? yMinPoint.x : start.x;
    y = start.y + height / 2;
  } else if (type === "xy") {
    if (coordinate2.isPolar) {
      x = coordinate2.getCenter().x;
      y = coordinate2.getCenter().y;
    } else {
      x = (start.x + end.x) / 2;
      y = (start.y + end.y) / 2;
    }
  }
  var endMatrix = transformShape(element, [x, y], type);
  element.animate({
    matrix: endMatrix
  }, animateCfg);
}
function growInX(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "x");
}
function growInY(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "y");
}
function growInXY(element, animateCfg, cfg) {
  var coordinate2 = cfg.coordinate, minYPoint = cfg.minYPoint;
  doScaleAnimate(element, animateCfg, coordinate2, minYPoint, "xy");
}
function pathIn(element, animateCfg, cfg) {
  var length2 = element.getTotalLength();
  element.attr("lineDash", [length2]);
  element.animate(function(ratio) {
    return {
      // 
      lineDashOffset: (1 - ratio) * length2
    };
  }, animateCfg);
}
function positionUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs;
  var x = toAttrs.x;
  var y = toAttrs.y;
  delete toAttrs.x;
  delete toAttrs.y;
  shape.attr(toAttrs);
  shape.animate({
    x,
    y
  }, animateCfg);
}
function scaleInX(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var points2 = mappingData.points;
  var x = points2[0].y - points2[1].y > 0 ? box2.maxX : box2.minX;
  var y = (box2.minY + box2.maxY) / 2;
  shape.applyToMatrix([x, y, 1]);
  var matrix = transform$6(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 0.01, 1],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 100, 1],
      ["t", x, y]
    ])
  }, animateCfg);
}
function scaleInY(shape, animateCfg, cfg) {
  var box2 = shape.getBBox();
  var mappingData = shape.get("origin").mappingData;
  var x = (box2.minX + box2.maxX) / 2;
  var points2 = mappingData.points;
  var y = points2[0].y - points2[1].y <= 0 ? box2.maxY : box2.minY;
  shape.applyToMatrix([x, y, 1]);
  var matrix = transform$6(shape.getMatrix(), [
    ["t", -x, -y],
    ["s", 1, 0.01],
    ["t", x, y]
  ]);
  shape.setMatrix(matrix);
  shape.animate({
    matrix: transform$6(shape.getMatrix(), [
      ["t", -x, -y],
      ["s", 1, 100],
      ["t", x, y]
    ])
  }, animateCfg);
}
function getAngle(startPoint, arcPath) {
  var _a2;
  var _b = getArcParams(startPoint, arcPath), startAngle = _b.startAngle, endAngle = _b.endAngle;
  if (!isNumberEqual$1(startAngle, -Math.PI * 0.5) && startAngle < -Math.PI * 0.5) {
    startAngle += Math.PI * 2;
  }
  if (!isNumberEqual$1(endAngle, -Math.PI * 0.5) && endAngle < -Math.PI * 0.5) {
    endAngle += Math.PI * 2;
  }
  if (arcPath[5] === 0) {
    _a2 = __read([endAngle, startAngle], 2), startAngle = _a2[0], endAngle = _a2[1];
  }
  if (isNumberEqual$1(startAngle, Math.PI * 1.5)) {
    startAngle = Math.PI * -0.5;
  }
  if (isNumberEqual$1(endAngle, Math.PI * -0.5) && !isNumberEqual$1(startAngle, endAngle)) {
    endAngle = Math.PI * 1.5;
  }
  return {
    startAngle,
    endAngle
  };
}
function getArcStartPoint(path2) {
  var startPoint;
  if (path2[0] === "M" || path2[0] === "L") {
    startPoint = [path2[1], path2[2]];
  } else if (path2[0] === "a" || path2[0] === "A" || path2[0] === "C") {
    startPoint = [path2[path2.length - 2], path2[path2.length - 1]];
  }
  return startPoint;
}
function getArcInfo(path2) {
  var _a2;
  var startAngle;
  var endAngle;
  var arcPaths = path2.filter(function(command) {
    return command[0] === "A" || command[0] === "a";
  });
  if (arcPaths.length === 0) {
    return {
      startAngle: 0,
      endAngle: 0,
      radius: 0,
      innerRadius: 0
    };
  }
  var firstArcPathCommand = arcPaths[0];
  var lastArcPathCommand = arcPaths.length > 1 ? arcPaths[1] : arcPaths[0];
  var firstIndex = path2.indexOf(firstArcPathCommand);
  var lastIndex = path2.indexOf(lastArcPathCommand);
  var firstStartPoint = getArcStartPoint(path2[firstIndex - 1]);
  var lastStartPoint = getArcStartPoint(path2[lastIndex - 1]);
  var _b = getAngle(firstStartPoint, firstArcPathCommand), firstStartAngle = _b.startAngle, firstEndAngle = _b.endAngle;
  var _c = getAngle(lastStartPoint, lastArcPathCommand), lastStartAngle = _c.startAngle, lastEndAngle = _c.endAngle;
  if (isNumberEqual$1(firstStartAngle, lastStartAngle) && isNumberEqual$1(firstEndAngle, lastEndAngle)) {
    startAngle = firstStartAngle;
    endAngle = firstEndAngle;
  } else {
    startAngle = Math.min(firstStartAngle, lastStartAngle);
    endAngle = Math.max(firstEndAngle, lastEndAngle);
  }
  var radius = firstArcPathCommand[1];
  var innerRadius = arcPaths[arcPaths.length - 1][1];
  if (radius < innerRadius) {
    _a2 = __read([innerRadius, radius], 2), radius = _a2[0], innerRadius = _a2[1];
  } else if (radius === innerRadius) {
    innerRadius = 0;
  }
  return {
    startAngle,
    endAngle,
    radius,
    innerRadius
  };
}
function sectorPathUpdate(shape, animateCfg, cfg) {
  var toAttrs = cfg.toAttrs, coordinate2 = cfg.coordinate;
  var path2 = toAttrs.path || [];
  var pathCommands = path2.map(function(command) {
    return command[0];
  });
  if (path2.length < 1)
    return;
  var _a2 = getArcInfo(path2), curStartAngle = _a2.startAngle, curEndAngle = _a2.endAngle, radius = _a2.radius, innerRadius = _a2.innerRadius;
  var _b = getArcInfo(shape.attr("path")), preStartAngle = _b.startAngle, preEndAngle = _b.endAngle;
  var center2 = coordinate2.getCenter();
  var diffStartAngle = curStartAngle - preStartAngle;
  var diffEndAngle = curEndAngle - preEndAngle;
  if (diffStartAngle === 0 && diffEndAngle === 0) {
    shape.attr("path", path2);
    return;
  }
  shape.animate(function(ratio) {
    var onFrameStartAngle = preStartAngle + ratio * diffStartAngle;
    var onFrameEndAngle = preEndAngle + ratio * diffEndAngle;
    return __assign$1(__assign$1({}, toAttrs), { path: (
      // hack,  /examples/bar/basic/demo/radial-line.ts 
      isEqual$1(pathCommands, ["M", "A", "A", "Z"]) ? getArcPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle) : getSectorPath(center2.x, center2.y, radius, onFrameStartAngle, onFrameEndAngle, innerRadius)
    ) });
  }, __assign$1(__assign$1({}, animateCfg), { callback: function() {
    shape.attr("path", path2);
  } }));
}
function waveIn(element, animateCfg, cfg) {
  var _a2 = getCoordinateClipCfg(cfg.coordinate, 20), type = _a2.type, startState = _a2.startState, endState = _a2.endState;
  var clipShape = element.setClip({
    type,
    attrs: startState
  });
  if (cfg.toAttrs) {
    element.attr(cfg.toAttrs);
  }
  clipShape.animate(endState, __assign$1(__assign$1({}, animateCfg), { callback: function() {
    if (element && !element.get("destroyed")) {
      element.set("clipShape", null);
    }
    clipShape.remove(true);
  } }));
}
function doShapeZoom(shape, animateCfg, type) {
  if (shape.isGroup()) {
    each$1(shape.getChildren(), function(child) {
      doShapeZoom(child, animateCfg, type);
    });
  } else {
    var bbox = shape.getBBox();
    var x = (bbox.minX + bbox.maxX) / 2;
    var y = (bbox.minY + bbox.maxY) / 2;
    shape.applyToMatrix([x, y, 1]);
    if (type === "zoomIn") {
      var matrix = transform$6(shape.getMatrix(), [
        ["t", -x, -y],
        ["s", 0.01, 0.01],
        ["t", x, y]
      ]);
      shape.setMatrix(matrix);
      shape.animate({
        matrix: transform$6(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 100, 100],
          ["t", x, y]
        ])
      }, animateCfg);
    } else {
      shape.animate({
        matrix: transform$6(shape.getMatrix(), [
          ["t", -x, -y],
          ["s", 0.01, 0.01],
          ["t", x, y]
        ])
      }, __assign$1(__assign$1({}, animateCfg), { callback: function() {
        shape.remove(true);
      } }));
    }
  }
}
function zoomIn(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomIn");
}
function zoomOut(shape, animateCfg, cfg) {
  doShapeZoom(shape, animateCfg, "zoomOut");
}
function getFactTitleConfig(direction2) {
  if ([DIRECTION.TOP, DIRECTION.BOTTOM].includes(direction2)) {
    return {
      offsetX: 0,
      offsetY: direction2 === DIRECTION.TOP ? -8 : 8,
      style: {
        textAlign: "center",
        textBaseline: direction2 === DIRECTION.TOP ? "bottom" : "top"
      }
    };
  }
  if ([DIRECTION.LEFT, DIRECTION.RIGHT].includes(direction2)) {
    return {
      offsetX: direction2 === DIRECTION.LEFT ? -8 : 8,
      offsetY: 0,
      style: {
        textAlign: direction2 === DIRECTION.LEFT ? "right" : "left",
        textBaseline: "middle",
        rotate: Math.PI / 2
        // 
      }
    };
  }
  return {};
}
function getAnglePoint(center2, r, angle2) {
  return {
    x: center2.x + r * Math.cos(angle2),
    y: center2.y + r * Math.sin(angle2)
  };
}
var Circle = (
  /** @class */
  function(_super) {
    __extends$1(Circle2, _super);
    function Circle2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Circle2.prototype.getDefaultCfg = function() {
      return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
        type: "circle",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Circle2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Circle2.prototype.getRegion = function(count2, index2) {
      var r = 1 / 2;
      var center2 = { x: 0.5, y: 0.5 };
      var avgAngle = Math.PI * 2 / count2;
      var angle2 = -1 * Math.PI / 2 + avgAngle * index2;
      var facetR = r / (1 + 1 / Math.sin(avgAngle / 2));
      var middle = getAnglePoint(center2, r - facetR, angle2);
      var startAngle = Math.PI * 5 / 4;
      var endAngle = Math.PI * 1 / 4;
      return {
        start: getAnglePoint(middle, facetR, startAngle),
        end: getAnglePoint(middle, facetR, endAngle)
      };
    };
    Circle2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Circle2.prototype.beforeEachView = function(view, facet) {
    };
    Circle2.prototype.generateFacets = function(data2) {
      var _this = this;
      var _a2 = this.cfg, fields = _a2.fields, type = _a2.type;
      var _b = __read(fields, 1), field2 = _b[0];
      if (!field2) {
        throw new Error("No `fields` specified!");
      }
      var values2 = this.getFieldValues(data2, field2);
      var count2 = values2.length;
      var rst = [];
      values2.forEach(function(value2, index2) {
        var conditions = [{ field: field2, value: value2, values: values2 }];
        var facetData = filter(data2, _this.getFacetDataFilter(conditions));
        var facet = {
          type,
          data: facetData,
          region: _this.getRegion(count2, index2),
          columnValue: value2,
          columnField: field2,
          columnIndex: index2,
          columnValuesLength: count2,
          rowValue: null,
          rowField: null,
          rowIndex: 0,
          rowValuesLength: 1
        };
        rst.push(facet);
      });
      return rst;
    };
    Circle2.prototype.getXAxisOption = function(x, axes, option, facet) {
      return option;
    };
    Circle2.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Circle2.prototype.renderTitle = function() {
      var _this = this;
      each$1(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get(_this.cfg.title, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    return Circle2;
  }(Facet)
);
var List = (
  /** @class */
  function(_super) {
    __extends$1(List2, _super);
    function List2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    List2.prototype.getDefaultCfg = function() {
      return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
        type: "list",
        cols: null,
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    List2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    List2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    List2.prototype.beforeEachView = function(view, facet) {
    };
    List2.prototype.generateFacets = function(data2) {
      var _this = this;
      var fields = this.cfg.fields;
      var cols = this.cfg.cols;
      var _a2 = __read(fields, 1), columnField = _a2[0];
      if (!columnField) {
        throw new Error("No `fields` specified!");
      }
      var colValues = this.getFieldValues(data2, columnField);
      var count2 = colValues.length;
      cols = cols || count2;
      var rows = this.getPageCount(count2, cols);
      var rst = [];
      colValues.forEach(function(val, index2) {
        var _a3 = _this.getRowCol(index2, cols), row = _a3.row, col = _a3.col;
        var conditions = [{ field: columnField, value: val, values: colValues }];
        var facetData = filter(data2, _this.getFacetDataFilter(conditions));
        var facet = {
          type: _this.cfg.type,
          data: facetData,
          region: _this.getRegion(rows, cols, col, row),
          columnValue: val,
          rowValue: val,
          columnField,
          rowField: null,
          columnIndex: col,
          rowIndex: row,
          columnValuesLength: cols,
          rowValuesLength: rows,
          total: count2
        };
        rst.push(facet);
      });
      return rst;
    };
    List2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1 && facet.columnValuesLength * facet.rowIndex + facet.columnIndex + 1 + facet.columnValuesLength <= facet.total) {
        return __assign$1(__assign$1({}, option), { label: null, title: null });
      }
      return option;
    };
    List2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign$1(__assign$1({}, option), { title: null, label: null });
      }
      return option;
    };
    List2.prototype.renderTitle = function() {
      var _this = this;
      each$1(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get(_this.cfg.title, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    List2.prototype.getPageCount = function(total, pageSize) {
      return Math.floor((total + pageSize - 1) / pageSize);
    };
    List2.prototype.getRowCol = function(index2, pageSize) {
      var row = Math.floor(index2 / pageSize);
      var col = index2 % pageSize;
      return { row, col };
    };
    return List2;
  }(Facet)
);
var Matrix = (
  /** @class */
  function(_super) {
    __extends$1(Matrix2, _super);
    function Matrix2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Matrix2.prototype.getDefaultCfg = function() {
      return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
        type: "matrix",
        showTitle: false,
        columnTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Matrix2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Matrix2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Matrix2.prototype.beforeEachView = function(view, facet) {
    };
    Matrix2.prototype.generateFacets = function(data2) {
      var _a2 = this.cfg, fields = _a2.fields, type = _a2.type;
      var rowValuesLength = fields.length;
      var columnValuesLength = rowValuesLength;
      var rst = [];
      for (var i = 0; i < columnValuesLength; i++) {
        var columnField = fields[i];
        for (var j = 0; j < rowValuesLength; j++) {
          var rowField = fields[j];
          var facet = {
            type,
            data: data2,
            region: this.getRegion(rowValuesLength, columnValuesLength, i, j),
            columnValue: columnField,
            rowValue: rowField,
            columnField,
            rowField,
            columnIndex: i,
            rowIndex: j,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        }
      }
      return rst;
    };
    Matrix2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign$1(__assign$1({}, option), { label: null, title: null });
      }
      return option;
    };
    Matrix2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign$1(__assign$1({}, option), { title: null, label: null });
      }
      return option;
    };
    Matrix2.prototype.renderTitle = function() {
      var _this = this;
      each$1(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength;
        facet.rowValuesLength;
        var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get(_this.cfg.columnTitle, "formatter");
          var config = deepMix({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get(_this.cfg.rowTitle, "formatter");
          var config = deepMix({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    return Matrix2;
  }(Facet)
);
var Mirror = (
  /** @class */
  function(_super) {
    __extends$1(Mirror2, _super);
    function Mirror2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Mirror2.prototype.getDefaultCfg = function() {
      return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
        type: "mirror",
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this),
        transpose: false
      });
    };
    Mirror2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Mirror2.prototype.beforeEachView = function(view, facet) {
      if (this.cfg.transpose) {
        if (facet.columnIndex % 2 === 0) {
          view.coordinate().transpose().reflect("x");
        } else {
          view.coordinate().transpose();
        }
      } else {
        if (facet.rowIndex % 2 !== 0) {
          view.coordinate().reflect("y");
        }
      }
    };
    Mirror2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Mirror2.prototype.generateFacets = function(data2) {
      var _this = this;
      var _a2 = __read(this.cfg.fields, 1), f = _a2[0];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      var columnField;
      var rowField;
      if (this.cfg.transpose) {
        columnField = f;
        columnValues = this.getFieldValues(data2, columnField).slice(0, 2);
        columnValuesLength = columnValues.length;
      } else {
        rowField = f;
        rowValues = this.getFieldValues(data2, rowField).slice(0, 2);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter(data2, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Mirror2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.columnIndex === 1 || facet.rowIndex === 1) {
        return __assign$1(__assign$1({}, option), { label: null, title: null });
      }
      return option;
    };
    Mirror2.prototype.getYAxisOption = function(y, axes, option, facet) {
      return option;
    };
    Mirror2.prototype.renderTitle = function() {
      var _this = this;
      each$1(this.facets, function(facet, facetIndex) {
        var columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        var formatter = get(_this.cfg.title, "formatter");
        if (_this.cfg.transpose) {
          var config = deepMix({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
          view.annotation().text(config);
        } else {
          var config = deepMix({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.title);
          view.annotation().text(config);
        }
      });
    };
    return Mirror2;
  }(Facet)
);
var Rect = (
  /** @class */
  function(_super) {
    __extends$1(Rect2, _super);
    function Rect2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Rect2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Rect2.prototype.beforeEachView = function(view, facet) {
    };
    Rect2.prototype.getDefaultCfg = function() {
      return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
        type: "rect",
        columnTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this)),
        rowTitle: __assign$1({}, _super.prototype.getDefaultTitleCfg.call(this))
      });
    };
    Rect2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Rect2.prototype.generateFacets = function(data2) {
      var _this = this;
      var _a2 = __read(this.cfg.fields, 2), columnField = _a2[0], rowField = _a2[1];
      var rst = [];
      var columnValuesLength = 1;
      var rowValuesLength = 1;
      var columnValues = [""];
      var rowValues = [""];
      if (columnField) {
        columnValues = this.getFieldValues(data2, columnField);
        columnValuesLength = columnValues.length;
      }
      if (rowField) {
        rowValues = this.getFieldValues(data2, rowField);
        rowValuesLength = rowValues.length;
      }
      columnValues.forEach(function(xVal, xIndex) {
        rowValues.forEach(function(yVal, yIndex) {
          var conditions = [
            { field: columnField, value: xVal, values: columnValues },
            { field: rowField, value: yVal, values: rowValues }
          ];
          var facetData = filter(data2, _this.getFacetDataFilter(conditions));
          var facet = {
            type: _this.cfg.type,
            data: facetData,
            region: _this.getRegion(rowValuesLength, columnValuesLength, xIndex, yIndex),
            columnValue: xVal,
            rowValue: yVal,
            columnField,
            rowField,
            columnIndex: xIndex,
            rowIndex: yIndex,
            columnValuesLength,
            rowValuesLength
          };
          rst.push(facet);
        });
      });
      return rst;
    };
    Rect2.prototype.renderTitle = function() {
      var _this = this;
      each$1(this.facets, function(facet, facetIndex) {
        var columnIndex = facet.columnIndex, rowIndex = facet.rowIndex, columnValuesLength = facet.columnValuesLength, columnValue = facet.columnValue, rowValue = facet.rowValue, view = facet.view;
        if (rowIndex === 0) {
          var formatter = get(_this.cfg.columnTitle, "formatter");
          var config = deepMix({
            position: ["50%", "0%"],
            content: formatter ? formatter(columnValue) : columnValue
          }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.columnTitle);
          view.annotation().text(config);
        }
        if (columnIndex === columnValuesLength - 1) {
          var formatter = get(_this.cfg.rowTitle, "formatter");
          var config = deepMix({
            position: ["100%", "50%"],
            content: formatter ? formatter(rowValue) : rowValue
          }, getFactTitleConfig(DIRECTION.RIGHT), _this.cfg.rowTitle);
          view.annotation().text(config);
        }
      });
    };
    Rect2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign$1(__assign$1({}, option), { title: null, label: null });
      } else if (facet.columnIndex !== Math.floor((facet.columnValuesLength - 1) / 2)) {
        return __assign$1(__assign$1({}, option), { title: null });
      }
      return option;
    };
    Rect2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.columnIndex !== 0) {
        return __assign$1(__assign$1({}, option), { title: null, label: null });
      } else if (facet.rowIndex !== Math.floor((facet.rowValuesLength - 1) / 2)) {
        return __assign$1(__assign$1({}, option), { title: null });
      }
      return option;
    };
    return Rect2;
  }(Facet)
);
var Tree = (
  /** @class */
  function(_super) {
    __extends$1(Tree2, _super);
    function Tree2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.afterChartRender = function() {
        if (_this.facets && _this.cfg.line) {
          _this.container.clear();
          _this.drawLines(_this.facets);
        }
      };
      return _this;
    }
    Tree2.prototype.afterEachView = function(view, facet) {
      this.processAxis(view, facet);
    };
    Tree2.prototype.beforeEachView = function(view, facet) {
    };
    Tree2.prototype.init = function() {
      _super.prototype.init.call(this);
      this.view.on(VIEW_LIFE_CIRCLE.AFTER_RENDER, this.afterChartRender);
    };
    Tree2.prototype.getDefaultCfg = function() {
      return deepMix({}, _super.prototype.getDefaultCfg.call(this), {
        type: "tree",
        line: {
          style: {
            lineWidth: 1,
            stroke: "#ddd"
          },
          smooth: false
        },
        showTitle: true,
        title: _super.prototype.getDefaultTitleCfg.call(this)
      });
    };
    Tree2.prototype.generateFacets = function(data2) {
      var fields = this.cfg.fields;
      if (!fields.length) {
        throw new Error("Please specify for the fields for rootFacet!");
      }
      var rst = [];
      var rootFacet = {
        type: this.cfg.type,
        data: data2,
        region: null,
        rowValuesLength: this.getRows(),
        columnValuesLength: 1,
        rowIndex: 0,
        columnIndex: 0,
        rowField: "",
        columnField: "",
        rowValue: "",
        columnValue: ""
      };
      rst.push(rootFacet);
      rootFacet.children = this.getChildFacets(data2, 1, rst);
      this.setRegion(rst);
      return rst;
    };
    Tree2.prototype.setRegion = function(facets) {
      var _this = this;
      this.forceColIndex(facets);
      facets.forEach(function(facet) {
        facet.region = _this.getRegion(facet.rowValuesLength, facet.columnValuesLength, facet.columnIndex, facet.rowIndex);
      });
    };
    Tree2.prototype.getRegion = function(rows, cols, xIndex, yIndex) {
      var xWidth = 1 / cols;
      var yWidth = 1 / rows;
      var start = {
        x: xWidth * xIndex,
        y: yWidth * yIndex
      };
      var end = {
        x: start.x + xWidth,
        y: start.y + yWidth * 2 / 3
        // 1/3
      };
      return {
        start,
        end
      };
    };
    Tree2.prototype.forceColIndex = function(facets) {
      var e_1, _a2;
      var _this = this;
      var leafs = [];
      var index2 = 0;
      facets.forEach(function(facet2) {
        if (_this.isLeaf(facet2)) {
          leafs.push(facet2);
          facet2.columnIndex = index2;
          index2++;
        }
      });
      leafs.forEach(function(facet2) {
        facet2.columnValuesLength = leafs.length;
      });
      var maxLevel = this.cfg.fields.length;
      for (var i = maxLevel - 1; i >= 0; i--) {
        var levelFacets = this.getFacetsByLevel(facets, i);
        try {
          for (var levelFacets_1 = (e_1 = void 0, __values(levelFacets)), levelFacets_1_1 = levelFacets_1.next(); !levelFacets_1_1.done; levelFacets_1_1 = levelFacets_1.next()) {
            var facet = levelFacets_1_1.value;
            if (!this.isLeaf(facet)) {
              facet.originColIndex = facet.columnIndex;
              facet.columnIndex = this.getRegionIndex(facet.children);
              facet.columnValuesLength = leafs.length;
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (levelFacets_1_1 && !levelFacets_1_1.done && (_a2 = levelFacets_1.return))
              _a2.call(levelFacets_1);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
    };
    Tree2.prototype.getFacetsByLevel = function(facets, level) {
      var rst = [];
      facets.forEach(function(facet) {
        if (facet.rowIndex === level) {
          rst.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.getRegionIndex = function(children) {
      var first = children[0];
      var last2 = children[children.length - 1];
      return (last2.columnIndex - first.columnIndex) / 2 + first.columnIndex;
    };
    Tree2.prototype.isLeaf = function(facet) {
      return !facet.children || !facet.children.length;
    };
    Tree2.prototype.getRows = function() {
      return this.cfg.fields.length + 1;
    };
    Tree2.prototype.getChildFacets = function(data2, level, arr) {
      var _this = this;
      var fields = this.cfg.fields;
      var length2 = fields.length;
      if (length2 < level) {
        return;
      }
      var rst = [];
      var field2 = fields[level - 1];
      var values2 = this.getFieldValues(data2, field2);
      values2.forEach(function(value2, index2) {
        var conditions = [{ field: field2, value: value2, values: values2 }];
        var subData = data2.filter(_this.getFacetDataFilter(conditions));
        if (subData.length) {
          var facet = {
            type: _this.cfg.type,
            data: subData,
            region: null,
            columnValue: value2,
            rowValue: "",
            columnField: field2,
            rowField: "",
            columnIndex: index2,
            rowValuesLength: _this.getRows(),
            columnValuesLength: 1,
            rowIndex: level,
            children: _this.getChildFacets(subData, level + 1, arr)
          };
          rst.push(facet);
          arr.push(facet);
        }
      });
      return rst;
    };
    Tree2.prototype.render = function() {
      _super.prototype.render.call(this);
      if (this.cfg.showTitle) {
        this.renderTitle();
      }
    };
    Tree2.prototype.renderTitle = function() {
      var _this = this;
      each$1(this.facets, function(facet) {
        var columnValue = facet.columnValue, view = facet.view;
        var formatter = get(_this.cfg.title, "formatter");
        var config = deepMix({
          position: ["50%", "0%"],
          content: formatter ? formatter(columnValue) : columnValue
        }, getFactTitleConfig(DIRECTION.TOP), _this.cfg.title);
        view.annotation().text(config);
      });
    };
    Tree2.prototype.drawLines = function(facets) {
      var _this = this;
      facets.forEach(function(facet) {
        if (!_this.isLeaf(facet)) {
          var children = facet.children;
          _this.addFacetLines(facet, children);
        }
      });
    };
    Tree2.prototype.addFacetLines = function(facet, children) {
      var _this = this;
      var view = facet.view;
      var region = view.coordinateBBox;
      var start = {
        x: region.x + region.width / 2,
        y: region.y + region.height
      };
      children.forEach(function(subFacet) {
        var subRegion = subFacet.view.coordinateBBox;
        var end = {
          x: subRegion.bl.x + (subRegion.tr.x - subRegion.bl.x) / 2,
          y: subRegion.tr.y
        };
        var middle1 = {
          x: start.x,
          y: start.y + (end.y - start.y) / 2
        };
        var middle2 = {
          x: end.x,
          y: middle1.y
        };
        _this.drawLine([start, middle1, middle2, end]);
      });
    };
    Tree2.prototype.getPath = function(points2) {
      var path2 = [];
      var smooth = this.cfg.line.smooth;
      if (smooth) {
        path2.push(["M", points2[0].x, points2[0].y]);
        path2.push(["C", points2[1].x, points2[1].y, points2[2].x, points2[2].y, points2[3].x, points2[3].y]);
      } else {
        points2.forEach(function(point2, index2) {
          if (index2 === 0) {
            path2.push(["M", point2.x, point2.y]);
          } else {
            path2.push(["L", point2.x, point2.y]);
          }
        });
      }
      return path2;
    };
    Tree2.prototype.drawLine = function(points2) {
      var path2 = this.getPath(points2);
      var line2 = this.cfg.line.style;
      this.container.addShape("path", {
        attrs: mix({
          // @ts-ignore
          path: path2
        }, line2)
      });
    };
    Tree2.prototype.getXAxisOption = function(x, axes, option, facet) {
      if (facet.rowIndex !== facet.rowValuesLength - 1) {
        return __assign$1(__assign$1({}, option), { title: null, label: null });
      }
      return option;
    };
    Tree2.prototype.getYAxisOption = function(y, axes, option, facet) {
      if (facet.originColIndex !== 0 && facet.columnIndex !== 0) {
        return __assign$1(__assign$1({}, option), { title: null, label: null });
      }
      return option;
    };
    return Tree2;
  }(Facet)
);
function getMedian(array2) {
  var arr = __spreadArray$1([], __read(array2), false);
  arr.sort(function(a, b) {
    return a - b;
  });
  var len = arr.length;
  if (len === 0) {
    return 0;
  }
  if (len % 2 === 1) {
    return arr[(len - 1) / 2];
  }
  return (arr[len / 2] + arr[len / 2 - 1]) / 2;
}
function getMean(array2) {
  var sum = reduce(array2, function(r, num) {
    return r += isNaN(num) || !isNumber$1(num) ? 0 : num;
  }, 0);
  return array2.length === 0 ? 0 : sum / array2.length;
}
function getNormalizedValue(val, scale2) {
  if (!scale2) {
    return null;
  }
  var scaled;
  switch (val) {
    case "start":
      return 0;
    case "center":
      return 0.5;
    case "end":
      return 1;
    case "median": {
      scaled = scale2.isCategory ? getMedian(scale2.values.map(function(_, idx) {
        return idx;
      })) : getMedian(scale2.values);
      break;
    }
    case "mean": {
      scaled = scale2.isCategory ? (scale2.values.length - 1) / 2 : getMean(scale2.values);
      break;
    }
    case "min":
      scaled = scale2.isCategory ? 0 : scale2[val];
      break;
    case "max":
      scaled = scale2.isCategory ? scale2.values.length - 1 : scale2[val];
      break;
    default:
      scaled = val;
      break;
  }
  return scale2.scale(scaled);
}
var ANNOTATIONS_AFTER_RENDER = ["regionFilter", "shape"];
var Annotation = (
  /** @class */
  function(_super) {
    __extends$1(Annotation2, _super);
    function Annotation2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = /* @__PURE__ */ new Map();
      _this.foregroundContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.backgroundContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.option = [];
      return _this;
    }
    Object.defineProperty(Annotation2.prototype, "name", {
      get: function() {
        return "annotation";
      },
      enumerable: false,
      configurable: true
    });
    Annotation2.prototype.init = function() {
    };
    Annotation2.prototype.layout = function() {
      this.update();
    };
    Annotation2.prototype.render = function() {
    };
    Annotation2.prototype.update = function() {
      var _this = this;
      this.onAfterRender(function() {
        var updated = /* @__PURE__ */ new Map();
        each$1(_this.option, function(option) {
          if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
            var co = _this.updateOrCreate(option);
            if (co) {
              updated.set(_this.getCacheKey(option), co);
            }
          }
        });
        _this.cache = _this.syncCache(updated);
      });
      var updateCache = /* @__PURE__ */ new Map();
      each$1(this.option, function(option) {
        if (!contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
          var co = _this.updateOrCreate(option);
          if (co) {
            updateCache.set(_this.getCacheKey(option), co);
          }
        }
      });
      this.cache = this.syncCache(updateCache);
    };
    Annotation2.prototype.clear = function(includeOption) {
      if (includeOption === void 0) {
        includeOption = false;
      }
      _super.prototype.clear.call(this);
      this.clearComponents();
      this.foregroundContainer.clear();
      this.backgroundContainer.clear();
      if (includeOption) {
        this.option = [];
      }
    };
    Annotation2.prototype.destroy = function() {
      this.clear(true);
      this.foregroundContainer.remove(true);
      this.backgroundContainer.remove(true);
    };
    Annotation2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value2) {
        co.push(value2);
      });
      return co;
    };
    Annotation2.prototype.clearComponents = function() {
      this.getComponents().forEach(function(co) {
        co.component.destroy();
      });
      this.cache.clear();
    };
    Annotation2.prototype.onAfterRender = function(doWhat) {
      var done = false;
      if (this.view.getOptions().animate) {
        this.view.geometries.forEach(function(g) {
          if (g.animateOption) {
            g.once(GEOMETRY_LIFE_CIRCLE.AFTER_DRAW_ANIMATE, function() {
              doWhat();
            });
            done = true;
          }
        });
      }
      if (!done) {
        this.view.getRootView().once(VIEW_LIFE_CIRCLE.AFTER_RENDER, function() {
          doWhat();
        });
      }
    };
    Annotation2.prototype.createAnnotation = function(option) {
      var type = option.type;
      var Ctor = AnnotationComponent[upperFirst(type)];
      if (Ctor) {
        var theme2 = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme2);
        if (!cfg) {
          return null;
        }
        var annotation2 = new Ctor(cfg);
        return {
          component: annotation2,
          layer: this.isTop(cfg) ? LAYER.FORE : LAYER.BG,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.ANNOTATION,
          extra: option
        };
      }
    };
    Annotation2.prototype.annotation = function(option) {
      this.option.push(option);
    };
    Annotation2.prototype.arc = function(option) {
      this.annotation(__assign$1({ type: "arc" }, option));
      return this;
    };
    Annotation2.prototype.image = function(option) {
      this.annotation(__assign$1({ type: "image" }, option));
      return this;
    };
    Annotation2.prototype.line = function(option) {
      this.annotation(__assign$1({ type: "line" }, option));
      return this;
    };
    Annotation2.prototype.region = function(option) {
      this.annotation(__assign$1({ type: "region" }, option));
      return this;
    };
    Annotation2.prototype.text = function(option) {
      this.annotation(__assign$1({ type: "text" }, option));
      return this;
    };
    Annotation2.prototype.dataMarker = function(option) {
      this.annotation(__assign$1({ type: "dataMarker" }, option));
      return this;
    };
    Annotation2.prototype.dataRegion = function(option) {
      this.annotation(__assign$1({ type: "dataRegion" }, option));
    };
    Annotation2.prototype.regionFilter = function(option) {
      this.annotation(__assign$1({ type: "regionFilter" }, option));
    };
    Annotation2.prototype.shape = function(option) {
      this.annotation(__assign$1({ type: "shape" }, option));
    };
    Annotation2.prototype.html = function(option) {
      this.annotation(__assign$1({ type: "html" }, option));
    };
    Annotation2.prototype.parsePosition = function(p) {
      var e_1, _a2;
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var position = isFunction(p) ? p.call(null, xScale, yScales) : p;
      var x = 0;
      var y = 0;
      if (isArray$1(position)) {
        var _b = __read(position, 2), xPos = _b[0], yPos = _b[1];
        if (isString(xPos) && xPos.indexOf("%") !== -1 && !isNaN(xPos.slice(0, -1))) {
          return this.parsePercentPosition(position);
        }
        x = getNormalizedValue(xPos, xScale);
        y = getNormalizedValue(yPos, Object.values(yScales)[0]);
      } else if (!isNil(position)) {
        try {
          for (var _c = __values(keys(position)), _d = _c.next(); !_d.done; _d = _c.next()) {
            var key = _d.value;
            var value2 = position[key];
            if (key === xScale.field) {
              x = getNormalizedValue(value2, xScale);
            }
            if (yScales[key]) {
              y = getNormalizedValue(value2, yScales[key]);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_d && !_d.done && (_a2 = _c.return))
              _a2.call(_c);
          } finally {
            if (e_1)
              throw e_1.error;
          }
        }
      }
      if (isNaN(x) || isNaN(y)) {
        return null;
      }
      return this.view.getCoordinate().convert({ x, y });
    };
    Annotation2.prototype.getRegionPoints = function(start, end) {
      var _this = this;
      var xScale = this.view.getXScale();
      var yScales = this.view.getScalesByDim("y");
      var yScale = Object.values(yScales)[0];
      var xField = xScale.field;
      var viewData = this.view.getData();
      var startXValue = isArray$1(start) ? start[0] : start[xField];
      var endXValue = isArray$1(end) ? end[0] : end[xField];
      var arr = [];
      var startIndex;
      each$1(viewData, function(item, idx) {
        if (item[xField] === startXValue) {
          startIndex = idx;
        }
        if (idx >= startIndex) {
          var point2 = _this.parsePosition([item[xField], item[yScale.field]]);
          if (point2) {
            arr.push(point2);
          }
        }
        if (item[xField] === endXValue) {
          return false;
        }
      });
      return arr;
    };
    Annotation2.prototype.parsePercentPosition = function(position) {
      var xPercent = parseFloat(position[0]) / 100;
      var yPercent = parseFloat(position[1]) / 100;
      var coordinate2 = this.view.getCoordinate();
      var start = coordinate2.start, end = coordinate2.end;
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      var x = coordinate2.getWidth() * xPercent + topLeft.x;
      var y = coordinate2.getHeight() * yPercent + topLeft.y;
      return { x, y };
    };
    Annotation2.prototype.getCoordinateBBox = function() {
      var coordinate2 = this.view.getCoordinate();
      var start = coordinate2.start, end = coordinate2.end;
      var width = coordinate2.getWidth();
      var height = coordinate2.getHeight();
      var topLeft = {
        x: Math.min(start.x, end.x),
        y: Math.min(start.y, end.y)
      };
      return {
        x: topLeft.x,
        y: topLeft.y,
        minX: topLeft.x,
        minY: topLeft.y,
        maxX: topLeft.x + width,
        maxY: topLeft.y + height,
        width,
        height
      };
    };
    Annotation2.prototype.getAnnotationCfg = function(type, option, theme2) {
      var _this = this;
      var coordinate2 = this.view.getCoordinate();
      var canvas = this.view.getCanvas();
      var o = {};
      if (isNil(option)) {
        return null;
      }
      var start = option.start, end = option.end, position = option.position;
      var sp = this.parsePosition(start);
      var ep = this.parsePosition(end);
      var textPoint = this.parsePosition(position);
      if (["arc", "image", "line", "region", "regionFilter"].includes(type) && (!sp || !ep)) {
        return null;
      } else if (["text", "dataMarker", "html"].includes(type) && !textPoint) {
        return null;
      }
      if (type === "arc") {
        var _a2 = option;
        _a2.start;
        _a2.end;
        var rest = __rest(_a2, ["start", "end"]);
        var startAngle = getAngleByPoint(coordinate2, sp);
        var endAngle = getAngleByPoint(coordinate2, ep);
        if (startAngle > endAngle) {
          endAngle = Math.PI * 2 + endAngle;
        }
        o = __assign$1(__assign$1({}, rest), { center: coordinate2.getCenter(), radius: getDistanceToCenter(coordinate2, sp), startAngle, endAngle });
      } else if (type === "image") {
        var _b = option;
        _b.start;
        _b.end;
        var rest = __rest(_b, ["start", "end"]);
        o = __assign$1(__assign$1({}, rest), { start: sp, end: ep, src: option.src });
      } else if (type === "line") {
        var _c = option;
        _c.start;
        _c.end;
        var rest = __rest(_c, ["start", "end"]);
        o = __assign$1(__assign$1({}, rest), { start: sp, end: ep, text: get(option, "text", null) });
      } else if (type === "region") {
        var _d = option;
        _d.start;
        _d.end;
        var rest = __rest(_d, ["start", "end"]);
        o = __assign$1(__assign$1({}, rest), { start: sp, end: ep });
      } else if (type === "text") {
        var filteredData = this.view.getData();
        var _e = option;
        _e.position;
        var content = _e.content, rest = __rest(_e, ["position", "content"]);
        var textContent = content;
        if (isFunction(content)) {
          textContent = content(filteredData);
        }
        o = __assign$1(__assign$1(__assign$1({}, textPoint), rest), { content: textContent });
      } else if (type === "dataMarker") {
        var _f = option;
        _f.position;
        var point2 = _f.point, line2 = _f.line, text2 = _f.text, autoAdjust = _f.autoAdjust, direction2 = _f.direction, rest = __rest(_f, ["position", "point", "line", "text", "autoAdjust", "direction"]);
        o = __assign$1(__assign$1(__assign$1({}, rest), textPoint), { coordinateBBox: this.getCoordinateBBox(), point: point2, line: line2, text: text2, autoAdjust, direction: direction2 });
      } else if (type === "dataRegion") {
        var _g = option, start_5 = _g.start, end_5 = _g.end, region = _g.region, text2 = _g.text, lineLength = _g.lineLength, rest = __rest(_g, ["start", "end", "region", "text", "lineLength"]);
        o = __assign$1(__assign$1({}, rest), { points: this.getRegionPoints(start_5, end_5), region, text: text2, lineLength });
      } else if (type === "regionFilter") {
        var _h = option;
        _h.start;
        _h.end;
        var apply_1 = _h.apply, color2 = _h.color, rest = __rest(_h, ["start", "end", "apply", "color"]);
        var geometries = this.view.geometries;
        var shapes_1 = [];
        var addShapes_1 = function(item) {
          if (!item) {
            return;
          }
          if (item.isGroup()) {
            item.getChildren().forEach(function(child) {
              return addShapes_1(child);
            });
          } else {
            shapes_1.push(item);
          }
        };
        each$1(geometries, function(geom) {
          if (apply_1) {
            if (contains(apply_1, geom.type)) {
              each$1(geom.elements, function(elem) {
                addShapes_1(elem.shape);
              });
            }
          } else {
            each$1(geom.elements, function(elem) {
              addShapes_1(elem.shape);
            });
          }
        });
        o = __assign$1(__assign$1({}, rest), { color: color2, shapes: shapes_1, start: sp, end: ep });
      } else if (type === "shape") {
        var _j = option, render_1 = _j.render, restOptions = __rest(_j, ["render"]);
        var wrappedRender = function(container) {
          if (isFunction(option.render)) {
            return render_1(container, _this.view, { parsePosition: _this.parsePosition.bind(_this) });
          }
        };
        o = __assign$1(__assign$1({}, restOptions), { render: wrappedRender });
      } else if (type === "html") {
        var _k = option, html_1 = _k.html;
        _k.position;
        var restOptions = __rest(_k, ["html", "position"]);
        var wrappedHtml = function(container) {
          if (isFunction(html_1)) {
            return html_1(container, _this.view);
          }
          return html_1;
        };
        o = __assign$1(__assign$1(__assign$1({}, restOptions), textPoint), {
          // html  parent
          parent: canvas.get("el").parentNode,
          html: wrappedHtml
        });
      }
      var cfg = deepMix({}, theme2, __assign$1(__assign$1({}, o), { top: option.top, style: option.style, offsetX: option.offsetX, offsetY: option.offsetY }));
      if (type !== "html") {
        cfg.container = this.getComponentContainer(cfg);
      }
      cfg.animate = this.view.getOptions().animate && cfg.animate && get(option, "animate", cfg.animate);
      cfg.animateOption = deepMix({}, DEFAULT_ANIMATE_CFG, cfg.animateOption, option.animateOption);
      return cfg;
    };
    Annotation2.prototype.isTop = function(option) {
      return get(option, "top", true);
    };
    Annotation2.prototype.getComponentContainer = function(option) {
      return this.isTop(option) ? this.foregroundContainer : this.backgroundContainer;
    };
    Annotation2.prototype.getAnnotationTheme = function(type) {
      return get(this.view.getTheme(), ["components", "annotation", type], {});
    };
    Annotation2.prototype.updateOrCreate = function(option) {
      var co = this.cache.get(this.getCacheKey(option));
      if (co) {
        var type = option.type;
        var theme2 = this.getAnnotationTheme(type);
        var cfg = this.getAnnotationCfg(type, option, theme2);
        if (cfg) {
          omit(cfg, ["container"]);
        }
        co.component.update(__assign$1(__assign$1({}, cfg || {}), { visible: !!cfg }));
        if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
          co.component.render();
        }
      } else {
        co = this.createAnnotation(option);
        if (co) {
          co.component.init();
          if (contains(ANNOTATIONS_AFTER_RENDER, option.type)) {
            co.component.render();
          }
        }
      }
      return co;
    };
    Annotation2.prototype.syncCache = function(updated) {
      var _this = this;
      var newCache = new Map(this.cache);
      updated.forEach(function(co, key) {
        newCache.set(key, co);
      });
      newCache.forEach(function(co, key) {
        if (!find$1(_this.option, function(option) {
          return key === _this.getCacheKey(option);
        })) {
          co.component.destroy();
          newCache.delete(key);
        }
      });
      return newCache;
    };
    Annotation2.prototype.getCacheKey = function(option) {
      return option;
    };
    return Annotation2;
  }(Controller)
);
function getGridThemeCfg(theme2, direction2) {
  var axisTheme = deepMix({}, get(theme2, ["components", "axis", "common"]), get(theme2, ["components", "axis", direction2]));
  return get(axisTheme, ["grid"], {});
}
function getLineGridItems(coordinate2, scale2, dim, alignTick) {
  var items = [];
  var ticks = scale2.getTicks();
  if (coordinate2.isPolar) {
    ticks.push({
      value: 1,
      text: "",
      tickValue: ""
    });
  }
  ticks.reduce(function(preTick, currentTick, currentIndex) {
    var currentValue = currentTick.value;
    if (alignTick) {
      items.push({
        points: [
          coordinate2.convert(dim === "y" ? { x: 0, y: currentValue } : { x: currentValue, y: 0 }),
          coordinate2.convert(dim === "y" ? { x: 1, y: currentValue } : { x: currentValue, y: 1 })
        ]
      });
    } else {
      if (currentIndex) {
        var preValue = preTick.value;
        var middleValue = (preValue + currentValue) / 2;
        items.push({
          points: [
            coordinate2.convert(dim === "y" ? { x: 0, y: middleValue } : { x: middleValue, y: 0 }),
            coordinate2.convert(dim === "y" ? { x: 1, y: middleValue } : { x: middleValue, y: 1 })
          ]
        });
      }
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function getCircleGridItems(coordinate2, xScale, yScale, alignTick, dim) {
  var count2 = xScale.values.length;
  var items = [];
  var ticks = yScale.getTicks();
  ticks.reduce(function(preTick, currentTick) {
    var preValue = preTick ? preTick.value : currentTick.value;
    var currentValue = currentTick.value;
    var middleValue = (preValue + currentValue) / 2;
    if (dim === "x") {
      items.push({
        points: [
          coordinate2.convert({
            x: alignTick ? currentValue : middleValue,
            y: 0
          }),
          coordinate2.convert({
            x: alignTick ? currentValue : middleValue,
            y: 1
          })
        ]
      });
    } else {
      items.push({
        points: map$2(Array(count2 + 1), function(__, idx) {
          return coordinate2.convert({
            x: idx / count2,
            y: alignTick ? currentValue : middleValue
          });
        })
      });
    }
    return currentTick;
  }, ticks[0]);
  return items;
}
function showGrid(axisTheme, axisOption) {
  var userGrid = get(axisOption, "grid");
  if (userGrid === null) {
    return false;
  }
  var themeGrid = get(axisTheme, "grid");
  return !(userGrid === void 0 && themeGrid === null);
}
var OMIT_CFG = ["container"];
var AXIS_DEFAULT_ANIMATE_CFG = __assign$1(__assign$1({}, DEFAULT_ANIMATE_CFG), { appear: null });
var Axis = (
  /** @class */
  function(_super) {
    __extends$1(Axis2, _super);
    function Axis2(view) {
      var _this = _super.call(this, view) || this;
      _this.cache = /* @__PURE__ */ new Map();
      _this.gridContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.gridForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.axisContainer = _this.view.getLayer(LAYER.BG).addGroup();
      _this.axisForeContainer = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Axis2.prototype, "name", {
      get: function() {
        return "axis";
      },
      enumerable: false,
      configurable: true
    });
    Axis2.prototype.init = function() {
    };
    Axis2.prototype.render = function() {
      this.update();
    };
    Axis2.prototype.layout = function() {
      var _this = this;
      var coordinate2 = this.view.getCoordinate();
      each$1(this.getComponents(), function(co) {
        var component2 = co.component, direction2 = co.direction, type = co.type, extra = co.extra;
        var dim = extra.dim, scale2 = extra.scale, alignTick = extra.alignTick;
        var updated;
        if (type === COMPONENT_TYPE.AXIS) {
          if (coordinate2.isPolar) {
            if (dim === "x") {
              updated = coordinate2.isTransposed ? getAxisRegion(coordinate2, direction2) : getCircleAxisCenterRadius(coordinate2);
            } else if (dim === "y") {
              updated = coordinate2.isTransposed ? getCircleAxisCenterRadius(coordinate2) : getAxisRegion(coordinate2, direction2);
            }
          } else {
            updated = getAxisRegion(coordinate2, direction2);
          }
        } else if (type === COMPONENT_TYPE.GRID) {
          if (coordinate2.isPolar) {
            var items = void 0;
            if (coordinate2.isTransposed) {
              items = dim === "x" ? getCircleGridItems(coordinate2, _this.view.getYScales()[0], scale2, alignTick, dim) : getLineGridItems(coordinate2, scale2, dim, alignTick);
            } else {
              items = dim === "x" ? getLineGridItems(coordinate2, scale2, dim, alignTick) : getCircleGridItems(coordinate2, _this.view.getXScale(), scale2, alignTick, dim);
            }
            updated = {
              items,
              // coordinate center 
              center: _this.view.getCoordinate().getCenter()
            };
          } else {
            updated = { items: getLineGridItems(coordinate2, scale2, dim, alignTick) };
          }
        }
        component2.update(updated);
      });
    };
    Axis2.prototype.update = function() {
      this.option = this.view.getOptions().axes;
      var updatedCache = /* @__PURE__ */ new Map();
      this.updateXAxes(updatedCache);
      this.updateYAxes(updatedCache);
      var newCache = /* @__PURE__ */ new Map();
      this.cache.forEach(function(co, key) {
        if (updatedCache.has(key)) {
          newCache.set(key, co);
        } else {
          co.component.destroy();
        }
      });
      this.cache = newCache;
    };
    Axis2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.cache.clear();
      this.gridContainer.clear();
      this.gridForeContainer.clear();
      this.axisContainer.clear();
      this.axisForeContainer.clear();
    };
    Axis2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.gridContainer.remove(true);
      this.gridForeContainer.remove(true);
      this.axisContainer.remove(true);
      this.axisForeContainer.remove(true);
    };
    Axis2.prototype.getComponents = function() {
      var co = [];
      this.cache.forEach(function(value2) {
        co.push(value2);
      });
      return co;
    };
    Axis2.prototype.updateXAxes = function(updatedCache) {
      var scale2 = this.view.getXScale();
      if (!scale2 || scale2.isIdentity) {
        return;
      }
      var xAxisOption = getAxisOption(this.option, scale2.field);
      if (xAxisOption === false) {
        return;
      }
      var direction2 = getAxisDirection(xAxisOption, DIRECTION.BOTTOM);
      var layer = LAYER.BG;
      var dim = "x";
      var coordinate2 = this.view.getCoordinate();
      var axisId = this.getId("axis", scale2.field);
      var gridId = this.getId("grid", scale2.field);
      if (coordinate2.isRect) {
        var axis2 = this.cache.get(axisId);
        if (axis2) {
          var cfg = this.getLineAxisCfg(scale2, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis2.component.update(cfg);
          updatedCache.set(axisId, axis2);
        } else {
          axis2 = this.createLineAxis(scale2, xAxisOption, layer, direction2, dim);
          this.cache.set(axisId, axis2);
          updatedCache.set(axisId, axis2);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = this.getLineGridCfg(scale2, xAxisOption, direction2, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          grid = this.createLineGrid(scale2, xAxisOption, layer, direction2, dim);
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else if (coordinate2.isPolar) {
        var axis2 = this.cache.get(axisId);
        if (axis2) {
          var cfg = coordinate2.isTransposed ? this.getLineAxisCfg(scale2, xAxisOption, DIRECTION.RADIUS) : this.getCircleAxisCfg(scale2, xAxisOption, direction2);
          omit(cfg, OMIT_CFG);
          axis2.component.update(cfg);
          updatedCache.set(axisId, axis2);
        } else {
          if (coordinate2.isTransposed) {
            if (isUndefined(xAxisOption)) {
              return;
            } else {
              axis2 = this.createLineAxis(scale2, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            axis2 = this.createCircleAxis(scale2, xAxisOption, layer, direction2, dim);
          }
          this.cache.set(axisId, axis2);
          updatedCache.set(axisId, axis2);
        }
        var grid = this.cache.get(gridId);
        if (grid) {
          var cfg = coordinate2.isTransposed ? this.getCircleGridCfg(scale2, xAxisOption, DIRECTION.RADIUS, dim) : this.getLineGridCfg(scale2, xAxisOption, DIRECTION.CIRCLE, dim);
          omit(cfg, OMIT_CFG);
          grid.component.update(cfg);
          updatedCache.set(gridId, grid);
        } else {
          if (coordinate2.isTransposed) {
            if (isUndefined(xAxisOption)) {
              return;
            } else {
              grid = this.createCircleGrid(scale2, xAxisOption, layer, DIRECTION.RADIUS, dim);
            }
          } else {
            grid = this.createLineGrid(scale2, xAxisOption, layer, DIRECTION.CIRCLE, dim);
          }
          if (grid) {
            this.cache.set(gridId, grid);
            updatedCache.set(gridId, grid);
          }
        }
      } else
        ;
    };
    Axis2.prototype.updateYAxes = function(updatedCache) {
      var _this = this;
      var yScales = this.view.getYScales();
      each$1(yScales, function(scale2, idx) {
        if (!scale2 || scale2.isIdentity) {
          return;
        }
        var field2 = scale2.field;
        var yAxisOption = getAxisOption(_this.option, field2);
        if (yAxisOption !== false) {
          var layer = LAYER.BG;
          var dim = "y";
          var axisId = _this.getId("axis", field2);
          var gridId = _this.getId("grid", field2);
          var coordinate2 = _this.view.getCoordinate();
          if (coordinate2.isRect) {
            var direction2 = getAxisDirection(yAxisOption, idx === 0 ? DIRECTION.LEFT : DIRECTION.RIGHT);
            var axis2 = _this.cache.get(axisId);
            if (axis2) {
              var cfg = _this.getLineAxisCfg(scale2, yAxisOption, direction2);
              omit(cfg, OMIT_CFG);
              axis2.component.update(cfg);
              updatedCache.set(axisId, axis2);
            } else {
              axis2 = _this.createLineAxis(scale2, yAxisOption, layer, direction2, dim);
              _this.cache.set(axisId, axis2);
              updatedCache.set(axisId, axis2);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = _this.getLineGridCfg(scale2, yAxisOption, direction2, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              grid = _this.createLineGrid(scale2, yAxisOption, layer, direction2, dim);
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else if (coordinate2.isPolar) {
            var axis2 = _this.cache.get(axisId);
            if (axis2) {
              var cfg = coordinate2.isTransposed ? _this.getCircleAxisCfg(scale2, yAxisOption, DIRECTION.CIRCLE) : _this.getLineAxisCfg(scale2, yAxisOption, DIRECTION.RADIUS);
              omit(cfg, OMIT_CFG);
              axis2.component.update(cfg);
              updatedCache.set(axisId, axis2);
            } else {
              if (coordinate2.isTransposed) {
                if (isUndefined(yAxisOption)) {
                  return;
                } else {
                  axis2 = _this.createCircleAxis(scale2, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                axis2 = _this.createLineAxis(scale2, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              _this.cache.set(axisId, axis2);
              updatedCache.set(axisId, axis2);
            }
            var grid = _this.cache.get(gridId);
            if (grid) {
              var cfg = coordinate2.isTransposed ? _this.getLineGridCfg(scale2, yAxisOption, DIRECTION.CIRCLE, dim) : _this.getCircleGridCfg(scale2, yAxisOption, DIRECTION.RADIUS, dim);
              omit(cfg, OMIT_CFG);
              grid.component.update(cfg);
              updatedCache.set(gridId, grid);
            } else {
              if (coordinate2.isTransposed) {
                if (isUndefined(yAxisOption)) {
                  return;
                } else {
                  grid = _this.createLineGrid(scale2, yAxisOption, layer, DIRECTION.CIRCLE, dim);
                }
              } else {
                grid = _this.createCircleGrid(scale2, yAxisOption, layer, DIRECTION.RADIUS, dim);
              }
              if (grid) {
                _this.cache.set(gridId, grid);
                updatedCache.set(gridId, grid);
              }
            }
          } else
            ;
        }
      });
    };
    Axis2.prototype.createLineAxis = function(scale2, option, layer, direction2, dim) {
      var axis2 = {
        component: new LineAxis(this.getLineAxisCfg(scale2, option, direction2)),
        layer,
        direction: direction2 === DIRECTION.RADIUS ? DIRECTION.NONE : direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale2 }
      };
      axis2.component.set("field", scale2.field);
      axis2.component.init();
      return axis2;
    };
    Axis2.prototype.createLineGrid = function(scale2, option, layer, direction2, dim) {
      var cfg = this.getLineGridCfg(scale2, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new LineGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale2,
            alignTick: get(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.createCircleAxis = function(scale2, option, layer, direction2, dim) {
      var axis2 = {
        component: new CircleAxis(this.getCircleAxisCfg(scale2, option, direction2)),
        layer,
        direction: direction2,
        type: COMPONENT_TYPE.AXIS,
        extra: { dim, scale: scale2 }
      };
      axis2.component.set("field", scale2.field);
      axis2.component.init();
      return axis2;
    };
    Axis2.prototype.createCircleGrid = function(scale2, option, layer, direction2, dim) {
      var cfg = this.getCircleGridCfg(scale2, option, direction2, dim);
      if (cfg) {
        var grid = {
          component: new CircleGrid(cfg),
          layer,
          direction: DIRECTION.NONE,
          type: COMPONENT_TYPE.GRID,
          extra: {
            dim,
            scale: scale2,
            alignTick: get(cfg, "alignTick", true)
          }
        };
        grid.component.init();
        return grid;
      }
    };
    Axis2.prototype.getLineAxisCfg = function(scale2, axisOption, direction2) {
      var container = get(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate2 = this.view.getCoordinate();
      var region = getAxisRegion(coordinate2, direction2);
      var titleText = getAxisTitleText(scale2, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), direction2);
      var optionWithTitle = get(axisOption, ["title"]) ? deepMix({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deepMix(__assign$1(__assign$1({ container }, region), { ticks: scale2.getTicks().map(function(tick) {
        return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
      }), verticalFactor: coordinate2.isPolar ? getAxisFactorByRegion(region, coordinate2.getCenter()) * -1 : getAxisFactorByRegion(region, coordinate2.getCenter()), theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a2 = this.getAnimateCfg(cfg), animate = _a2.animate, animateOption = _a2.animateOption;
      cfg.animateOption = animateOption;
      cfg.animate = animate;
      var isAxisVertical = isVertical(region);
      var verticalLimitLength = get(cfg, "verticalLimitLength", isAxisVertical ? 1 / 3 : 1 / 2);
      if (verticalLimitLength <= 1) {
        var canvasWidth = this.view.getCanvas().get("width");
        var canvasHeight = this.view.getCanvas().get("height");
        cfg.verticalLimitLength = verticalLimitLength * (isAxisVertical ? canvasWidth : canvasHeight);
      }
      return cfg;
    };
    Axis2.prototype.getLineGridCfg = function(scale2, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), direction2);
      var gridCfg = deepMix({
        container: get(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer
      }, gridThemeCfg, get(axisOption, "grid"), this.getAnimateCfg(axisOption));
      gridCfg.items = getLineGridItems(this.view.getCoordinate(), scale2, dim, get(gridCfg, "alignTick", true));
      return gridCfg;
    };
    Axis2.prototype.getCircleAxisCfg = function(scale2, axisOption, direction2) {
      var container = get(axisOption, ["top"]) ? this.axisForeContainer : this.axisContainer;
      var coordinate2 = this.view.getCoordinate();
      var ticks = scale2.getTicks().map(function(tick) {
        return { id: "".concat(tick.tickValue), name: tick.text, value: tick.value };
      });
      if (!scale2.isCategory && Math.abs(coordinate2.endAngle - coordinate2.startAngle) === Math.PI * 2) {
        if (ticks.length)
          ticks[ticks.length - 1].name = "";
      }
      var titleText = getAxisTitleText(scale2, axisOption);
      var axisThemeCfg = getAxisThemeCfg(this.view.getTheme(), DIRECTION.CIRCLE);
      var optionWithTitle = get(axisOption, ["title"]) ? deepMix({ title: { style: { text: titleText } } }, { title: getAxisTitleOptions(this.view.getTheme(), direction2, axisOption.title) }, axisOption) : axisOption;
      var cfg = deepMix(__assign$1(__assign$1({ container }, getCircleAxisCenterRadius(this.view.getCoordinate())), { ticks, verticalFactor: 1, theme: axisThemeCfg }), axisThemeCfg, optionWithTitle);
      var _a2 = this.getAnimateCfg(cfg), animate = _a2.animate, animateOption = _a2.animateOption;
      cfg.animate = animate;
      cfg.animateOption = animateOption;
      return cfg;
    };
    Axis2.prototype.getCircleGridCfg = function(scale2, axisOption, direction2, dim) {
      if (!showGrid(getAxisThemeCfg(this.view.getTheme(), direction2), axisOption)) {
        return void 0;
      }
      var gridThemeCfg = getGridThemeCfg(this.view.getTheme(), DIRECTION.RADIUS);
      var gridCfg = deepMix({
        container: get(axisOption, ["top"]) ? this.gridForeContainer : this.gridContainer,
        center: this.view.getCoordinate().getCenter()
      }, gridThemeCfg, get(axisOption, "grid"), this.getAnimateCfg(axisOption));
      var alignTick = get(gridCfg, "alignTick", true);
      var verticalScale = dim === "x" ? this.view.getYScales()[0] : this.view.getXScale();
      gridCfg.items = getCircleGridItems(this.view.getCoordinate(), verticalScale, scale2, alignTick, dim);
      return gridCfg;
    };
    Axis2.prototype.getId = function(name, key) {
      var coordinate2 = this.view.getCoordinate();
      return "".concat(name, "-").concat(key, "-").concat(coordinate2.type);
    };
    Axis2.prototype.getAnimateCfg = function(cfg) {
      return {
        animate: this.view.getOptions().animate && get(cfg, "animate"),
        animateOption: cfg && cfg.animateOption ? deepMix({}, AXIS_DEFAULT_ANIMATE_CFG, cfg.animateOption) : AXIS_DEFAULT_ANIMATE_CFG
      };
    };
    return Axis2;
  }(Controller)
);
function directionToPosition(parentBBox, bbox, direction2) {
  if (direction2 === DIRECTION.TOP) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.minY];
  }
  if (direction2 === DIRECTION.BOTTOM) {
    return [parentBBox.minX + parentBBox.width / 2 - bbox.width / 2, parentBBox.maxY - bbox.height];
  }
  if (direction2 === DIRECTION.LEFT) {
    return [parentBBox.minX, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.RIGHT) {
    return [parentBBox.maxX - bbox.width, parentBBox.minY + parentBBox.height / 2 - bbox.height / 2];
  }
  if (direction2 === DIRECTION.TOP_LEFT || direction2 === DIRECTION.LEFT_TOP) {
    return [parentBBox.tl.x, parentBBox.tl.y];
  }
  if (direction2 === DIRECTION.TOP_RIGHT || direction2 === DIRECTION.RIGHT_TOP) {
    return [parentBBox.tr.x - bbox.width, parentBBox.tr.y];
  }
  if (direction2 === DIRECTION.BOTTOM_LEFT || direction2 === DIRECTION.LEFT_BOTTOM) {
    return [parentBBox.bl.x, parentBBox.bl.y - bbox.height];
  }
  if (direction2 === DIRECTION.BOTTOM_RIGHT || direction2 === DIRECTION.RIGHT_BOTTOM) {
    return [parentBBox.br.x - bbox.width, parentBBox.br.y - bbox.height];
  }
  return [0, 0];
}
function getLegendOption(legends, field2) {
  if (isBoolean(legends)) {
    return legends === false ? false : {};
  }
  return get(legends, [field2], legends);
}
function getDirection(legendOption) {
  return get(legendOption, "position", DIRECTION.BOTTOM);
}
var Legend = (
  /** @class */
  function(_super) {
    __extends$1(Legend2, _super);
    function Legend2(view) {
      var _this = _super.call(this, view) || this;
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      return _this;
    }
    Object.defineProperty(Legend2.prototype, "name", {
      get: function() {
        return "legend";
      },
      enumerable: false,
      configurable: true
    });
    Legend2.prototype.init = function() {
    };
    Legend2.prototype.render = function() {
      this.update();
    };
    Legend2.prototype.layout = function() {
      var _this = this;
      this.layoutBBox = this.view.viewBBox;
      each$1(this.components, function(co) {
        var component2 = co.component, direction2 = co.direction;
        var layout2 = getLegendLayout(direction2);
        var maxWidthRatio = component2.get("maxWidthRatio");
        var maxHeightRatio = component2.get("maxHeightRatio");
        var maxSize = _this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
        var maxWidth = component2.get("maxWidth");
        var maxHeight = component2.get("maxHeight");
        component2.update({
          maxWidth: Math.min(maxSize.maxWidth, maxWidth || 0),
          maxHeight: Math.min(maxSize.maxHeight, maxHeight || 0)
        });
        var padding2 = component2.get("padding");
        var bboxObject = component2.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, bboxObject.width, bboxObject.height).expand(padding2);
        var _a2 = __read(directionToPosition(_this.view.viewBBox, bbox, direction2), 2), x1 = _a2[0], y1 = _a2[1];
        var _b = __read(directionToPosition(_this.layoutBBox, bbox, direction2), 2), x2 = _b[0], y2 = _b[1];
        var x = 0;
        var y = 0;
        if (direction2.startsWith("top") || direction2.startsWith("bottom")) {
          x = x1;
          y = y2;
        } else {
          x = x2;
          y = y1;
        }
        component2.setLocation({ x: x + padding2[3], y: y + padding2[0] });
        _this.layoutBBox = _this.layoutBBox.cut(bbox, direction2);
      });
    };
    Legend2.prototype.update = function() {
      var _this = this;
      this.option = this.view.getOptions().legends;
      var updated = {};
      var eachLegend = function(geometry2, attr, scale2) {
        var id3 = _this.getId(scale2.field);
        var existCo2 = _this.getComponentById(id3);
        if (existCo2) {
          var cfg = void 0;
          var legendOption = getLegendOption(_this.option, scale2.field);
          if (legendOption !== false) {
            if (get(legendOption, "custom")) {
              cfg = _this.getCategoryCfg(geometry2, attr, scale2, legendOption, true);
            } else {
              if (scale2.isLinear) {
                cfg = _this.getContinuousCfg(geometry2, attr, scale2, legendOption);
              } else if (scale2.isCategory) {
                cfg = _this.getCategoryCfg(geometry2, attr, scale2, legendOption);
              }
            }
          }
          if (cfg) {
            omit(cfg, ["container"]);
            existCo2.direction = getDirection(legendOption);
            existCo2.component.update(cfg);
            updated[id3] = true;
          }
        } else {
          var legend2 = _this.createFieldLegend(geometry2, attr, scale2);
          if (legend2) {
            legend2.component.init();
            _this.components.push(legend2);
            updated[id3] = true;
          }
        }
      };
      if (get(this.option, "custom")) {
        var id2 = "global-custom";
        var existCo = this.getComponentById(id2);
        if (existCo) {
          var customCfg = this.getCategoryCfg(void 0, void 0, void 0, this.option, true);
          omit(customCfg, ["container"]);
          existCo.component.update(customCfg);
          updated[id2] = true;
        } else {
          var component2 = this.createCustomLegend(void 0, void 0, void 0, this.option);
          if (component2) {
            component2.init();
            var layer = LAYER.FORE;
            var direction2 = getDirection(this.option);
            this.components.push({
              id: id2,
              component: component2,
              layer,
              direction: direction2,
              type: COMPONENT_TYPE.LEGEND,
              extra: void 0
            });
            updated[id2] = true;
          }
        }
      } else {
        this.loopLegends(eachLegend);
      }
      var components = [];
      each$1(this.getComponents(), function(co) {
        if (updated[co.id]) {
          components.push(co);
        } else {
          co.component.destroy();
        }
      });
      this.components = components;
    };
    Legend2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.container.clear();
    };
    Legend2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.container.remove(true);
    };
    Legend2.prototype.getGeometries = function(view) {
      var _this = this;
      var geometries = view.geometries;
      each$1(view.views, function(v) {
        geometries = geometries.concat(_this.getGeometries(v));
      });
      return geometries;
    };
    Legend2.prototype.loopLegends = function(doEach) {
      var isRootView = this.view.getRootView() === this.view;
      if (!isRootView) {
        return;
      }
      var geometries = this.getGeometries(this.view);
      var looped = {};
      each$1(geometries, function(geometry2) {
        var attributes = geometry2.getGroupAttributes();
        each$1(attributes, function(attr) {
          var scale2 = attr.getScale(attr.type);
          if (!scale2 || scale2.type === "identity" || looped[scale2.field]) {
            return;
          }
          doEach(geometry2, attr, scale2);
          looped[scale2.field] = true;
        });
      });
    };
    Legend2.prototype.createFieldLegend = function(geometry2, attr, scale2) {
      var component2;
      var legendOption = getLegendOption(this.option, scale2.field);
      var layer = LAYER.FORE;
      var direction2 = getDirection(legendOption);
      if (legendOption !== false) {
        if (get(legendOption, "custom")) {
          component2 = this.createCustomLegend(geometry2, attr, scale2, legendOption);
        } else {
          if (scale2.isLinear) {
            component2 = this.createContinuousLegend(geometry2, attr, scale2, legendOption);
          } else if (scale2.isCategory) {
            component2 = this.createCategoryLegend(geometry2, attr, scale2, legendOption);
          }
        }
      }
      if (component2) {
        component2.set("field", scale2.field);
        return {
          id: this.getId(scale2.field),
          component: component2,
          layer,
          direction: direction2,
          type: COMPONENT_TYPE.LEGEND,
          extra: { scale: scale2 }
        };
      }
    };
    Legend2.prototype.createCustomLegend = function(geometry2, attr, scale2, legendOption) {
      var cfg = this.getCategoryCfg(geometry2, attr, scale2, legendOption, true);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.createContinuousLegend = function(geometry2, attr, scale2, legendOption) {
      var cfg = this.getContinuousCfg(geometry2, attr, scale2, omit(legendOption, ["value"]));
      return new ContinuousLegend(cfg);
    };
    Legend2.prototype.createCategoryLegend = function(geometry2, attr, scale2, legendOption) {
      var cfg = this.getCategoryCfg(geometry2, attr, scale2, legendOption);
      return new CategoryLegend(cfg);
    };
    Legend2.prototype.getContinuousCfg = function(geometry2, attr, scale2, legendOption) {
      var ticks = scale2.getTicks();
      var containMin = find$1(ticks, function(tick) {
        return tick.value === 0;
      });
      var containMax = find$1(ticks, function(tick) {
        return tick.value === 1;
      });
      var items = ticks.map(function(tick) {
        var value2 = tick.value, tickValue = tick.tickValue;
        var attrValue = attr.mapping(scale2.invert(value2)).join("");
        return {
          value: tickValue,
          attrValue,
          color: attrValue,
          scaleValue: value2
        };
      });
      if (!containMin) {
        items.push({
          value: scale2.min,
          attrValue: attr.mapping(scale2.invert(0)).join(""),
          color: attr.mapping(scale2.invert(0)).join(""),
          scaleValue: 0
        });
      }
      if (!containMax) {
        items.push({
          value: scale2.max,
          attrValue: attr.mapping(scale2.invert(1)).join(""),
          color: attr.mapping(scale2.invert(1)).join(""),
          scaleValue: 1
        });
      }
      items.sort(function(a, b) {
        return a.value - b.value;
      });
      var attrLegendCfg = {
        min: head(items).value,
        max: last(items).value,
        colors: [],
        rail: {
          type: attr.type
        },
        track: {}
      };
      if (attr.type === "size") {
        attrLegendCfg.track = {
          style: {
            // size  color color 
            // @ts-ignore
            fill: attr.type === "size" ? this.view.getTheme().defaultColor : void 0
          }
        };
      }
      if (attr.type === "color") {
        attrLegendCfg.colors = items.map(function(item) {
          return item.attrValue;
        });
      }
      var container = this.container;
      var direction2 = getDirection(legendOption);
      var layout2 = getLegendLayout(direction2);
      var title = get(legendOption, "title");
      if (title) {
        title = deepMix({
          text: getName(scale2)
        }, title);
      }
      attrLegendCfg.container = container;
      attrLegendCfg.layout = layout2;
      attrLegendCfg.title = title;
      attrLegendCfg.animateOption = DEFAULT_ANIMATE_CFG;
      return this.mergeLegendCfg(attrLegendCfg, legendOption, "continuous");
    };
    Legend2.prototype.getCategoryCfg = function(geometry2, attr, scale2, legendOption, custom12) {
      var container = this.container;
      var direction2 = get(legendOption, "position", DIRECTION.BOTTOM);
      var legendTheme = getLegendThemeCfg(this.view.getTheme(), direction2);
      var themeMarker = get(legendTheme, ["marker"]);
      var userMarker = get(legendOption, "marker");
      var layout2 = getLegendLayout(direction2);
      var themePageNavigator = get(legendTheme, ["pageNavigator"]);
      var userPageNavigator = get(legendOption, "pageNavigator");
      var items = custom12 ? getCustomLegendItems(themeMarker, userMarker, legendOption.items) : getLegendItems(this.view, geometry2, attr, themeMarker, userMarker);
      var title = get(legendOption, "title");
      if (title) {
        title = deepMix({
          text: scale2 ? getName(scale2) : ""
        }, title);
      }
      var maxWidthRatio = get(legendOption, "maxWidthRatio");
      var maxHeightRatio = get(legendOption, "maxHeightRatio");
      var baseCfg = this.getCategoryLegendSizeCfg(layout2, maxWidthRatio, maxHeightRatio);
      baseCfg.container = container;
      baseCfg.layout = layout2;
      baseCfg.items = items;
      baseCfg.title = title;
      baseCfg.animateOption = DEFAULT_ANIMATE_CFG;
      baseCfg.pageNavigator = deepMix({}, themePageNavigator, userPageNavigator);
      var categoryCfg = this.mergeLegendCfg(baseCfg, legendOption, direction2);
      if (categoryCfg.reversed) {
        categoryCfg.items.reverse();
      }
      var maxItemWidth = get(categoryCfg, "maxItemWidth");
      if (maxItemWidth && maxItemWidth <= 1) {
        categoryCfg.maxItemWidth = this.view.viewBBox.width * maxItemWidth;
      }
      return categoryCfg;
    };
    Legend2.prototype.mergeLegendCfg = function(baseCfg, legendOption, direction2) {
      var position = direction2.split("-")[0];
      var themeObject = getLegendThemeCfg(this.view.getTheme(), position);
      return deepMix({}, themeObject, baseCfg, legendOption);
    };
    Legend2.prototype.getId = function(key) {
      return "".concat(this.name, "-").concat(key);
    };
    Legend2.prototype.getComponentById = function(id2) {
      return find$1(this.components, function(co) {
        return co.id === id2;
      });
    };
    Legend2.prototype.getCategoryLegendSizeCfg = function(layout2, maxWidthRatio, maxHeightRatio) {
      if (maxWidthRatio === void 0) {
        maxWidthRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      if (maxHeightRatio === void 0) {
        maxHeightRatio = COMPONENT_MAX_VIEW_PERCENTAGE;
      }
      var _a2 = this.view.viewBBox, vw = _a2.width, vh = _a2.height;
      return layout2 === "vertical" ? {
        maxWidth: vw * maxWidthRatio,
        maxHeight: vh
      } : {
        maxWidth: vw,
        maxHeight: vh * maxHeightRatio
      };
    };
    return Legend2;
  }(Controller)
);
var Slider = (
  /** @class */
  function(_super) {
    __extends$1(Slider2, _super);
    function Slider2(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(v) {
        var _a2 = __read(v, 2), min2 = _a2[0], max2 = _a2[1];
        _this.start = min2;
        _this.end = max2;
        _this.changeViewData(min2, max2);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle(_this.onValueChange, 20, {
        leading: true
      });
      _this.width = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Slider2.prototype, "name", {
      get: function() {
        return "slider";
      },
      enumerable: false,
      configurable: true
    });
    Slider2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Slider2.prototype.init = function() {
    };
    Slider2.prototype.render = function() {
      this.option = this.view.getOptions().slider;
      var _a2 = this.getSliderCfg(), start = _a2.start, end = _a2.end;
      if (isNil(this.start)) {
        this.start = start;
        this.end = end;
      }
      var viewData = this.view.getOptions().data;
      if (this.option && !isEmpty(viewData)) {
        if (this.slider) {
          this.slider = this.updateSlider();
        } else {
          this.slider = this.createSlider();
          this.slider.component.on("sliderchange", this.onChangeFn);
        }
      } else {
        if (this.slider) {
          this.slider.component.destroy();
          this.slider = void 0;
        }
      }
    };
    Slider2.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.width) {
        this.measureSlider();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.start, _this.end);
          }
        }, 0);
      }
      if (this.slider) {
        var width = this.view.coordinateBBox.width;
        var padding2 = this.slider.component.get("padding");
        var _a2 = __read(padding2, 4), paddingTop = _a2[0];
        _a2[1];
        _a2[2];
        var paddingLeft = _a2[3];
        var bboxObject = this.slider.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding2);
        var _b = this.getMinMaxText(this.start, this.end), minText = _b.minText, maxText = _b.maxText;
        var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2);
        _c[0];
        var y1 = _c[1];
        var _d = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _d[0];
        _d[1];
        this.slider.component.update(__assign$1(__assign$1({}, this.getSliderCfg()), { x: x2 + paddingLeft, y: y1 + paddingTop, width: this.width, start: this.start, end: this.end, minText, maxText }));
        this.view.viewBBox = this.view.viewBBox.cut(bbox, DIRECTION.BOTTOM);
      }
    };
    Slider2.prototype.update = function() {
      this.render();
    };
    Slider2.prototype.createSlider = function() {
      var cfg = this.getSliderCfg();
      var component2 = new Slider$1(__assign$1({ container: this.container }, cfg));
      component2.init();
      return {
        component: component2,
        layer: LAYER.FORE,
        direction: DIRECTION.BOTTOM,
        type: COMPONENT_TYPE.SLIDER
      };
    };
    Slider2.prototype.updateSlider = function() {
      var cfg = this.getSliderCfg();
      if (this.width) {
        var _a2 = this.getMinMaxText(this.start, this.end), minText = _a2.minText, maxText = _a2.maxText;
        cfg = __assign$1(__assign$1({}, cfg), { width: this.width, start: this.start, end: this.end, minText, maxText });
      }
      this.slider.component.update(cfg);
      return this.slider;
    };
    Slider2.prototype.measureSlider = function() {
      var width = this.getSliderCfg().width;
      this.width = width;
    };
    Slider2.prototype.getSliderCfg = function() {
      var cfg = {
        height: 16,
        start: 0,
        end: 1,
        minText: "",
        maxText: "",
        x: 0,
        y: 0,
        width: this.view.coordinateBBox.width
      };
      if (isObject(this.option)) {
        var trendCfg = __assign$1({ data: this.getData() }, get(this.option, "trendCfg", {}));
        cfg = deepMix({}, cfg, this.getThemeOptions(), this.option);
        cfg = __assign$1(__assign$1({}, cfg), { trendCfg });
      }
      cfg.start = clamp(Math.min(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);
      cfg.end = clamp(Math.max(isNil(cfg.start) ? 0 : cfg.start, isNil(cfg.end) ? 1 : cfg.end), 0, 1);
      return cfg;
    };
    Slider2.prototype.getData = function() {
      var data2 = this.view.getOptions().data;
      var _a2 = __read(this.view.getYScales(), 1), yScale = _a2[0];
      var groupScales = this.view.getGroupScales();
      if (groupScales.length) {
        var _b = groupScales[0], field_1 = _b.field, ticks_1 = _b.ticks;
        return data2.reduce(function(pre, cur) {
          if (cur[field_1] === ticks_1[0]) {
            pre.push(cur[yScale.field]);
          }
          return pre;
        }, []);
      }
      return data2.map(function(datum) {
        return datum[yScale.field] || 0;
      });
    };
    Slider2.prototype.getThemeOptions = function() {
      var theme2 = this.view.getTheme();
      return get(theme2, ["components", "slider", "common"], {});
    };
    Slider2.prototype.getMinMaxText = function(min2, max2) {
      var data2 = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var values2 = valuesOfKey(data2, xScale.field);
      if (xScale.isLinear) {
        values2 = values2.sort();
      }
      var xValues = values2;
      var dataSize = size(data2);
      if (!xScale || !dataSize) {
        return {};
      }
      var xTickCount = size(xValues);
      var minIndex = Math.round(min2 * (xTickCount - 1));
      var maxIndex = Math.round(max2 * (xTickCount - 1));
      var minText = get(xValues, [minIndex]);
      var maxText = get(xValues, [maxIndex]);
      var formatter = this.getSliderCfg().formatter;
      if (formatter) {
        minText = formatter(minText, data2[minIndex], minIndex);
        maxText = formatter(maxText, data2[maxIndex], maxIndex);
      }
      return {
        minText,
        maxText
      };
    };
    Slider2.prototype.changeViewData = function(min2, max2) {
      var data2 = this.view.getOptions().data;
      var xScale = this.view.getXScale();
      var dataSize = size(data2);
      if (!xScale || !dataSize) {
        return;
      }
      var values2 = valuesOfKey(data2, xScale.field);
      var xScaleValues = this.view.getXScale().isLinear ? values2.sort(function(a, b) {
        return Number(a) - Number(b);
      }) : values2;
      var xValues = xScaleValues;
      var xTickCount = size(xValues);
      var minIndex = Math.round(min2 * (xTickCount - 1));
      var maxIndex = Math.round(max2 * (xTickCount - 1));
      this.view.filter(xScale.field, function(value2, datum) {
        var idx = xValues.indexOf(value2);
        return idx > -1 ? isBetween$1(idx, minIndex, maxIndex) : true;
      });
      this.view.render(true);
    };
    Slider2.prototype.getComponents = function() {
      return this.slider ? [this.slider] : [];
    };
    Slider2.prototype.clear = function() {
      if (this.slider) {
        this.slider.component.destroy();
        this.slider = void 0;
      }
      this.width = 0;
      this.start = void 0;
      this.end = void 0;
    };
    return Slider2;
  }(Controller)
);
var DEFAULT_PADDING = 0;
var DEFAULT_SIZE = 8;
var DEFAULT_CATEGORY_SIZE = 32;
var MIN_THUMB_LENGTH = 20;
var Scrollbar = (
  /** @class */
  function(_super) {
    __extends$1(Scrollbar2, _super);
    function Scrollbar2(view) {
      var _this = _super.call(this, view) || this;
      _this.onChangeFn = noop;
      _this.resetMeasure = function() {
        _this.clear();
      };
      _this.onValueChange = function(_a2) {
        var ratio = _a2.ratio;
        var animate = _this.getValidScrollbarCfg().animate;
        _this.ratio = clamp(ratio, 0, 1);
        var originalAnimate = _this.view.getOptions().animate;
        if (!animate) {
          _this.view.animate(false);
        }
        _this.changeViewData(_this.getScrollRange(), true);
        _this.view.animate(originalAnimate);
      };
      _this.container = _this.view.getLayer(LAYER.FORE).addGroup();
      _this.onChangeFn = throttle(_this.onValueChange, 20, {
        leading: true
      });
      _this.trackLen = 0;
      _this.thumbLen = 0;
      _this.ratio = 0;
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, _this.resetMeasure);
      _this.view.on(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, _this.resetMeasure);
      return _this;
    }
    Object.defineProperty(Scrollbar2.prototype, "name", {
      get: function() {
        return "scrollbar";
      },
      enumerable: false,
      configurable: true
    });
    Scrollbar2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, this.resetMeasure);
      this.view.off(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_SIZE, this.resetMeasure);
    };
    Scrollbar2.prototype.init = function() {
    };
    Scrollbar2.prototype.render = function() {
      this.option = this.view.getOptions().scrollbar;
      if (this.option) {
        if (this.scrollbar) {
          this.scrollbar = this.updateScrollbar();
        } else {
          this.scrollbar = this.createScrollbar();
          this.scrollbar.component.on("scrollchange", this.onChangeFn);
        }
      } else {
        if (this.scrollbar) {
          this.scrollbar.component.destroy();
          this.scrollbar = void 0;
        }
      }
    };
    Scrollbar2.prototype.layout = function() {
      var _this = this;
      if (this.option && !this.trackLen) {
        this.measureScrollbar();
        setTimeout(function() {
          if (!_this.view.destroyed) {
            _this.changeViewData(_this.getScrollRange(), true);
          }
        });
      }
      if (this.scrollbar) {
        var width = this.view.coordinateBBox.width;
        var padding2 = this.scrollbar.component.get("padding");
        var bboxObject = this.scrollbar.component.getLayoutBBox();
        var bbox = new BBox(bboxObject.x, bboxObject.y, Math.min(bboxObject.width, width), bboxObject.height).expand(padding2);
        var cfg = this.getScrollbarComponentCfg();
        var x = void 0;
        var y = void 0;
        if (cfg.isHorizontal) {
          var _a2 = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.BOTTOM), 2);
          _a2[0];
          var y1 = _a2[1];
          var _b = __read(directionToPosition(this.view.coordinateBBox, bbox, DIRECTION.BOTTOM), 2), x2 = _b[0];
          _b[1];
          x = x2;
          y = y1;
        } else {
          var _c = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2);
          _c[0];
          var y1 = _c[1];
          var _d = __read(directionToPosition(this.view.viewBBox, bbox, DIRECTION.RIGHT), 2), x2 = _d[0];
          _d[1];
          x = x2;
          y = y1;
        }
        x += padding2[3];
        y += padding2[0];
        if (this.trackLen) {
          this.scrollbar.component.update(__assign$1(__assign$1({}, cfg), { x, y, trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }));
        } else {
          this.scrollbar.component.update(__assign$1(__assign$1({}, cfg), { x, y }));
        }
        this.view.viewBBox = this.view.viewBBox.cut(bbox, cfg.isHorizontal ? DIRECTION.BOTTOM : DIRECTION.RIGHT);
      }
    };
    Scrollbar2.prototype.update = function() {
      this.render();
    };
    Scrollbar2.prototype.getComponents = function() {
      return this.scrollbar ? [this.scrollbar] : [];
    };
    Scrollbar2.prototype.clear = function() {
      if (this.scrollbar) {
        this.scrollbar.component.destroy();
        this.scrollbar = void 0;
      }
      this.trackLen = 0;
      this.thumbLen = 0;
      this.ratio = 0;
      this.cnt = 0;
      this.step = 0;
      this.data = void 0;
      this.xScaleCfg = void 0;
      this.yScalesCfg = [];
    };
    Scrollbar2.prototype.setValue = function(ratio) {
      this.onValueChange({ ratio });
    };
    Scrollbar2.prototype.getValue = function() {
      return this.ratio;
    };
    Scrollbar2.prototype.getThemeOptions = function() {
      var theme2 = this.view.getTheme();
      return get(theme2, ["components", "scrollbar", "common"], {});
    };
    Scrollbar2.prototype.getScrollbarTheme = function(style) {
      var theme2 = get(this.view.getTheme(), ["components", "scrollbar"]);
      var _a2 = style || {}, thumbHighlightColor = _a2.thumbHighlightColor, restStyles = __rest(_a2, ["thumbHighlightColor"]);
      return {
        default: deepMix({}, get(theme2, ["default", "style"], {}), restStyles),
        hover: deepMix({}, get(theme2, ["hover", "style"], {}), { thumbColor: thumbHighlightColor })
      };
    };
    Scrollbar2.prototype.measureScrollbar = function() {
      var xScale = this.view.getXScale();
      var yScales = this.view.getYScales().slice();
      this.data = this.getScrollbarData();
      this.step = this.getStep();
      this.cnt = this.getCnt();
      var _a2 = this.getScrollbarComponentCfg(), trackLen = _a2.trackLen, thumbLen = _a2.thumbLen;
      this.trackLen = trackLen;
      this.thumbLen = thumbLen;
      this.xScaleCfg = {
        field: xScale.field,
        values: xScale.values || []
      };
      this.yScalesCfg = yScales;
    };
    Scrollbar2.prototype.getScrollRange = function() {
      var startIdx = Math.floor((this.cnt - this.step) * clamp(this.ratio, 0, 1));
      var endIdx = Math.min(startIdx + this.step - 1, this.cnt - 1);
      return [startIdx, endIdx];
    };
    Scrollbar2.prototype.changeViewData = function(_a2, render) {
      var _this = this;
      var _b = __read(_a2, 2), startIdx = _b[0], endIdx = _b[1];
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal2 = type !== "vertical";
      var values2 = valuesOfKey(this.data, this.xScaleCfg.field);
      var xScaleValues = this.view.getXScale().isLinear ? values2.sort(function(a, b) {
        return Number(a) - Number(b);
      }) : values2;
      var xValues = isHorizontal2 ? xScaleValues : xScaleValues.reverse();
      this.yScalesCfg.forEach(function(cfg) {
        _this.view.scale(cfg.field, {
          formatter: cfg.formatter,
          type: cfg.type,
          min: cfg.min,
          max: cfg.max,
          tickMethod: cfg.tickMethod
        });
      });
      this.view.filter(this.xScaleCfg.field, function(val) {
        var idx = xValues.indexOf(val);
        return idx > -1 ? isBetween$1(idx, startIdx, endIdx) : true;
      });
      this.view.render(true);
    };
    Scrollbar2.prototype.createScrollbar = function() {
      var type = this.getValidScrollbarCfg().type;
      var isHorizontal2 = type !== "vertical";
      var component2 = new Scrollbar$1(__assign$1(__assign$1({ container: this.container }, this.getScrollbarComponentCfg()), { x: 0, y: 0 }));
      component2.init();
      return {
        component: component2,
        layer: LAYER.FORE,
        direction: isHorizontal2 ? DIRECTION.BOTTOM : DIRECTION.RIGHT,
        type: COMPONENT_TYPE.SCROLLBAR
      };
    };
    Scrollbar2.prototype.updateScrollbar = function() {
      var config = this.getScrollbarComponentCfg();
      var realConfig = this.trackLen ? __assign$1(__assign$1({}, config), { trackLen: this.trackLen, thumbLen: this.thumbLen, thumbOffset: (this.trackLen - this.thumbLen) * this.ratio }) : __assign$1({}, config);
      this.scrollbar.component.update(realConfig);
      return this.scrollbar;
    };
    Scrollbar2.prototype.getStep = function() {
      if (this.step) {
        return this.step;
      }
      var coordinateBBox = this.view.coordinateBBox;
      var _a2 = this.getValidScrollbarCfg(), type = _a2.type, categorySize = _a2.categorySize;
      var isHorizontal2 = type !== "vertical";
      return Math.floor((isHorizontal2 ? coordinateBBox.width : coordinateBBox.height) / categorySize);
    };
    Scrollbar2.prototype.getCnt = function() {
      if (this.cnt) {
        return this.cnt;
      }
      var xScale = this.view.getXScale();
      var data2 = this.getScrollbarData();
      var values2 = valuesOfKey(data2, xScale.field);
      return size(values2);
    };
    Scrollbar2.prototype.getScrollbarComponentCfg = function() {
      var _a2 = this.view, coordinateBBox = _a2.coordinateBBox, viewBBox = _a2.viewBBox;
      var _b = this.getValidScrollbarCfg(), type = _b.type, padding2 = _b.padding, width = _b.width, height = _b.height, style = _b.style;
      var isHorizontal2 = type !== "vertical";
      var _c = __read(padding2, 4), paddingTop = _c[0], paddingRight = _c[1], paddingBottom = _c[2], paddingLeft = _c[3];
      var position = isHorizontal2 ? {
        x: coordinateBBox.minX + paddingLeft,
        y: viewBBox.maxY - height - paddingBottom
      } : {
        x: viewBBox.maxX - width - paddingRight,
        y: coordinateBBox.minY + paddingTop
      };
      var step = this.getStep();
      var cnt = this.getCnt();
      var trackLen = isHorizontal2 ? coordinateBBox.width - paddingLeft - paddingRight : coordinateBBox.height - paddingTop - paddingBottom;
      var thumbLen = Math.max(trackLen * clamp(step / cnt, 0, 1), MIN_THUMB_LENGTH);
      return __assign$1(__assign$1({}, this.getThemeOptions()), { x: position.x, y: position.y, size: isHorizontal2 ? height : width, isHorizontal: isHorizontal2, trackLen, thumbLen, thumbOffset: 0, theme: this.getScrollbarTheme(style) });
    };
    Scrollbar2.prototype.getValidScrollbarCfg = function() {
      var cfg = {
        type: "horizontal",
        categorySize: DEFAULT_CATEGORY_SIZE,
        width: DEFAULT_SIZE,
        height: DEFAULT_SIZE,
        padding: [0, 0, 0, 0],
        animate: true,
        style: {}
      };
      if (isObject(this.option)) {
        cfg = __assign$1(__assign$1({}, cfg), this.option);
      }
      if (!isObject(this.option) || !this.option.padding) {
        cfg.padding = cfg.type === "horizontal" ? [DEFAULT_PADDING, 0, DEFAULT_PADDING, 0] : [0, DEFAULT_PADDING, 0, DEFAULT_PADDING];
      }
      return cfg;
    };
    Scrollbar2.prototype.getScrollbarData = function() {
      var coordinate2 = this.view.getCoordinate();
      var cfg = this.getValidScrollbarCfg();
      var data2 = this.view.getOptions().data || [];
      if (coordinate2.isReflect("y") && cfg.type === "vertical") {
        data2 = __spreadArray$1([], __read(data2), false).reverse();
      }
      return data2;
    };
    return Scrollbar2;
  }(Controller)
);
var DEFAULT_REGION_PATH_STYLE = {
  fill: "#CCD6EC",
  opacity: 0.3
};
function getItemsOfView(view, point2, tooltipCfg) {
  var e_1, _a2, e_2, _b, e_3, _c;
  var items = findItemsFromViewRecurisive(view, point2, tooltipCfg);
  if (items.length) {
    items = flatten(items);
    try {
      for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
        var itemArr = items_1_1.value;
        try {
          for (var itemArr_1 = (e_2 = void 0, __values(itemArr)), itemArr_1_1 = itemArr_1.next(); !itemArr_1_1.done; itemArr_1_1 = itemArr_1.next()) {
            var item = itemArr_1_1.value;
            var _d = item.mappingData, x = _d.x, y = _d.y;
            item.x = isArray$1(x) ? x[x.length - 1] : x;
            item.y = isArray$1(y) ? y[y.length - 1] : y;
          }
        } catch (e_2_1) {
          e_2 = { error: e_2_1 };
        } finally {
          try {
            if (itemArr_1_1 && !itemArr_1_1.done && (_b = itemArr_1.return))
              _b.call(itemArr_1);
          } finally {
            if (e_2)
              throw e_2.error;
          }
        }
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
          _a2.call(items_1);
      } finally {
        if (e_1)
          throw e_1.error;
      }
    }
    var shared = tooltipCfg.shared;
    if (shared === false && items.length > 1) {
      var snapItem = items[0];
      var min2 = Math.abs(point2.y - snapItem[0].y);
      try {
        for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
          var aItem = items_2_1.value;
          var yDistance = Math.abs(point2.y - aItem[0].y);
          if (yDistance <= min2) {
            snapItem = aItem;
            min2 = yDistance;
          }
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (items_2_1 && !items_2_1.done && (_c = items_2.return))
            _c.call(items_2);
        } finally {
          if (e_3)
            throw e_3.error;
        }
      }
      items = [snapItem];
    }
    return uniq$2(flatten(items));
  }
  return [];
}
var ActiveRegion = (
  /** @class */
  function(_super) {
    __extends$1(ActiveRegion2, _super);
    function ActiveRegion2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ActiveRegion2.prototype.show = function(args) {
      var view = this.context.view;
      var ev = this.context.event;
      var tooltipCfg = view.getController("tooltip").getTooltipCfg();
      var tooltipItems = getItemsOfView(view, {
        x: ev.x,
        y: ev.y
      }, tooltipCfg);
      if (isEqual$1(tooltipItems, this.items)) {
        return;
      }
      this.items = tooltipItems;
      if (tooltipItems.length) {
        var xField_1 = view.getXScale().field;
        var xValue_1 = tooltipItems[0].data[xField_1];
        var elements_1 = [];
        var geometries = view.geometries;
        each$1(geometries, function(geometry2) {
          if (geometry2.type === "interval" || geometry2.type === "schema") {
            var result = geometry2.getElementsBy(function(ele) {
              var eleData = ele.getData();
              return eleData[xField_1] === xValue_1;
            });
            elements_1 = elements_1.concat(result);
          }
        });
        if (elements_1.length) {
          var coordinate_1 = view.getCoordinate();
          var firstBBox_1 = elements_1[0].shape.getCanvasBBox();
          var lastBBox_1 = elements_1[0].shape.getCanvasBBox();
          var groupBBox_1 = firstBBox_1;
          each$1(elements_1, function(ele) {
            var bbox = ele.shape.getCanvasBBox();
            if (coordinate_1.isTransposed) {
              if (bbox.minY < firstBBox_1.minY) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxY > lastBBox_1.maxY) {
                lastBBox_1 = bbox;
              }
            } else {
              if (bbox.minX < firstBBox_1.minX) {
                firstBBox_1 = bbox;
              }
              if (bbox.maxX > lastBBox_1.maxX) {
                lastBBox_1 = bbox;
              }
            }
            groupBBox_1.x = Math.min(bbox.minX, groupBBox_1.minX);
            groupBBox_1.y = Math.min(bbox.minY, groupBBox_1.minY);
            groupBBox_1.width = Math.max(bbox.maxX, groupBBox_1.maxX) - groupBBox_1.x;
            groupBBox_1.height = Math.max(bbox.maxY, groupBBox_1.maxY) - groupBBox_1.y;
          });
          var backgroundGroup = view.backgroundGroup, coordinateBBox = view.coordinateBBox;
          var path2 = void 0;
          if (coordinate_1.isRect) {
            var xScale = view.getXScale();
            var _a2 = args || {}, appendRatio = _a2.appendRatio, appendWidth = _a2.appendWidth;
            if (isNil(appendWidth)) {
              appendRatio = isNil(appendRatio) ? xScale.isLinear ? 0 : 0.25 : appendRatio;
              appendWidth = coordinate_1.isTransposed ? appendRatio * lastBBox_1.height : appendRatio * firstBBox_1.width;
            }
            var minX = void 0;
            var minY = void 0;
            var width = void 0;
            var height = void 0;
            if (coordinate_1.isTransposed) {
              minX = coordinateBBox.minX;
              minY = Math.min(lastBBox_1.minY, firstBBox_1.minY) - appendWidth;
              width = coordinateBBox.width;
              height = groupBBox_1.height + appendWidth * 2;
            } else {
              minX = Math.min(firstBBox_1.minX, lastBBox_1.minX) - appendWidth;
              minY = coordinateBBox.minY;
              width = groupBBox_1.width + appendWidth * 2;
              height = coordinateBBox.height;
            }
            path2 = [
              ["M", minX, minY],
              ["L", minX + width, minY],
              ["L", minX + width, minY + height],
              ["L", minX, minY + height],
              ["Z"]
            ];
          } else {
            var firstElement = head(elements_1);
            var lastElement = last(elements_1);
            var startAngle = getAngle$1(firstElement.getModel(), coordinate_1).startAngle;
            var endAngle = getAngle$1(lastElement.getModel(), coordinate_1).endAngle;
            var center2 = coordinate_1.getCenter();
            var radius = coordinate_1.getRadius();
            var innterRadius = coordinate_1.innerRadius * radius;
            path2 = getSectorPath(center2.x, center2.y, radius, startAngle, endAngle, innterRadius);
          }
          if (this.regionPath) {
            this.regionPath.attr("path", path2);
            this.regionPath.show();
          } else {
            var style = get(args, "style", DEFAULT_REGION_PATH_STYLE);
            this.regionPath = backgroundGroup.addShape({
              type: "path",
              name: "active-region",
              capture: false,
              attrs: __assign$1(__assign$1({}, style), { path: path2 })
            });
          }
        }
      }
    };
    ActiveRegion2.prototype.hide = function() {
      if (this.regionPath) {
        this.regionPath.hide();
      }
      this.items = null;
    };
    ActiveRegion2.prototype.destroy = function() {
      this.hide();
      if (this.regionPath) {
        this.regionPath.remove(true);
      }
      _super.prototype.destroy.call(this);
    };
    return ActiveRegion2;
  }(Action)
);
var TooltipAction = (
  /** @class */
  function(_super) {
    __extends$1(TooltipAction2, _super);
    function TooltipAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    TooltipAction2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var view = context.view;
      var isTooltipLocked = view.isTooltipLocked();
      if (isTooltipLocked) {
        return;
      }
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +/* @__PURE__ */ new Date();
      var showDelay = get(context.view.getOptions(), "tooltip.showDelay", 16);
      if (timeStamp - lastTimeStamp > showDelay) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !isEqual$1(preLoc, curLoc)) {
          this.showTooltip(view, curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    TooltipAction2.prototype.hide = function() {
      var view = this.context.view;
      var tooltip2 = view.getController("tooltip");
      var _a2 = this.context.event, clientX = _a2.clientX, clientY = _a2.clientY;
      if (tooltip2.isCursorEntered({ x: clientX, y: clientY })) {
        return;
      }
      if (view.isTooltipLocked()) {
        return;
      }
      this.hideTooltip(view);
      this.location = null;
    };
    TooltipAction2.prototype.showTooltip = function(view, point2) {
      view.showTooltip(point2);
    };
    TooltipAction2.prototype.hideTooltip = function(view) {
      view.hideTooltip();
    };
    return TooltipAction2;
  }(Action)
);
var SiblingTooltip = (
  /** @class */
  function(_super) {
    __extends$1(SiblingTooltip2, _super);
    function SiblingTooltip2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingTooltip2.prototype.showTooltip = function(view, point2) {
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        var siblingPoint = getSiblingPoint(view, sibling, point2);
        sibling.showTooltip(siblingPoint);
      });
    };
    SiblingTooltip2.prototype.hideTooltip = function(view) {
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        sibling.hideTooltip();
      });
    };
    return SiblingTooltip2;
  }(TooltipAction)
);
var EllipsisText = (
  /** @class */
  function(_super) {
    __extends$1(EllipsisText2, _super);
    function EllipsisText2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    EllipsisText2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    EllipsisText2.prototype.show = function() {
      var context = this.context;
      var ev = context.event;
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +/* @__PURE__ */ new Date();
      if (timeStamp - lastTimeStamp > 16) {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        if (!preLoc || !isEqual$1(preLoc, curLoc)) {
          this.showTooltip(curLoc);
        }
        this.timeStamp = timeStamp;
        this.location = curLoc;
      }
    };
    EllipsisText2.prototype.hide = function() {
      this.hideTooltip();
      this.location = null;
    };
    EllipsisText2.prototype.showTooltip = function(curLoc) {
      var context = this.context;
      var ev = context.event;
      var target2 = ev.target;
      if (target2 && target2.get("tip")) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        var tipContent = target2.get("tip");
        this.tooltip.update(__assign$1({ title: tipContent }, curLoc));
        this.tooltip.show();
      }
    };
    EllipsisText2.prototype.hideTooltip = function() {
      this.tooltip && this.tooltip.hide();
    };
    EllipsisText2.prototype.renderTooltip = function() {
      var _a2;
      var view = this.context.view;
      var canvas = view.canvas;
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var theme2 = view.getTheme();
      var tooltipStyles = get(theme2, ["components", "tooltip", "domStyles"], {});
      var tooltip2 = new HtmlTooltip({
        parent: canvas.get("el").parentNode,
        region,
        visible: false,
        crosshairs: null,
        domStyles: __assign$1({}, deepMix({}, tooltipStyles, (_a2 = {}, // tooltip tip  50%
        _a2[CONTAINER_CLASS] = { "max-width": "50%" }, _a2[TITLE_CLASS] = { "word-break": "break-all" }, _a2)))
      });
      tooltip2.init();
      tooltip2.setCapture(false);
      this.tooltip = tooltip2;
    };
    return EllipsisText2;
  }(Action)
);
var StateBase = (
  /** @class */
  function(_super) {
    __extends$1(StateBase2, _super);
    function StateBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      return _this;
    }
    StateBase2.prototype.hasState = function(element) {
      return element.hasState(this.stateName);
    };
    StateBase2.prototype.setElementState = function(element, enable) {
      element.setState(this.stateName, enable);
    };
    StateBase2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    StateBase2.prototype.clear = function() {
      var view = this.context.view;
      this.clearViewState(view);
    };
    StateBase2.prototype.clearViewState = function(view) {
      var _this = this;
      var elements = getElementsByState(view, this.stateName);
      each$1(elements, function(el) {
        _this.setElementState(el, false);
      });
    };
    return StateBase2;
  }(Action)
);
function getItem(shape) {
  return get(shape.get("delegateObject"), "item");
}
var ElementState = (
  /** @class */
  function(_super) {
    __extends$1(ElementState2, _super);
    function ElementState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.ignoreListItemStates = ["unchecked"];
      return _this;
    }
    ElementState2.prototype.isItemIgnore = function(item, list) {
      var states = this.ignoreListItemStates;
      var filtered = states.filter(function(state2) {
        return list.hasState(item, state2);
      });
      return !!filtered.length;
    };
    ElementState2.prototype.setStateByComponent = function(component2, item, enable) {
      var view = this.context.view;
      var field2 = component2.get("field");
      var elements = getElements(view);
      this.setElementsStateByItem(elements, field2, item, enable);
    };
    ElementState2.prototype.setStateByElement = function(element, enable) {
      this.setElementState(element, enable);
    };
    ElementState2.prototype.isMathItem = function(element, field2, item) {
      var view = this.context.view;
      var scale2 = getScaleByField(view, field2);
      var value2 = getElementValue$1(element, field2);
      return !isNil(value2) && item.name === scale2.getText(value2);
    };
    ElementState2.prototype.setElementsStateByItem = function(elements, field2, item, enable) {
      var _this = this;
      each$1(elements, function(el) {
        if (_this.isMathItem(el, field2, item)) {
          el.setState(_this.stateName, enable);
        }
      });
    };
    ElementState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement$1(this.context);
      if (element) {
        if (isElementChange(this.context)) {
          this.setStateByElement(element, enable);
        }
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component2 = delegateObject.component;
          if (item && component2 && !this.isItemIgnore(item, component2)) {
            var event_1 = this.context.event.gEvent;
            if (event_1 && event_1.fromShape && event_1.toShape && getItem(event_1.fromShape) === getItem(event_1.toShape)) {
              return;
            }
            this.setStateByComponent(component2, item, enable);
          }
        }
      }
    };
    ElementState2.prototype.toggle = function() {
      var element = getCurrentElement$1(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setElementState(element, !hasState);
      }
    };
    ElementState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementState2;
  }(StateBase)
);
var ElementActive = (
  /** @class */
  function(_super) {
    __extends$1(ElementActive2, _super);
    function ElementActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementActive2.prototype.active = function() {
      this.setState();
    };
    return ElementActive2;
  }(ElementState)
);
var LinkByColor = (
  /** @class */
  function(_super) {
    __extends$1(LinkByColor2, _super);
    function LinkByColor2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.cache = {};
      return _this;
    }
    LinkByColor2.prototype.getColorScale = function(view, element) {
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return null;
      }
      var scale2 = view.getScaleByField(colorAttr.getFields()[0]);
      return scale2;
    };
    LinkByColor2.prototype.getLinkPath = function(element, nextElement) {
      var view = this.context.view;
      var isTransposed = view.getCoordinate().isTransposed;
      var bbox = element.shape.getCanvasBBox();
      var nextBBox = nextElement.shape.getCanvasBBox();
      var path2 = isTransposed ? [
        ["M", bbox.minX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", nextBBox.maxX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.minY],
        ["Z"]
      ] : [
        ["M", bbox.maxX, bbox.minY],
        ["L", nextBBox.minX, nextBBox.minY],
        ["L", nextBBox.minX, nextBBox.maxY],
        ["L", bbox.maxX, bbox.maxY],
        ["Z"]
      ];
      return path2;
    };
    LinkByColor2.prototype.addLinkShape = function(group2, element, nextElement, activeStyle) {
      var style = {
        opacity: 0.4,
        fill: element.shape.attr("fill")
      };
      group2.addShape({
        type: "path",
        attrs: __assign$1(__assign$1({}, deepMix({}, style, isFunction(activeStyle) ? activeStyle(style, element) : activeStyle)), { path: this.getLinkPath(element, nextElement) })
      });
    };
    LinkByColor2.prototype.linkByElement = function(element, activeStyle) {
      var _this = this;
      var view = this.context.view;
      var scale2 = this.getColorScale(view, element);
      if (!scale2) {
        return;
      }
      var value2 = getElementValue$1(element, scale2.field);
      if (!this.cache[value2]) {
        var elements_1 = getElementsByField(view, scale2.field, value2);
        var linkGroup = this.linkGroup;
        var group_1 = linkGroup.addGroup();
        this.cache[value2] = group_1;
        var count_1 = elements_1.length;
        each$1(elements_1, function(el, index2) {
          if (index2 < count_1 - 1) {
            var nextEl = elements_1[index2 + 1];
            _this.addLinkShape(group_1, el, nextEl, activeStyle);
          }
        });
      }
    };
    LinkByColor2.prototype.removeLink = function(element) {
      var scale2 = this.getColorScale(this.context.view, element);
      if (!scale2) {
        return;
      }
      var value2 = getElementValue$1(element, scale2.field);
      if (this.cache[value2]) {
        this.cache[value2].remove();
        this.cache[value2] = null;
      }
    };
    LinkByColor2.prototype.link = function(args) {
      var context = this.context;
      if (!this.linkGroup) {
        this.linkGroup = context.view.foregroundGroup.addGroup({
          id: "link-by-color-group",
          capture: false
        });
      }
      var element = getCurrentElement$1(context);
      if (element) {
        this.linkByElement(element, args === null || args === void 0 ? void 0 : args.style);
      }
    };
    LinkByColor2.prototype.unlink = function() {
      var element = getCurrentElement$1(this.context);
      if (element) {
        this.removeLink(element);
      }
    };
    LinkByColor2.prototype.clear = function() {
      if (this.linkGroup) {
        this.linkGroup.clear();
      }
      this.cache = {};
    };
    LinkByColor2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      if (this.linkGroup) {
        this.linkGroup.remove();
      }
    };
    return LinkByColor2;
  }(Action)
);
var ElementRangeState = (
  /** @class */
  function(_super) {
    __extends$1(ElementRangeState2, _super);
    function ElementRangeState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.endPoint = null;
      _this.isStarted = false;
      _this.effectSiblings = false;
      _this.effectByRecord = false;
      return _this;
    }
    ElementRangeState2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    ElementRangeState2.prototype.start = function() {
      this.clear();
      this.startPoint = this.getCurrentPoint();
      this.isStarted = true;
    };
    ElementRangeState2.prototype.getIntersectElements = function() {
      var elements = null;
      if (isMask(this.context)) {
        elements = getMaskedElements(this.context, 10);
      } else {
        var startPoint = this.startPoint;
        var endPoint = this.isStarted ? this.getCurrentPoint() : this.endPoint;
        if (!startPoint || !endPoint) {
          return;
        }
        var box2 = {
          minX: Math.min(startPoint.x, endPoint.x),
          minY: Math.min(startPoint.y, endPoint.y),
          maxX: Math.max(startPoint.x, endPoint.x),
          maxY: Math.max(startPoint.y, endPoint.y)
        };
        var view = this.context.view;
        elements = getIntersectElements(view, box2);
      }
      return elements;
    };
    ElementRangeState2.prototype.setStateEnable = function(enable) {
      if (this.effectSiblings && !this.effectByRecord) {
        this.setSiblingsState(enable);
      } else {
        var allElements = getElements(this.context.view);
        var elements = this.getIntersectElements();
        if (elements && elements.length) {
          if (this.effectByRecord) {
            this.setSiblingsStateByRecord(elements, enable);
          } else {
            this.setElementsState(elements, enable, allElements);
          }
        } else {
          this.clear();
        }
      }
    };
    ElementRangeState2.prototype.setSiblingsStateByRecord = function(elements, enable) {
      var _this = this;
      var view = this.context.view;
      var siblings2 = getSilbings(view);
      var records = elements.map(function(el) {
        return el.getModel().data;
      });
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      each$1(siblings2, function(sibling) {
        var allElements = getElements(sibling);
        var effectElements = allElements.filter(function(el) {
          var record = el.getModel().data;
          return isInRecords(records, record, xFiled, yField);
        });
        _this.setElementsState(effectElements, enable, allElements);
      });
    };
    ElementRangeState2.prototype.setSiblingsState = function(enable) {
      var _this = this;
      var view = this.context.view;
      var siblings2 = getSilbings(view);
      if (isMask(this.context)) {
        each$1(siblings2, function(sibling) {
          var allElements = getElements(sibling);
          var effectElements = getSiblingMaskElements(_this.context, sibling, 10);
          if (effectElements && effectElements.length) {
            _this.setElementsState(effectElements, enable, allElements);
          } else {
            _this.clearViewState(sibling);
          }
        });
      }
    };
    ElementRangeState2.prototype.setElementsState = function(elements, enable, allElements) {
      var _this = this;
      each$1(allElements, function(el) {
        if (!elements.includes(el)) {
          _this.setElementState(el, false);
        } else {
          _this.setElementState(el, enable);
        }
      });
    };
    ElementRangeState2.prototype.end = function() {
      this.isStarted = false;
      this.endPoint = this.getCurrentPoint();
    };
    ElementRangeState2.prototype.clear = function() {
      var _this = this;
      var view = this.context.view;
      if (this.effectSiblings) {
        var siblings2 = getSilbings(view);
        each$1(siblings2, function(sibling) {
          _this.clearViewState(sibling);
        });
      } else {
        this.clearViewState(view);
      }
    };
    return ElementRangeState2;
  }(StateBase)
);
var ElementRangeActive = (
  /** @class */
  function(_super) {
    __extends$1(ElementRangeActive2, _super);
    function ElementRangeActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeActive2.prototype.active = function() {
      this.setState();
    };
    return ElementRangeActive2;
  }(ElementRangeState)
);
var ElementSingleState = (
  /** @class */
  function(_super) {
    __extends$1(ElementSingleState2, _super);
    function ElementSingleState2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementSingleState2.prototype.setStateEnable = function(enable) {
      var element = getCurrentElement$1(this.context);
      if (element) {
        if (!isElementChange(this.context)) {
          return;
        }
        if (enable) {
          this.clear();
          this.setElementState(element, true);
        } else if (this.hasState(element)) {
          this.setElementState(element, false);
        }
      }
    };
    ElementSingleState2.prototype.toggle = function() {
      var element = getCurrentElement$1(this.context);
      if (element) {
        var hasState = this.hasState(element);
        if (!hasState) {
          this.clear();
        }
        this.setElementState(element, !hasState);
      }
    };
    ElementSingleState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    return ElementSingleState2;
  }(StateBase)
);
var ElementSingleActive = (
  /** @class */
  function(_super) {
    __extends$1(ElementSingleActive2, _super);
    function ElementSingleActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleActive2.prototype.active = function() {
      this.setState();
    };
    return ElementSingleActive2;
  }(ElementSingleState)
);
var STATUS_UNACTIVE$3 = "inactive";
var STATUS_ACTIVE$3 = "active";
function clearHighlight$1(view) {
  var elements = getElements(view);
  each$1(elements, function(el) {
    if (el.hasState(STATUS_ACTIVE$3)) {
      el.setState(STATUS_ACTIVE$3, false);
    }
    if (el.hasState(STATUS_UNACTIVE$3)) {
      el.setState(STATUS_UNACTIVE$3, false);
    }
  });
}
function setHighlightBy(elements, callback, enable) {
  each$1(elements, function(el) {
    if (callback(el)) {
      if (el.hasState(STATUS_UNACTIVE$3)) {
        el.setState(STATUS_UNACTIVE$3, false);
      }
      el.setState(STATUS_ACTIVE$3, enable);
    } else {
      if (el.hasState(STATUS_ACTIVE$3)) {
        el.setState(STATUS_ACTIVE$3, false);
      }
      el.setState(STATUS_UNACTIVE$3, enable);
    }
  });
}
var STATUS_UNACTIVE$2 = ELEMENT_STATE.INACTIVE;
var STATUS_ACTIVE$2 = ELEMENT_STATE.ACTIVE;
var ElementHighlight = (
  /** @class */
  function(_super) {
    __extends$1(ElementHighlight2, _super);
    function ElementHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE$2;
      return _this;
    }
    ElementHighlight2.prototype.setElementsStateByItem = function(elements, field2, item, enable) {
      var _this = this;
      var callback = function(el) {
        return _this.isMathItem(el, field2, item);
      };
      this.setHighlightBy(elements, callback, enable);
    };
    ElementHighlight2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE$2)) {
          el.setState(STATUS_UNACTIVE$2, false);
        }
        el.setState(STATUS_ACTIVE$2, true);
      } else if (!el.hasState(STATUS_ACTIVE$2)) {
        el.setState(STATUS_UNACTIVE$2, true);
      }
    };
    ElementHighlight2.prototype.setHighlightBy = function(elements, callback, enable) {
      var _this = this;
      if (enable) {
        each$1(elements, function(el) {
          _this.setElementHighlight(el, callback);
        });
      } else {
        var activeElements = getElementsByState(this.context.view, STATUS_ACTIVE$2);
        var allCancel_1 = true;
        each$1(activeElements, function(el) {
          if (!callback(el)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each$1(elements, function(el) {
            if (callback(el)) {
              if (el.hasState(STATUS_ACTIVE$2)) {
                el.setState(STATUS_ACTIVE$2, false);
              }
              el.setState(STATUS_UNACTIVE$2, true);
            }
          });
        }
      }
    };
    ElementHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      this.setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight$1(view);
    };
    return ElementHighlight2;
  }(ElementState)
);
var HighlightColor = (
  /** @class */
  function(_super) {
    __extends$1(HighlightColor2, _super);
    function HighlightColor2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightColor2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var colorAttr = element.geometry.getAttribute("color");
      if (!colorAttr) {
        return;
      }
      var scale2 = view.getScaleByField(colorAttr.getFields()[0]);
      var value2 = getElementValue$1(element, scale2.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue$1(el, scale2.field) === value2;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    return HighlightColor2;
  }(ElementHighlight)
);
var HighlightX = (
  /** @class */
  function(_super) {
    __extends$1(HighlightX2, _super);
    function HighlightX2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    HighlightX2.prototype.setElementHighlight = function(el, callback) {
      if (callback(el)) {
        if (el.hasState(STATUS_UNACTIVE$2)) {
          el.setState(STATUS_UNACTIVE$2, false);
        }
        el.setState(STATUS_ACTIVE$2, true);
      } else {
        el.setState(STATUS_UNACTIVE$2, true);
        if (el.hasState(STATUS_ACTIVE$2)) {
          el.setState(STATUS_ACTIVE$2, false);
        }
      }
    };
    HighlightX2.prototype.setStateByElement = function(element, enable) {
      var view = this.context.view;
      var scale2 = view.getXScale();
      var value2 = getElementValue$1(element, scale2.field);
      var elements = getElements(view);
      var highlightElements = elements.filter(function(el) {
        return getElementValue$1(el, scale2.field) === value2;
      });
      this.setHighlightBy(elements, function(el) {
        return highlightElements.includes(el);
      }, enable);
    };
    HighlightX2.prototype.toggle = function() {
      var element = getCurrentElement$1(this.context);
      if (element) {
        var hasState = element.hasState(this.stateName);
        this.setStateByElement(element, !hasState);
      }
    };
    return HighlightX2;
  }(ElementHighlight)
);
var EVENTS$1;
(function(EVENTS2) {
  EVENTS2["BEFORE_HIGHLIGHT"] = "element-range-highlight:beforehighlight";
  EVENTS2["AFTER_HIGHLIGHT"] = "element-range-highlight:afterhighlight";
  EVENTS2["BEFORE_CLEAR"] = "element-range-highlight:beforeclear";
  EVENTS2["AFTER_CLEAR"] = "element-range-highlight:afterclear";
})(EVENTS$1 || (EVENTS$1 = {}));
var ElementRangeHighlight = (
  /** @class */
  function(_super) {
    __extends$1(ElementRangeHighlight2, _super);
    function ElementRangeHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementRangeHighlight2.prototype.clearViewState = function(view) {
      clearHighlight$1(view);
    };
    ElementRangeHighlight2.prototype.highlight = function() {
      var _a2 = this.context, view = _a2.view, event = _a2.event;
      var elements = this.getIntersectElements();
      var payload = { view, event, highlightElements: elements };
      view.emit(EVENTS$1.BEFORE_HIGHLIGHT, Event.fromData(view, EVENTS$1.BEFORE_HIGHLIGHT, payload));
      this.setState();
      view.emit(EVENTS$1.AFTER_HIGHLIGHT, Event.fromData(view, EVENTS$1.AFTER_HIGHLIGHT, payload));
    };
    ElementRangeHighlight2.prototype.clear = function() {
      var view = this.context.view;
      view.emit(EVENTS$1.BEFORE_CLEAR, Event.fromData(view, EVENTS$1.BEFORE_CLEAR, {}));
      _super.prototype.clear.call(this);
      view.emit(EVENTS$1.AFTER_CLEAR, Event.fromData(view, EVENTS$1.AFTER_CLEAR, {}));
    };
    ElementRangeHighlight2.prototype.setElementsState = function(elements, enable, allElements) {
      setHighlightBy(allElements, function(el) {
        return elements.indexOf(el) >= 0;
      }, enable);
    };
    return ElementRangeHighlight2;
  }(ElementRangeState)
);
var ElementSingleHighlight = (
  /** @class */
  function(_super) {
    __extends$1(ElementSingleHighlight2, _super);
    function ElementSingleHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ElementSingleHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ElementSingleHighlight2.prototype.setElementState = function(element, enable) {
      var view = this.context.view;
      var elements = getElements(view);
      setHighlightBy(elements, function(el) {
        return element === el;
      }, enable);
    };
    ElementSingleHighlight2.prototype.clear = function() {
      var view = this.context.view;
      clearHighlight$1(view);
    };
    return ElementSingleHighlight2;
  }(ElementSingleState)
);
var ElementRangeSelected = (
  /** @class */
  function(_super) {
    __extends$1(ElementRangeSelected2, _super);
    function ElementRangeSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementRangeSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementRangeSelected2;
  }(ElementRangeState)
);
var ElementMultipleSelected = (
  /** @class */
  function(_super) {
    __extends$1(ElementMultipleSelected2, _super);
    function ElementMultipleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementMultipleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementMultipleSelected2;
  }(ElementState)
);
var ElementSingleSelected = (
  /** @class */
  function(_super) {
    __extends$1(ElementSingleSelected2, _super);
    function ElementSingleSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ElementSingleSelected2.prototype.selected = function() {
      this.setState();
    };
    return ElementSingleSelected2;
  }(ElementSingleState)
);
var ListState = (
  /** @class */
  function(_super) {
    __extends$1(ListState2, _super);
    function ListState2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "";
      _this.ignoreItemStates = [];
      return _this;
    }
    ListState2.prototype.getTriggerListInfo = function() {
      var delegateObject = getDelegationObject(this.context);
      var info = null;
      if (isList(delegateObject)) {
        info = {
          item: delegateObject.item,
          list: delegateObject.component
        };
      }
      return info;
    };
    ListState2.prototype.getAllowComponents = function() {
      var _this = this;
      var view = this.context.view;
      var components = getComponents(view);
      var rst = [];
      each$1(components, function(component2) {
        if (component2.isList() && _this.allowSetStateByElement(component2)) {
          rst.push(component2);
        }
      });
      return rst;
    };
    ListState2.prototype.hasState = function(list, item) {
      return list.hasState(item, this.stateName);
    };
    ListState2.prototype.clearAllComponentsState = function() {
      var _this = this;
      var components = this.getAllowComponents();
      each$1(components, function(component2) {
        component2.clearItemsState(_this.stateName);
      });
    };
    ListState2.prototype.allowSetStateByElement = function(component2) {
      var field2 = component2.get("field");
      if (!field2) {
        return false;
      }
      if (this.cfg && this.cfg.componentNames) {
        var name_1 = component2.get("name");
        if (this.cfg.componentNames.indexOf(name_1) === -1) {
          return false;
        }
      }
      var view = this.context.view;
      var scale2 = getScaleByField(view, field2);
      return scale2 && scale2.isCategory;
    };
    ListState2.prototype.allowSetStateByItem = function(item, list) {
      var ignoreStates = this.ignoreItemStates;
      if (ignoreStates.length) {
        var filterStates = ignoreStates.filter(function(state2) {
          return list.hasState(item, state2);
        });
        return filterStates.length === 0;
      }
      return true;
    };
    ListState2.prototype.setStateByElement = function(component2, element, enable) {
      var field2 = component2.get("field");
      var view = this.context.view;
      var scale2 = getScaleByField(view, field2);
      var value2 = getElementValue$1(element, field2);
      var text2 = scale2.getText(value2);
      this.setItemsState(component2, text2, enable);
    };
    ListState2.prototype.setStateEnable = function(enable) {
      var _this = this;
      var element = getCurrentElement$1(this.context);
      if (element) {
        var components = this.getAllowComponents();
        each$1(components, function(component3) {
          _this.setStateByElement(component3, element, enable);
        });
      } else {
        var delegateObject = getDelegationObject(this.context);
        if (isList(delegateObject)) {
          var item = delegateObject.item, component2 = delegateObject.component;
          if (this.allowSetStateByElement(component2) && this.allowSetStateByItem(item, component2)) {
            this.setItemState(component2, item, enable);
          }
        }
      }
    };
    ListState2.prototype.setItemsState = function(list, name, enable) {
      var _this = this;
      var items = list.getItems();
      each$1(items, function(item) {
        if (item.name === name) {
          _this.setItemState(list, item, enable);
        }
      });
    };
    ListState2.prototype.setItemState = function(list, item, enable) {
      list.setItemState(item, this.stateName, enable);
    };
    ListState2.prototype.setState = function() {
      this.setStateEnable(true);
    };
    ListState2.prototype.reset = function() {
      this.setStateEnable(false);
    };
    ListState2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        var enable = this.hasState(list, item);
        this.setItemState(list, item, !enable);
      }
    };
    ListState2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        triggerInfo.list.clearItemsState(this.stateName);
      } else {
        this.clearAllComponentsState();
      }
    };
    return ListState2;
  }(Action)
);
var ListActive = (
  /** @class */
  function(_super) {
    __extends$1(ListActive2, _super);
    function ListActive2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "active";
      return _this;
    }
    ListActive2.prototype.active = function() {
      this.setState();
    };
    return ListActive2;
  }(ListState)
);
var STATUS_UNACTIVE$1 = "inactive";
var STATUS_ACTIVE$1 = "active";
function clearList(list) {
  var items = list.getItems();
  each$1(items, function(item) {
    if (list.hasState(item, STATUS_ACTIVE$1)) {
      list.setItemState(item, STATUS_ACTIVE$1, false);
    }
    if (list.hasState(item, STATUS_UNACTIVE$1)) {
      list.setItemState(item, STATUS_UNACTIVE$1, false);
    }
  });
}
var STATUS_UNACTIVE = "inactive";
var STATUS_ACTIVE = "active";
var ListHighlight = (
  /** @class */
  function(_super) {
    __extends$1(ListHighlight2, _super);
    function ListHighlight2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_ACTIVE;
      _this.ignoreItemStates = ["unchecked"];
      return _this;
    }
    ListHighlight2.prototype.setItemsState = function(list, name, enable) {
      this.setHighlightBy(list, function(item) {
        return item.name === name;
      }, enable);
    };
    ListHighlight2.prototype.setItemState = function(list, item, enable) {
      list.getItems();
      this.setHighlightBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListHighlight2.prototype.setHighlightBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each$1(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNACTIVE)) {
              list.setItemState(item, STATUS_UNACTIVE, false);
            }
            list.setItemState(item, STATUS_ACTIVE, true);
          } else if (!list.hasState(item, STATUS_ACTIVE)) {
            list.setItemState(item, STATUS_UNACTIVE, true);
          }
        });
      } else {
        var activeItems = list.getItemsByState(STATUS_ACTIVE);
        var allCancel_1 = true;
        each$1(activeItems, function(item) {
          if (!callback(item)) {
            allCancel_1 = false;
            return false;
          }
        });
        if (allCancel_1) {
          this.clear();
        } else {
          each$1(items, function(item) {
            if (callback(item)) {
              if (list.hasState(item, STATUS_ACTIVE)) {
                list.setItemState(item, STATUS_ACTIVE, false);
              }
              list.setItemState(item, STATUS_UNACTIVE, true);
            }
          });
        }
      }
    };
    ListHighlight2.prototype.highlight = function() {
      this.setState();
    };
    ListHighlight2.prototype.clear = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo) {
        clearList(triggerInfo.list);
      } else {
        var components = this.getAllowComponents();
        each$1(components, function(component2) {
          component2.clearItemsState(STATUS_ACTIVE);
          component2.clearItemsState(STATUS_UNACTIVE);
        });
      }
    };
    return ListHighlight2;
  }(ListState)
);
var ListSelected = (
  /** @class */
  function(_super) {
    __extends$1(ListSelected2, _super);
    function ListSelected2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "selected";
      return _this;
    }
    ListSelected2.prototype.selected = function() {
      this.setState();
    };
    return ListSelected2;
  }(ListState)
);
var ListUnchecked = (
  /** @class */
  function(_super) {
    __extends$1(ListUnchecked2, _super);
    function ListUnchecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = "unchecked";
      return _this;
    }
    ListUnchecked2.prototype.unchecked = function() {
      this.setState();
    };
    return ListUnchecked2;
  }(ListState)
);
var STATUS_UNCHECKED$1 = "unchecked";
var STATUS_CHECKED = "checked";
var ListChecked = (
  /** @class */
  function(_super) {
    __extends$1(ListChecked2, _super);
    function ListChecked2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.stateName = STATUS_CHECKED;
      return _this;
    }
    ListChecked2.prototype.setItemState = function(list, item, enable) {
      this.setCheckedBy(list, function(el) {
        return el === item;
      }, enable);
    };
    ListChecked2.prototype.setCheckedBy = function(list, callback, enable) {
      var items = list.getItems();
      if (enable) {
        each$1(items, function(item) {
          if (callback(item)) {
            if (list.hasState(item, STATUS_UNCHECKED$1)) {
              list.setItemState(item, STATUS_UNCHECKED$1, false);
            }
            list.setItemState(item, STATUS_CHECKED, true);
          } else if (!list.hasState(item, STATUS_CHECKED)) {
            list.setItemState(item, STATUS_UNCHECKED$1, true);
          }
        });
      }
    };
    ListChecked2.prototype.toggle = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo && triggerInfo.item) {
        var list_1 = triggerInfo.list, item = triggerInfo.item;
        var allChecked = !some(list_1.getItems(), function(t) {
          return list_1.hasState(t, STATUS_UNCHECKED$1);
        });
        if (allChecked || list_1.hasState(item, STATUS_UNCHECKED$1)) {
          this.setItemState(list_1, item, true);
        } else {
          this.reset();
        }
      }
    };
    ListChecked2.prototype.checked = function() {
      this.setState();
    };
    ListChecked2.prototype.reset = function() {
      var components = this.getAllowComponents();
      each$1(components, function(component2) {
        component2.clearItemsState(STATUS_CHECKED);
        component2.clearItemsState(STATUS_UNCHECKED$1);
      });
    };
    return ListChecked2;
  }(ListState)
);
var STATUS_UNCHECKED = "unchecked";
var ListFocus = (
  /** @class */
  function(_super) {
    __extends$1(ListFocus2, _super);
    function ListFocus2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ListFocus2.prototype.toggle = function() {
      var e_1, _a2, e_2, _b, e_3, _c, e_4, _d;
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
        var list_1 = triggerInfo.list, clickedItem = triggerInfo.item;
        var items = list_1.getItems();
        var checkedItems = items.filter(function(t) {
          return !list_1.hasState(t, STATUS_UNCHECKED);
        });
        var uncheckedItems = items.filter(function(t) {
          return list_1.hasState(t, STATUS_UNCHECKED);
        });
        var checkedItem = checkedItems[0];
        if (items.length === checkedItems.length) {
          try {
            for (var items_1 = __values(items), items_1_1 = items_1.next(); !items_1_1.done; items_1_1 = items_1.next()) {
              var item = items_1_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (items_1_1 && !items_1_1.done && (_a2 = items_1.return))
                _a2.call(items_1);
            } finally {
              if (e_1)
                throw e_1.error;
            }
          }
        } else if (items.length - uncheckedItems.length === 1) {
          if (checkedItem.id === clickedItem.id) {
            try {
              for (var items_2 = __values(items), items_2_1 = items_2.next(); !items_2_1.done; items_2_1 = items_2.next()) {
                var item = items_2_1.value;
                list_1.setItemState(item, STATUS_UNCHECKED, false);
              }
            } catch (e_2_1) {
              e_2 = { error: e_2_1 };
            } finally {
              try {
                if (items_2_1 && !items_2_1.done && (_b = items_2.return))
                  _b.call(items_2);
              } finally {
                if (e_2)
                  throw e_2.error;
              }
            }
          } else {
            try {
              for (var items_3 = __values(items), items_3_1 = items_3.next(); !items_3_1.done; items_3_1 = items_3.next()) {
                var item = items_3_1.value;
                list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
              }
            } catch (e_3_1) {
              e_3 = { error: e_3_1 };
            } finally {
              try {
                if (items_3_1 && !items_3_1.done && (_c = items_3.return))
                  _c.call(items_3);
              } finally {
                if (e_3)
                  throw e_3.error;
              }
            }
          }
        } else {
          try {
            for (var items_4 = __values(items), items_4_1 = items_4.next(); !items_4_1.done; items_4_1 = items_4.next()) {
              var item = items_4_1.value;
              list_1.setItemState(item, STATUS_UNCHECKED, item.id !== clickedItem.id);
            }
          } catch (e_4_1) {
            e_4 = { error: e_4_1 };
          } finally {
            try {
              if (items_4_1 && !items_4_1.done && (_d = items_4.return))
                _d.call(items_4);
            } finally {
              if (e_4)
                throw e_4.error;
            }
          }
        }
      }
    };
    return ListFocus2;
  }(ListState)
);
var STATUS_SHOW = "showRadio";
var TIP_ID = "legend-radio-tip";
var ListRadio = (
  /** @class */
  function(_super) {
    __extends$1(ListRadio2, _super);
    function ListRadio2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.timeStamp = 0;
      return _this;
    }
    ListRadio2.prototype.show = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        list.setItemState(item, STATUS_SHOW, true);
      }
    };
    ListRadio2.prototype.hide = function() {
      var triggerInfo = this.getTriggerListInfo();
      if (triggerInfo === null || triggerInfo === void 0 ? void 0 : triggerInfo.item) {
        var list = triggerInfo.list, item = triggerInfo.item;
        list.setItemState(item, STATUS_SHOW, false);
      }
    };
    ListRadio2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    ListRadio2.prototype.showTip = function() {
      var context = this.context;
      var ev = context.event;
      var lastTimeStamp = this.timeStamp;
      var timeStamp = +/* @__PURE__ */ new Date();
      var target2 = this.context.event.target;
      if (timeStamp - lastTimeStamp > 16 && target2.get("name") === "legend-item-radio") {
        var preLoc = this.location;
        var curLoc = { x: ev.x, y: ev.y };
        this.timeStamp = timeStamp;
        this.location = curLoc;
        if (!preLoc || !isEqual$1(preLoc, curLoc)) {
          this.showTooltip(curLoc);
        }
      }
    };
    ListRadio2.prototype.hideTip = function() {
      this.hideTooltip();
      this.location = null;
    };
    ListRadio2.prototype.showTooltip = function(curLoc) {
      var context = this.context;
      var ev = context.event;
      var target2 = ev.target;
      if (target2 && target2.get("tip")) {
        if (!this.tooltip) {
          this.renderTooltip();
        }
        var _a2 = context.view.getCanvas().get("el").getBoundingClientRect(), offsetX = _a2.x, offsetY = _a2.y;
        this.tooltip.update(__assign$1(__assign$1({ title: target2.get("tip") }, curLoc), { x: curLoc.x + offsetX, y: curLoc.y + offsetY }));
        this.tooltip.show();
      }
    };
    ListRadio2.prototype.hideTooltip = function() {
      this.tooltip && this.tooltip.hide();
    };
    ListRadio2.prototype.renderTooltip = function() {
      var _a2;
      var tooltipStyles = (_a2 = {}, _a2[CONTAINER_CLASS] = {
        padding: "6px 8px",
        transform: "translate(-50%, -80%)",
        background: "rgba(0,0,0,0.75)",
        color: "#fff",
        "border-radius": "2px",
        // 
        "z-index": 100
      }, _a2[TITLE_CLASS] = {
        "font-size": "12px",
        "line-height": "14px",
        "margin-bottom": 0,
        "word-break": "break-all"
      }, _a2);
      if (document.getElementById(TIP_ID)) {
        document.body.removeChild(document.getElementById(TIP_ID));
      }
      var tooltip2 = new HtmlTooltip({
        parent: document.body,
        // tooltip 
        region: null,
        visible: false,
        crosshairs: null,
        domStyles: tooltipStyles,
        containerId: TIP_ID
      });
      tooltip2.init();
      tooltip2.setCapture(false);
      this.tooltip = tooltip2;
    };
    return ListRadio2;
  }(ListState)
);
var MaskBase = (
  /** @class */
  function(_super) {
    __extends$1(MaskBase2, _super);
    function MaskBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.maskShape = null;
      _this.points = [];
      _this.starting = false;
      _this.moving = false;
      _this.preMovePoint = null;
      _this.shapeType = "path";
      return _this;
    }
    MaskBase2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    MaskBase2.prototype.emitEvent = function(type) {
      var eventName = "mask:".concat(type);
      var view = this.context.view;
      var event = this.context.event;
      view.emit(eventName, {
        target: this.maskShape,
        shape: this.maskShape,
        points: this.points,
        x: event.x,
        y: event.y
      });
    };
    MaskBase2.prototype.createMask = function() {
      var view = this.context.view;
      var maskAttrs = this.getMaskAttrs();
      var maskShape = view.foregroundGroup.addShape({
        type: this.shapeType,
        name: "mask",
        draggable: true,
        attrs: __assign$1({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
      });
      return maskShape;
    };
    MaskBase2.prototype.getMaskPath = function() {
      return [];
    };
    MaskBase2.prototype.show = function() {
      if (this.maskShape) {
        this.maskShape.show();
        this.emitEvent("show");
      }
    };
    MaskBase2.prototype.start = function(arg) {
      this.starting = true;
      this.moving = false;
      this.points = [this.getCurrentPoint()];
      if (!this.maskShape) {
        this.maskShape = this.createMask();
        this.maskShape.set("capture", false);
      }
      this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
      this.emitEvent("start");
    };
    MaskBase2.prototype.moveStart = function() {
      this.moving = true;
      this.preMovePoint = this.getCurrentPoint();
    };
    MaskBase2.prototype.move = function() {
      if (!this.moving || !this.maskShape) {
        return;
      }
      var currentPoint = this.getCurrentPoint();
      var preMovePoint = this.preMovePoint;
      var dx = currentPoint.x - preMovePoint.x;
      var dy = currentPoint.y - preMovePoint.y;
      var points2 = this.points;
      each$1(points2, function(point2) {
        point2.x += dx;
        point2.y += dy;
      });
      this.updateMask();
      this.emitEvent("change");
      this.preMovePoint = currentPoint;
    };
    MaskBase2.prototype.updateMask = function(maskStyle) {
      var attrs = deepMix({}, this.getMaskAttrs(), maskStyle);
      this.maskShape.attr(attrs);
    };
    MaskBase2.prototype.moveEnd = function() {
      this.moving = false;
      this.preMovePoint = null;
    };
    MaskBase2.prototype.end = function() {
      this.starting = false;
      this.emitEvent("end");
      if (this.maskShape) {
        this.maskShape.set("capture", true);
      }
    };
    MaskBase2.prototype.hide = function() {
      if (this.maskShape) {
        this.maskShape.hide();
        this.emitEvent("hide");
      }
    };
    MaskBase2.prototype.resize = function() {
      if (this.starting && this.maskShape) {
        this.points.push(this.getCurrentPoint());
        this.updateMask();
        this.emitEvent("change");
      }
    };
    MaskBase2.prototype.destroy = function() {
      this.points = [];
      if (this.maskShape) {
        this.maskShape.remove();
      }
      this.maskShape = null;
      this.preMovePoint = null;
      _super.prototype.destroy.call(this);
    };
    return MaskBase2;
  }(Action)
);
function getMaskAttrs$3(points2) {
  var currentPoint = last(points2);
  var r = 0;
  var x = 0;
  var y = 0;
  if (points2.length) {
    var first = points2[0];
    r = distance$2(first, currentPoint) / 2;
    x = (currentPoint.x + first.x) / 2;
    y = (currentPoint.y + first.y) / 2;
  }
  return {
    x,
    y,
    r
  };
}
var CircleMask = (
  /** @class */
  function(_super) {
    __extends$1(CircleMask2, _super);
    function CircleMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "circle";
      return _this;
    }
    CircleMask2.prototype.getMaskAttrs = function() {
      return getMaskAttrs$3(this.points);
    };
    return CircleMask2;
  }(MaskBase)
);
function getRegion$1(points2) {
  return {
    start: head(points2),
    end: last(points2)
  };
}
function getMaskAttrs$2(start, end) {
  var x = Math.min(start.x, end.x);
  var y = Math.min(start.y, end.y);
  var width = Math.abs(end.x - start.x);
  var height = Math.abs(end.y - start.y);
  return {
    x,
    y,
    width,
    height
  };
}
var RectMask = (
  /** @class */
  function(_super) {
    __extends$1(RectMask2, _super);
    function RectMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "rect";
      return _this;
    }
    RectMask2.prototype.getRegion = function() {
      return getRegion$1(this.points);
    };
    RectMask2.prototype.getMaskAttrs = function() {
      var _a2 = this.getRegion(), start = _a2.start, end = _a2.end;
      return getMaskAttrs$2(start, end);
    };
    return RectMask2;
  }(MaskBase)
);
function clampPoint(point2) {
  point2.x = clamp(point2.x, 0, 1);
  point2.y = clamp(point2.y, 0, 1);
}
function getRegion(points2, dim, inPlot, coord2) {
  var start = null;
  var end = null;
  var normalStart = coord2.invert(head(points2));
  var normalEnd = coord2.invert(last(points2));
  if (inPlot) {
    clampPoint(normalStart);
    clampPoint(normalEnd);
  }
  if (dim === "x") {
    start = coord2.convert({
      x: normalStart.x,
      y: 0
    });
    end = coord2.convert({
      x: normalEnd.x,
      y: 1
    });
  } else {
    start = coord2.convert({
      x: 0,
      y: normalStart.y
    });
    end = coord2.convert({
      x: 1,
      y: normalEnd.y
    });
  }
  return {
    start,
    end
  };
}
var DimRect = (
  /** @class */
  function(_super) {
    __extends$1(DimRect2, _super);
    function DimRect2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dim = "x";
      _this.inPlot = true;
      return _this;
    }
    DimRect2.prototype.getRegion = function() {
      var coord2 = this.context.view.getCoordinate();
      return getRegion(this.points, this.dim, this.inPlot, coord2);
    };
    return DimRect2;
  }(RectMask)
);
function getMaskPath$1(points2) {
  var path2 = [];
  if (points2.length) {
    each$1(points2, function(point2, index2) {
      if (index2 === 0) {
        path2.push(["M", point2.x, point2.y]);
      } else {
        path2.push(["L", point2.x, point2.y]);
      }
    });
    path2.push(["L", points2[0].x, points2[0].y]);
  }
  return path2;
}
function getMaskAttrs$1(points2) {
  return {
    path: getMaskPath$1(points2)
  };
}
var PathMask = (
  /** @class */
  function(_super) {
    __extends$1(PathMask2, _super);
    function PathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PathMask2.prototype.getMaskPath = function() {
      return getMaskPath$1(this.points);
    };
    PathMask2.prototype.getMaskAttrs = function() {
      return getMaskAttrs$1(this.points);
    };
    PathMask2.prototype.addPoint = function() {
      this.resize();
    };
    return PathMask2;
  }(MaskBase)
);
function getMaskPath(points2) {
  return getSpline(points2, true);
}
function getMaskAttrs(points2) {
  return {
    path: getMaskPath(points2)
  };
}
var SmoothPathMask = (
  /** @class */
  function(_super) {
    __extends$1(SmoothPathMask2, _super);
    function SmoothPathMask2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SmoothPathMask2.prototype.getMaskPath = function() {
      return getMaskPath(this.points);
    };
    SmoothPathMask2.prototype.getMaskAttrs = function() {
      return getMaskAttrs(this.points);
    };
    return SmoothPathMask2;
  }(PathMask)
);
var MultipleMaskBase = (
  /** @class */
  function(_super) {
    __extends$1(MultipleMaskBase2, _super);
    function MultipleMaskBase2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.maskShapes = [];
      _this.starting = false;
      _this.moving = false;
      _this.recordPoints = null;
      _this.preMovePoint = null;
      _this.shapeType = "path";
      _this.maskType = "multi-mask";
      return _this;
    }
    MultipleMaskBase2.prototype.getCurrentPoint = function() {
      var event = this.context.event;
      return {
        x: event.x,
        y: event.y
      };
    };
    MultipleMaskBase2.prototype.emitEvent = function(type) {
      var eventName = "".concat(this.maskType, ":").concat(type);
      var view = this.context.view;
      var event = this.context.event;
      var target2 = {
        type: this.shapeType,
        name: this.maskType,
        get: function(key) {
          return target2.hasOwnProperty(key) ? target2[key] : void 0;
        }
      };
      view.emit(eventName, {
        target: target2,
        maskShapes: this.maskShapes,
        multiPoints: this.recordPoints,
        x: event.x,
        y: event.y
      });
    };
    MultipleMaskBase2.prototype.createMask = function(index2) {
      var view = this.context.view;
      var points2 = this.recordPoints[index2];
      var maskAttrs = this.getMaskAttrs(points2);
      var maskShape = view.foregroundGroup.addShape({
        type: this.shapeType,
        name: "mask",
        draggable: true,
        attrs: __assign$1({ fill: "#C5D4EB", opacity: 0.3 }, maskAttrs)
      });
      this.maskShapes.push(maskShape);
    };
    MultipleMaskBase2.prototype.getMaskPath = function(points2) {
      return [];
    };
    MultipleMaskBase2.prototype.show = function() {
      if (this.maskShapes.length > 0) {
        this.maskShapes.forEach(function(maskShape) {
          return maskShape.show();
        });
        this.emitEvent("show");
      }
    };
    MultipleMaskBase2.prototype.start = function(arg) {
      this.recordPointStart();
      this.starting = true;
      this.moving = false;
      var index2 = this.recordPoints.length - 1;
      this.createMask(index2);
      this.updateShapesCapture(false);
      this.updateMask(arg === null || arg === void 0 ? void 0 : arg.maskStyle);
      this.emitEvent("start");
    };
    MultipleMaskBase2.prototype.moveStart = function() {
      this.moving = true;
      this.preMovePoint = this.getCurrentPoint();
      this.updateShapesCapture(false);
    };
    MultipleMaskBase2.prototype.move = function() {
      if (!this.moving || this.maskShapes.length === 0) {
        return;
      }
      var currentPoint = this.getCurrentPoint();
      var preMovePoint = this.preMovePoint;
      var dx = currentPoint.x - preMovePoint.x;
      var dy = currentPoint.y - preMovePoint.y;
      var index2 = this.getCurMaskShapeIndex();
      if (index2 > -1) {
        this.recordPoints[index2].forEach(function(point2) {
          point2.x += dx;
          point2.y += dy;
        });
        this.updateMask();
        this.emitEvent("change");
        this.preMovePoint = currentPoint;
      }
    };
    MultipleMaskBase2.prototype.updateMask = function(maskStyle) {
      var _this = this;
      this.recordPoints.forEach(function(points2, index2) {
        var attrs = deepMix({}, _this.getMaskAttrs(points2), maskStyle);
        _this.maskShapes[index2].attr(attrs);
      });
    };
    MultipleMaskBase2.prototype.resize = function() {
      if (this.starting && this.maskShapes.length > 0) {
        this.recordPointContinue();
        this.updateMask();
        this.emitEvent("change");
      }
    };
    MultipleMaskBase2.prototype.moveEnd = function() {
      this.moving = false;
      this.preMovePoint = null;
      this.updateShapesCapture(true);
    };
    MultipleMaskBase2.prototype.end = function() {
      this.starting = false;
      this.emitEvent("end");
      this.updateShapesCapture(true);
    };
    MultipleMaskBase2.prototype.hide = function() {
      if (this.maskShapes.length > 0) {
        this.maskShapes.forEach(function(maskShape) {
          return maskShape.hide();
        });
        this.emitEvent("hide");
      }
    };
    MultipleMaskBase2.prototype.remove = function() {
      var index2 = this.getCurMaskShapeIndex();
      if (index2 > -1) {
        this.recordPoints.splice(index2, 1);
        this.maskShapes[index2].remove();
        this.maskShapes.splice(index2, 1);
        this.preMovePoint = null;
        this.updateShapesCapture(true);
        this.emitEvent("change");
      }
    };
    MultipleMaskBase2.prototype.clearAll = function() {
      this.recordPointClear();
      this.maskShapes.forEach(function(maskShape) {
        return maskShape.remove();
      });
      this.maskShapes = [];
      this.preMovePoint = null;
    };
    MultipleMaskBase2.prototype.clear = function() {
      var index2 = this.getCurMaskShapeIndex();
      if (index2 === -1) {
        this.recordPointClear();
        this.maskShapes.forEach(function(maskShape) {
          return maskShape.remove();
        });
        this.maskShapes = [];
        this.emitEvent("clearAll");
      } else {
        this.recordPoints.splice(index2, 1);
        this.maskShapes[index2].remove();
        this.maskShapes.splice(index2, 1);
        this.preMovePoint = null;
        this.emitEvent("clearSingle");
      }
      this.preMovePoint = null;
    };
    MultipleMaskBase2.prototype.destroy = function() {
      this.clear();
      _super.prototype.destroy.call(this);
    };
    MultipleMaskBase2.prototype.getRecordPoints = function() {
      var _a2;
      return __spreadArray$1([], __read((_a2 = this.recordPoints) !== null && _a2 !== void 0 ? _a2 : []), false);
    };
    MultipleMaskBase2.prototype.recordPointStart = function() {
      var recordPoints = this.getRecordPoints();
      var currentPoint = this.getCurrentPoint();
      this.recordPoints = __spreadArray$1(__spreadArray$1([], __read(recordPoints), false), [[currentPoint]], false);
    };
    MultipleMaskBase2.prototype.recordPointContinue = function() {
      var recordPoints = this.getRecordPoints();
      var currentPoint = this.getCurrentPoint();
      var lastPoints = recordPoints.splice(-1, 1)[0] || [];
      lastPoints.push(currentPoint);
      this.recordPoints = __spreadArray$1(__spreadArray$1([], __read(recordPoints), false), [lastPoints], false);
    };
    MultipleMaskBase2.prototype.recordPointClear = function() {
      this.recordPoints = [];
    };
    MultipleMaskBase2.prototype.updateShapesCapture = function(isCapture) {
      this.maskShapes.forEach(function(maskShape) {
        return maskShape.set("capture", isCapture);
      });
    };
    MultipleMaskBase2.prototype.getCurMaskShapeIndex = function() {
      var currentPoint = this.getCurrentPoint();
      return this.maskShapes.findIndex(function(maskShape) {
        var _a2 = maskShape.attrs, width = _a2.width, height = _a2.height, r = _a2.r;
        var isEmpty2 = width === 0 || height === 0 || r === 0;
        return !isEmpty2 && maskShape.isHit(currentPoint.x, currentPoint.y);
      });
    };
    return MultipleMaskBase2;
  }(Action)
);
var RectMultiMask = (
  /** @class */
  function(_super) {
    __extends$1(RectMultiMask2, _super);
    function RectMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "rect";
      return _this;
    }
    RectMultiMask2.prototype.getRegion = function(points2) {
      return getRegion$1(points2);
    };
    RectMultiMask2.prototype.getMaskAttrs = function(points2) {
      var _a2 = this.getRegion(points2), start = _a2.start, end = _a2.end;
      return getMaskAttrs$2(start, end);
    };
    return RectMultiMask2;
  }(MultipleMaskBase)
);
var DimRectMultiMask = (
  /** @class */
  function(_super) {
    __extends$1(DimRectMultiMask2, _super);
    function DimRectMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dim = "x";
      _this.inPlot = true;
      return _this;
    }
    DimRectMultiMask2.prototype.getRegion = function(points2) {
      var coord2 = this.context.view.getCoordinate();
      return getRegion(points2, this.dim, this.inPlot, coord2);
    };
    return DimRectMultiMask2;
  }(RectMultiMask)
);
var CircleMultiMask = (
  /** @class */
  function(_super) {
    __extends$1(CircleMultiMask2, _super);
    function CircleMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.shapeType = "circle";
      _this.getMaskAttrs = getMaskAttrs$3;
      return _this;
    }
    return CircleMultiMask2;
  }(MultipleMaskBase)
);
var PathMultiMask = (
  /** @class */
  function(_super) {
    __extends$1(PathMultiMask2, _super);
    function PathMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.getMaskPath = getMaskPath$1;
      _this.getMaskAttrs = getMaskAttrs$1;
      return _this;
    }
    PathMultiMask2.prototype.addPoint = function() {
      this.resize();
    };
    return PathMultiMask2;
  }(MultipleMaskBase)
);
var SmoothPathMultiMask = (
  /** @class */
  function(_super) {
    __extends$1(SmoothPathMultiMask2, _super);
    function SmoothPathMultiMask2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.getMaskPath = getMaskPath;
      _this.getMaskAttrs = getMaskAttrs;
      return _this;
    }
    return SmoothPathMultiMask2;
  }(PathMultiMask)
);
var CursorAction = (
  /** @class */
  function(_super) {
    __extends$1(CursorAction2, _super);
    function CursorAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    CursorAction2.prototype.setCursor = function(cursor) {
      var view = this.context.view;
      view.getCanvas().setCursor(cursor);
    };
    CursorAction2.prototype.default = function() {
      this.setCursor("default");
    };
    CursorAction2.prototype.pointer = function() {
      this.setCursor("pointer");
    };
    CursorAction2.prototype.move = function() {
      this.setCursor("move");
    };
    CursorAction2.prototype.crosshair = function() {
      this.setCursor("crosshair");
    };
    CursorAction2.prototype.wait = function() {
      this.setCursor("wait");
    };
    CursorAction2.prototype.help = function() {
      this.setCursor("help");
    };
    CursorAction2.prototype.text = function() {
      this.setCursor("text");
    };
    CursorAction2.prototype.eResize = function() {
      this.setCursor("e-resize");
    };
    CursorAction2.prototype.wResize = function() {
      this.setCursor("w-resize");
    };
    CursorAction2.prototype.nResize = function() {
      this.setCursor("n-resize");
    };
    CursorAction2.prototype.sResize = function() {
      this.setCursor("s-resize");
    };
    CursorAction2.prototype.neResize = function() {
      this.setCursor("ne-resize");
    };
    CursorAction2.prototype.nwResize = function() {
      this.setCursor("nw-resize");
    };
    CursorAction2.prototype.seResize = function() {
      this.setCursor("se-resize");
    };
    CursorAction2.prototype.swResize = function() {
      this.setCursor("sw-resize");
    };
    CursorAction2.prototype.nsResize = function() {
      this.setCursor("ns-resize");
    };
    CursorAction2.prototype.ewResize = function() {
      this.setCursor("ew-resize");
    };
    CursorAction2.prototype.zoomIn = function() {
      this.setCursor("zoom-in");
    };
    CursorAction2.prototype.zoomOut = function() {
      this.setCursor("zoom-out");
    };
    return CursorAction2;
  }(Action)
);
var DataFilter = (
  /** @class */
  function(_super) {
    __extends$1(DataFilter2, _super);
    function DataFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    DataFilter2.prototype.filterView = function(view, field2, filter2) {
      var _this = this;
      if (view.getScaleByField(field2)) {
        view.filter(field2, filter2);
      }
      if (view.views && view.views.length) {
        each$1(view.views, function(subView) {
          _this.filterView(subView, field2, filter2);
        });
      }
    };
    DataFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      if (delegateObject) {
        var view = this.context.view;
        var component2 = delegateObject.component;
        var field2 = component2.get("field");
        if (isList(delegateObject)) {
          if (field2) {
            var unCheckedItems = component2.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field2);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            if (names_1.length) {
              this.filterView(view, field2, function(value2) {
                var text2 = scale_1.getText(value2);
                return !names_1.includes(text2);
              });
            } else {
              this.filterView(view, field2, null);
            }
            view.render(true);
          }
        } else if (isSlider(delegateObject)) {
          var range = component2.getValue();
          var _a2 = __read(range, 2), min_1 = _a2[0], max_1 = _a2[1];
          this.filterView(view, field2, function(value2) {
            return value2 >= min_1 && value2 <= max_1;
          });
          view.render(true);
        }
      }
    };
    return DataFilter2;
  }(Action)
);
function getFilter(scale2, dim, point1, point2) {
  var min2 = Math.min(point1[dim], point2[dim]);
  var max2 = Math.max(point1[dim], point2[dim]);
  var _a2 = __read(scale2.range, 2), rangeMin = _a2[0], rangeMax = _a2[1];
  if (min2 < rangeMin) {
    min2 = rangeMin;
  }
  if (max2 > rangeMax) {
    max2 = rangeMax;
  }
  if (min2 === rangeMax && max2 === rangeMax) {
    return null;
  }
  var minValue = scale2.invert(min2);
  var maxValue = scale2.invert(max2);
  if (scale2.isCategory) {
    var minIndex = scale2.values.indexOf(minValue);
    var maxIndex = scale2.values.indexOf(maxValue);
    var arr_1 = scale2.values.slice(minIndex, maxIndex + 1);
    return function(value2) {
      return arr_1.includes(value2);
    };
  } else {
    return function(value2) {
      return value2 >= minValue && value2 <= maxValue;
    };
  }
}
var EVENTS;
(function(EVENTS2) {
  EVENTS2["FILTER"] = "brush-filter-processing";
  EVENTS2["RESET"] = "brush-filter-reset";
  EVENTS2["BEFORE_FILTER"] = "brush-filter:beforefilter";
  EVENTS2["AFTER_FILTER"] = "brush-filter:afterfilter";
  EVENTS2["BEFORE_RESET"] = "brush-filter:beforereset";
  EVENTS2["AFTER_RESET"] = "brush-filter:afterreset";
})(EVENTS || (EVENTS = {}));
var RangeFilter = (
  /** @class */
  function(_super) {
    __extends$1(RangeFilter2, _super);
    function RangeFilter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = ["x", "y"];
      _this.startPoint = null;
      _this.isStarted = false;
      return _this;
    }
    RangeFilter2.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    RangeFilter2.prototype.start = function() {
      var context = this.context;
      this.isStarted = true;
      this.startPoint = context.getCurrentPoint();
    };
    RangeFilter2.prototype.filter = function() {
      var startPoint;
      var currentPoint;
      if (isMask(this.context)) {
        var maskShape = this.context.event.target;
        var bbox = maskShape.getCanvasBBox();
        startPoint = { x: bbox.x, y: bbox.y };
        currentPoint = { x: bbox.maxX, y: bbox.maxY };
      } else {
        if (!this.isStarted) {
          return;
        }
        startPoint = this.startPoint;
        currentPoint = this.context.getCurrentPoint();
      }
      if (Math.abs(startPoint.x - currentPoint.x) < 5 || Math.abs(startPoint.x - currentPoint.y) < 5) {
        return;
      }
      var _a2 = this.context, view = _a2.view, event = _a2.event;
      var payload = { view, event, dims: this.dims };
      view.emit(EVENTS.BEFORE_FILTER, Event.fromData(view, EVENTS.BEFORE_FILTER, payload));
      var coord2 = view.getCoordinate();
      var normalCurrent = coord2.invert(currentPoint);
      var normalStart = coord2.invert(startPoint);
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        var filter2 = getFilter(xScale, "x", normalCurrent, normalStart);
        this.filterView(view, xScale.field, filter2);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        var filter2 = getFilter(yScale, "y", normalCurrent, normalStart);
        this.filterView(view, yScale.field, filter2);
      }
      this.reRender(view, { source: EVENTS.FILTER });
      view.emit(EVENTS.AFTER_FILTER, Event.fromData(view, EVENTS.AFTER_FILTER, payload));
    };
    RangeFilter2.prototype.end = function() {
      this.isStarted = false;
    };
    RangeFilter2.prototype.reset = function() {
      var view = this.context.view;
      view.emit(EVENTS.BEFORE_RESET, Event.fromData(view, EVENTS.BEFORE_RESET, {}));
      this.isStarted = false;
      if (this.hasDim("x")) {
        var xScale = view.getXScale();
        this.filterView(view, xScale.field, null);
      }
      if (this.hasDim("y")) {
        var yScale = view.getYScales()[0];
        this.filterView(view, yScale.field, null);
      }
      this.reRender(view, { source: EVENTS.RESET });
      view.emit(EVENTS.AFTER_RESET, Event.fromData(view, EVENTS.AFTER_RESET, {}));
    };
    RangeFilter2.prototype.filterView = function(view, field2, filter2) {
      view.filter(field2, filter2);
    };
    RangeFilter2.prototype.reRender = function(view, payload) {
      view.render(true, payload);
    };
    return RangeFilter2;
  }(Action)
);
var SiblingFilter$1 = (
  /** @class */
  function(_super) {
    __extends$1(SiblingFilter2, _super);
    function SiblingFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    SiblingFilter2.prototype.filterView = function(view, field2, filter2) {
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        sibling.filter(field2, filter2);
      });
    };
    SiblingFilter2.prototype.reRender = function(view) {
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        sibling.render(true);
      });
    };
    return SiblingFilter2;
  }(RangeFilter)
);
var ElementFilter = (
  /** @class */
  function(_super) {
    __extends$1(ElementFilter2, _super);
    function ElementFilter2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ElementFilter2.prototype.filter = function() {
      var delegateObject = getDelegationObject(this.context);
      var view = this.context.view;
      var elements = getElements(view);
      if (isMask(this.context)) {
        var maskElements_1 = getMaskedElements(this.context, 10);
        if (maskElements_1) {
          each$1(elements, function(el) {
            if (maskElements_1.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      } else if (delegateObject) {
        var component2 = delegateObject.component;
        var field_1 = component2.get("field");
        if (isList(delegateObject)) {
          if (field_1) {
            var unCheckedItems = component2.getItemsByState("unchecked");
            var scale_1 = getScaleByField(view, field_1);
            var names_1 = unCheckedItems.map(function(item) {
              return item.name;
            });
            each$1(elements, function(el) {
              var value2 = getElementValue$1(el, field_1);
              var text2 = scale_1.getText(value2);
              if (names_1.indexOf(text2) >= 0) {
                el.hide();
              } else {
                el.show();
              }
            });
          }
        } else if (isSlider(delegateObject)) {
          var range = component2.getValue();
          var _a2 = __read(range, 2), min_1 = _a2[0], max_1 = _a2[1];
          each$1(elements, function(el) {
            var value2 = getElementValue$1(el, field_1);
            if (value2 >= min_1 && value2 <= max_1) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      }
    };
    ElementFilter2.prototype.clear = function() {
      var elements = getElements(this.context.view);
      each$1(elements, function(el) {
        el.show();
      });
    };
    ElementFilter2.prototype.reset = function() {
      this.clear();
    };
    return ElementFilter2;
  }(Action)
);
var SiblingFilter = (
  /** @class */
  function(_super) {
    __extends$1(SiblingFilter2, _super);
    function SiblingFilter2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.byRecord = false;
      return _this;
    }
    SiblingFilter2.prototype.filter = function() {
      if (isMask(this.context)) {
        if (this.byRecord) {
          this.filterByRecord();
        } else {
          this.filterByBBox();
        }
      }
    };
    SiblingFilter2.prototype.filterByRecord = function() {
      var view = this.context.view;
      var maskElements = getMaskedElements(this.context, 10);
      if (!maskElements) {
        return;
      }
      var xFiled = view.getXScale().field;
      var yField = view.getYScales()[0].field;
      var records = maskElements.map(function(el) {
        return el.getModel().data;
      });
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        var elements = getElements(sibling);
        each$1(elements, function(el) {
          var record = el.getModel().data;
          if (isInRecords(records, record, xFiled, yField)) {
            el.show();
          } else {
            el.hide();
          }
        });
      });
    };
    SiblingFilter2.prototype.filterByBBox = function() {
      var _this = this;
      var view = this.context.view;
      var siblings2 = getSilbings(view);
      each$1(siblings2, function(sibling) {
        var maskElements = getSiblingMaskElements(_this.context, sibling, 10);
        var elements = getElements(sibling);
        if (maskElements) {
          each$1(elements, function(el) {
            if (maskElements.includes(el)) {
              el.show();
            } else {
              el.hide();
            }
          });
        }
      });
    };
    SiblingFilter2.prototype.reset = function() {
      var siblings2 = getSilbings(this.context.view);
      each$1(siblings2, function(sibling) {
        var elements = getElements(sibling);
        each$1(elements, function(el) {
          el.show();
        });
      });
    };
    return SiblingFilter2;
  }(Action)
);
var PADDING_RIGHT$1 = 10;
var PADDING_TOP$2 = 5;
var ButtonAction$1 = (
  /** @class */
  function(_super) {
    __extends$1(ButtonAction2, _super);
    function ButtonAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonGroup = null;
      _this.buttonCfg = {
        name: "button",
        text: "button",
        textStyle: {
          x: 0,
          y: 0,
          fontSize: 12,
          fill: "#333333",
          cursor: "pointer"
        },
        padding: [8, 10],
        style: {
          fill: "#f7f7f7",
          stroke: "#cccccc",
          cursor: "pointer"
        },
        activeStyle: {
          fill: "#e6e6e6"
        }
      };
      return _this;
    }
    ButtonAction2.prototype.getButtonCfg = function() {
      return deepMix(this.buttonCfg, this.cfg);
    };
    ButtonAction2.prototype.drawButton = function() {
      var config = this.getButtonCfg();
      var group2 = this.context.view.foregroundGroup.addGroup({
        name: config.name
      });
      var textShape = group2.addShape({
        type: "text",
        name: "button-text",
        attrs: __assign$1({ text: config.text }, config.textStyle)
      });
      var textBBox = textShape.getBBox();
      var padding2 = parsePadding(config.padding);
      var buttonShape = group2.addShape({
        type: "rect",
        name: "button-rect",
        attrs: __assign$1({ x: textBBox.x - padding2[3], y: textBBox.y - padding2[0], width: textBBox.width + padding2[1] + padding2[3], height: textBBox.height + padding2[0] + padding2[2] }, config.style)
      });
      buttonShape.toBack();
      group2.on("mouseenter", function() {
        buttonShape.attr(config.activeStyle);
      });
      group2.on("mouseleave", function() {
        buttonShape.attr(config.style);
      });
      this.buttonGroup = group2;
    };
    ButtonAction2.prototype.resetPosition = function() {
      var view = this.context.view;
      var coord2 = view.getCoordinate();
      var point2 = coord2.convert({ x: 1, y: 1 });
      var buttonGroup = this.buttonGroup;
      var bbox = buttonGroup.getBBox();
      var matrix = transform$6(null, [
        ["t", point2.x - bbox.width - PADDING_RIGHT$1, point2.y + bbox.height + PADDING_TOP$2]
      ]);
      buttonGroup.setMatrix(matrix);
    };
    ButtonAction2.prototype.show = function() {
      if (!this.buttonGroup) {
        this.drawButton();
      }
      this.resetPosition();
      this.buttonGroup.show();
    };
    ButtonAction2.prototype.hide = function() {
      if (this.buttonGroup) {
        this.buttonGroup.hide();
      }
    };
    ButtonAction2.prototype.destroy = function() {
      var buttonGroup = this.buttonGroup;
      if (buttonGroup) {
        buttonGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return ButtonAction2;
  }(Action)
);
var DISTANCE = 4;
var Drag = (
  /** @class */
  function(_super) {
    __extends$1(Drag2, _super);
    function Drag2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.dragStart = false;
      return _this;
    }
    Drag2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
    };
    Drag2.prototype.drag = function() {
      if (!this.startPoint) {
        return;
      }
      var current = this.context.getCurrentPoint();
      var view = this.context.view;
      var event = this.context.event;
      if (!this.dragStart) {
        if (distance$2(current, this.startPoint) > DISTANCE) {
          view.emit("dragstart", {
            target: event.target,
            x: event.x,
            y: event.y
          });
          this.dragStart = true;
        }
      } else {
        view.emit("drag", {
          target: event.target,
          x: event.x,
          y: event.y
        });
      }
    };
    Drag2.prototype.end = function() {
      if (this.dragStart) {
        var view = this.context.view;
        var event_1 = this.context.event;
        view.emit("dragend", {
          target: event_1.target,
          x: event_1.x,
          y: event_1.y
        });
      }
      this.starting = false;
      this.dragStart = false;
    };
    return Drag2;
  }(Action)
);
var MIN_DISTANCE = 5;
var Move = (
  /** @class */
  function(_super) {
    __extends$1(Move2, _super);
    function Move2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.starting = false;
      _this.isMoving = false;
      _this.startPoint = null;
      _this.startMatrix = null;
      return _this;
    }
    Move2.prototype.start = function() {
      this.starting = true;
      this.startPoint = this.context.getCurrentPoint();
      this.startMatrix = this.context.view.middleGroup.getMatrix();
    };
    Move2.prototype.move = function() {
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var currentPoint = this.context.getCurrentPoint();
      var d = distance$2(startPoint, currentPoint);
      if (d > MIN_DISTANCE && !this.isMoving) {
        this.isMoving = true;
      }
      if (this.isMoving) {
        var view = this.context.view;
        var matrix = transform$6(this.startMatrix, [
          ["t", currentPoint.x - startPoint.x, currentPoint.y - startPoint.y]
        ]);
        view.backgroundGroup.setMatrix(matrix);
        view.foregroundGroup.setMatrix(matrix);
        view.middleGroup.setMatrix(matrix);
      }
    };
    Move2.prototype.end = function() {
      if (this.isMoving) {
        this.isMoving = false;
      }
      this.startMatrix = null;
      this.starting = false;
      this.startPoint = null;
    };
    Move2.prototype.reset = function() {
      this.starting = false;
      this.startPoint = null;
      this.isMoving = false;
      var view = this.context.view;
      view.backgroundGroup.resetMatrix();
      view.foregroundGroup.resetMatrix();
      view.middleGroup.resetMatrix();
      this.isMoving = false;
    };
    return Move2;
  }(Action)
);
var DIM_X = "x";
var DIM_Y = "y";
var ScaleTranslate$2 = (
  /** @class */
  function(_super) {
    __extends$1(ScaleTranslate2, _super);
    function ScaleTranslate2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.dims = [DIM_X, DIM_Y];
      _this.cfgFields = ["dims"];
      _this.cacheScaleDefs = {};
      return _this;
    }
    ScaleTranslate2.prototype.hasDim = function(dim) {
      return this.dims.includes(dim);
    };
    ScaleTranslate2.prototype.getScale = function(dim) {
      var view = this.context.view;
      if (dim === "x") {
        return view.getXScale();
      } else {
        return view.getYScales()[0];
      }
    };
    ScaleTranslate2.prototype.resetDim = function(dim) {
      var view = this.context.view;
      if (this.hasDim(dim) && this.cacheScaleDefs[dim]) {
        var scale2 = this.getScale(dim);
        view.scale(scale2.field, this.cacheScaleDefs[dim]);
        this.cacheScaleDefs[dim] = null;
      }
    };
    ScaleTranslate2.prototype.reset = function() {
      this.resetDim(DIM_X);
      this.resetDim(DIM_Y);
      var view = this.context.view;
      view.render(true);
    };
    return ScaleTranslate2;
  }(Action)
);
var ScaleTranslate$1 = (
  /** @class */
  function(_super) {
    __extends$1(ScaleTranslate2, _super);
    function ScaleTranslate2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.startPoint = null;
      _this.starting = false;
      _this.startCache = {};
      return _this;
    }
    ScaleTranslate2.prototype.start = function() {
      var _this = this;
      this.startPoint = this.context.getCurrentPoint();
      this.starting = true;
      var dims = this.dims;
      each$1(dims, function(dim) {
        var scale2 = _this.getScale(dim);
        var min2 = scale2.min, max2 = scale2.max, values2 = scale2.values;
        _this.startCache[dim] = { min: min2, max: max2, values: values2 };
      });
    };
    ScaleTranslate2.prototype.end = function() {
      this.startPoint = null;
      this.starting = false;
      this.startCache = {};
    };
    ScaleTranslate2.prototype.translate = function() {
      var _this = this;
      if (!this.starting) {
        return;
      }
      var startPoint = this.startPoint;
      var coord2 = this.context.view.getCoordinate();
      var currentPoint = this.context.getCurrentPoint();
      var normalStart = coord2.invert(startPoint);
      var noramlCurrent = coord2.invert(currentPoint);
      var dx = noramlCurrent.x - normalStart.x;
      var dy = noramlCurrent.y - normalStart.y;
      var view = this.context.view;
      var dims = this.dims;
      each$1(dims, function(dim) {
        _this.translateDim(dim, { x: dx * -1, y: dy * -1 });
      });
      view.render(true);
    };
    ScaleTranslate2.prototype.translateDim = function(dim, normalPoint) {
      if (this.hasDim(dim)) {
        var scale2 = this.getScale(dim);
        if (scale2.isLinear) {
          this.translateLinear(dim, scale2, normalPoint);
        }
      }
    };
    ScaleTranslate2.prototype.translateLinear = function(dim, scale2, normalPoint) {
      var view = this.context.view;
      var _a2 = this.startCache[dim], min2 = _a2.min, max2 = _a2.max;
      var range = max2 - min2;
      var d = normalPoint[dim] * range;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          // @ts-ignore
          nice: scale2.nice,
          min: min2,
          max: max2
        };
      }
      view.scale(scale2.field, {
        // @ts-ignore
        nice: false,
        min: min2 + d,
        max: max2 + d
      });
    };
    ScaleTranslate2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.startPoint = null;
      this.starting = false;
    };
    return ScaleTranslate2;
  }(ScaleTranslate$2)
);
var ScaleTranslate = (
  /** @class */
  function(_super) {
    __extends$1(ScaleTranslate2, _super);
    function ScaleTranslate2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.zoomRatio = 0.05;
      return _this;
    }
    ScaleTranslate2.prototype.zoomIn = function() {
      this.zoom(this.zoomRatio);
    };
    ScaleTranslate2.prototype.zoom = function(scale2) {
      var _this = this;
      var dims = this.dims;
      each$1(dims, function(dim) {
        _this.zoomDim(dim, scale2);
      });
      this.context.view.render(true);
    };
    ScaleTranslate2.prototype.zoomOut = function() {
      this.zoom(-1 * this.zoomRatio);
    };
    ScaleTranslate2.prototype.zoomDim = function(dim, dRatio) {
      if (this.hasDim(dim)) {
        var scale2 = this.getScale(dim);
        if (scale2.isLinear) {
          this.zoomLinear(dim, scale2, dRatio);
        }
      }
    };
    ScaleTranslate2.prototype.zoomLinear = function(dim, scale2, dRatio) {
      var view = this.context.view;
      if (!this.cacheScaleDefs[dim]) {
        this.cacheScaleDefs[dim] = {
          // @ts-ignore
          nice: scale2.nice,
          min: scale2.min,
          max: scale2.max
        };
      }
      var scaleDef = this.cacheScaleDefs[dim];
      var range = scaleDef.max - scaleDef.min;
      var min2 = scale2.min, max2 = scale2.max;
      var d = dRatio * range;
      var toMin = min2 - d;
      var toMax = max2 + d;
      var curRange = toMax - toMin;
      var scaled = curRange / range;
      if (toMax > toMin && scaled < 100 && scaled > 0.01) {
        view.scale(scale2.field, {
          // @ts-ignore
          nice: false,
          min: min2 - d,
          max: max2 + d
        });
      }
    };
    return ScaleTranslate2;
  }(ScaleTranslate$2)
);
function isWheelDown$1(event) {
  var wheelEvent = event.gEvent.originalEvent;
  return wheelEvent.deltaY > 0;
}
var DEFAULT_WHEELDELTA = 1;
var MousewheelScroll = (
  /** @class */
  function(_super) {
    __extends$1(MousewheelScroll2, _super);
    function MousewheelScroll2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MousewheelScroll2.prototype.scroll = function(arg) {
      var _a2 = this.context, view = _a2.view, event = _a2.event;
      if (!view.getOptions().scrollbar) {
        return;
      }
      var wheelDelta = (arg === null || arg === void 0 ? void 0 : arg.wheelDelta) || DEFAULT_WHEELDELTA;
      var scrollbarController = view.getController("scrollbar");
      var xScale = view.getXScale();
      var data2 = view.getOptions().data;
      var dataSize = size(valuesOfKey(data2, xScale.field));
      var step = size(xScale.values);
      var currentRatio = scrollbarController.getValue();
      var currentStart = Math.floor((dataSize - step) * currentRatio);
      var nextStart = currentStart + (isWheelDown$1(event) ? wheelDelta : -wheelDelta);
      var correction = wheelDelta / (dataSize - step) / 1e4;
      var nextRatio = clamp(nextStart / (dataSize - step) + correction, 0, 1);
      scrollbarController.setValue(nextRatio);
    };
    return MousewheelScroll2;
  }(Action)
);
var AXIS_DESCRIPTION_TOOLTIP = "aixs-description-tooltip";
var AxisDescription = (
  /** @class */
  function(_super) {
    __extends$1(AxisDescription2, _super);
    function AxisDescription2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    AxisDescription2.prototype.show = function() {
      var context = this.context;
      var axis2 = getDelegationObject(context).axis;
      var _a2 = axis2.cfg.title, description = _a2.description, text2 = _a2.text, descriptionTooltipStyle = _a2.descriptionTooltipStyle;
      var _b = context.event, x = _b.x, y = _b.y;
      if (!this.tooltip) {
        this.renderTooltip();
      }
      this.tooltip.update({
        title: text2 || "",
        customContent: function() {
          return '\n          <div class="'.concat(CONTAINER_CLASS, '" style={').concat(descriptionTooltipStyle, '}>\n            <div class="').concat(TITLE_CLASS, '">\n              ').concat(description, "\n            </div>\n          </div>\n        ");
        },
        x,
        y
      });
      this.tooltip.show();
    };
    AxisDescription2.prototype.destroy = function() {
      _super.prototype.destroy.call(this);
      this.tooltip && this.tooltip.destroy();
    };
    AxisDescription2.prototype.hide = function() {
      this.tooltip && this.tooltip.hide();
    };
    AxisDescription2.prototype.renderTooltip = function() {
      var _a2;
      var view = this.context.view;
      var canvas = view.canvas;
      var region = {
        start: { x: 0, y: 0 },
        end: { x: canvas.get("width"), y: canvas.get("height") }
      };
      var tooltip2 = new HtmlTooltip({
        parent: canvas.get("el").parentNode,
        region,
        visible: false,
        containerId: AXIS_DESCRIPTION_TOOLTIP,
        domStyles: __assign$1({}, deepMix({}, (_a2 = {}, // tooltip tip  50%
        _a2[CONTAINER_CLASS] = {
          "max-width": "50%",
          padding: "10px",
          "line-height": "15px",
          "font-size": "12px",
          color: "rgba(0, 0, 0, .65)"
        }, _a2[TITLE_CLASS] = {
          "word-break": "break-all",
          "margin-bottom": "3px"
        }, _a2)))
      });
      tooltip2.init();
      tooltip2.setCapture(false);
      this.tooltip = tooltip2;
    };
    return AxisDescription2;
  }(Action)
);
registerTheme("dark", createThemeByStyleSheet(antvDark));
registerEngine("canvas", CanvasEngine);
registerEngine("svg", SVGEngine);
registerGeometry("Polygon", Polygon);
registerGeometry("Interval", Interval);
registerGeometry("Schema", Schema);
registerGeometry("Path", Path);
registerGeometry("Point", Point);
registerGeometry("Line", Line$1);
registerGeometry("Area", Area$1);
registerGeometry("Edge", Edge);
registerGeometry("Heatmap", Heatmap);
registerGeometry("Violin", Violin);
registerGeometryLabel("base", GeometryLabel);
registerGeometryLabel("interval", IntervalLabel);
registerGeometryLabel("pie", PieLabel);
registerGeometryLabel("polar", PolarLabel);
registerGeometryLabelLayout("overlap", overlap);
registerGeometryLabelLayout("distribute", distribute);
registerGeometryLabelLayout("fixed-overlap", fixedOverlap);
registerGeometryLabelLayout("hide-overlap", hideOverlap);
registerGeometryLabelLayout("limit-in-shape", limitInShape);
registerGeometryLabelLayout("limit-in-canvas", limitInCanvas);
registerGeometryLabelLayout("limit-in-plot", limitInPlot$3);
registerGeometryLabelLayout("pie-outer", pieOuterLabelLayout);
registerGeometryLabelLayout("adjust-color", adjustColor);
registerGeometryLabelLayout("interval-adjust-position", intervalAdjustPosition);
registerGeometryLabelLayout("interval-hide-overlap", intervalHideOverlap);
registerGeometryLabelLayout("point-adjust-position", pointAdjustPosition);
registerGeometryLabelLayout("pie-spider", pieSpiderLabelLayout);
registerGeometryLabelLayout("path-adjust-position", pathAdjustPosition);
registerAnimation("fade-in", fadeIn);
registerAnimation("fade-out", fadeOut);
registerAnimation("grow-in-x", growInX);
registerAnimation("grow-in-xy", growInXY);
registerAnimation("grow-in-y", growInY);
registerAnimation("scale-in-x", scaleInX);
registerAnimation("scale-in-y", scaleInY);
registerAnimation("wave-in", waveIn);
registerAnimation("zoom-in", zoomIn);
registerAnimation("zoom-out", zoomOut);
registerAnimation("position-update", positionUpdate);
registerAnimation("sector-path-update", sectorPathUpdate);
registerAnimation("path-in", pathIn);
registerFacet("rect", Rect);
registerFacet("mirror", Mirror);
registerFacet("list", List);
registerFacet("matrix", Matrix);
registerFacet("circle", Circle);
registerFacet("tree", Tree);
registerComponentController("axis", Axis);
registerComponentController("legend", Legend);
registerComponentController("tooltip", Tooltip);
registerComponentController("annotation", Annotation);
registerComponentController("slider", Slider);
registerComponentController("scrollbar", Scrollbar);
registerAction("tooltip", TooltipAction);
registerAction("sibling-tooltip", SiblingTooltip);
registerAction("ellipsis-text", EllipsisText);
registerAction("element-active", ElementActive);
registerAction("element-single-active", ElementSingleActive);
registerAction("element-range-active", ElementRangeActive);
registerAction("element-highlight", ElementHighlight);
registerAction("element-highlight-by-x", HighlightX);
registerAction("element-highlight-by-color", HighlightColor);
registerAction("element-single-highlight", ElementSingleHighlight);
registerAction("element-range-highlight", ElementRangeHighlight);
registerAction("element-sibling-highlight", ElementRangeHighlight, {
  effectSiblings: true,
  effectByRecord: true
});
registerAction("element-selected", ElementMultipleSelected);
registerAction("element-single-selected", ElementSingleSelected);
registerAction("element-range-selected", ElementRangeSelected);
registerAction("element-link-by-color", LinkByColor);
registerAction("active-region", ActiveRegion);
registerAction("list-active", ListActive);
registerAction("list-selected", ListSelected);
registerAction("list-highlight", ListHighlight);
registerAction("list-unchecked", ListUnchecked);
registerAction("list-checked", ListChecked);
registerAction("list-focus", ListFocus);
registerAction("list-radio", ListRadio);
registerAction("legend-item-highlight", ListHighlight, {
  componentNames: ["legend"]
});
registerAction("axis-label-highlight", ListHighlight, {
  componentNames: ["axis"]
});
registerAction("axis-description", AxisDescription);
registerAction("rect-mask", RectMask);
registerAction("x-rect-mask", DimRect, { dim: "x" });
registerAction("y-rect-mask", DimRect, { dim: "y" });
registerAction("circle-mask", CircleMask);
registerAction("path-mask", PathMask);
registerAction("smooth-path-mask", SmoothPathMask);
registerAction("rect-multi-mask", RectMultiMask);
registerAction("x-rect-multi-mask", DimRectMultiMask, { dim: "x" });
registerAction("y-rect-multi-mask", DimRectMultiMask, { dim: "y" });
registerAction("circle-multi-mask", CircleMultiMask);
registerAction("path-multi-mask", PathMultiMask);
registerAction("smooth-path-multi-mask", SmoothPathMultiMask);
registerAction("cursor", CursorAction);
registerAction("data-filter", DataFilter);
registerAction("brush", RangeFilter);
registerAction("brush-x", RangeFilter, { dims: ["x"] });
registerAction("brush-y", RangeFilter, { dims: ["y"] });
registerAction("sibling-filter", SiblingFilter$1);
registerAction("sibling-x-filter", SiblingFilter$1);
registerAction("sibling-y-filter", SiblingFilter$1);
registerAction("element-filter", ElementFilter);
registerAction("element-sibling-filter", SiblingFilter);
registerAction("element-sibling-filter-record", SiblingFilter, { byRecord: true });
registerAction("view-drag", Drag);
registerAction("view-move", Move);
registerAction("scale-translate", ScaleTranslate$1);
registerAction("scale-zoom", ScaleTranslate);
registerAction("reset-button", ButtonAction$1, {
  name: "reset-button",
  text: "reset"
});
registerAction("mousewheel-scroll", MousewheelScroll);
function isPointInView$1(context) {
  return context.isInPlot();
}
registerInteraction("tooltip", {
  start: [
    { trigger: "plot:mousemove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } },
    { trigger: "plot:touchmove", action: "tooltip:show", throttle: { wait: 50, leading: true, trailing: false } }
  ],
  end: [
    { trigger: "plot:mouseleave", action: "tooltip:hide" },
    { trigger: "plot:leave", action: "tooltip:hide" },
    { trigger: "plot:touchend", action: "tooltip:hide" }
  ]
});
registerInteraction("ellipsis-text", {
  start: [
    {
      trigger: "legend-item-name:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "legend-item-name:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:mousemove",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    },
    {
      trigger: "axis-label:touchstart",
      action: "ellipsis-text:show",
      throttle: { wait: 50, leading: true, trailing: false }
    }
  ],
  end: [
    { trigger: "legend-item-name:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "legend-item-name:touchend", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseleave", action: "ellipsis-text:hide" },
    { trigger: "axis-label:mouseout", action: "ellipsis-text:hide" },
    { trigger: "axis-label:touchend", action: "ellipsis-text:hide" }
  ]
});
registerInteraction("element-active", {
  start: [{ trigger: "element:mouseenter", action: "element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "element-active:reset" }]
});
registerInteraction("element-selected", {
  start: [{ trigger: "element:click", action: "element-selected:toggle" }]
});
registerInteraction("element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight:reset" }]
});
registerInteraction("element-highlight-by-x", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-x:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-x:reset" }]
});
registerInteraction("element-highlight-by-color", {
  start: [{ trigger: "element:mouseenter", action: "element-highlight-by-color:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "element-highlight-by-color:reset" }]
});
registerInteraction("legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "element-active:reset"] }]
});
registerInteraction("legend-highlight", {
  start: [
    { trigger: "legend-item:mouseenter", action: ["legend-item-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("axis-label-highlight", {
  start: [
    { trigger: "axis-label:mouseenter", action: ["axis-label-highlight:highlight", "element-highlight:highlight"] }
  ],
  end: [{ trigger: "axis-label:mouseleave", action: ["axis-label-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-list-highlight", {
  start: [{ trigger: "element:mouseenter", action: ["list-highlight:highlight", "element-highlight:highlight"] }],
  end: [{ trigger: "element:mouseleave", action: ["list-highlight:reset", "element-highlight:reset"] }]
});
registerInteraction("element-range-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      isEnable: function(context) {
        return !context.isInShape("mask");
      },
      action: ["rect-mask:start", "rect-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["rect-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    {
      trigger: "mask:drag",
      action: ["rect-mask:move"]
    },
    {
      trigger: "mask:change",
      action: ["element-range-highlight:highlight"]
    }
  ],
  end: [
    { trigger: "plot:mouseup", action: ["rect-mask:end"] },
    { trigger: "mask:dragend", action: ["rect-mask:moveEnd"] },
    {
      trigger: "document:mouseup",
      isEnable: function(context) {
        return !context.isInPlot();
      },
      action: ["element-range-highlight:clear", "rect-mask:end", "rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "rect-mask:hide"] }]
});
registerInteraction("brush", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["brush:start", "rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView$1,
      action: ["rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView$1,
      action: ["brush:filter", "brush:end", "rect-mask:end", "rect-mask:hide", "reset-button:show"]
    }
  ],
  rollback: [{ trigger: "reset-button:click", action: ["brush:reset", "reset-button:hide", "cursor:crosshair"] }]
});
registerInteraction("brush-visible", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "plot:mousedown",
      action: ["rect-mask:start", "rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "plot:mousemove",
      action: ["rect-mask:resize"]
    },
    { trigger: "mask:change", action: ["element-range-highlight:highlight"] }
  ],
  end: [
    {
      trigger: "plot:mouseup",
      action: ["rect-mask:end", "rect-mask:hide", "element-filter:filter", "element-range-highlight:clear"]
    }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["element-filter:clear"]
    }
  ]
});
registerInteraction("brush-x", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["brush-x:start", "x-rect-mask:start", "x-rect-mask:show"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: isPointInView$1,
      action: ["x-rect-mask:resize"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      isEnable: isPointInView$1,
      action: ["brush-x:filter", "brush-x:end", "x-rect-mask:end", "x-rect-mask:hide"]
    }
  ],
  rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
});
registerInteraction("element-path-highlight", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "plot:mouseleave", action: "cursor:default" }
  ],
  start: [
    { trigger: "mousedown", isEnable: isPointInView$1, action: "path-mask:start" },
    { trigger: "mousedown", isEnable: isPointInView$1, action: "path-mask:show" }
  ],
  processing: [{ trigger: "mousemove", action: "path-mask:addPoint" }],
  end: [{ trigger: "mouseup", action: "path-mask:end" }],
  rollback: [{ trigger: "dblclick", action: "path-mask:hide" }]
});
registerInteraction("brush-x-multi", {
  showEnable: [
    { trigger: "plot:mouseenter", action: "cursor:crosshair" },
    { trigger: "mask:mouseenter", action: "cursor:move" },
    { trigger: "plot:mouseleave", action: "cursor:default" },
    { trigger: "mask:mouseleave", action: "cursor:crosshair" }
  ],
  start: [
    {
      trigger: "mousedown",
      isEnable: isPointInView$1,
      action: ["x-rect-multi-mask:start", "x-rect-multi-mask:show"]
    },
    {
      trigger: "mask:dragstart",
      action: ["x-rect-multi-mask:moveStart"]
    }
  ],
  processing: [
    {
      trigger: "mousemove",
      isEnable: function(context) {
        return !isMultipleMask(context);
      },
      action: ["x-rect-multi-mask:resize"]
    },
    {
      trigger: "multi-mask:change",
      action: "element-range-highlight:highlight"
    },
    {
      trigger: "mask:drag",
      action: ["x-rect-multi-mask:move"]
    }
  ],
  end: [
    {
      trigger: "mouseup",
      action: ["x-rect-multi-mask:end"]
    },
    { trigger: "mask:dragend", action: ["x-rect-multi-mask:moveEnd"] }
  ],
  rollback: [
    {
      trigger: "dblclick",
      action: ["x-rect-multi-mask:clear", "cursor:crosshair"]
    },
    {
      trigger: "multi-mask:clearAll",
      action: ["element-range-highlight:clear"]
    },
    {
      trigger: "multi-mask:clearSingle",
      action: ["element-range-highlight:highlight"]
    }
  ]
});
registerInteraction("element-single-selected", {
  start: [{ trigger: "element:click", action: "element-single-selected:toggle" }]
});
registerInteraction("legend-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: ["cursor:pointer", "list-radio:show"] },
    { trigger: "legend-item:mouseleave", action: ["cursor:default", "list-radio:hide"] }
  ],
  start: [
    {
      trigger: "legend-item:click",
      isEnable: function(context) {
        return !context.isInShape("legend-item-radio");
      },
      action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "data-filter:filter", "list-radio:show"]
    },
    //  :  radio === truthy  legend-item-radio 
    {
      trigger: "legend-item-radio:mouseenter",
      action: ["list-radio:showTip"]
    },
    {
      trigger: "legend-item-radio:mouseleave",
      action: ["list-radio:hideTip"]
    },
    {
      trigger: "legend-item-radio:click",
      action: ["list-focus:toggle", "data-filter:filter", "list-radio:show"]
    }
  ]
});
registerInteraction("continuous-filter", {
  start: [{ trigger: "legend:valuechanged", action: "data-filter:filter" }]
});
registerInteraction("continuous-visible-filter", {
  start: [{ trigger: "legend:valuechanged", action: "element-filter:filter" }]
});
registerInteraction("legend-visible-filter", {
  showEnable: [
    { trigger: "legend-item:mouseenter", action: "cursor:pointer" },
    { trigger: "legend-item:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "legend-item:click", action: ["legend-item-highlight:reset", "element-highlight:reset", "list-unchecked:toggle", "element-filter:filter"] }]
});
registerInteraction("active-region", {
  start: [{ trigger: "plot:mousemove", action: "active-region:show" }],
  end: [{ trigger: "plot:mouseleave", action: "active-region:hide" }]
});
registerInteraction("axis-description", {
  start: [{ trigger: "axis-description:mousemove", action: "axis-description:show" }],
  end: [{ trigger: "axis-description:mouseleave", action: "axis-description:hide" }]
});
function isWheelDown(event) {
  event.gEvent.preventDefault();
  return event.gEvent.originalEvent.deltaY > 0;
}
registerInteraction("view-zoom", {
  start: [
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return isWheelDown(context.event);
      },
      action: "scale-zoom:zoomOut",
      throttle: { wait: 100, leading: true, trailing: false }
    },
    {
      trigger: "plot:mousewheel",
      isEnable: function(context) {
        return !isWheelDown(context.event);
      },
      action: "scale-zoom:zoomIn",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ]
});
registerInteraction("sibling-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "sibling-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "sibling-tooltip:hide" }]
});
registerInteraction("plot-mousewheel-scroll", {
  start: [{ trigger: "plot:mousewheel", action: "mousewheel-scroll:scroll" }]
});
var AXIS_META_CONFIG_KEYS = [
  "type",
  "alias",
  "tickCount",
  "tickInterval",
  "min",
  "max",
  "nice",
  "minLimit",
  "maxLimit",
  // 
  "range",
  "tickMethod",
  // type: 'log' 
  "base",
  // type: 'exp' 
  "exponent",
  // time 
  "mask",
  // 
  "sync"
];
var LEVEL;
(function(LEVEL2) {
  LEVEL2["ERROR"] = "error";
  LEVEL2["WARN"] = "warn";
  LEVEL2["INFO"] = "log";
})(LEVEL || (LEVEL = {}));
var BRAND = "AntV/G2Plot";
function getMessage(format2) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  var argIndex = 0;
  return "".concat(BRAND, ": ").concat(format2.replace(/%s/g, function() {
    return "".concat(args[argIndex++]);
  }));
}
function log(level, condition, format2) {
  var args = [];
  for (var _i = 3; _i < arguments.length; _i++) {
    args[_i - 3] = arguments[_i];
  }
  if (!condition) {
    console[level](getMessage.apply(void 0, __spreadArray$1([format2], args, false)));
  }
}
function pick(obj, keys2) {
  var r = {};
  if (obj !== null && typeof obj === "object") {
    keys2.forEach(function(key) {
      var v = obj[key];
      if (v !== void 0) {
        r[key] = v;
      }
    });
  }
  return r;
}
function adjustYMetaByZero(data2, field2) {
  if (!data2)
    return {};
  var numberData = data2.filter(function(datum) {
    var v = get(datum, [field2]);
    return isNumber$1(v) && !isNaN(v);
  });
  var gtZero = numberData.every(function(datum) {
    return get(datum, [field2]) >= 0;
  });
  var ltZero = numberData.every(function(datum) {
    return get(datum, [field2]) <= 0;
  });
  if (gtZero) {
    return { min: 0 };
  }
  if (ltZero) {
    return { max: 0 };
  }
  return {};
}
function transformDataToNodeLinkData(data2, sourceField, targetField, weightField, rawFields) {
  if (rawFields === void 0) {
    rawFields = [];
  }
  if (!Array.isArray(data2)) {
    return {
      nodes: [],
      links: []
    };
  }
  var links = [];
  var nodesMap = {};
  var nodesIndex = -1;
  data2.forEach(function(datum) {
    var source = datum[sourceField];
    var target2 = datum[targetField];
    var weight = datum[weightField];
    var rawData = pick(datum, rawFields);
    if (!nodesMap[source]) {
      nodesMap[source] = __assign$1({ id: ++nodesIndex, name: source }, rawData);
    }
    if (!nodesMap[target2]) {
      nodesMap[target2] = __assign$1({ id: ++nodesIndex, name: target2 }, rawData);
    }
    links.push(__assign$1({
      source: nodesMap[source].id,
      target: nodesMap[target2].id,
      // sourceName: source,
      // targetName: target,
      value: weight
    }, rawData));
  });
  return {
    //  id 
    nodes: Object.values(nodesMap).sort(function(a, b) {
      return a.id - b.id;
    }),
    links
  };
}
function processIllegalData(data2, field2) {
  var processData2 = filter(data2, function(d) {
    var v = d[field2];
    return v === null || typeof v === "number" && !isNaN(v);
  });
  log(LEVEL.WARN, processData2.length === data2.length, "illegal data existed in chart data.");
  return processData2;
}
var MAX_MIX_LEVEL = 5;
var toString = {}.toString;
var isType = function(value2, type) {
  return toString.call(value2) === "[object " + type + "]";
};
var isArray = function(value2) {
  return isType(value2, "Array");
};
var isObjectLike = function(value2) {
  return typeof value2 === "object" && value2 !== null;
};
var isPlainObject = function(value2) {
  if (!isObjectLike(value2) || !isType(value2, "Object")) {
    return false;
  }
  var proto = value2;
  while (Object.getPrototypeOf(proto) !== null) {
    proto = Object.getPrototypeOf(proto);
  }
  return Object.getPrototypeOf(value2) === proto;
};
var deep = function(dist, src2, level, maxLevel) {
  level = level || 0;
  maxLevel = maxLevel || MAX_MIX_LEVEL;
  for (var key in src2) {
    if (Object.prototype.hasOwnProperty.call(src2, key)) {
      var value2 = src2[key];
      if (!value2) {
        dist[key] = value2;
      } else {
        if (isPlainObject(value2)) {
          if (!isPlainObject(dist[key])) {
            dist[key] = {};
          }
          if (level < maxLevel) {
            deep(dist[key], value2, level + 1, maxLevel);
          } else {
            dist[key] = src2[key];
          }
        } else if (isArray(value2)) {
          dist[key] = [];
          dist[key] = dist[key].concat(value2);
        } else {
          dist[key] = value2;
        }
      }
    }
  }
};
var deepAssign = function(rst) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var i = 0; i < args.length; i += 1) {
    deep(rst, args[i]);
  }
  return rst;
};
function getContainerSize(ele) {
  if (!ele) {
    return { width: 0, height: 0 };
  }
  var style = getComputedStyle(ele);
  return {
    width: (ele.clientWidth || parseInt(style.width, 10)) - parseInt(style.paddingLeft, 10) - parseInt(style.paddingRight, 10),
    height: (ele.clientHeight || parseInt(style.height, 10)) - parseInt(style.paddingTop, 10) - parseInt(style.paddingBottom, 10)
  };
}
function flow() {
  var flows = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    flows[_i] = arguments[_i];
  }
  return function(param) {
    return flows.reduce(function(result, f) {
      return f(result);
    }, param);
  };
}
function findGeometry(view, type) {
  return view.geometries.find(function(g) {
    return g.type === type;
  });
}
function getAllElements(view) {
  return reduce(view.geometries, function(r, geometry2) {
    return r.concat(geometry2.elements);
  }, []);
}
function getAllElementsRecursively(view) {
  if (get(view, ["views", "length"], 0) <= 0) {
    return getAllElements(view);
  }
  return reduce(view.views, function(ele, subView) {
    return ele.concat(getAllElementsRecursively(subView));
  }, getAllElements(view));
}
function getAllGeometriesRecursively(view) {
  if (get(view, ["views", "length"], 0) <= 0) {
    return view.geometries;
  }
  return reduce(view.views, function(ele, subView) {
    return ele.concat(subView.geometries);
  }, view.geometries);
}
function kebabCase(word2) {
  if (!word2) {
    return word2;
  }
  var result = word2.match(/(([A-Z]{0,1}[a-z]*[^A-Z])|([A-Z]{1}))/g);
  return result.map(function(s) {
    return s.toLowerCase();
  }).join("-");
}
function transformLabel(labelOptions) {
  if (!isType$1(labelOptions, "Object")) {
    return labelOptions;
  }
  var label2 = __assign$1({}, labelOptions);
  if (label2.formatter && !label2.content) {
    label2.content = label2.formatter;
  }
  return label2;
}
var ctx;
function getCanvasContext() {
  if (!ctx) {
    ctx = document.createElement("canvas").getContext("2d");
  }
  return ctx;
}
memoize(function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  var fontSize = font.fontSize, _a2 = font.fontFamily, fontFamily = _a2 === void 0 ? "sans-serif" : _a2, fontWeight = font.fontWeight, fontStyle = font.fontStyle, fontVariant = font.fontVariant;
  var ctx2 = getCanvasContext();
  ctx2.font = [fontStyle, fontWeight, fontVariant, "".concat(fontSize, "px"), fontFamily].join(" ");
  var metrics = ctx2.measureText(isString(text2) ? text2 : "");
  return metrics.width;
}, function(text2, font) {
  if (font === void 0) {
    font = {};
  }
  return __spreadArray$1([text2], values(font), true).join("");
});
function isRealNumber(v) {
  return typeof v === "number" && !isNaN(v);
}
function isBetween(value2, start, end) {
  var min2 = Math.min(start, end);
  var max2 = Math.max(start, end);
  return value2 >= min2 && value2 <= max2;
}
function normalPadding(padding2) {
  if (isNumber$1(padding2)) {
    return [padding2, padding2, padding2, padding2];
  }
  if (isArray$1(padding2)) {
    var length_1 = padding2.length;
    if (length_1 === 1) {
      return [padding2[0], padding2[0], padding2[0], padding2[0]];
    }
    if (length_1 === 2) {
      return [padding2[0], padding2[1], padding2[0], padding2[1]];
    }
    if (length_1 === 3) {
      return [padding2[0], padding2[1], padding2[2], padding2[1]];
    }
    if (length_1 === 4) {
      return padding2;
    }
  }
  return [0, 0, 0, 0];
}
function getAdjustAppendPadding(padding2, position, append) {
  if (position === void 0) {
    position = "bottom";
  }
  if (append === void 0) {
    append = 25;
  }
  var currentAppendPadding = normalPadding(padding2);
  var PADDING2 = [
    position.startsWith("top") ? append : 0,
    position.startsWith("right") ? append : 0,
    position.startsWith("bottom") ? append : 0,
    position.startsWith("left") ? append : 0
  ];
  return [
    currentAppendPadding[0] + PADDING2[0],
    currentAppendPadding[1] + PADDING2[1],
    currentAppendPadding[2] + PADDING2[2],
    currentAppendPadding[3] + PADDING2[3]
  ];
}
function resolveAllPadding(paddings) {
  var normalPaddings = paddings.map(function(item) {
    return normalPadding(item);
  });
  var finalPadding = [0, 0, 0, 0];
  if (normalPaddings.length > 0) {
    finalPadding = finalPadding.map(function(item, index2) {
      normalPaddings.forEach(function(d, i) {
        item += normalPaddings[i][index2];
      });
      return item;
    });
  }
  return finalPadding;
}
function points2Path(points2, isInCircle) {
  var path2 = [];
  if (points2.length) {
    path2.push(["M", points2[0].x, points2[0].y]);
    for (var i = 1, length_1 = points2.length; i < length_1; i += 1) {
      var item = points2[i];
      path2.push(["L", item.x, item.y]);
    }
    if (isInCircle) {
      path2.push(["Z"]);
    }
  }
  return path2;
}
var smoothBezier = function(points2, smooth, isLoop, constraint) {
  var cps = [];
  var prevPoint;
  var nextPoint;
  var hasConstraint = !!constraint;
  var min2;
  var max2;
  if (hasConstraint) {
    min2 = [Infinity, Infinity];
    max2 = [-Infinity, -Infinity];
    for (var i = 0, l = points2.length; i < l; i++) {
      var point2 = points2[i];
      min2 = min$1([0, 0], min2, point2);
      max2 = max$1([0, 0], max2, point2);
    }
    min2 = min$1([0, 0], min2, constraint[0]);
    max2 = max$1([0, 0], max2, constraint[1]);
  }
  for (var i = 0, len = points2.length; i < len; i++) {
    var point2 = points2[i];
    if (isLoop) {
      prevPoint = points2[i ? i - 1 : len - 1];
      nextPoint = points2[(i + 1) % len];
    } else {
      if (i === 0 || i === len - 1) {
        cps.push(point2);
        continue;
      } else {
        prevPoint = points2[i - 1];
        nextPoint = points2[i + 1];
      }
    }
    var v = [0, 0];
    v = sub(v, nextPoint, prevPoint);
    v = scale$3(v, v, smooth);
    var d0 = distance$6(point2, prevPoint);
    var d1 = distance$6(point2, nextPoint);
    var sum = d0 + d1;
    if (sum !== 0) {
      d0 /= sum;
      d1 /= sum;
    }
    var v1 = scale$3([0, 0], v, -d0);
    var v2 = scale$3([0, 0], v, d1);
    var cp0 = add([0, 0], point2, v1);
    var cp1 = add([0, 0], point2, v2);
    if (hasConstraint) {
      cp0 = max$1([0, 0], cp0, min2);
      cp0 = min$1([0, 0], cp0, max2);
      cp1 = max$1([0, 0], cp1, min2);
      cp1 = min$1([0, 0], cp1, max2);
    }
    cps.push(cp0);
    cps.push(cp1);
  }
  if (isLoop) {
    cps.push(cps.shift());
  }
  return cps;
};
function catmullRom2bezier(crp, z, constraint) {
  var isLoop = !!z;
  var pointList = [];
  for (var i = 0, l = crp.length; i < l; i += 2) {
    pointList.push([crp[i], crp[i + 1]]);
  }
  var controlPointList = smoothBezier(pointList, 0.4, isLoop, constraint);
  var len = pointList.length;
  var d1 = [];
  var cp1;
  var cp2;
  var p;
  for (var i = 0; i < len - 1; i++) {
    cp1 = controlPointList[i * 2];
    cp2 = controlPointList[i * 2 + 1];
    p = pointList[i + 1];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  if (isLoop) {
    cp1 = controlPointList[len];
    cp2 = controlPointList[len + 1];
    p = pointList[0];
    d1.push(["C", cp1[0], cp1[1], cp2[0], cp2[1], p[0], p[1]]);
  }
  return d1;
}
function getSplinePath(points2, isInCircle, constaint) {
  var data2 = [];
  var first = points2[0];
  var prePoint = null;
  if (points2.length <= 2) {
    return points2Path(points2, isInCircle);
  }
  for (var i = 0, len = points2.length; i < len; i++) {
    var point2 = points2[i];
    if (!prePoint || !(prePoint.x === point2.x && prePoint.y === point2.y)) {
      data2.push(point2.x);
      data2.push(point2.y);
      prePoint = point2;
    }
  }
  var constraint = constaint || [
    // 
    [0, 0],
    [1, 1]
  ];
  var splinePath2 = catmullRom2bezier(data2, isInCircle, constraint);
  splinePath2.unshift(["M", first.x, first.y]);
  return splinePath2;
}
function adapteStyle(style) {
  var styleObject = {
    overflow: "hidden",
    "white-space": "nowrap",
    "text-overflow": "ellipsis",
    display: "flex",
    justifyContent: "center",
    alignItems: "center"
  };
  var shapeStyleKeys = [
    "stroke",
    "lineWidth",
    "shadowColor",
    "strokeOpacity",
    "shadowBlur",
    "shadowOffsetX",
    "shadowOffsetY",
    "fill"
  ];
  if (get(style, "fill")) {
    styleObject["color"] = style["fill"];
  }
  var _a2 = pick(style, shapeStyleKeys), shadowColor = _a2.shadowColor, _b = _a2.shadowBlur, shadowBlur = _b === void 0 ? 0 : _b, _c = _a2.shadowOffsetX, shadowOffsetX = _c === void 0 ? 0 : _c, _d = _a2.shadowOffsetY, shadowOffsetY = _d === void 0 ? 0 : _d;
  styleObject["text-shadow"] = "".concat([shadowColor, "".concat(shadowOffsetX, "px"), "".concat(shadowOffsetY, "px"), "".concat(shadowBlur, "px")].join(" "));
  var _e = pick(style, shapeStyleKeys), stroke = _e.stroke, _f = _e.lineWidth, lineWidth = _f === void 0 ? 0 : _f;
  styleObject["-webkit-text-stroke"] = "".concat(["".concat(lineWidth, "px"), stroke].join(" "));
  each$1(style, function(v, k) {
    if (["fontSize"].includes(k) && isNumber$1(v)) {
      styleObject[kebabCase(k)] = "".concat(v, "px");
    } else if (k && !shapeStyleKeys.includes(k)) {
      styleObject[kebabCase(k)] = "".concat(v);
    }
  });
  return styleObject;
}
function setStatisticContainerStyle(container, style) {
  container.style["pointer-events"] = "none";
  each$1(style, function(v, k) {
    if (k && v) {
      container.style[k] = v;
    }
  });
}
var renderStatistic = function(chart, options, datum) {
  var statistic2 = options.statistic, plotType = options.plotType;
  var titleOpt = statistic2.title, contentOpt = statistic2.content;
  [titleOpt, contentOpt].forEach(function(option, idx) {
    if (!option) {
      return;
    }
    var transform2 = "";
    if (idx === 0) {
      transform2 = contentOpt ? "translate(-50%, -100%)" : "translate(-50%, -50%)";
    } else {
      transform2 = titleOpt ? "translate(-50%, 0)" : "translate(-50%, -50%)";
    }
    var style = isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign$1(
      {
        position: ["50%", "50%"],
        html: function(container, view) {
          var coordinate2 = view.getCoordinate();
          var containerW = 0;
          if (plotType === "pie" || plotType === "ring-progress") {
            containerW = coordinate2.getRadius() * coordinate2.innerRadius * 2;
          } else if (plotType === "liquid") {
            var liquidShape = get(view.geometries, [0, "elements", 0, "shape"]);
            if (liquidShape) {
              var path2 = liquidShape.find(function(t) {
                return t.get("name") === "wrap";
              });
              var width = path2.getCanvasBBox().width;
              containerW = width;
            }
          } else if (!containerW) {
            containerW = coordinate2.getWidth();
          }
          setStatisticContainerStyle(container, __assign$1({ width: "".concat(containerW, "px"), transform: transform2 }, adapteStyle(style)));
          var filteredData = view.getData();
          if (option.customHtml) {
            return option.customHtml(container, view, datum, filteredData);
          }
          var text2 = option.content;
          if (option.formatter) {
            text2 = option.formatter(datum, filteredData);
          }
          return text2 ? isString(text2) ? text2 : "".concat(text2) : "<div></div>";
        },
        // @ts-ignore
        key: "".concat(idx === 0 ? "top" : "bottom", "-statistic")
      },
      pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])
      /**  */
    ));
  });
};
var renderGaugeStatistic = function(chart, options, datum) {
  var statistic2 = options.statistic;
  var titleOpt = statistic2.title, contentOpt = statistic2.content;
  [titleOpt, contentOpt].forEach(function(option) {
    if (!option) {
      return;
    }
    var style = isFunction(option.style) ? option.style(datum) : option.style;
    chart.annotation().html(__assign$1(
      { position: ["50%", "100%"], html: function(container, view) {
        var coordinate2 = view.getCoordinate();
        var polarCoord = view.views[0].getCoordinate();
        var polarCenter = polarCoord.getCenter();
        var polarRadius = polarCoord.getRadius();
        var polarMaxY = Math.max(Math.sin(polarCoord.startAngle), Math.sin(polarCoord.endAngle)) * polarRadius;
        var offsetY = polarCenter.y + polarMaxY - coordinate2.y.start - parseFloat(get(style, "fontSize", 0));
        var containerWidth = coordinate2.getRadius() * coordinate2.innerRadius * 2;
        setStatisticContainerStyle(container, __assign$1({ width: "".concat(containerWidth, "px"), transform: "translate(-50%, ".concat(offsetY, "px)") }, adapteStyle(style)));
        var filteredData = view.getData();
        if (option.customHtml) {
          return option.customHtml(container, view, datum, filteredData);
        }
        var text2 = option.content;
        if (option.formatter) {
          text2 = option.formatter(datum, filteredData);
        }
        return text2 ? isString(text2) ? text2 : "".concat(text2) : "<div></div>";
      } },
      pick(option, ["offsetX", "offsetY", "rotate", "style", "formatter"])
      /**  */
    ));
  });
};
function template(source, data2) {
  if (!data2) {
    return source;
  }
  return reduce(
    // @ts-ignore
    data2,
    function(r, v, k) {
      return r.replace(new RegExp("{\\s*".concat(k, "\\s*}"), "g"), v);
    },
    source
  );
}
function findViewById(chart, id2) {
  return chart.views.find(function(view) {
    return view.id === id2;
  });
}
function getViews(view) {
  var parent = view.parent;
  return parent ? parent.views : [];
}
function getSiblingViews(view) {
  return getViews(view).filter(function(sub2) {
    return sub2 !== view;
  });
}
function addViewAnimation(view, animation2, geometries) {
  if (geometries === void 0) {
    geometries = view.geometries;
  }
  if (typeof animation2 === "boolean") {
    view.animate(animation2);
  } else {
    view.animate(true);
  }
  each$1(geometries, function(g) {
    var animationCfg;
    if (isFunction(animation2)) {
      animationCfg = animation2(g.type || g.shapeType, g) || true;
    } else {
      animationCfg = animation2;
    }
    g.animate(animationCfg);
  });
}
function getPixelRatio() {
  return typeof window === "object" ? window === null || window === void 0 ? void 0 : window.devicePixelRatio : 2;
}
function initCanvas(width, height) {
  if (height === void 0) {
    height = width;
  }
  var canvas = document.createElement("canvas");
  var pixelRatio = getPixelRatio();
  canvas.width = width * pixelRatio;
  canvas.height = height * pixelRatio;
  canvas.style.width = "".concat(width, "px");
  canvas.style.height = "".concat(height, "px");
  var ctx2 = canvas.getContext("2d");
  ctx2.scale(pixelRatio, pixelRatio);
  return canvas;
}
function drawBackground(context, cfg, width, height) {
  if (height === void 0) {
    height = width;
  }
  var backgroundColor = cfg.backgroundColor, opacity = cfg.opacity;
  context.globalAlpha = opacity;
  context.fillStyle = backgroundColor;
  context.beginPath();
  context.fillRect(0, 0, width, height);
  context.closePath();
}
function getUnitPatternSize(size2, padding2, isStagger) {
  var unitSize = size2 + padding2;
  return isStagger ? unitSize * 2 : unitSize;
}
function getSymbolsPosition(unitSize, isStagger) {
  var symbolsPos = isStagger ? [
    [unitSize * (1 / 4), unitSize * (1 / 4)],
    [unitSize * (3 / 4), unitSize * (3 / 4)]
  ] : [[unitSize * (1 / 2), unitSize * (1 / 2)]];
  return symbolsPos;
}
function transformMatrix(dpr, rotation) {
  var radian = rotation * Math.PI / 180;
  var matrix = {
    a: Math.cos(radian) * (1 / dpr),
    b: Math.sin(radian) * (1 / dpr),
    c: -Math.sin(radian) * (1 / dpr),
    d: Math.cos(radian) * (1 / dpr),
    e: 0,
    f: 0
  };
  return matrix;
}
var defaultDotPatternCfg = {
  size: 6,
  padding: 2,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0,
  isStagger: true
};
function drawDot(context, cfg, x, y) {
  var size2 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, stroke = cfg.stroke, fillOpacity = cfg.fillOpacity;
  context.beginPath();
  context.globalAlpha = fillOpacity;
  context.fillStyle = fill;
  context.strokeStyle = stroke;
  context.lineWidth = lineWidth;
  context.arc(x, y, size2 / 2, 0, 2 * Math.PI, false);
  context.fill();
  if (lineWidth) {
    context.stroke();
  }
  context.closePath();
}
function createDotPattern(cfg) {
  var dotCfg = deepAssign({}, defaultDotPatternCfg, cfg);
  var size2 = dotCfg.size, padding2 = dotCfg.padding, isStagger = dotCfg.isStagger, rotation = dotCfg.rotation;
  var unitSize = getUnitPatternSize(size2, padding2, isStagger);
  var dots = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, dotCfg, unitSize);
  for (var _i = 0, dots_1 = dots; _i < dots_1.length; _i++) {
    var _a2 = dots_1[_i], x = _a2[0], y = _a2[1];
    drawDot(ctx2, dotCfg, x, y);
  }
  var pattern2 = ctx2.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}
var defaultLinePatternCfg = {
  rotation: 45,
  spacing: 5,
  opacity: 1,
  backgroundColor: "transparent",
  strokeOpacity: 0.5,
  stroke: "#fff",
  lineWidth: 2
};
function drawLine(context, cfg, d) {
  var stroke = cfg.stroke, lineWidth = cfg.lineWidth, strokeOpacity = cfg.strokeOpacity;
  var path2 = new Path2D(d);
  context.globalAlpha = strokeOpacity;
  context.lineCap = "square";
  context.strokeStyle = lineWidth ? stroke : "transparent";
  context.lineWidth = lineWidth;
  context.stroke(path2);
}
function createLinePattern(cfg) {
  var lineCfg = deepAssign({}, defaultLinePatternCfg, cfg);
  var spacing = lineCfg.spacing, rotation = lineCfg.rotation, lineWidth = lineCfg.lineWidth;
  var width = spacing + lineWidth || 1;
  var height = spacing + lineWidth || 1;
  var d = "\n            M 0 0 L ".concat(width, " 0\n            M 0 ").concat(height, " L ").concat(width, " ").concat(height, "\n            ");
  var canvas = initCanvas(width, height);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, lineCfg, width, height);
  drawLine(ctx2, lineCfg, d);
  var pattern2 = ctx2.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}
var defaultSquarePatternCfg = {
  size: 6,
  padding: 1,
  isStagger: true,
  backgroundColor: "transparent",
  opacity: 1,
  rotation: 0,
  fill: "#fff",
  fillOpacity: 0.5,
  stroke: "transparent",
  lineWidth: 0
};
function drawSquare(context, cfg, x, y) {
  var stroke = cfg.stroke, size2 = cfg.size, fill = cfg.fill, lineWidth = cfg.lineWidth, fillOpacity = cfg.fillOpacity;
  context.globalAlpha = fillOpacity;
  context.strokeStyle = stroke;
  context.lineWidth = lineWidth;
  context.fillStyle = fill;
  context.strokeRect(x - size2 / 2, y - size2 / 2, size2, size2);
  context.fillRect(x - size2 / 2, y - size2 / 2, size2, size2);
}
function createSquarePattern(cfg) {
  var squareCfg = deepAssign({}, defaultSquarePatternCfg, cfg);
  var size2 = squareCfg.size, padding2 = squareCfg.padding, isStagger = squareCfg.isStagger, rotation = squareCfg.rotation;
  var unitSize = getUnitPatternSize(size2, padding2, isStagger);
  var squares = getSymbolsPosition(unitSize, isStagger);
  var canvas = initCanvas(unitSize, unitSize);
  var ctx2 = canvas.getContext("2d");
  drawBackground(ctx2, squareCfg, unitSize);
  for (var _i = 0, squares_1 = squares; _i < squares_1.length; _i++) {
    var _a2 = squares_1[_i], x = _a2[0], y = _a2[1];
    drawSquare(ctx2, squareCfg, x, y);
  }
  var pattern2 = ctx2.createPattern(canvas, "repeat");
  if (pattern2) {
    var dpr = getPixelRatio();
    var matrix = transformMatrix(dpr, rotation);
    pattern2.setTransform(matrix);
  }
  return pattern2;
}
function getCanvasPattern(options) {
  var type = options.type, cfg = options.cfg;
  var pattern2;
  switch (type) {
    case "dot":
      pattern2 = createDotPattern(cfg);
      break;
    case "line":
      pattern2 = createLinePattern(cfg);
      break;
    case "square":
      pattern2 = createSquarePattern(cfg);
      break;
  }
  return pattern2;
}
function pattern(key) {
  var _this = this;
  return function(params) {
    var _a2;
    var options = params.options, chart = params.chart;
    var patternOption = options.pattern;
    if (!patternOption) {
      return params;
    }
    var style = function(datum) {
      var _a3, _b, _c;
      var args = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
      }
      var defaultColor = chart.getTheme().defaultColor;
      var color2 = defaultColor;
      var colorAttribute = (_b = (_a3 = chart.geometries) === null || _a3 === void 0 ? void 0 : _a3[0]) === null || _b === void 0 ? void 0 : _b.getAttribute("color");
      if (colorAttribute) {
        var colorField = colorAttribute.getFields()[0];
        var seriesValue = get(datum, colorField);
        color2 = Util.getMappingValue(colorAttribute, seriesValue, ((_c = colorAttribute.values) === null || _c === void 0 ? void 0 : _c[0]) || defaultColor);
      }
      var pattern2 = patternOption;
      if (typeof patternOption === "function") {
        pattern2 = patternOption.call(_this, datum, color2);
      }
      if (pattern2 instanceof CanvasPattern === false) {
        pattern2 = getCanvasPattern(deepAssign({}, { cfg: { backgroundColor: color2 } }, pattern2));
      }
      var styleOption = options[key];
      return __assign$1(__assign$1({}, typeof styleOption === "function" ? styleOption.call.apply(styleOption, __spreadArray$1([_this, datum], args, false)) : styleOption || {}), { fill: pattern2 || color2 });
    };
    return deepAssign({}, params, { options: (_a2 = {}, _a2[key] = style, _a2) });
  };
}
function legend$g(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, seriesField = options.seriesField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (colorField || seriesField) {
    chart.legend(colorField || seriesField, legend2);
  }
  return params;
}
function tooltip$9(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 !== void 0) {
    chart.tooltip(tooltip2);
  }
  return params;
}
function interaction$8(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions;
  each$1(interactions, function(i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function animation$5(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  addViewAnimation(chart, animation2);
  return params;
}
function theme$2(params) {
  var chart = params.chart, options = params.options;
  var theme2 = options.theme;
  if (theme2) {
    chart.theme(theme2);
  }
  return params;
}
function state(params) {
  var chart = params.chart, options = params.options;
  var state2 = options.state;
  if (state2) {
    each$1(chart.geometries, function(geometry2) {
      geometry2.state(state2);
    });
  }
  return params;
}
function slider$2(params) {
  var chart = params.chart, options = params.options;
  var slider2 = options.slider;
  chart.option("slider", slider2);
  return params;
}
function scrollbar(params) {
  var chart = params.chart, options = params.options;
  var scrollbar2 = options.scrollbar;
  chart.option("scrollbar", scrollbar2);
  return params;
}
function scale$2(axes, meta2) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var scales = {};
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
    scales = deepAssign({}, meta2, options.meta, scales);
    chart.scale(scales);
    return params;
  };
}
function annotation$2(annotationOptions) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var annotationController = chart.getController("annotation");
    each$1(__spreadArray$1(__spreadArray$1([], options.annotations || [], true), annotationOptions || [], true), function(annotationOption) {
      annotationController.annotation(annotationOption);
    });
    return params;
  };
}
function limitInPlot$2(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis, limitInPlot2 = options.limitInPlot;
  var value2 = limitInPlot2;
  if (isObject(yAxis) && isNil(limitInPlot2)) {
    if (Object.values(pick(yAxis, ["min", "max", "minLimit", "maxLimit"])).some(function(value3) {
      return !isNil(value3);
    })) {
      value2 = true;
    } else {
      value2 = false;
    }
  }
  chart.limitInPlot = value2;
  return params;
}
function transformations(coordinateType) {
  if (coordinateType === void 0) {
    coordinateType = "rect";
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var coordinate2 = options.coordinate;
    var actions = Array.from(coordinate2 || []).map(function(cfg) {
      if (cfg.type === "reflectX")
        return ["reflect", "x"];
      if (cfg.type === "reflectY")
        return ["reflect", "y"];
      if (cfg.type === "transpose")
        return ["transpose"];
      return null;
    }).filter(function(d) {
      return !!d;
    });
    if (actions.length !== 0) {
      chart.coordinate({ type: coordinateType, actions });
    }
    return params;
  };
}
var GLOBAL = {
  /**  */
  locale: "en-US"
};
var LocaleMap = {};
function registerLocale(locale, localeObj) {
  LocaleMap[locale] = localeObj;
}
function getLocale(locale) {
  return {
    get: function(key, obj) {
      return template(get(LocaleMap[locale], key) || get(LocaleMap[GLOBAL.locale], key) || get(LocaleMap["en-US"], key) || key, obj);
    }
  };
}
var EN_US_LOCALE = {
  locale: "en-US",
  // General
  general: {
    increase: "Increase",
    decrease: "Decrease",
    root: "Root"
  },
  // Plot Components
  /** statistic text component */
  statistic: {
    total: "Total"
  },
  /** conversionTag component */
  conversionTag: {
    label: "Rate"
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  // Plots
  waterfall: {
    total: "Total"
  }
};
var ZH_CN_LOCALE = {
  locale: "zh-CN",
  // 
  general: {
    increase: "",
    decrease: "",
    root: ""
  },
  // 
  /**  */
  statistic: {
    total: ""
  },
  /**  */
  conversionTag: {
    label: ""
  },
  legend: {},
  tooltip: {},
  slider: {},
  scrollbar: {},
  // 
  waterfall: {
    total: ""
  }
};
function getTooltipMapping(tooltip2, defaultFields) {
  if (tooltip2 === false) {
    return {
      fields: false
      //  tooltip
    };
  }
  var fields = get(tooltip2, "fields");
  var formatter = get(tooltip2, "formatter");
  if (formatter && !fields) {
    fields = defaultFields;
  }
  return {
    fields,
    formatter
  };
}
function getMappingField(o, field2) {
  var type = o.type, xField = o.xField, yField = o.yField, colorField = o.colorField, shapeField = o.shapeField, sizeField = o.sizeField, styleField = o.styleField;
  var rawFields = o.rawFields;
  var fields = [];
  rawFields = (isFunction(rawFields) ? rawFields(type, field2) : rawFields) || [];
  if (field2 === "color") {
    fields = __spreadArray$1([colorField || xField], rawFields, true);
  } else if (field2 === "shape") {
    fields = __spreadArray$1([shapeField || xField], rawFields, true);
  } else if (field2 === "size") {
    fields = __spreadArray$1([sizeField || xField], rawFields, true);
  } else {
    fields = __spreadArray$1([xField, yField, colorField, shapeField, sizeField, styleField], rawFields, true);
    var idx = ["x", "y", "color", "shape", "size", "style"].indexOf(field2);
    var f = fields[idx];
    fields.splice(idx, 1);
    fields.unshift(f);
  }
  var mappingFields = uniq$2(fields.filter(function(f2) {
    return !!f2;
  }));
  var tileMappingField = type === "line" && [xField, yField].includes(mappingFields.join("*")) ? "" : mappingFields.join("*");
  return {
    mappingFields,
    tileMappingField
  };
}
function getMappingFunction(mappingFields, func) {
  if (!func)
    return void 0;
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var params = {};
    mappingFields.forEach(function(f, idx) {
      params[f] = args[idx];
    });
    delete params["undefined"];
    return func(params);
  };
}
function geometry$x(params) {
  var chart = params.chart, options = params.options;
  var type = options.type, args = options.args, mapping = options.mapping, xField = options.xField, yField = options.yField, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, tooltipFields = options.tooltipFields, label2 = options.label, state2 = options.state, customInfo = options.customInfo;
  if (!mapping) {
    return params;
  }
  var color2 = mapping.color, shape = mapping.shape, size2 = mapping.size, style = mapping.style, tooltip2 = mapping.tooltip;
  var geometry2 = chart[type](args).position("".concat(xField, "*").concat(yField));
  if (isString(color2)) {
    colorField ? geometry2.color(colorField, color2) : geometry2.color(color2);
  } else if (isFunction(color2)) {
    var _a2 = getMappingField(options, "color"), mappingFields = _a2.mappingFields, tileMappingField = _a2.tileMappingField;
    geometry2.color(tileMappingField, getMappingFunction(mappingFields, color2));
  } else {
    colorField && geometry2.color(colorField, color2);
  }
  if (isString(shape)) {
    shapeField ? geometry2.shape(shapeField, [shape]) : geometry2.shape(shape);
  } else if (isFunction(shape)) {
    var _b = getMappingField(options, "shape"), mappingFields = _b.mappingFields, tileMappingField = _b.tileMappingField;
    geometry2.shape(tileMappingField, getMappingFunction(mappingFields, shape));
  } else {
    shapeField && geometry2.shape(shapeField, shape);
  }
  if (isNumber$1(size2)) {
    sizeField ? geometry2.size(sizeField, size2) : geometry2.size(size2);
  } else if (isFunction(size2)) {
    var _c = getMappingField(options, "size"), mappingFields = _c.mappingFields, tileMappingField = _c.tileMappingField;
    geometry2.size(tileMappingField, getMappingFunction(mappingFields, size2));
  } else {
    sizeField && geometry2.size(sizeField, size2);
  }
  if (isFunction(style)) {
    var _d = getMappingField(options, "style"), mappingFields = _d.mappingFields, tileMappingField = _d.tileMappingField;
    geometry2.style(tileMappingField, getMappingFunction(mappingFields, style));
  } else if (isObject(style)) {
    geometry2.style(style);
  }
  if (tooltipFields === false) {
    geometry2.tooltip(false);
  } else if (!isEmpty(tooltipFields)) {
    geometry2.tooltip(tooltipFields.join("*"), getMappingFunction(tooltipFields, tooltip2));
  }
  if (label2 === false) {
    geometry2.label(false);
  } else if (label2) {
    var callback = label2.callback, fields = label2.fields, cfg = __rest(label2, ["callback", "fields"]);
    geometry2.label({
      fields: fields || [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  if (state2) {
    geometry2.state(state2);
  }
  if (customInfo) {
    geometry2.customInfo(customInfo);
  }
  [xField, yField].filter(function(f) {
    return f !== colorField;
  }).forEach(function(f) {
    chart.legend(f, false);
  });
  return __assign$1(__assign$1({}, params), {
    // geometry adaptor  geometry  adaptor type 
    ext: { geometry: geometry2 }
  });
}
function area(params) {
  var options = params.options;
  var area2 = options.area, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return area2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "area",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: deepMix({
        shape: smooth ? "smooth" : "area",
        tooltip: formatter
      }, area2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function edge(params) {
  var options = params.options;
  var edge2 = options.edge, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return edge2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "edge",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, edge2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function otherAdaptor(params) {
  var chart = params.chart, options = params.options, ext = params.ext;
  var seriesField = options.seriesField, isGroup = options.isGroup, isStack = options.isStack, marginRatio = options.marginRatio, widthRatio = options.widthRatio, groupField = options.groupField, theme2 = options.theme;
  var adjust2 = [];
  if (seriesField) {
    if (isGroup) {
      adjust2.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        marginRatio
      });
    }
    if (isStack) {
      adjust2.push({
        type: "stack",
        marginRatio
      });
    }
  }
  if (adjust2.length && (ext === null || ext === void 0 ? void 0 : ext.geometry)) {
    var g = ext === null || ext === void 0 ? void 0 : ext.geometry;
    g.adjust(adjust2);
  }
  if (!isNil(widthRatio)) {
    chart.theme(deepAssign({}, isObject(theme2) ? theme2 : getTheme(theme2), {
      // columWidthRatio  theme 
      columnWidthRatio: widthRatio
    }));
  }
  return params;
}
function interval(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, interval2 = options.interval, seriesField = options.seriesField, tooltip2 = options.tooltip, minColumnWidth = options.minColumnWidth, maxColumnWidth = options.maxColumnWidth, columnBackground = options.columnBackground, dodgePadding = options.dodgePadding, intervalPadding = options.intervalPadding, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  var ext = (interval2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "interval",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, interval2),
      args: {
        dodgePadding,
        intervalPadding,
        minColumnWidth,
        maxColumnWidth,
        background: columnBackground,
        useDeferredLabel
      }
    }
  })) : params).ext;
  return otherAdaptor(__assign$1(__assign$1({}, params), { ext }));
}
function line(params) {
  var options = params.options;
  var line2 = options.line, stepType = options.stepType, xField = options.xField, yField = options.yField, seriesField = options.seriesField, smooth = options.smooth, connectNulls = options.connectNulls, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return line2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "line",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: deepMix({
        shape: stepType || (smooth ? "smooth" : "line"),
        tooltip: formatter
      }, line2),
      args: { connectNulls, useDeferredLabel }
    }
  })) : params;
}
function point(params) {
  var options = params.options;
  var point2 = options.point, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, shapeField = options.shapeField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField, sizeField, shapeField]), fields = _a2.fields, formatter = _a2.formatter;
  return point2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "point",
      colorField: seriesField,
      shapeField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, point2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function polygon(params) {
  var options = params.options;
  var polygon2 = options.polygon, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return polygon2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "polygon",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, polygon2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function schema(params) {
  var options = params.options;
  var schema2 = options.schema, xField = options.xField, yField = options.yField, seriesField = options.seriesField, tooltip2 = options.tooltip, useDeferredLabel = options.useDeferredLabel;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField]), fields = _a2.fields, formatter = _a2.formatter;
  return schema2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "schema",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, schema2),
      args: { useDeferredLabel }
    }
  })) : params;
}
function violin(params) {
  var options = params.options;
  var violin2 = options.violin, xField = options.xField, yField = options.yField, seriesField = options.seriesField, sizeField = options.sizeField, tooltip2 = options.tooltip;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, seriesField, sizeField]), fields = _a2.fields, formatter = _a2.formatter;
  return violin2 ? geometry$x(deepAssign({}, params, {
    options: {
      type: "violin",
      colorField: seriesField,
      tooltipFields: fields,
      mapping: __assign$1({ tooltip: formatter }, violin2)
    }
  })) : params;
}
var lib = {};
var sensorPool = {};
var id = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var id2 = 1;
  var _default = function _default2() {
    return "".concat(id2++);
  };
  exports["default"] = _default;
})(id);
var sensors = {};
var object = {};
var debounce = {};
(function(exports) {
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  var _default = function _default2(fn) {
    var delay = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 60;
    var timer2 = null;
    return function() {
      var _this = this;
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }
      clearTimeout(timer2);
      timer2 = setTimeout(function() {
        fn.apply(_this, args);
      }, delay);
    };
  };
  exports["default"] = _default;
})(debounce);
var constant$2 = {};
Object.defineProperty(constant$2, "__esModule", {
  value: true
});
constant$2.SensorTabIndex = constant$2.SensorClassName = constant$2.SizeSensorId = void 0;
var SizeSensorId = "size-sensor-id";
constant$2.SizeSensorId = SizeSensorId;
var SensorClassName = "size-sensor-object";
constant$2.SensorClassName = SensorClassName;
var SensorTabIndex = "-1";
constant$2.SensorTabIndex = SensorTabIndex;
Object.defineProperty(object, "__esModule", {
  value: true
});
object.createSensor = void 0;
var _debounce$1 = _interopRequireDefault$2(debounce);
var _constant$1 = constant$2;
function _interopRequireDefault$2(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var createSensor$2 = function createSensor(element) {
  var sensor = void 0;
  var listeners = [];
  var newSensor = function newSensor2() {
    if (getComputedStyle(element).position === "static") {
      element.style.position = "relative";
    }
    var obj = document.createElement("object");
    obj.onload = function() {
      obj.contentDocument.defaultView.addEventListener("resize", resizeListener);
      resizeListener();
    };
    obj.style.display = "block";
    obj.style.position = "absolute";
    obj.style.top = "0";
    obj.style.left = "0";
    obj.style.height = "100%";
    obj.style.width = "100%";
    obj.style.overflow = "hidden";
    obj.style.pointerEvents = "none";
    obj.style.zIndex = "-1";
    obj.style.opacity = "0";
    obj.setAttribute("class", _constant$1.SensorClassName);
    obj.setAttribute("tabindex", _constant$1.SensorTabIndex);
    obj.type = "text/html";
    element.appendChild(obj);
    obj.data = "about:blank";
    return obj;
  };
  var resizeListener = (0, _debounce$1["default"])(function() {
    listeners.forEach(function(listener) {
      listener(element);
    });
  });
  var bind3 = function bind4(cb) {
    if (!sensor) {
      sensor = newSensor();
    }
    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  var destroy = function destroy2() {
    if (sensor && sensor.parentNode) {
      if (sensor.contentDocument) {
        sensor.contentDocument.defaultView.removeEventListener("resize", resizeListener);
      }
      sensor.parentNode.removeChild(sensor);
      sensor = void 0;
      listeners = [];
    }
  };
  var unbind = function unbind2(cb) {
    var idx = listeners.indexOf(cb);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };
  return {
    element,
    bind: bind3,
    destroy,
    unbind
  };
};
object.createSensor = createSensor$2;
var resizeObserver = {};
Object.defineProperty(resizeObserver, "__esModule", {
  value: true
});
resizeObserver.createSensor = void 0;
var _debounce = _interopRequireDefault$1(debounce);
function _interopRequireDefault$1(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var createSensor$1 = function createSensor2(element) {
  var sensor = void 0;
  var listeners = [];
  var resizeListener = (0, _debounce["default"])(function() {
    listeners.forEach(function(listener) {
      listener(element);
    });
  });
  var newSensor = function newSensor2() {
    var s = new ResizeObserver(resizeListener);
    s.observe(element);
    resizeListener();
    return s;
  };
  var bind3 = function bind4(cb) {
    if (!sensor) {
      sensor = newSensor();
    }
    if (listeners.indexOf(cb) === -1) {
      listeners.push(cb);
    }
  };
  var destroy = function destroy2() {
    sensor.disconnect();
    listeners = [];
    sensor = void 0;
  };
  var unbind = function unbind2(cb) {
    var idx = listeners.indexOf(cb);
    if (idx !== -1) {
      listeners.splice(idx, 1);
    }
    if (listeners.length === 0 && sensor) {
      destroy();
    }
  };
  return {
    element,
    bind: bind3,
    destroy,
    unbind
  };
};
resizeObserver.createSensor = createSensor$1;
Object.defineProperty(sensors, "__esModule", {
  value: true
});
sensors.createSensor = void 0;
var _object = object;
var _resizeObserver = resizeObserver;
var createSensor3 = typeof ResizeObserver !== "undefined" ? _resizeObserver.createSensor : _object.createSensor;
sensors.createSensor = createSensor3;
Object.defineProperty(sensorPool, "__esModule", {
  value: true
});
sensorPool.removeSensor = sensorPool.getSensor = void 0;
var _id = _interopRequireDefault(id);
var _sensors = sensors;
var _constant = constant$2;
function _interopRequireDefault(obj) {
  return obj && obj.__esModule ? obj : { "default": obj };
}
var Sensors = {};
var getSensor = function getSensor2(element) {
  var sensorId = element.getAttribute(_constant.SizeSensorId);
  if (sensorId && Sensors[sensorId]) {
    return Sensors[sensorId];
  }
  var newId = (0, _id["default"])();
  element.setAttribute(_constant.SizeSensorId, newId);
  var sensor = (0, _sensors.createSensor)(element);
  Sensors[newId] = sensor;
  return sensor;
};
sensorPool.getSensor = getSensor;
var removeSensor = function removeSensor2(sensor) {
  var sensorId = sensor.element.getAttribute(_constant.SizeSensorId);
  sensor.element.removeAttribute(_constant.SizeSensorId);
  sensor.destroy();
  if (sensorId && Sensors[sensorId]) {
    delete Sensors[sensorId];
  }
};
sensorPool.removeSensor = removeSensor;
Object.defineProperty(lib, "__esModule", {
  value: true
});
lib.ver = lib.clear = bind_1 = lib.bind = void 0;
var _sensorPool = sensorPool;
var bind = function bind2(element, cb) {
  var sensor = (0, _sensorPool.getSensor)(element);
  sensor.bind(cb);
  return function() {
    sensor.unbind(cb);
  };
};
var bind_1 = lib.bind = bind;
var clear = function clear2(element) {
  var sensor = (0, _sensorPool.getSensor)(element);
  (0, _sensorPool.removeSensor)(sensor);
};
lib.clear = clear;
var ver = "1.0.1";
lib.ver = ver;
var SOURCE_ATTRIBUTE_NAME = "data-chart-source-type";
var PLOT_CONTAINER_OPTIONS = [
  "padding",
  "appendPadding",
  "renderer",
  "pixelRatio",
  "syncViewPadding",
  "supportCSSTransform",
  "limitInPlot"
];
var Plot = (
  /** @class */
  function(_super) {
    __extends$1(Plot2, _super);
    function Plot2(container, options) {
      var _this = _super.call(this) || this;
      _this.container = typeof container === "string" ? document.getElementById(container) : container;
      _this.options = deepAssign({}, _this.getDefaultOptions(), options);
      _this.createG2();
      _this.bindEvents();
      return _this;
    }
    Plot2.getDefaultOptions = function() {
      return {
        renderer: "canvas",
        xAxis: {
          nice: true,
          label: {
            autoRotate: false,
            autoHide: { type: "equidistance", cfg: { minGap: 6 } }
          }
        },
        yAxis: {
          nice: true,
          label: {
            autoHide: true,
            autoRotate: false
          }
        },
        animation: true
      };
    };
    Plot2.prototype.createG2 = function() {
      var _a2 = this.options, width = _a2.width, height = _a2.height, defaultInteractions = _a2.defaultInteractions;
      this.chart = new Chart(__assign$1(__assign$1(__assign$1(__assign$1({ container: this.container, autoFit: false }, this.getChartSize(width, height)), { localRefresh: false }), pick(this.options, PLOT_CONTAINER_OPTIONS)), { defaultInteractions }));
      this.container.setAttribute(SOURCE_ATTRIBUTE_NAME, "G2Plot");
    };
    Plot2.prototype.getChartSize = function(width, height) {
      var chartSize = getContainerSize(this.container);
      return { width: width || chartSize.width || 400, height: height || chartSize.height || 400 };
    };
    Plot2.prototype.bindEvents = function() {
      var _this = this;
      if (this.chart) {
        this.chart.on("*", function(e) {
          if (e === null || e === void 0 ? void 0 : e.type) {
            _this.emit(e.type, e);
          }
        });
      }
    };
    Plot2.prototype.getDefaultOptions = function() {
      return Plot2.getDefaultOptions();
    };
    Plot2.prototype.render = function() {
      this.chart.clear();
      this.chart.options = {
        data: [],
        animate: true
      };
      this.chart.views = [];
      this.execAdaptor();
      this.chart.render();
      this.bindSizeSensor();
    };
    Plot2.prototype.update = function(options) {
      this.updateOption(options);
      this.render();
    };
    Plot2.prototype.updateOption = function(options) {
      this.options = deepAssign({}, this.options, options);
    };
    Plot2.prototype.setState = function(type, condition, status) {
      if (status === void 0) {
        status = true;
      }
      var elements = getAllElementsRecursively(this.chart);
      each$1(elements, function(ele) {
        if (condition(ele.getData())) {
          ele.setState(type, status);
        }
      });
    };
    Plot2.prototype.getStates = function() {
      var elements = getAllElementsRecursively(this.chart);
      var stateObjects = [];
      each$1(elements, function(element) {
        var data2 = element.getData();
        var states = element.getStates();
        each$1(states, function(state2) {
          stateObjects.push({ data: data2, state: state2, geometry: element.geometry, element });
        });
      });
      return stateObjects;
    };
    Plot2.prototype.changeData = function(data2) {
      this.update({ data: data2 });
    };
    Plot2.prototype.changeSize = function(width, height) {
      this.chart.changeSize(width, height);
    };
    Plot2.prototype.addAnnotations = function(annotations, view) {
      view = view ? view : this.chart;
      var incoming = __spreadArray$1([], annotations, true);
      var controller = view.getController("annotation");
      var current = controller.getComponents().map(function(co) {
        return co.extra;
      });
      controller.clear(true);
      var _loop_1 = function(i2) {
        var annotation2 = current[i2];
        var findIndex2 = incoming.findIndex(function(item) {
          return item.id && item.id === annotation2.id;
        });
        if (findIndex2 !== -1) {
          annotation2 = deepAssign({}, annotation2, incoming[findIndex2]);
          incoming.splice(findIndex2, 1);
        }
        controller.annotation(annotation2);
      };
      for (var i = 0; i < current.length; i++) {
        _loop_1(i);
      }
      incoming.forEach(function(annotation2) {
        return controller.annotation(annotation2);
      });
      view.render(true);
    };
    Plot2.prototype.removeAnnotations = function(annotations) {
      var controller = this.chart.getController("annotation");
      var current = controller.getComponents().map(function(co) {
        return co.extra;
      });
      controller.clear(true);
      var _loop_2 = function(i2) {
        var annotation2 = current[i2];
        if (!annotations.find(function(item) {
          return item.id && item.id === annotation2.id;
        })) {
          controller.annotation(annotation2);
        }
      };
      for (var i = 0; i < current.length; i++) {
        _loop_2(i);
      }
      this.chart.render(true);
    };
    Plot2.prototype.destroy = function() {
      this.unbindSizeSensor();
      this.chart.destroy();
      this.off();
      this.container.removeAttribute(SOURCE_ATTRIBUTE_NAME);
    };
    Plot2.prototype.execAdaptor = function() {
      var adaptor2 = this.getSchemaAdaptor();
      var _a2 = this.options, padding2 = _a2.padding, appendPadding = _a2.appendPadding;
      this.chart.padding = padding2;
      this.chart.appendPadding = appendPadding;
      adaptor2({
        chart: this.chart,
        options: this.options
      });
    };
    Plot2.prototype.triggerResize = function() {
      this.chart.forceFit();
    };
    Plot2.prototype.bindSizeSensor = function() {
      var _this = this;
      if (this.unbind) {
        return;
      }
      var _a2 = this.options.autoFit, autoFit = _a2 === void 0 ? true : _a2;
      if (autoFit) {
        this.unbind = bind_1(this.container, function() {
          var _a3 = getContainerSize(_this.container), width = _a3.width, height = _a3.height;
          if (width !== _this.chart.width || height !== _this.chart.height) {
            _this.triggerResize();
          }
        });
      }
    };
    Plot2.prototype.unbindSizeSensor = function() {
      if (this.unbind) {
        this.unbind();
        this.unbind = void 0;
      }
    };
    return Plot2;
  }(EventEmitter)
);
function percent(data2, measure, groupField, as) {
  var sumMap = reduce(data2, function(map2, datum) {
    var groupValue = datum[groupField];
    var sum = map2.has(groupValue) ? map2.get(groupValue) : 0;
    var v = datum[measure];
    sum = isRealNumber(v) ? sum + v : sum;
    map2.set(groupValue, sum);
    return map2;
  }, /* @__PURE__ */ new Map());
  return map$2(data2, function(datum) {
    var _a2;
    var v = datum[measure];
    var groupValue = datum[groupField];
    var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
    return __assign$1(__assign$1({}, datum), (_a2 = {}, _a2[as] = percentage, _a2));
  });
}
function getDeepPercent(data2, measure, fields, percent2) {
  var sumMap = reduce(data2, function(map2, datum) {
    var groupValue = reduce(fields, function(value2, field2) {
      return "".concat(value2).concat(datum[field2]);
    }, "");
    var sum = map2.has(groupValue) ? map2.get(groupValue) : 0;
    var v = datum[measure];
    sum = isRealNumber(v) ? sum + v : sum;
    map2.set(groupValue, sum);
    return map2;
  }, /* @__PURE__ */ new Map());
  return map$2(data2, function(datum) {
    var _a2;
    var v = datum[measure];
    var groupValue = reduce(fields, function(value2, field2) {
      return "".concat(value2).concat(datum[field2]);
    }, "");
    var percentage = isRealNumber(v) && sumMap.get(groupValue) !== 0 ? v / sumMap.get(groupValue) : 0;
    return __assign$1(__assign$1({}, datum), (_a2 = {}, _a2[percent2] = percentage, _a2));
  });
}
function getDataWhetherPercentage(data2, yField, groupField, asField, isPercent) {
  return !isPercent ? data2 : percent(data2, yField, groupField, asField);
}
function geometry$w(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, lineStyle = options.lineStyle, lineShape = options.lineShape, pointMapping = options.point, areaMapping = options.area, seriesField = options.seriesField;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var areaState = areaMapping === null || areaMapping === void 0 ? void 0 : areaMapping.state;
  chart.data(data2);
  var primary = deepAssign({}, params, {
    options: {
      shapeField: seriesField,
      line: {
        color: color2,
        style: lineStyle,
        shape: lineShape
      },
      //  tooltip 
      // 
      point: pointMapping && __assign$1({ color: color2, shape: "circle" }, pointMapping),
      // 
      area: areaMapping && __assign$1({ color: color2 }, areaMapping),
      // label  geometry adaptor label adaptor 
      label: void 0
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  var areaParams = deepAssign({}, primary, { options: { tooltip: false, state: areaState } });
  line(primary);
  point(second);
  area(areaParams);
  return params;
}
function meta$l(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data2 = options.data;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = adjustYMetaByZero(data2, yField), _b)))(params);
}
function coordinate$9(params) {
  var chart = params.chart, options = params.options;
  var reflect = options.reflect;
  if (reflect) {
    var p = reflect;
    if (!isArray$1(p)) {
      p = [p];
    }
    var actions = p.map(function(d) {
      return ["reflect", d];
    });
    chart.coordinate({ type: "rect", actions });
  }
  return params;
}
function axis$k(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$f(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 && seriesField) {
    chart.legend(seriesField, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function label$f(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var lineGeometry = findGeometry(chart, "line");
  if (!label2) {
    lineGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    lineGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$1({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust$1(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack;
  if (isStack) {
    each$1(chart.geometries, function(g) {
      g.adjust("stack");
    });
  }
  return params;
}
function adaptor$y(params) {
  return flow(geometry$w, meta$l, adjust$1, theme$2, coordinate$9, axis$k, legend$f, tooltip$9, label$f, slider$2, scrollbar, interaction$8, animation$5, annotation$2(), limitInPlot$2)(params);
}
function geometry$v(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, areaStyle = options.areaStyle, areaShape = options.areaShape, color2 = options.color, pointMapping = options.point, lineMapping = options.line, isPercent = options.isPercent, xField = options.xField, yField = options.yField, tooltip2 = options.tooltip, seriesField = options.seriesField, startOnZero = options.startOnZero;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var chartData = getDataWhetherPercentage(data2, yField, xField, yField, isPercent);
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign$1({ formatter: function(datum) {
    return {
      name: datum[seriesField] || datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip2) : tooltip2;
  var primary = deepAssign({}, params, {
    options: {
      area: {
        color: color2,
        style: areaStyle,
        shape: areaShape
      },
      point: pointMapping && __assign$1({ color: color2 }, pointMapping),
      tooltip: tooltipOptions,
      // label  geometry adaptor label adaptor 
      label: void 0,
      args: {
        startOnZero
      }
    }
  });
  var lineParams = {
    chart,
    options: deepAssign({ line: { size: 2 } }, omit$1(options, ["state"]), {
      //  tooltip 
      // 
      line: lineMapping && __assign$1({ color: color2 }, lineMapping),
      sizeField: seriesField,
      state: lineMapping === null || lineMapping === void 0 ? void 0 : lineMapping.state,
      tooltip: false,
      // label  geometry adaptor label adaptor 
      label: void 0,
      args: {
        startOnZero
      }
    })
  };
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(lineParams);
  point(pointParams);
  return params;
}
function label$e(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var areaGeometry = findGeometry(chart, "area");
  if (!label2) {
    areaGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    areaGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$1({ layout: [
        { type: "limit-in-plot" },
        { type: "path-adjust-position" },
        { type: "point-adjust-position" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ] }, transformLabel(cfg))
    });
  }
  return params;
}
function adjust(params) {
  var chart = params.chart, options = params.options;
  var isStack = options.isStack, isPercent = options.isPercent, seriesField = options.seriesField;
  if ((isPercent || isStack) && seriesField) {
    each$1(chart.geometries, function(g) {
      g.adjust("stack");
    });
  }
  return params;
}
function adaptor$x(params) {
  return flow(theme$2, pattern("areaStyle"), transformations("rect"), geometry$v, meta$l, adjust, axis$k, legend$f, tooltip$9, label$e, slider$2, annotation$2(), interaction$8, animation$5, limitInPlot$2)(params);
}
var DEFAULT_OPTIONS$z = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  isStack: true,
  // 
  line: {},
  legend: {
    position: "top-left",
    radio: {}
  }
});
var Area = (
  /** @class */
  function(_super) {
    __extends$1(Area2, _super);
    function Area2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "area";
      return _this;
    }
    Area2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$z;
    };
    Area2.prototype.getDefaultOptions = function() {
      return Area2.getDefaultOptions();
    };
    Area2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this.options, isPercent = _a2.isPercent, xField = _a2.xField, yField = _a2.yField;
      var _b = this, chart = _b.chart, options = _b.options;
      meta$l({ chart, options });
      this.chart.changeData(getDataWhetherPercentage(data2, yField, xField, yField, isPercent));
    };
    Area2.prototype.getSchemaAdaptor = function() {
      return adaptor$x;
    };
    return Area2;
  }(Plot)
);
var PADDING_RIGHT = 10;
var PADDING_TOP$1 = 5;
var BUTTON_ACTION_CONFIG = {
  padding: [8, 10],
  text: "reset",
  textStyle: {
    default: {
      x: 0,
      y: 0,
      fontSize: 12,
      fill: "#333333",
      cursor: "pointer"
    }
  },
  buttonStyle: {
    default: {
      fill: "#f7f7f7",
      stroke: "#cccccc",
      cursor: "pointer"
    },
    active: {
      fill: "#e6e6e6"
    }
  }
};
var ButtonAction = (
  /** @class */
  function(_super) {
    __extends$1(ButtonAction2, _super);
    function ButtonAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.buttonGroup = null;
      _this.buttonCfg = __assign$1({ name: "button" }, BUTTON_ACTION_CONFIG);
      return _this;
    }
    ButtonAction2.prototype.getButtonCfg = function() {
      var view = this.context.view;
      var buttonCfg = get(view, ["interactions", "filter-action", "cfg", "buttonConfig"]);
      return deepAssign(this.buttonCfg, buttonCfg, this.cfg);
    };
    ButtonAction2.prototype.drawButton = function() {
      var config = this.getButtonCfg();
      var group2 = this.context.view.foregroundGroup.addGroup({
        name: config.name
      });
      var textShape = this.drawText(group2);
      this.drawBackground(group2, textShape.getBBox());
      this.buttonGroup = group2;
    };
    ButtonAction2.prototype.drawText = function(group2) {
      var _a2;
      var config = this.getButtonCfg();
      return group2.addShape({
        type: "text",
        name: "button-text",
        attrs: __assign$1({ text: config.text }, (_a2 = config.textStyle) === null || _a2 === void 0 ? void 0 : _a2.default)
      });
    };
    ButtonAction2.prototype.drawBackground = function(group2, bbox) {
      var _a2;
      var config = this.getButtonCfg();
      var padding2 = normalPadding(config.padding);
      var buttonShape = group2.addShape({
        type: "rect",
        name: "button-rect",
        attrs: __assign$1({ x: bbox.x - padding2[3], y: bbox.y - padding2[0], width: bbox.width + padding2[1] + padding2[3], height: bbox.height + padding2[0] + padding2[2] }, (_a2 = config.buttonStyle) === null || _a2 === void 0 ? void 0 : _a2.default)
      });
      buttonShape.toBack();
      group2.on("mouseenter", function() {
        var _a3;
        buttonShape.attr((_a3 = config.buttonStyle) === null || _a3 === void 0 ? void 0 : _a3.active);
      });
      group2.on("mouseleave", function() {
        var _a3;
        buttonShape.attr((_a3 = config.buttonStyle) === null || _a3 === void 0 ? void 0 : _a3.default);
      });
      return buttonShape;
    };
    ButtonAction2.prototype.resetPosition = function() {
      var view = this.context.view;
      var coord2 = view.getCoordinate();
      var point2 = coord2.convert({ x: 1, y: 1 });
      var buttonGroup = this.buttonGroup;
      var bbox = buttonGroup.getBBox();
      var matrix = Util.transform(null, [
        ["t", point2.x - bbox.width - PADDING_RIGHT, point2.y + bbox.height + PADDING_TOP$1]
      ]);
      buttonGroup.setMatrix(matrix);
    };
    ButtonAction2.prototype.show = function() {
      if (!this.buttonGroup) {
        this.drawButton();
      }
      this.resetPosition();
      this.buttonGroup.show();
    };
    ButtonAction2.prototype.hide = function() {
      if (this.buttonGroup) {
        this.buttonGroup.hide();
      }
    };
    ButtonAction2.prototype.destroy = function() {
      var buttonGroup = this.buttonGroup;
      if (buttonGroup) {
        buttonGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return ButtonAction2;
  }(Action)
);
registerAction("brush-reset-button", ButtonAction, {
  name: "brush-reset-button"
});
registerInteraction("filter-action", {});
function isPointInView(context) {
  return context.isInPlot();
}
function getInteractionCfg(interactionType, brushType, options) {
  var _a2 = options || {}, mask = _a2.mask, isStartEnable = _a2.isStartEnable;
  var maskType = brushType || "rect";
  switch (interactionType) {
    case "brush":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView,
            action: ["brush:start", "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            // action
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: ["".concat(maskType, "-mask:resize")]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: [
              "brush:filter",
              "brush:end",
              "".concat(maskType, "-mask:end"),
              "".concat(maskType, "-mask:hide"),
              "brush-reset-button:show"
            ]
          }
        ],
        rollback: [
          {
            trigger: "brush-reset-button:click",
            action: ["brush:reset", "brush-reset-button:hide", "cursor:crosshair"]
          }
        ]
      };
    case "brush-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mousemove", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          {
            trigger: "plot:mousemove",
            action: "cursor:default",
            isEnable: function(context) {
              return isStartEnable ? !isStartEnable(context) : false;
            }
          },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context) {
              return !context.isInShape("mask");
            },
            action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            //  1 action
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: ["".concat(maskType, "-mask:moveStart")]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: ["".concat(maskType, "-mask:resize")]
          },
          {
            trigger: "mask:drag",
            action: ["".concat(maskType, "-mask:move")]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: ["".concat(maskType, "-mask:end")] },
          { trigger: "mask:dragend", action: ["".concat(maskType, "-mask:moveEnd")] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")] }]
      };
    case "brush-x":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView,
            action: ["brush-x:start", "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            // action
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: ["".concat(maskType, "-mask:resize")]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: ["brush-x:filter", "brush-x:end", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-x:reset"] }]
      };
    case "brush-x-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context) {
              return !context.isInShape("mask");
            },
            action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            //  1 action
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: ["".concat(maskType, "-mask:moveStart")]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: ["".concat(maskType, "-mask:resize")]
          },
          {
            trigger: "mask:drag",
            action: ["".concat(maskType, "-mask:move")]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: ["".concat(maskType, "-mask:end")] },
          { trigger: "mask:dragend", action: ["".concat(maskType, "-mask:moveEnd")] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")] }]
      };
    case "brush-y":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" }
        ],
        start: [
          {
            trigger: "mousedown",
            isEnable: isStartEnable || isPointInView,
            action: ["brush-y:start", "".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            // action
            arg: [null, { maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          }
        ],
        processing: [
          {
            trigger: "mousemove",
            isEnable: isPointInView,
            action: ["".concat(maskType, "-mask:resize")]
          }
        ],
        end: [
          {
            trigger: "mouseup",
            isEnable: isPointInView,
            action: ["brush-y:filter", "brush-y:end", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["brush-y:reset"] }]
      };
    case "brush-y-highlight":
      return {
        showEnable: [
          { trigger: "plot:mouseenter", action: "cursor:crosshair", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "mask:mouseenter", action: "cursor:move", isEnable: isStartEnable || function() {
            return true;
          } },
          { trigger: "plot:mouseleave", action: "cursor:default" },
          { trigger: "mask:mouseleave", action: "cursor:crosshair" }
        ],
        start: [
          {
            trigger: "plot:mousedown",
            isEnable: isStartEnable || function(context) {
              return !context.isInShape("mask");
            },
            action: ["".concat(maskType, "-mask:start"), "".concat(maskType, "-mask:show")],
            //  1 action
            arg: [{ maskStyle: mask === null || mask === void 0 ? void 0 : mask.style }]
          },
          {
            trigger: "mask:dragstart",
            action: ["".concat(maskType, "-mask:moveStart")]
          }
        ],
        processing: [
          {
            trigger: "plot:mousemove",
            action: ["".concat(maskType, "-mask:resize")]
          },
          {
            trigger: "mask:drag",
            action: ["".concat(maskType, "-mask:move")]
          },
          {
            trigger: "mask:change",
            action: ["element-range-highlight:highlight"]
          }
        ],
        end: [
          { trigger: "plot:mouseup", action: ["".concat(maskType, "-mask:end")] },
          { trigger: "mask:dragend", action: ["".concat(maskType, "-mask:moveEnd")] },
          {
            trigger: "document:mouseup",
            isEnable: function(context) {
              return !context.isInPlot();
            },
            action: ["element-range-highlight:clear", "".concat(maskType, "-mask:end"), "".concat(maskType, "-mask:hide")]
          }
        ],
        rollback: [{ trigger: "dblclick", action: ["element-range-highlight:clear", "".concat(maskType, "-mask:hide")] }]
      };
    default:
      return {};
  }
}
registerInteraction("brush", getInteractionCfg("brush"));
registerInteraction("brush-highlight", getInteractionCfg("brush-highlight"));
registerInteraction("brush-x", getInteractionCfg("brush-x", "x-rect"));
registerInteraction("brush-y", getInteractionCfg("brush-y", "y-rect"));
registerInteraction("brush-x-highlight", getInteractionCfg("brush-x-highlight", "x-rect"));
registerInteraction("brush-y-highlight", getInteractionCfg("brush-y-highlight", "y-rect"));
var BRUSH_TYPES = ["brush", "brush-x", "brush-y", "brush-highlight", "brush-x-highlight", "brush-y-highlight"];
function brushInteraction(params) {
  var options = params.options;
  var brush = options.brush;
  var interactions = filter(options.interactions || [], function(i) {
    return BRUSH_TYPES.indexOf(i.type) === -1;
  });
  if (brush === null || brush === void 0 ? void 0 : brush.enabled) {
    BRUSH_TYPES.forEach(function(type) {
      var enable = false;
      switch (brush.type) {
        case "x-rect":
          enable = type === (brush.action === "highlight" ? "brush-x-highlight" : "brush-x");
          break;
        case "y-rect":
          enable = type === (brush.action === "highlight" ? "brush-y-highlight" : "brush-y");
          break;
        default:
          enable = type === (brush.action === "highlight" ? "brush-highlight" : "brush");
          break;
      }
      var obj = { type, enable };
      if (brush) {
        obj.cfg = getInteractionCfg(type, brush.type, brush);
      }
      interactions.push(obj);
    });
    if ((brush === null || brush === void 0 ? void 0 : brush.action) !== "highlight") {
      interactions.push({
        type: "filter-action",
        cfg: {
          buttonConfig: brush.button
        }
      });
    }
  }
  return deepAssign({}, params, { options: { interactions } });
}
var INTERACTION_MAP = {
  hover: "__interval-connected-area-hover__",
  click: "__interval-connected-area-click__"
};
var getStartStages = function(trigger, style) {
  if (trigger === "hover") {
    return [
      {
        trigger: "interval:mouseenter",
        action: ["element-highlight-by-color:highlight", "element-link-by-color:link"],
        arg: [null, { style }]
      }
    ];
  }
  return [
    {
      trigger: "interval:click",
      action: [
        "element-highlight-by-color:clear",
        "element-highlight-by-color:highlight",
        "element-link-by-color:clear",
        "element-link-by-color:unlink",
        "element-link-by-color:link"
      ],
      arg: [null, null, null, null, { style }]
    }
  ];
};
registerInteraction(INTERACTION_MAP.hover, {
  start: getStartStages(INTERACTION_MAP.hover),
  end: [
    {
      trigger: "interval:mouseleave",
      action: ["element-highlight-by-color:reset", "element-link-by-color:unlink"]
    }
  ]
});
registerInteraction(INTERACTION_MAP.click, {
  start: getStartStages(INTERACTION_MAP.click),
  end: [
    {
      trigger: "document:mousedown",
      action: ["element-highlight-by-color:clear", "element-link-by-color:clear"]
    }
  ]
});
function connectedArea(disable) {
  if (disable === void 0) {
    disable = false;
  }
  return function(params) {
    var chart = params.chart, options = params.options;
    var connectedArea2 = options.connectedArea;
    var clear3 = function() {
      chart.removeInteraction(INTERACTION_MAP.hover);
      chart.removeInteraction(INTERACTION_MAP.click);
    };
    if (!disable && connectedArea2) {
      var trigger = connectedArea2.trigger || "hover";
      clear3();
      chart.interaction(INTERACTION_MAP[trigger], {
        start: getStartStages(trigger, connectedArea2.style)
      });
    } else {
      clear3();
    }
    return params;
  };
}
function conversionTagFormatter(prev, next) {
  if (!isNumber$1(prev) || !isNumber$1(next)) {
    return "-";
  }
  if (prev === 0 && next === 0) {
    return "-";
  }
  if (prev === next) {
    return "100%";
  }
  if (prev === 0) {
    return "";
  }
  return "".concat((100 * next / prev).toFixed(2), "%");
}
function getConversionTagOptionsWithDefaults(options, horizontal) {
  return deepAssign({
    size: horizontal ? 32 : 80,
    spacing: horizontal ? 8 : 12,
    offset: horizontal ? 32 : 0,
    arrow: options.arrow !== false && {
      headSize: 12,
      style: {
        fill: "rgba(0, 0, 0, 0.05)"
      }
    },
    text: options.text !== false && {
      style: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.85)",
        textAlign: "center",
        textBaseline: "middle"
      },
      formatter: conversionTagFormatter
    }
  }, options);
}
function parsePoints(coordinate2, element) {
  return map$2(element.getModel().points, function(point2) {
    return coordinate2.convertPoint(point2);
  });
}
function renderArrowTag(config, elemPrev, elemNext) {
  var view = config.view, geometry2 = config.geometry, group2 = config.group, options = config.options, horizontal = config.horizontal;
  var offset = options.offset, size2 = options.size, arrow = options.arrow;
  var coordinate2 = view.getCoordinate();
  var pointPrev = parsePoints(coordinate2, elemPrev)[3];
  var pointNext = parsePoints(coordinate2, elemNext)[0];
  var totalHeight = pointNext.y - pointPrev.y;
  var totalWidth = pointNext.x - pointPrev.x;
  if (typeof arrow === "boolean") {
    return;
  }
  var headSize = arrow.headSize;
  var spacing = options.spacing;
  var points2;
  if (horizontal) {
    if ((totalWidth - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalWidth - headSize) / 2);
      points2 = [
        [pointPrev.x + spacing, pointPrev.y - offset],
        [pointPrev.x + spacing, pointPrev.y - offset - size2],
        [pointNext.x - spacing, pointNext.y - offset - size2 / 2]
      ];
    } else {
      points2 = [
        [pointPrev.x + spacing, pointPrev.y - offset],
        [pointPrev.x + spacing, pointPrev.y - offset - size2],
        [pointNext.x - spacing - headSize, pointNext.y - offset - size2],
        [pointNext.x - spacing, pointNext.y - offset - size2 / 2],
        [pointNext.x - spacing - headSize, pointNext.y - offset]
      ];
    }
  } else {
    if ((totalHeight - headSize) / 2 < spacing) {
      spacing = Math.max(1, (totalHeight - headSize) / 2);
      points2 = [
        [pointPrev.x + offset, pointPrev.y + spacing],
        [pointPrev.x + offset + size2, pointPrev.y + spacing],
        [pointNext.x + offset + size2 / 2, pointNext.y - spacing]
      ];
    } else {
      points2 = [
        [pointPrev.x + offset, pointPrev.y + spacing],
        [pointPrev.x + offset + size2, pointPrev.y + spacing],
        [pointNext.x + offset + size2, pointNext.y - spacing - headSize],
        [pointNext.x + offset + size2 / 2, pointNext.y - spacing],
        [pointNext.x + offset, pointNext.y - spacing - headSize]
      ];
    }
  }
  group2.addShape("polygon", {
    id: "".concat(view.id, "-conversion-tag-arrow-").concat(geometry2.getElementId(elemPrev.getModel().mappingData)),
    name: "conversion-tag-arrow",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign$1(__assign$1({}, arrow.style || {}), { points: points2 })
  });
}
function renderTextTag(config, elemPrev, elemNext) {
  var _a2, _b, _c;
  var view = config.view, geometry2 = config.geometry, group2 = config.group, options = config.options, field2 = config.field, horizontal = config.horizontal;
  var offset = options.offset, size2 = options.size;
  if (typeof options.text === "boolean") {
    return;
  }
  var coordinate2 = view.getCoordinate();
  var text2 = ((_a2 = options.text) === null || _a2 === void 0 ? void 0 : _a2.formatter) && ((_b = options.text) === null || _b === void 0 ? void 0 : _b.formatter(elemPrev.getData()[field2], elemNext.getData()[field2]));
  var pointPrev = parsePoints(coordinate2, elemPrev)[horizontal ? 3 : 0];
  var pointNext = parsePoints(coordinate2, elemNext)[horizontal ? 0 : 3];
  var textShape = group2.addShape("text", {
    id: "".concat(view.id, "-conversion-tag-text-").concat(geometry2.getElementId(elemPrev.getModel().mappingData)),
    name: "conversion-tag-text",
    origin: {
      element: elemPrev,
      nextElement: elemNext
    },
    attrs: __assign$1(__assign$1({}, ((_c = options.text) === null || _c === void 0 ? void 0 : _c.style) || {}), { text: text2, x: horizontal ? (pointPrev.x + pointNext.x) / 2 : pointPrev.x + offset + size2 / 2, y: horizontal ? pointPrev.y - offset - size2 / 2 : (pointPrev.y + pointNext.y) / 2 })
  });
  if (horizontal) {
    var totalWidth = pointNext.x - pointPrev.x;
    var textWidth = textShape.getBBox().width;
    if (textWidth > totalWidth) {
      var cWidth = textWidth / text2.length;
      var cEnd = Math.max(1, Math.ceil(totalWidth / cWidth) - 1);
      var textAdjusted = "".concat(text2.slice(0, cEnd), "...");
      textShape.attr("text", textAdjusted);
    }
  }
}
function renderTag(options, elemPrev, elemNext) {
  renderArrowTag(options, elemPrev, elemNext);
  renderTextTag(options, elemPrev, elemNext);
}
function conversionTag$3(field2, horizontal, disabled) {
  if (horizontal === void 0) {
    horizontal = true;
  }
  if (disabled === void 0) {
    disabled = false;
  }
  return function(params) {
    var options = params.options, chart = params.chart;
    var conversionTag2 = options.conversionTag, theme2 = options.theme;
    if (conversionTag2 && !disabled) {
      chart.theme(deepAssign({}, isObject(theme2) ? theme2 : getTheme(theme2), {
        columnWidthRatio: 1 / 3
      }));
      chart.annotation().shape({
        render: function(container, view) {
          var group2 = container.addGroup({
            id: "".concat(chart.id, "-conversion-tag-group"),
            name: "conversion-tag-group"
          });
          var interval2 = find$1(chart.geometries, function(geom) {
            return geom.type === "interval";
          });
          var config = {
            view,
            geometry: interval2,
            group: group2,
            field: field2,
            horizontal,
            options: getConversionTagOptionsWithDefaults(conversionTag2, horizontal)
          };
          var elements = interval2.elements;
          each$1(elements, function(elem, idx) {
            if (idx > 0) {
              renderTag(config, elements[idx - 1], elem);
            }
          });
        }
      });
    }
    return params;
  };
}
function defaultOptions$6(params) {
  var options = params.options;
  var legend2 = options.legend;
  var seriesField = options.seriesField, isStack = options.isStack;
  if (seriesField) {
    if (legend2 !== false) {
      legend2 = __assign$1({ position: isStack ? "right-top" : "top-left" }, legend2);
    }
  } else {
    legend2 = false;
  }
  params.options.legend = legend2;
  return params;
}
function geometry$u(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, columnStyle = options.columnStyle, color2 = options.color, columnWidthRatio = options.columnWidthRatio, isPercent = options.isPercent, isGroup = options.isGroup, isStack = options.isStack, xField = options.xField, yField = options.yField, seriesField = options.seriesField, groupField = options.groupField, tooltip2 = options.tooltip, shape = options.shape;
  var percentData = isPercent && isGroup && isStack ? getDeepPercent(data2, yField, [xField, groupField], yField) : getDataWhetherPercentage(data2, yField, xField, yField, isPercent);
  var chartData = [];
  if (isStack && seriesField && !isGroup) {
    percentData.forEach(function(item) {
      var stackedItem = chartData.find(function(v) {
        return v[xField] === item[xField] && v[seriesField] === item[seriesField];
      });
      if (stackedItem) {
        stackedItem[yField] += item[yField] || 0;
      } else {
        chartData.push(__assign$1({}, item));
      }
    });
  } else {
    chartData = percentData;
  }
  chart.data(chartData);
  var tooltipOptions = isPercent ? __assign$1({ formatter: function(datum) {
    var _a2;
    return {
      name: isGroup && isStack ? "".concat(datum[seriesField], " - ").concat(datum[groupField]) : (_a2 = datum[seriesField]) !== null && _a2 !== void 0 ? _a2 : datum[xField],
      value: (Number(datum[yField]) * 100).toFixed(2) + "%"
    };
  } }, tooltip2) : tooltip2;
  var p = deepAssign({}, params, {
    options: {
      data: chartData,
      widthRatio: columnWidthRatio,
      tooltip: tooltipOptions,
      interval: {
        shape,
        style: columnStyle,
        color: color2
      }
    }
  });
  interval(p);
  return p;
}
function meta$k(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, data2 = options.data, isPercent = options.isPercent;
  var percentYMeta = isPercent ? { max: 1, min: 0, minLimit: 0, maxLimit: 1 } : {};
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2), (_b = {}, _b[xField] = {
    type: "cat"
  }, _b[yField] = __assign$1(__assign$1({}, adjustYMetaByZero(data2, yField)), percentYMeta), _b)))(params);
}
function axis$j(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$e(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 && seriesField) {
    chart.legend(seriesField, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function label$d(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField, isRange = options.isRange;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [yField],
      callback,
      cfg: __assign$1({
        //  label layout  layout  position  layout
        layout: (cfg === null || cfg === void 0 ? void 0 : cfg.position) ? void 0 : [
          { type: "interval-adjust-position" },
          { type: "interval-hide-overlap" },
          { type: "adjust-color" },
          { type: "limit-in-plot", cfg: { action: "hide" } }
        ]
      }, transformLabel(isRange ? __assign$1({ content: function(item) {
        var _a2;
        return (_a2 = item[yField]) === null || _a2 === void 0 ? void 0 : _a2.join("-");
      } }, cfg) : cfg))
    });
  }
  return params;
}
function columnTooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, isGroup = options.isGroup, isStack = options.isStack, groupField = options.groupField, data2 = options.data, xField = options.xField, yField = options.yField, seriesField = options.seriesField;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (isGroup && isStack) {
      var customItems_1 = tooltipOptions.customItems;
      var tooltipFormatter_1 = (tooltipOptions === null || tooltipOptions === void 0 ? void 0 : tooltipOptions.formatter) || function(datum) {
        return { name: "".concat(datum[seriesField], " - ").concat(datum[groupField]), value: datum[yField] };
      };
      tooltipOptions = __assign$1(__assign$1({}, tooltipOptions), { customItems: function(originalItems) {
        var items = [];
        each$1(originalItems, function(item) {
          var datas = filter(data2, function(d) {
            return isMatch(d, pick(item.data, [xField, seriesField]));
          });
          datas.forEach(function(datum) {
            items.push(__assign$1(__assign$1(__assign$1({}, item), { value: datum[yField], data: datum, mappingData: { _origin: datum } }), tooltipFormatter_1(datum)));
          });
        });
        return customItems_1 ? customItems_1(items) : items;
      } });
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptor$w(params, isBar) {
  if (isBar === void 0) {
    isBar = false;
  }
  var options = params.options;
  var seriesField = options.seriesField;
  return flow(
    defaultOptions$6,
    // 
    theme$2,
    // theme  geometry 
    pattern("columnStyle"),
    state,
    transformations("rect"),
    geometry$u,
    meta$k,
    axis$j,
    legend$e,
    columnTooltip,
    slider$2,
    scrollbar,
    label$d,
    brushInteraction,
    interaction$8,
    animation$5,
    annotation$2(),
    conversionTag$3(options.yField, !isBar, !!seriesField),
    // 
    connectedArea(!options.isStack),
    limitInPlot$2
  )(params);
}
function defaultOptions$5(params) {
  var options = params.options;
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  var position = {
    left: "bottom",
    right: "top",
    top: "left",
    bottom: "right"
  };
  var verticalAxis = yAxis !== false ? __assign$1({ position: position[(yAxis === null || yAxis === void 0 ? void 0 : yAxis.position) || "left"] }, yAxis) : false;
  var horizontalAxis = xAxis !== false ? __assign$1({ position: position[(xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) || "bottom"] }, xAxis) : false;
  return __assign$1(__assign$1({}, params), { options: __assign$1(__assign$1({}, options), {
    xField: yField,
    yField: xField,
    //  xAxisyAxis  deepAssign
    xAxis: verticalAxis,
    yAxis: horizontalAxis
  }) });
}
function label$c(params) {
  var options = params.options;
  var label2 = options.label;
  if (label2 && !label2.position) {
    label2.position = "left";
    if (!label2.layout) {
      label2.layout = [
        { type: "interval-adjust-position" },
        { type: "interval-hide-overlap" },
        { type: "adjust-color" },
        { type: "limit-in-plot", cfg: { action: "hide" } }
      ];
    }
  }
  return deepAssign({}, params, { options: { label: label2 } });
}
function legend$d(params) {
  var options = params.options;
  var seriesField = options.seriesField, isStack = options.isStack;
  var legend2 = options.legend;
  if (seriesField) {
    if (legend2 !== false) {
      legend2 = __assign$1({ position: isStack ? "top-left" : "right-top" }, legend2 || {});
    }
  } else {
    legend2 = false;
  }
  return deepAssign({}, params, { options: { legend: legend2 } });
}
function coordinate$8(params) {
  var options = params.options;
  var coordinateOptions = [{ type: "transpose" }, { type: "reflectY" }].concat(options.coordinate || []);
  return deepAssign({}, params, { options: { coordinate: coordinateOptions } });
}
function geometry$t(params) {
  var chart = params.chart, options = params.options;
  var barStyle = options.barStyle, barWidthRatio = options.barWidthRatio, minBarWidth = options.minBarWidth, maxBarWidth = options.maxBarWidth, barBackground = options.barBackground;
  return adaptor$w({
    chart,
    options: __assign$1(__assign$1({}, options), {
      // rename attrs as column
      columnStyle: barStyle,
      columnWidthRatio: barWidthRatio,
      minColumnWidth: minBarWidth,
      maxColumnWidth: maxBarWidth,
      columnBackground: barBackground
    })
  }, true);
}
function adaptor$v(params) {
  return flow(defaultOptions$5, label$c, legend$d, tooltip$9, coordinate$8, geometry$t)(params);
}
var DEFAULT_OPTIONS$y = deepAssign({}, Plot.getDefaultOptions(), {
  barWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  legend: {
    radio: {}
  },
  interactions: [{ type: "active-region" }]
});
var Bar = (
  /** @class */
  function(_super) {
    __extends$1(Bar2, _super);
    function Bar2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "bar";
      return _this;
    }
    Bar2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$y;
    };
    Bar2.prototype.changeData = function(data2) {
      var _a2, _b;
      this.updateOption({ data: data2 });
      var _c = this, chart = _c.chart, options = _c.options;
      var isPercent = options.isPercent;
      var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
      _a2 = [yField, xField], xField = _a2[0], yField = _a2[1];
      _b = [yAxis, xAxis], xAxis = _b[0], yAxis = _b[1];
      var switchedFieldOptions = __assign$1(__assign$1({}, options), { xField, yField, yAxis, xAxis });
      meta$k({ chart, options: switchedFieldOptions });
      chart.changeData(getDataWhetherPercentage(data2, xField, yField, xField, isPercent));
    };
    Bar2.prototype.getDefaultOptions = function() {
      return Bar2.getDefaultOptions();
    };
    Bar2.prototype.getSchemaAdaptor = function() {
      return adaptor$v;
    };
    return Bar2;
  }(Plot)
);
var DEFAULT_OPTIONS$x = deepAssign({}, Plot.getDefaultOptions(), {
  columnWidthRatio: 0.6,
  marginRatio: 1 / 32,
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20
  },
  legend: {
    radio: {}
  },
  interactions: [{ type: "active-region" }]
});
var Column = (
  /** @class */
  function(_super) {
    __extends$1(Column2, _super);
    function Column2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "column";
      return _this;
    }
    Column2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$x;
    };
    Column2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this.options, yField = _a2.yField, xField = _a2.xField, isPercent = _a2.isPercent;
      var _b = this, chart = _b.chart, options = _b.options;
      meta$k({ chart, options });
      this.chart.changeData(getDataWhetherPercentage(data2, yField, xField, yField, isPercent));
    };
    Column2.prototype.getDefaultOptions = function() {
      return Column2.getDefaultOptions();
    };
    Column2.prototype.getSchemaAdaptor = function() {
      return adaptor$w;
    };
    return Column2;
  }(Plot)
);
var _a$2;
var FUNNEL_PERCENT = "$$percentage$$";
var FUNNEL_MAPPING_VALUE = "$$mappingValue$$";
var FUNNEL_CONVERSATION = "$$conversion$$";
var FUNNEL_TOTAL_PERCENT = "$$totalPercentage$$";
var PLOYGON_X = "$$x$$";
var PLOYGON_Y = "$$y$$";
var DEFAULT_OPTIONS$w = {
  appendPadding: [0, 80],
  minSize: 0,
  maxSize: 1,
  meta: (_a$2 = {}, _a$2[FUNNEL_MAPPING_VALUE] = {
    min: 0,
    max: 1,
    nice: false
  }, _a$2),
  label: {
    style: {
      fill: "#fff",
      fontSize: 12
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    shared: false
  },
  conversionTag: {
    offsetX: 10,
    offsetY: 0,
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.45)"
    }
  }
};
var CONVERSION_TAG_NAME = "CONVERSION_TAG_NAME";
function transformData$8(data2, originData, options) {
  var formatData = [];
  var yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var maxYFieldValue = get(maxBy(originData, yField), [yField]);
  var max2 = isNumber$1(maxSize) ? maxSize : 1;
  var min2 = isNumber$1(minSize) ? minSize : 0;
  formatData = map$2(data2, function(row, index2) {
    var percent2 = (row[yField] || 0) / maxYFieldValue;
    row[FUNNEL_PERCENT] = percent2;
    row[FUNNEL_MAPPING_VALUE] = (max2 - min2) * percent2 + min2;
    row[FUNNEL_CONVERSATION] = [get(data2, [index2 - 1, yField]), row[yField]];
    return row;
  });
  return formatData;
}
function conversionTagComponent(getLineCoordinate) {
  return function(params) {
    var chart = params.chart, options = params.options;
    var conversionTag2 = options.conversionTag, filteredData = options.filteredData;
    var data2 = filteredData || chart.getOptions().data;
    if (conversionTag2) {
      var formatter_1 = conversionTag2.formatter;
      data2.forEach(function(obj, index2) {
        if (index2 <= 0 || Number.isNaN(obj[FUNNEL_MAPPING_VALUE]))
          return;
        var lineOption = getLineCoordinate(obj, index2, data2, {
          top: true,
          name: CONVERSION_TAG_NAME,
          text: {
            content: isFunction(formatter_1) ? formatter_1(obj, data2) : formatter_1,
            offsetX: conversionTag2.offsetX,
            offsetY: conversionTag2.offsetY,
            position: "end",
            autoRotate: false,
            style: __assign$1({ textAlign: "start", textBaseline: "middle" }, conversionTag2.style)
          }
        });
        chart.annotation().line(lineOption);
      });
    }
    return params;
  };
}
function field$4(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField, maxSize = options.maxSize, minSize = options.minSize;
  var formatData = transformData$8(data2, data2, {
    yField,
    maxSize,
    minSize
  });
  chart.data(formatData);
  return params;
}
function geometry$s(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color2 = options.color, tooltip2 = options.tooltip, label2 = options.label, _a2 = options.shape, shape = _a2 === void 0 ? "funnel" : _a2, funnelStyle = options.funnelStyle, state2 = options.state;
  var _b = getTooltipMapping(tooltip2, [xField, yField]), fields = _b.fields, formatter = _b.formatter;
  geometry$x({
    chart,
    options: {
      type: "interval",
      xField,
      yField: FUNNEL_MAPPING_VALUE,
      colorField: xField,
      tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      mapping: {
        shape,
        tooltip: formatter,
        color: color2,
        style: funnelStyle
      },
      label: label2,
      state: state2
    }
  });
  var geo = findGeometry(params.chart, "interval");
  geo.adjust("symmetric");
  return params;
}
function transpose$1(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: !isTransposed ? [["transpose"], ["scale", 1, -1]] : []
  });
  return params;
}
function conversionTag$2(params) {
  var options = params.options, chart = params.chart;
  var maxSize = options.maxSize;
  var dataArray = get(chart, ["geometries", "0", "dataArray"], []);
  var size2 = get(chart, ["options", "data", "length"]);
  var x = map$2(dataArray, function(item) {
    return get(item, ["0", "nextPoints", "0", "x"]) * size2 - 0.5;
  });
  var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
    var percent2 = maxSize - (maxSize - datum[FUNNEL_MAPPING_VALUE]) / 2;
    return __assign$1(__assign$1({}, initLineOption), { start: [x[datumIndex - 1] || datumIndex - 0.5, percent2], end: [x[datumIndex - 1] || datumIndex - 0.5, percent2 + 0.05] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function basicFunnel(params) {
  return flow(field$4, geometry$s, transpose$1, conversionTag$2)(params);
}
function field$3(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var _b = options.data, data2 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data2);
  chart.scale((_a2 = {}, _a2[yField] = {
    sync: true
  }, _a2));
  return params;
}
function geometry$r(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, color2 = options.color, compareField = options.compareField, isTransposed = options.isTransposed, tooltip2 = options.tooltip, maxSize = options.maxSize, minSize = options.minSize, label2 = options.label, funnelStyle = options.funnelStyle, state2 = options.state, showFacetTitle = options.showFacetTitle;
  chart.facet("mirror", {
    fields: [compareField],
    // 
    transpose: !isTransposed,
    padding: isTransposed ? 0 : [32, 0, 0, 0],
    showTitle: showFacetTitle,
    eachView: function(view, facet) {
      var index2 = isTransposed ? facet.rowIndex : facet.columnIndex;
      if (!isTransposed) {
        view.coordinate({
          type: "rect",
          actions: [["transpose"], ["scale", index2 === 0 ? -1 : 1, -1]]
        });
      }
      var formatterData = transformData$8(facet.data, data2, {
        yField,
        maxSize,
        minSize
      });
      view.data(formatterData);
      var _a2 = getTooltipMapping(tooltip2, [xField, yField, compareField]), fields = _a2.fields, formatter = _a2.formatter;
      var defaultFacetLabel = isTransposed ? {
        offset: index2 === 0 ? 10 : -23,
        position: index2 === 0 ? "bottom" : "top"
      } : {
        offset: 10,
        position: "left",
        style: {
          textAlign: index2 === 0 ? "end" : "start"
        }
      };
      geometry$x({
        chart: view,
        options: {
          type: "interval",
          xField,
          yField: FUNNEL_MAPPING_VALUE,
          colorField: xField,
          tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
          mapping: {
            // todo   shape
            shape: "funnel",
            tooltip: formatter,
            color: color2,
            style: funnelStyle
          },
          label: label2 === false ? false : deepAssign({}, defaultFacetLabel, label2),
          state: state2
        }
      });
    }
  });
  return params;
}
function compareConversionTag(params) {
  var chart = params.chart, index2 = params.index, options = params.options;
  var conversionTag2 = options.conversionTag, isTransposed = options.isTransposed;
  (isNumber$1(index2) ? [chart] : chart.views).forEach(function(view, viewIndex) {
    var dataArray = get(view, ["geometries", "0", "dataArray"], []);
    var size2 = get(view, ["options", "data", "length"]);
    var x = map$2(dataArray, function(item) {
      return get(item, ["0", "nextPoints", "0", "x"]) * size2 - 0.5;
    });
    var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
      var ratio = (index2 || viewIndex) === 0 ? -1 : 1;
      return deepAssign({}, initLineOption, {
        start: [x[datumIndex - 1] || datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE]],
        end: [x[datumIndex - 1] || datumIndex - 0.5, datum[FUNNEL_MAPPING_VALUE] + 0.05],
        text: isTransposed ? {
          style: {
            textAlign: "start"
          }
        } : {
          offsetX: conversionTag2 !== false ? ratio * conversionTag2.offsetX : 0,
          style: {
            textAlign: (index2 || viewIndex) === 0 ? "end" : "start"
          }
        }
      });
    };
    conversionTagComponent(getLineCoordinate)(deepAssign({}, {
      chart: view,
      options
    }));
  });
}
function conversionTag$1(params) {
  var chart = params.chart;
  chart.once("beforepaint", function() {
    return compareConversionTag(params);
  });
  return params;
}
function compareFunnel(params) {
  return flow(field$3, geometry$r, conversionTag$1)(params);
}
function field$2(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, yField = options.yField;
  var sum = reduce(data2, function(total, item) {
    return total + (item[yField] || 0);
  }, 0);
  var max2 = maxBy(data2, yField)[yField];
  var formatData = map$2(data2, function(row, index2) {
    var x = [];
    var y = [];
    row[FUNNEL_TOTAL_PERCENT] = (row[yField] || 0) / sum;
    if (index2) {
      var preItemX = data2[index2 - 1][PLOYGON_X];
      var preItemY = data2[index2 - 1][PLOYGON_Y];
      x[0] = preItemX[3];
      y[0] = preItemY[3];
      x[1] = preItemX[2];
      y[1] = preItemY[2];
    } else {
      x[0] = -0.5;
      y[0] = 1;
      x[1] = 0.5;
      y[1] = 1;
    }
    y[2] = y[1] - row[FUNNEL_TOTAL_PERCENT];
    x[2] = (y[2] + 1) / 4;
    y[3] = y[2];
    x[3] = -x[2];
    row[PLOYGON_X] = x;
    row[PLOYGON_Y] = y;
    row[FUNNEL_PERCENT] = (row[yField] || 0) / max2;
    row[FUNNEL_CONVERSATION] = [get(data2, [index2 - 1, yField]), row[yField]];
    return row;
  });
  chart.data(formatData);
  return params;
}
function geometry$q(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, color2 = options.color, tooltip2 = options.tooltip, label2 = options.label, funnelStyle = options.funnelStyle, state2 = options.state;
  var _a2 = getTooltipMapping(tooltip2, [xField, yField]), fields = _a2.fields, formatter = _a2.formatter;
  geometry$x({
    chart,
    options: {
      type: "polygon",
      xField: PLOYGON_X,
      yField: PLOYGON_Y,
      colorField: xField,
      tooltipFields: isArray$1(fields) && fields.concat([FUNNEL_PERCENT, FUNNEL_CONVERSATION]),
      label: label2,
      state: state2,
      mapping: {
        tooltip: formatter,
        color: color2,
        style: funnelStyle
      }
    }
  });
  return params;
}
function transpose(params) {
  var chart = params.chart, options = params.options;
  var isTransposed = options.isTransposed;
  chart.coordinate({
    type: "rect",
    actions: isTransposed ? [["transpose"], ["reflect", "x"]] : []
  });
  return params;
}
function conversionTag(params) {
  var getLineCoordinate = function(datum, datumIndex, data2, initLineOption) {
    return __assign$1(__assign$1({}, initLineOption), { start: [datum[PLOYGON_X][1], datum[PLOYGON_Y][1]], end: [datum[PLOYGON_X][1] + 0.05, datum[PLOYGON_Y][1]] });
  };
  conversionTagComponent(getLineCoordinate)(params);
  return params;
}
function dynamicHeightFunnel(params) {
  return flow(field$2, geometry$q, transpose, conversionTag)(params);
}
function field$1(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var _b = options.data, data2 = _b === void 0 ? [] : _b, yField = options.yField;
  chart.data(data2);
  chart.scale((_a2 = {}, _a2[yField] = {
    sync: true
  }, _a2));
  return params;
}
function geometry$p(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, isTransposed = options.isTransposed, showFacetTitle = options.showFacetTitle;
  chart.facet("rect", {
    fields: [seriesField],
    padding: [isTransposed ? 0 : 32, 10, 0, 10],
    showTitle: showFacetTitle,
    eachView: function(view, facet) {
      basicFunnel(deepAssign({}, params, {
        chart: view,
        options: {
          data: facet.data
        }
      }));
    }
  });
  return params;
}
function facetFunnel(params) {
  return flow(field$1, geometry$p)(params);
}
var ConversionTagAction = (
  /** @class */
  function(_super) {
    __extends$1(ConversionTagAction2, _super);
    function ConversionTagAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.rendering = false;
      return _this;
    }
    ConversionTagAction2.prototype.change = function(options) {
      var _this = this;
      if (!this.rendering) {
        var seriesField = options.seriesField, compareField = options.compareField;
        var conversionTag_1 = compareField ? compareConversionTag : conversionTag$2;
        var view = this.context.view;
        var views = seriesField || compareField ? view.views : [view];
        map$2(views, function(v, index2) {
          var annotationController = v.getController("annotation");
          var annotations = filter(get(annotationController, ["option"], []), function(_a2) {
            var name = _a2.name;
            return name !== CONVERSION_TAG_NAME;
          });
          annotationController.clear(true);
          each$1(annotations, function(annotation2) {
            if (typeof annotation2 === "object") {
              v.annotation()[annotation2.type](annotation2);
            }
          });
          var data2 = get(v, ["filteredData"], v.getOptions().data);
          conversionTag_1({
            chart: v,
            index: index2,
            options: __assign$1(__assign$1({}, options), {
              // @ts-ignore
              filteredData: transformData$8(data2, data2, options)
            })
          });
          v.filterData(data2);
          _this.rendering = true;
          v.render(true);
        });
      }
      this.rendering = false;
    };
    return ConversionTagAction2;
  }(Action)
);
var FUNNEL_CONVERSION_TAG = "funnel-conversion-tag";
var FUNNEL_LEGEND_FILTER = "funnel-afterrender";
var interactionStart = { trigger: "afterrender", action: "".concat(FUNNEL_CONVERSION_TAG, ":change") };
registerAction(FUNNEL_CONVERSION_TAG, ConversionTagAction);
registerInteraction(FUNNEL_LEGEND_FILTER, {
  start: [interactionStart]
});
function defaultOptions$4(params) {
  var options = params.options;
  var compareField = options.compareField, xField = options.xField, yField = options.yField, locale = options.locale, funnelStyle = options.funnelStyle, data2 = options.data;
  var i18n = getLocale(locale);
  var defaultOption = {
    label: compareField ? {
      fields: [xField, yField, compareField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      formatter: function(datum) {
        return "".concat(datum[yField]);
      }
    } : {
      fields: [xField, yField, FUNNEL_PERCENT, FUNNEL_CONVERSATION],
      offset: 0,
      position: "middle",
      formatter: function(datum) {
        return "".concat(datum[xField], " ").concat(datum[yField]);
      }
    },
    tooltip: {
      title: xField,
      formatter: function(datum) {
        return { name: datum[xField], value: datum[yField] };
      }
    },
    conversionTag: {
      // conversionTag 
      formatter: function(datum) {
        return "".concat(i18n.get(["conversionTag", "label"]), ": ").concat(conversionTagFormatter.apply(void 0, datum[FUNNEL_CONVERSATION]));
      }
    }
  };
  var style;
  if (compareField || funnelStyle) {
    style = function(datum) {
      return deepAssign(
        {},
        // 
        compareField && { lineWidth: 1, stroke: "#fff" },
        isFunction(funnelStyle) ? funnelStyle(datum) : funnelStyle
      );
    };
  }
  return deepAssign({ options: defaultOption }, params, { options: { funnelStyle: style, data: clone(data2) } });
}
function geometry$o(params) {
  var options = params.options;
  var compareField = options.compareField, dynamicHeight = options.dynamicHeight, seriesField = options.seriesField;
  if (seriesField) {
    return facetFunnel(params);
  }
  if (compareField) {
    return compareFunnel(params);
  }
  if (dynamicHeight) {
    return dynamicHeightFunnel(params);
  }
  return basicFunnel(params);
}
function meta$j(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$i(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend$c(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  if (legend2 === false) {
    chart.legend(false);
  } else {
    chart.legend(legend2);
  }
  return params;
}
function interaction$7(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions, dynamicHeight = options.dynamicHeight;
  each$1(interactions, function(i) {
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  if (!dynamicHeight) {
    chart.interaction(FUNNEL_LEGEND_FILTER, {
      start: [__assign$1(__assign$1({}, interactionStart), { arg: options })]
    });
  } else {
    chart.removeInteraction(FUNNEL_LEGEND_FILTER);
  }
  return params;
}
function adaptor$u(params) {
  return flow(defaultOptions$4, geometry$o, meta$j, axis$i, tooltip$9, interaction$7, legend$c, animation$5, theme$2, annotation$2())(params);
}
var Funnel = (
  /** @class */
  function(_super) {
    __extends$1(Funnel2, _super);
    function Funnel2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "funnel";
      return _this;
    }
    Funnel2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$w;
    };
    Funnel2.prototype.getDefaultOptions = function() {
      return Funnel2.getDefaultOptions();
    };
    Funnel2.prototype.getSchemaAdaptor = function() {
      return adaptor$u;
    };
    Funnel2.prototype.setState = function(type, condition, status) {
      if (status === void 0) {
        status = true;
      }
      var elements = getAllElementsRecursively(this.chart);
      each$1(elements, function(ele) {
        if (condition(ele.getData())) {
          ele.setState(type, status);
        }
      });
    };
    Funnel2.prototype.getStates = function() {
      var elements = getAllElementsRecursively(this.chart);
      var stateObjects = [];
      each$1(elements, function(element) {
        var data2 = element.getData();
        var states = element.getStates();
        each$1(states, function(state2) {
          stateObjects.push({ data: data2, state: state2, geometry: element.geometry, element });
        });
      });
      return stateObjects;
    };
    Funnel2.CONVERSATION_FIELD = FUNNEL_CONVERSATION;
    Funnel2.PERCENT_FIELD = FUNNEL_PERCENT;
    Funnel2.TOTAL_PERCENT_FIELD = FUNNEL_TOTAL_PERCENT;
    return Funnel2;
  }(Plot)
);
var _a$1;
var RANGE_VALUE = "range";
var RANGE_TYPE = "type";
var PERCENT = "percent";
var DEFAULT_COLOR$1 = "#f0f0f0";
var INDICATEOR_VIEW_ID = "indicator-view";
var RANGE_VIEW_ID = "range-view";
var DEFAULT_OPTIONS$v = {
  percent: 0,
  range: {
    ticks: []
  },
  innerRadius: 0.9,
  radius: 0.95,
  startAngle: -7 / 6 * Math.PI,
  endAngle: 1 / 6 * Math.PI,
  syncViewPadding: true,
  axis: {
    line: null,
    label: {
      offset: -24,
      style: {
        textAlign: "center",
        textBaseline: "middle"
      }
    },
    subTickLine: {
      length: -8
    },
    tickLine: {
      length: -12
    },
    grid: null
  },
  indicator: {
    pointer: {
      style: {
        lineWidth: 5,
        lineCap: "round"
      }
    },
    pin: {
      style: {
        r: 9.75,
        lineWidth: 4.5,
        fill: "#fff"
      }
    }
  },
  statistic: {
    title: false
  },
  meta: (_a$1 = {}, //  view  scale  v 
  _a$1[RANGE_VALUE] = {
    sync: "v"
  }, _a$1[PERCENT] = {
    sync: "v",
    tickCount: 5,
    tickInterval: 0.2
  }, _a$1),
  animation: false
};
function processRangeData(range, percent2) {
  return range.map(function(r, idx) {
    var _a2;
    return _a2 = {}, _a2[RANGE_VALUE] = r - (range[idx - 1] || 0), _a2[RANGE_TYPE] = "".concat(idx), _a2[PERCENT] = percent2, _a2;
  });
}
function getIndicatorData(percent2) {
  var _a2;
  return [(_a2 = {}, _a2[PERCENT] = clamp(percent2, 0, 1), _a2)];
}
function getRangeData(percent2, range) {
  var ticks = get(range, ["ticks"], []);
  var clampTicks = size(ticks) ? uniq$2(ticks) : [0, clamp(percent2, 0, 1), 1];
  if (!clampTicks[0]) {
    clampTicks.shift();
  }
  return processRangeData(clampTicks, percent2);
}
function geometry$n(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, range = options.range, radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle, axis2 = options.axis, indicator = options.indicator, gaugeStyle = options.gaugeStyle, type = options.type, meter = options.meter;
  var color2 = range.color, rangeWidth = range.width;
  if (indicator) {
    var indicatorData = getIndicatorData(percent2);
    var v1 = chart.createView({ id: INDICATEOR_VIEW_ID });
    v1.data(indicatorData);
    v1.point().position("".concat(PERCENT, "*1")).shape(indicator.shape || "gauge-indicator").customInfo({
      defaultColor: chart.getTheme().defaultColor,
      indicator
    });
    v1.coordinate("polar", {
      startAngle,
      endAngle,
      radius: innerRadius * radius
      //  innerRadius * radius =  radius
    });
    v1.axis(PERCENT, axis2);
    v1.scale(PERCENT, pick(axis2, AXIS_META_CONFIG_KEYS));
  }
  var rangeData = getRangeData(percent2, options.range);
  var v2 = chart.createView({ id: RANGE_VIEW_ID });
  v2.data(rangeData);
  var rangeColor = isString(color2) ? [color2, DEFAULT_COLOR$1] : color2;
  var ext = interval({
    chart: v2,
    options: {
      xField: "1",
      yField: RANGE_VALUE,
      seriesField: RANGE_TYPE,
      rawFields: [PERCENT],
      isStack: true,
      interval: {
        color: rangeColor,
        style: gaugeStyle,
        shape: type === "meter" ? "meter-gauge" : null
      },
      args: {
        zIndexReversed: true,
        sortZIndex: true
      },
      minColumnWidth: rangeWidth,
      maxColumnWidth: rangeWidth
    }
  }).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo({ meter });
  v2.coordinate("polar", {
    innerRadius,
    radius,
    startAngle,
    endAngle
  }).transpose();
  return params;
}
function meta$i(params) {
  var _a2;
  return flow(scale$2((_a2 = {
    range: {
      min: 0,
      max: 1,
      maxLimit: 1,
      minLimit: 0
    }
  }, _a2[PERCENT] = {}, _a2)))(params);
}
function statistic$2(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic2 = options.statistic, percent2 = options.percent;
  chart.getController("annotation").clear(true);
  if (statistic2) {
    var contentOption = statistic2.content;
    var transformContent = void 0;
    if (contentOption) {
      transformContent = deepAssign({}, {
        content: "".concat((percent2 * 100).toFixed(2), "%"),
        style: {
          opacity: 0.75,
          fontSize: "30px",
          lineHeight: 1,
          textAlign: "center",
          color: "rgba(44,53,66,0.85)"
        }
      }, contentOption);
    }
    renderGaugeStatistic(chart, { statistic: __assign$1(__assign$1({}, statistic2), { content: transformContent }) }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function tooltip$8(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2) {
    chart.tooltip(deepAssign({
      showTitle: false,
      showMarkers: false,
      containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
      domStyles: {
        "g2-tooltip": {
          padding: "4px 8px",
          fontSize: "10px"
        }
      },
      customContent: function(x, data2) {
        var percent2 = get(data2, [0, "data", PERCENT], 0);
        return "".concat((percent2 * 100).toFixed(2), "%");
      }
    }, tooltip2));
  } else {
    chart.tooltip(false);
  }
  return params;
}
function other(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function adaptor$t(params) {
  return flow(
    theme$2,
    // animation  createView  View 
    animation$5,
    geometry$n,
    meta$i,
    tooltip$8,
    statistic$2,
    interaction$8,
    annotation$2(),
    other
    // ...  adaptor flow
  )(params);
}
registerShape("point", "gauge-indicator", {
  draw: function(cfg, container) {
    var _a2 = cfg.customInfo, indicator = _a2.indicator, defaultColor = _a2.defaultColor;
    var _b = indicator, pointer = _b.pointer, pin2 = _b.pin;
    var group2 = container.addGroup();
    var center2 = this.parsePoint({ x: 0, y: 0 });
    if (pointer) {
      group2.addShape("line", {
        name: "pointer",
        attrs: __assign$1({ x1: center2.x, y1: center2.y, x2: cfg.x, y2: cfg.y, stroke: defaultColor }, pointer.style)
      });
    }
    if (pin2) {
      group2.addShape("circle", {
        name: "pin",
        attrs: __assign$1({ x: center2.x, y: center2.y, stroke: defaultColor }, pin2.style)
      });
    }
    return group2;
  }
});
registerShape("interval", "meter-gauge", {
  draw: function(cfg, container) {
    var _a2 = cfg.customInfo.meter, meter = _a2 === void 0 ? {} : _a2;
    var _b = meter.steps, STEP = _b === void 0 ? 50 : _b, _c = meter.stepRatio, STEP_RATIO = _c === void 0 ? 0.5 : _c;
    STEP = STEP < 1 ? 1 : STEP;
    STEP_RATIO = clamp(STEP_RATIO, 0, 1);
    var _d = this.coordinate, COORD_START_ANGLE = _d.startAngle, COORD_END_ANGLE = _d.endAngle;
    var GAP2 = 0;
    if (STEP_RATIO > 0 && STEP_RATIO < 1) {
      var TOTAL = COORD_END_ANGLE - COORD_START_ANGLE;
      GAP2 = TOTAL / STEP / (STEP_RATIO / (1 - STEP_RATIO) + 1 - 1 / STEP);
    }
    var INTERVAL = GAP2 / (1 - STEP_RATIO) * STEP_RATIO;
    var group2 = container.addGroup();
    var center2 = this.coordinate.getCenter();
    var radius = this.coordinate.getRadius();
    var _e = Util.getAngle(cfg, this.coordinate), START_ANGLE = _e.startAngle, END_ANGLE = _e.endAngle;
    for (var startAngle = START_ANGLE; startAngle < END_ANGLE; ) {
      var endAngle = void 0;
      var r = (startAngle - COORD_START_ANGLE) % (INTERVAL + GAP2);
      if (r < INTERVAL) {
        endAngle = startAngle + (INTERVAL - r);
      } else {
        startAngle += INTERVAL + GAP2 - r;
        endAngle = startAngle + INTERVAL;
      }
      var path2 = Util.getSectorPath(center2.x, center2.y, radius, startAngle, Math.min(endAngle, END_ANGLE), radius * this.coordinate.innerRadius);
      group2.addShape("path", {
        name: "meter-gauge",
        attrs: {
          path: path2,
          fill: cfg.color,
          stroke: cfg.color,
          lineWidth: 0.5
        }
      });
      startAngle = endAngle + GAP2;
    }
    return group2;
  }
});
var Gauge = (
  /** @class */
  function(_super) {
    __extends$1(Gauge2, _super);
    function Gauge2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "gauge";
      return _this;
    }
    Gauge2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$v;
    };
    Gauge2.prototype.changeData = function(percent2) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.updateOption({ percent: percent2 });
      var indicatorView = this.chart.views.find(function(v) {
        return v.id === INDICATEOR_VIEW_ID;
      });
      if (indicatorView) {
        indicatorView.data(getIndicatorData(percent2));
      }
      var rangeView = this.chart.views.find(function(v) {
        return v.id === RANGE_VIEW_ID;
      });
      if (rangeView) {
        rangeView.data(getRangeData(percent2, this.options.range));
      }
      statistic$2({ chart: this.chart, options: this.options }, true);
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    Gauge2.prototype.getDefaultOptions = function() {
      return Gauge2.getDefaultOptions();
    };
    Gauge2.prototype.getSchemaAdaptor = function() {
      return adaptor$t;
    };
    return Gauge2;
  }(Plot)
);
function getBinKey(value2, binWidth, binNumber) {
  if (binNumber === 1) {
    return [0, binWidth];
  }
  var index2 = Math.floor(value2 / binWidth);
  return [binWidth * index2, binWidth * (index2 + 1)];
}
function sturges(values2) {
  return Math.ceil(Math.log(values2.length) / Math.LN2) + 1;
}
function binHistogram(data2, binField, binWidth, binNumber, stackField) {
  var originData_copy = clone(data2);
  sortBy(originData_copy, binField);
  var values2 = valuesOfKey(originData_copy, binField);
  var range = getRange(values2);
  var rangeWidth = range.max - range.min;
  var _binWidth = binWidth;
  if (!binWidth && binNumber) {
    _binWidth = binNumber > 1 ? rangeWidth / (binNumber - 1) : range.max;
  }
  if (!binWidth && !binNumber) {
    var _defaultBinNumber = sturges(values2);
    _binWidth = rangeWidth / _defaultBinNumber;
  }
  var bins = {};
  var groups = groupBy(originData_copy, stackField);
  if (isEmpty(groups)) {
    each$1(originData_copy, function(data3) {
      var value2 = data3[binField];
      var bin = getBinKey(value2, _binWidth, binNumber);
      var binKey = "".concat(bin[0], "-").concat(bin[1]);
      if (!has(bins, binKey)) {
        bins[binKey] = { range: bin, count: 0 };
      }
      bins[binKey].count += 1;
    });
  } else {
    Object.keys(groups).forEach(function(groupKey) {
      each$1(groups[groupKey], function(data3) {
        var value2 = data3[binField];
        var bin = getBinKey(value2, _binWidth, binNumber);
        var binKey = "".concat(bin[0], "-").concat(bin[1]);
        var groupKeyBinKey = "".concat(binKey, "-").concat(groupKey);
        if (!has(bins, groupKeyBinKey)) {
          bins[groupKeyBinKey] = { range: bin, count: 0 };
          bins[groupKeyBinKey][stackField] = groupKey;
        }
        bins[groupKeyBinKey].count += 1;
      });
    });
  }
  var plotData = [];
  each$1(bins, function(bin) {
    plotData.push(bin);
  });
  return plotData;
}
var HISTOGRAM_X_FIELD = "range";
var HISTOGRAM_Y_FIELD = "count";
var DEFAULT_OPTIONS$u = deepAssign({}, Plot.getDefaultOptions(), {
  columnStyle: {
    stroke: "#FFFFFF"
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});
function geometry$m(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, binField = options.binField, binNumber = options.binNumber, binWidth = options.binWidth, color2 = options.color, stackField = options.stackField, legend2 = options.legend, columnStyle = options.columnStyle;
  var plotData = binHistogram(data2, binField, binWidth, binNumber, stackField);
  chart.data(plotData);
  var p = deepAssign({}, params, {
    options: {
      xField: HISTOGRAM_X_FIELD,
      yField: HISTOGRAM_Y_FIELD,
      seriesField: stackField,
      isStack: true,
      interval: {
        color: color2,
        style: columnStyle
      }
    }
  });
  interval(p);
  if (legend2 && stackField) {
    chart.legend(stackField, legend2);
  } else {
    chart.legend(false);
  }
  return params;
}
function meta$h(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  return flow(scale$2((_a2 = {}, _a2[HISTOGRAM_X_FIELD] = xAxis, _a2[HISTOGRAM_Y_FIELD] = yAxis, _a2)))(params);
}
function axis$h(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  if (xAxis === false) {
    chart.axis(HISTOGRAM_X_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_X_FIELD, xAxis);
  }
  if (yAxis === false) {
    chart.axis(HISTOGRAM_Y_FIELD, false);
  } else {
    chart.axis(HISTOGRAM_Y_FIELD, yAxis);
  }
  return params;
}
function label$b(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [HISTOGRAM_Y_FIELD],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor$s(params) {
  return flow(theme$2, pattern("columnStyle"), geometry$m, meta$h, axis$h, state, label$b, tooltip$9, interaction$8, animation$5)(params);
}
var Histogram = (
  /** @class */
  function(_super) {
    __extends$1(Histogram2, _super);
    function Histogram2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "histogram";
      return _this;
    }
    Histogram2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$u;
    };
    Histogram2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this.options, binField = _a2.binField, binNumber = _a2.binNumber, binWidth = _a2.binWidth, stackField = _a2.stackField;
      this.chart.changeData(binHistogram(data2, binField, binWidth, binNumber, stackField));
    };
    Histogram2.prototype.getDefaultOptions = function() {
      return Histogram2.getDefaultOptions();
    };
    Histogram2.prototype.getSchemaAdaptor = function() {
      return adaptor$s;
    };
    return Histogram2;
  }(Plot)
);
var DEFAULT_OPTIONS$t = deepAssign({}, Plot.getDefaultOptions(), {
  tooltip: {
    shared: true,
    showMarkers: true,
    showCrosshairs: true,
    crosshairs: {
      type: "x"
    }
  },
  legend: {
    position: "top-left",
    radio: {}
  },
  isStack: false
});
var MarkerActiveAction = (
  /** @class */
  function(_super) {
    __extends$1(MarkerActiveAction2, _super);
    function MarkerActiveAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    MarkerActiveAction2.prototype.active = function() {
      var view = this.getView();
      var evt = this.context.event;
      if (evt.data) {
        var items_1 = evt.data.items;
        var points2 = view.geometries.filter(function(geom) {
          return geom.type === "point";
        });
        each$1(points2, function(point2) {
          each$1(point2.elements, function(element) {
            var active = findIndex(items_1, function(item) {
              return item.data === element.data;
            }) !== -1;
            element.setState("active", active);
          });
        });
      }
    };
    MarkerActiveAction2.prototype.reset = function() {
      var view = this.getView();
      var points2 = view.geometries.filter(function(geom) {
        return geom.type === "point";
      });
      each$1(points2, function(point2) {
        each$1(point2.elements, function(element) {
          element.setState("active", false);
        });
      });
    };
    MarkerActiveAction2.prototype.getView = function() {
      return this.context.view;
    };
    return MarkerActiveAction2;
  }(Action)
);
registerAction("marker-active", MarkerActiveAction);
registerInteraction("marker-active", {
  start: [
    {
      trigger: "tooltip:show",
      action: "marker-active:active"
    }
  ],
  end: [
    {
      trigger: "tooltip:hide",
      action: "marker-active:reset"
    }
  ]
});
var Line = (
  /** @class */
  function(_super) {
    __extends$1(Line2, _super);
    function Line2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "line";
      return _this;
    }
    Line2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$t;
    };
    Line2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this, chart = _a2.chart, options = _a2.options;
      meta$l({ chart, options });
      this.chart.changeData(data2);
    };
    Line2.prototype.getDefaultOptions = function() {
      return Line2.getDefaultOptions();
    };
    Line2.prototype.getSchemaAdaptor = function() {
      return adaptor$y;
    };
    return Line2;
  }(Plot)
);
var DEFAULT_OPTIONS$s = deepAssign({}, Plot.getDefaultOptions(), {
  legend: {
    position: "right",
    radio: {}
  },
  tooltip: {
    shared: false,
    showTitle: false,
    showMarkers: false
  },
  label: {
    layout: { type: "limit-in-plot", cfg: { action: "ellipsis" } }
  },
  /** ,  */
  pieStyle: {
    stroke: "white",
    lineWidth: 1
  },
  /**  */
  statistic: {
    title: {
      style: { fontWeight: 300, color: "#4B535E", textAlign: "center", fontSize: "20px", lineHeight: 1 }
    },
    content: {
      style: {
        fontWeight: "bold",
        color: "rgba(44,53,66,0.85)",
        textAlign: "center",
        fontSize: "32px",
        lineHeight: 1
      }
    }
  },
  /**  text-annotation  */
  theme: {
    components: {
      annotation: {
        text: {
          animate: false
        }
      }
    }
  }
});
var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];
function transform$2(actions, matrix) {
  var ulMatrix = matrix ? __spreadArray$1([], matrix, true) : __spreadArray$1([], ORIGIN_MATRIX, true);
  return Util.transform(ulMatrix, actions);
}
var PieLegendAction = (
  /** @class */
  function(_super) {
    __extends$1(PieLegendAction2, _super);
    function PieLegendAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PieLegendAction2.prototype.getActiveElements = function() {
      var delegateObject = Util.getDelegationObject(this.context);
      if (delegateObject) {
        var view = this.context.view;
        var component2 = delegateObject.component, item_1 = delegateObject.item;
        var field_1 = component2.get("field");
        if (field_1) {
          var elements = view.geometries[0].elements;
          return elements.filter(function(ele) {
            return ele.getModel().data[field_1] === item_1.value;
          });
        }
      }
      return [];
    };
    PieLegendAction2.prototype.getActiveElementLabels = function() {
      var view = this.context.view;
      var elements = this.getActiveElements();
      var labels = view.geometries[0].labelsContainer.getChildren();
      return labels.filter(function(label2) {
        return elements.find(function(ele) {
          return isEqual$1(ele.getData(), label2.get("data"));
        });
      });
    };
    PieLegendAction2.prototype.transfrom = function(offset) {
      if (offset === void 0) {
        offset = 7.5;
      }
      var elements = this.getActiveElements();
      var elementLabels = this.getActiveElementLabels();
      elements.forEach(function(element, idx) {
        var labelShape = elementLabels[idx];
        var coordinate2 = element.geometry.coordinate;
        if (coordinate2.isPolar && coordinate2.isTransposed) {
          var _a2 = Util.getAngle(element.getModel(), coordinate2), startAngle = _a2.startAngle, endAngle = _a2.endAngle;
          var middleAngle = (startAngle + endAngle) / 2;
          var r = offset;
          var x = r * Math.cos(middleAngle);
          var y = r * Math.sin(middleAngle);
          element.shape.setMatrix(transform$2([["t", x, y]]));
          labelShape.setMatrix(transform$2([["t", x, y]]));
        }
      });
    };
    PieLegendAction2.prototype.active = function() {
      this.transfrom();
    };
    PieLegendAction2.prototype.reset = function() {
      this.transfrom(0);
    };
    return PieLegendAction2;
  }(Action)
);
function getCurrentElement(context) {
  var event = context.event;
  var element;
  var target2 = event.target;
  if (target2) {
    element = target2.get("element");
  }
  return element;
}
var StatisticAction = (
  /** @class */
  function(_super) {
    __extends$1(StatisticAction2, _super);
    function StatisticAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    StatisticAction2.prototype.getAnnotations = function(_view) {
      var view = _view || this.context.view;
      return view.getController("annotation").option;
    };
    StatisticAction2.prototype.getInitialAnnotation = function() {
      return this.initialAnnotation;
    };
    StatisticAction2.prototype.init = function() {
      var _this = this;
      var view = this.context.view;
      view.removeInteraction("tooltip");
      view.on("afterchangesize", function() {
        var annotations = _this.getAnnotations(view);
        _this.initialAnnotation = annotations;
      });
    };
    StatisticAction2.prototype.change = function(arg) {
      var _a2 = this.context, view = _a2.view, event = _a2.event;
      if (!this.initialAnnotation) {
        this.initialAnnotation = this.getAnnotations();
      }
      var data2 = get(event, ["data", "data"]);
      if (event.type.match("legend-item")) {
        var delegateObject = Util.getDelegationObject(this.context);
        var colorField_1 = view.getGroupedFields()[0];
        if (delegateObject && colorField_1) {
          var item_1 = delegateObject.item;
          data2 = view.getData().find(function(d) {
            return d[colorField_1] === item_1.value;
          });
        }
      }
      if (data2) {
        var annotations = get(arg, "annotations", []);
        var statistic2 = get(arg, "statistic", {});
        view.getController("annotation").clear(true);
        each$1(annotations, function(annotation2) {
          if (typeof annotation2 === "object") {
            view.annotation()[annotation2.type](annotation2);
          }
        });
        renderStatistic(view, { statistic: statistic2, plotType: "pie" }, data2);
        view.render(true);
      }
      var ele = getCurrentElement(this.context);
      if (ele) {
        ele.shape.toFront();
      }
    };
    StatisticAction2.prototype.reset = function() {
      var view = this.context.view;
      var annotationController = view.getController("annotation");
      annotationController.clear(true);
      var initialStatistic = this.getInitialAnnotation();
      each$1(initialStatistic, function(a) {
        view.annotation()[a.type](a);
      });
      view.render(true);
    };
    return StatisticAction2;
  }(Action)
);
var PIE_STATISTIC = "pie-statistic";
registerAction(PIE_STATISTIC, StatisticAction);
registerInteraction("pie-statistic-active", {
  start: [{ trigger: "element:mouseenter", action: "pie-statistic:change" }],
  end: [{ trigger: "element:mouseleave", action: "pie-statistic:reset" }]
});
registerAction("pie-legend", PieLegendAction);
registerInteraction("pie-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: "pie-legend:active" }],
  end: [{ trigger: "legend-item:mouseleave", action: "pie-legend:reset" }]
});
function getTotalValue(data2, field2) {
  var total = null;
  each$1(data2, function(item) {
    if (typeof item[field2] === "number") {
      total += item[field2];
    }
  });
  return total;
}
function adaptOffset(type, offset) {
  var defaultOffset;
  switch (type) {
    case "inner":
      defaultOffset = "-30%";
      if (isString(offset) && offset.endsWith("%")) {
        return parseFloat(offset) * 0.01 > 0 ? defaultOffset : offset;
      }
      return offset < 0 ? offset : defaultOffset;
    case "outer":
      defaultOffset = 12;
      if (isString(offset) && offset.endsWith("%")) {
        return parseFloat(offset) * 0.01 < 0 ? defaultOffset : offset;
      }
      return offset > 0 ? offset : defaultOffset;
    default:
      return offset;
  }
}
function isAllZero(data2, angleField) {
  return every(processIllegalData(data2, angleField), function(d) {
    return d[angleField] === 0;
  });
}
function geometry$l(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, angleField = options.angleField, colorField = options.colorField, color2 = options.color, pieStyle = options.pieStyle, shape = options.shape;
  var processData2 = processIllegalData(data2, angleField);
  if (isAllZero(processData2, angleField)) {
    var percentageField_1 = "$$percentage$$";
    processData2 = processData2.map(function(d) {
      var _a2;
      return __assign$1(__assign$1({}, d), (_a2 = {}, _a2[percentageField_1] = 1 / processData2.length, _a2));
    });
    chart.data(processData2);
    var p = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: percentageField_1,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color2,
          shape,
          style: pieStyle
        },
        args: {
          zIndexReversed: true,
          sortZIndex: true
        }
      }
    });
    interval(p);
  } else {
    chart.data(processData2);
    var p = deepAssign({}, params, {
      options: {
        xField: "1",
        yField: angleField,
        seriesField: colorField,
        isStack: true,
        interval: {
          color: color2,
          shape,
          style: pieStyle
        },
        args: {
          zIndexReversed: true,
          sortZIndex: true
        }
      }
    });
    interval(p);
  }
  return params;
}
function meta$g(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, colorField = options.colorField;
  var scales = deepAssign({}, meta2);
  chart.scale(scales, (_a2 = {}, _a2[colorField] = { type: "cat" }, _a2));
  return params;
}
function coordinate$7(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "theta",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function label$a(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, colorField = options.colorField, angleField = options.angleField;
  var geometry2 = chart.geometries[0];
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    var labelCfg = transformLabel(cfg);
    if (labelCfg.content) {
      var content_1 = labelCfg.content;
      labelCfg.content = function(data2, dataum, index2) {
        var name = data2[colorField];
        var value2 = data2[angleField];
        var angleScale = chart.getScaleByField(angleField);
        var percent2 = angleScale === null || angleScale === void 0 ? void 0 : angleScale.scale(value2);
        return isFunction(content_1) ? (
          // append percent (number) to data, users can get origin data from `dataum._origin`
          content_1(__assign$1(__assign$1({}, data2), { percent: percent2 }), dataum, index2)
        ) : isString(content_1) ? template(content_1, {
          value: value2,
          name,
          // percentage (string), default keep 2
          percentage: isNumber$1(percent2) && !isNil(value2) ? "".concat((percent2 * 100).toFixed(2), "%") : null
        }) : content_1;
      };
    }
    var LABEL_LAYOUT_TYPE_MAP = {
      inner: "",
      outer: "pie-outer",
      spider: "pie-spider"
    };
    var labelLayoutType = labelCfg.type ? LABEL_LAYOUT_TYPE_MAP[labelCfg.type] : "pie-outer";
    var labelLayoutCfg = labelCfg.layout ? !isArray$1(labelCfg.layout) ? [labelCfg.layout] : labelCfg.layout : [];
    labelCfg.layout = (labelLayoutType ? [{ type: labelLayoutType }] : []).concat(labelLayoutCfg);
    geometry2.label({
      // fix: could not create scale, when field is undefinedattributes  fields  scale
      fields: colorField ? [angleField, colorField] : [angleField],
      callback,
      cfg: __assign$1(__assign$1({}, labelCfg), { offset: adaptOffset(labelCfg.type, labelCfg.offset), type: "pie" })
    });
  }
  return params;
}
function transformStatisticOptions(options) {
  var innerRadius = options.innerRadius, statistic2 = options.statistic, angleField = options.angleField, colorField = options.colorField, meta2 = options.meta, locale = options.locale;
  var i18n = getLocale(locale);
  if (innerRadius && statistic2) {
    var _a2 = deepAssign({}, DEFAULT_OPTIONS$s.statistic, statistic2), titleOpt_1 = _a2.title, contentOpt_1 = _a2.content;
    if (titleOpt_1 !== false) {
      titleOpt_1 = deepAssign({}, {
        formatter: function(datum) {
          var text2 = datum ? datum[colorField] : !isNil(titleOpt_1.content) ? titleOpt_1.content : i18n.get(["statistic", "total"]);
          var metaFormatter = get(meta2, [colorField, "formatter"]) || function(v) {
            return v;
          };
          return metaFormatter(text2);
        }
      }, titleOpt_1);
    }
    if (contentOpt_1 !== false) {
      contentOpt_1 = deepAssign({}, {
        formatter: function(datum, data2) {
          var dataValue = datum ? datum[angleField] : getTotalValue(data2, angleField);
          var metaFormatter = get(meta2, [angleField, "formatter"]) || function(v) {
            return v;
          };
          if (datum) {
            return metaFormatter(dataValue);
          }
          return !isNil(contentOpt_1.content) ? contentOpt_1.content : metaFormatter(dataValue);
        }
      }, contentOpt_1);
    }
    return deepAssign({}, { statistic: { title: titleOpt_1, content: contentOpt_1 } }, options);
  }
  return options;
}
function pieAnnotation(params) {
  var chart = params.chart, options = params.options;
  var _a2 = transformStatisticOptions(options), innerRadius = _a2.innerRadius, statistic2 = _a2.statistic;
  chart.getController("annotation").clear(true);
  flow(annotation$2())(params);
  if (innerRadius && statistic2) {
    renderStatistic(chart, { statistic: statistic2, plotType: "pie" });
  }
  return params;
}
function tooltip$7(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, colorField = options.colorField, angleField = options.angleField, data2 = options.data;
  if (tooltip2 === false) {
    chart.tooltip(tooltip2);
  } else {
    chart.tooltip(deepAssign({}, tooltip2, { shared: false }));
    if (isAllZero(data2, angleField)) {
      var fields = get(tooltip2, "fields");
      var formatter = get(tooltip2, "formatter");
      if (isEmpty(get(tooltip2, "fields"))) {
        fields = [colorField, angleField];
        formatter = formatter || function(datum) {
          return { name: datum[colorField], value: toString$2(datum[angleField]) };
        };
      }
      chart.geometries[0].tooltip(fields.join("*"), getMappingFunction(fields, formatter));
    }
  }
  return params;
}
function interaction$6(params) {
  var chart = params.chart, options = params.options;
  var _a2 = transformStatisticOptions(options), interactions = _a2.interactions, statistic2 = _a2.statistic, annotations = _a2.annotations;
  each$1(interactions, function(i) {
    var _a3, _b;
    if (i.enable === false) {
      chart.removeInteraction(i.type);
    } else if (i.type === "pie-statistic-active") {
      var startStages_1 = [];
      if (!((_a3 = i.cfg) === null || _a3 === void 0 ? void 0 : _a3.start)) {
        startStages_1 = [
          {
            trigger: "element:mouseenter",
            action: "".concat(PIE_STATISTIC, ":change"),
            arg: { statistic: statistic2, annotations }
          }
        ];
      }
      each$1((_b = i.cfg) === null || _b === void 0 ? void 0 : _b.start, function(stage) {
        startStages_1.push(__assign$1(__assign$1({}, stage), { arg: { statistic: statistic2, annotations } }));
      });
      chart.interaction(i.type, deepAssign({}, i.cfg, { start: startStages_1 }));
    } else {
      chart.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function adaptor$r(params) {
  return flow(
    pattern("pieStyle"),
    geometry$l,
    meta$g,
    theme$2,
    coordinate$7,
    legend$g,
    tooltip$7,
    label$a,
    state,
    /**   */
    pieAnnotation,
    interaction$6,
    animation$5
  )(params);
}
var Pie = (
  /** @class */
  function(_super) {
    __extends$1(Pie2, _super);
    function Pie2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "pie";
      return _this;
    }
    Pie2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$s;
    };
    Pie2.prototype.changeData = function(data2) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      var prevOptions = this.options;
      var angleField = this.options.angleField;
      var prevData = processIllegalData(prevOptions.data, angleField);
      var curData = processIllegalData(data2, angleField);
      if (isAllZero(prevData, angleField) || isAllZero(curData, angleField)) {
        this.update({ data: data2 });
      } else {
        this.updateOption({ data: data2 });
        this.chart.data(curData);
        pieAnnotation({ chart: this.chart, options: this.options });
        this.chart.render(true);
      }
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    Pie2.prototype.getDefaultOptions = function() {
      return Pie2.getDefaultOptions();
    };
    Pie2.prototype.getSchemaAdaptor = function() {
      return adaptor$r;
    };
    return Pie2;
  }(Plot)
);
var DEFAULT_COLOR = ["#FAAD14", "#E8EDF3"];
var DEFAULT_OPTIONS$r = {
  percent: 0.2,
  color: DEFAULT_COLOR,
  animation: {}
};
function getProgressData(percent2) {
  var clampPercent = clamp(isRealNumber(percent2) ? percent2 : 0, 0, 1);
  return [
    {
      //  progressStyle 
      current: "".concat(clampPercent),
      type: "current",
      percent: clampPercent
    },
    {
      current: "".concat(clampPercent),
      type: "target",
      percent: 1
    }
  ];
}
function geometry$k(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, progressStyle = options.progressStyle, color2 = options.color, barWidthRatio = options.barWidthRatio;
  chart.data(getProgressData(percent2));
  var p = deepAssign({}, params, {
    options: {
      xField: "current",
      yField: "percent",
      seriesField: "type",
      widthRatio: barWidthRatio,
      interval: {
        style: progressStyle,
        color: isString(color2) ? [color2, DEFAULT_COLOR[1]] : color2
      },
      args: {
        zIndexReversed: true,
        sortZIndex: true
      }
    }
  });
  interval(p);
  chart.tooltip(false);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function coordinate$6(params) {
  var chart = params.chart;
  chart.coordinate("rect").transpose();
  return params;
}
function adaptor$q(params) {
  return flow(geometry$k, scale$2({}), coordinate$6, animation$5, theme$2, annotation$2())(params);
}
var Progress = (
  /** @class */
  function(_super) {
    __extends$1(Progress2, _super);
    function Progress2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "process";
      return _this;
    }
    Progress2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$r;
    };
    Progress2.prototype.changeData = function(percent2) {
      this.updateOption({ percent: percent2 });
      this.chart.changeData(getProgressData(percent2));
    };
    Progress2.prototype.getDefaultOptions = function() {
      return Progress2.getDefaultOptions();
    };
    Progress2.prototype.getSchemaAdaptor = function() {
      return adaptor$q;
    };
    return Progress2;
  }(Plot)
);
function coordinate$5(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius;
  chart.coordinate("theta", {
    innerRadius,
    radius
  });
  return params;
}
function statistic$1(params, updated) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, statistic2 = options.statistic, percent2 = options.percent, meta2 = options.meta;
  chart.getController("annotation").clear(true);
  if (innerRadius && statistic2) {
    var metaFormatter = get(meta2, ["percent", "formatter"]) || function(v) {
      return "".concat((v * 100).toFixed(2), "%");
    };
    var contentOpt = statistic2.content;
    if (contentOpt) {
      contentOpt = deepAssign({}, contentOpt, {
        content: !isNil(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
      });
    }
    renderStatistic(chart, { statistic: __assign$1(__assign$1({}, statistic2), { content: contentOpt }), plotType: "ring-progress" }, { percent: percent2 });
  }
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor$p(params) {
  return flow(geometry$k, scale$2({}), coordinate$5, statistic$1, animation$5, theme$2, annotation$2())(params);
}
var DEFAULT_OPTIONS$q = {
  percent: 0.2,
  innerRadius: 0.8,
  radius: 0.98,
  color: ["#FAAD14", "#E8EDF3"],
  statistic: {
    title: false,
    content: {
      style: {
        fontSize: "14px",
        fontWeight: 300,
        fill: "#4D4D4D",
        textAlign: "center",
        textBaseline: "middle"
      }
    }
  },
  animation: {}
};
var RingProgress = (
  /** @class */
  function(_super) {
    __extends$1(RingProgress2, _super);
    function RingProgress2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "ring-process";
      return _this;
    }
    RingProgress2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$q;
    };
    RingProgress2.prototype.changeData = function(percent2) {
      this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
      this.updateOption({ percent: percent2 });
      this.chart.data(getProgressData(percent2));
      statistic$1({ chart: this.chart, options: this.options }, true);
      this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
    };
    RingProgress2.prototype.getDefaultOptions = function() {
      return RingProgress2.getDefaultOptions();
    };
    RingProgress2.prototype.getSchemaAdaptor = function() {
      return adaptor$p;
    };
    return RingProgress2;
  }(Plot)
);
function _slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest();
}
function _arrayWithHoles(arr) {
  if (Array.isArray(arr))
    return arr;
}
function _iterableToArrayLimit(arr, i) {
  var _arr = [];
  var _n = true;
  var _d = false;
  var _e = void 0;
  try {
    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance");
}
function points(data2, x, y, sort) {
  data2 = data2.filter(function(d2, i2) {
    var u = x(d2, i2), v = y(d2, i2);
    return u != null && isFinite(u) && v != null && isFinite(v);
  });
  if (sort) {
    data2.sort(function(a, b) {
      return x(a) - x(b);
    });
  }
  var n = data2.length, X = new Float64Array(n), Y = new Float64Array(n);
  var ux = 0, uy = 0, xv, yv, d;
  for (var i = 0; i < n; ) {
    d = data2[i];
    X[i] = xv = +x(d, i, data2);
    Y[i] = yv = +y(d, i, data2);
    ++i;
    ux += (xv - ux) / i;
    uy += (yv - uy) / i;
  }
  for (var _i = 0; _i < n; ++_i) {
    X[_i] -= ux;
    Y[_i] -= uy;
  }
  return [X, Y, ux, uy];
}
function visitPoints(data2, x, y, cb) {
  var iterations = 0;
  for (var i = 0, n = data2.length; i < n; i++) {
    var d = data2[i], dx = +x(d, i, data2), dy = +y(d, i, data2);
    if (dx != null && isFinite(dx) && dy != null && isFinite(dy)) {
      cb(dx, dy, iterations++);
    }
  }
}
function determination(data2, x, y, uY, predict) {
  var SSE = 0, SST = 0;
  visitPoints(data2, x, y, function(dx, dy) {
    var sse = dy - predict(dx), sst = dy - uY;
    SSE += sse * sse;
    SST += sst * sst;
  });
  return 1 - SSE / SST;
}
function angle(line2) {
  return Math.atan2(line2[1][1] - line2[0][1], line2[1][0] - line2[0][0]) * 180 / Math.PI;
}
function midpoint(line2) {
  return [(line2[0][0] + line2[1][0]) / 2, (line2[0][1] + line2[1][1]) / 2];
}
function interpose(xmin, xmax, predict) {
  var l = Math.log(xmax - xmin) * Math.LOG10E + 1 | 0;
  var precision = 1 * Math.pow(10, -l / 2 - 1), maxIter = 1e4;
  var points2 = [px(xmin), px(xmax)], iter = 0;
  while (find2(points2) && iter < maxIter) {
  }
  return points2;
  function px(x) {
    return [x, predict(x)];
  }
  function find2(points3) {
    iter++;
    var n = points3.length;
    var found = false;
    for (var i = 0; i < n - 1; i++) {
      var p0 = points3[i], p1 = points3[i + 1], m = midpoint([p0, p1]), mp = px(m[0]), a0 = angle([p0, m]), a1 = angle([p0, mp]), a = Math.abs(a0 - a1);
      if (a > precision) {
        points3.splice(i + 1, 0, mp);
        found = true;
      }
    }
    return found;
  }
}
function ols(uX, uY, uXY, uX2) {
  var delta = uX2 - uX * uX, slope = Math.abs(delta) < 1e-24 ? 0 : (uXY - uX * uY) / delta, intercept = uY - slope * uX;
  return [intercept, slope];
}
function exponential() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function exponential2(data2) {
    var n = 0, Y = 0, YL = 0, XY = 0, XYL = 0, X2Y = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x, y, function(dx, dy) {
      var ly = Math.log(dy), xy = dx * dy;
      ++n;
      Y += (dy - Y) / n;
      XY += (xy - XY) / n;
      X2Y += (dx * xy - X2Y) / n;
      YL += (dy * ly - YL) / n;
      XYL += (xy * ly - XYL) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(XY / Y, YL / Y, XYL / Y, X2Y / Y), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
    a = Math.exp(a);
    var fn = function fn2(x2) {
      return a * Math.exp(b * x2);
    }, out = interpose(xmin, xmax, fn);
    out.a = a;
    out.b = b;
    out.predict = fn;
    out.rSquared = determination(data2, x, y, Y, fn);
    return out;
  }
  exponential2.domain = function(arr) {
    return arguments.length ? (domain = arr, exponential2) : domain;
  };
  exponential2.x = function(fn) {
    return arguments.length ? (x = fn, exponential2) : x;
  };
  exponential2.y = function(fn) {
    return arguments.length ? (y = fn, exponential2) : y;
  };
  return exponential2;
}
function linear() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function linear2(data2) {
    var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x, y, function(dx, dy) {
      ++n;
      X += (dx - X) / n;
      Y += (dy - Y) / n;
      XY += (dx * dy - XY) / n;
      X2 += (dx * dx - X2) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn2(x2) {
      return slope * x2 + intercept;
    }, out = [[xmin, fn(xmin)], [xmax, fn(xmax)]];
    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = determination(data2, x, y, Y, fn);
    return out;
  }
  linear2.domain = function(arr) {
    return arguments.length ? (domain = arr, linear2) : domain;
  };
  linear2.x = function(fn) {
    return arguments.length ? (x = fn, linear2) : x;
  };
  linear2.y = function(fn) {
    return arguments.length ? (y = fn, linear2) : y;
  };
  return linear2;
}
function median(arr) {
  arr.sort(function(a, b) {
    return a - b;
  });
  var i = arr.length / 2;
  return i % 1 === 0 ? (arr[i - 1] + arr[i]) / 2 : arr[Math.floor(i)];
}
var maxiters = 2, epsilon = 1e-12;
function loess() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, bandwidth = 0.3;
  function loess2(data2) {
    var _points = points(data2, x, y, true), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, bw = Math.max(2, ~~(bandwidth * n)), yhat = new Float64Array(n), residuals = new Float64Array(n), robustWeights = new Float64Array(n).fill(1);
    for (var iter = -1; ++iter <= maxiters; ) {
      var interval2 = [0, bw - 1];
      for (var i = 0; i < n; ++i) {
        var dx = xv[i], i0 = interval2[0], i1 = interval2[1], edge2 = dx - xv[i0] > xv[i1] - dx ? i0 : i1;
        var W = 0, X = 0, Y = 0, XY = 0, X2 = 0, denom = 1 / Math.abs(xv[edge2] - dx || 1);
        for (var k = i0; k <= i1; ++k) {
          var xk = xv[k], yk = yv[k], w = tricube(Math.abs(dx - xk) * denom) * robustWeights[k], xkw = xk * w;
          W += w;
          X += xkw;
          Y += yk * w;
          XY += yk * xkw;
          X2 += xk * xkw;
        }
        var _ols = ols(X / W, Y / W, XY / W, X2 / W), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
        yhat[i] = a + b * dx;
        residuals[i] = Math.abs(yv[i] - yhat[i]);
        updateInterval(xv, i + 1, interval2);
      }
      if (iter === maxiters) {
        break;
      }
      var medianResidual = median(residuals);
      if (Math.abs(medianResidual) < epsilon)
        break;
      for (var _i = 0, arg, _w; _i < n; ++_i) {
        arg = residuals[_i] / (6 * medianResidual);
        robustWeights[_i] = arg >= 1 ? epsilon : (_w = 1 - arg * arg) * _w;
      }
    }
    return output(xv, yhat, ux, uy);
  }
  loess2.bandwidth = function(bw) {
    return arguments.length ? (bandwidth = bw, loess2) : bandwidth;
  };
  loess2.x = function(fn) {
    return arguments.length ? (x = fn, loess2) : x;
  };
  loess2.y = function(fn) {
    return arguments.length ? (y = fn, loess2) : y;
  };
  return loess2;
}
function tricube(x) {
  return (x = 1 - x * x * x) * x * x;
}
function updateInterval(xv, i, interval2) {
  var val = xv[i], left2 = interval2[0], right2 = interval2[1] + 1;
  if (right2 >= xv.length)
    return;
  while (i > left2 && xv[right2] - val <= val - xv[left2]) {
    interval2[0] = ++left2;
    interval2[1] = right2;
    ++right2;
  }
}
function output(xv, yhat, ux, uy) {
  var n = xv.length, out = [];
  var i = 0, cnt = 0, prev = [], v;
  for (; i < n; ++i) {
    v = xv[i] + ux;
    if (prev[0] === v) {
      prev[1] += (yhat[i] - prev[1]) / ++cnt;
    } else {
      cnt = 0;
      prev[1] += uy;
      prev = [v, yhat[i]];
      out.push(prev);
    }
  }
  prev[1] += uy;
  return out;
}
function logarithmic() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, base = Math.E, domain;
  function logarithmic2(data2) {
    var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity, lb = Math.log(base);
    visitPoints(data2, x, y, function(dx, dy) {
      var lx = Math.log(dx) / lb;
      ++n;
      X += (lx - X) / n;
      Y += (dy - Y) / n;
      XY += (lx * dy - XY) / n;
      X2 += (lx * lx - X2) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), intercept = _ols2[0], slope = _ols2[1], fn = function fn2(x2) {
      return slope * Math.log(x2) / lb + intercept;
    }, out = interpose(xmin, xmax, fn);
    out.a = slope;
    out.b = intercept;
    out.predict = fn;
    out.rSquared = determination(data2, x, y, Y, fn);
    return out;
  }
  logarithmic2.domain = function(arr) {
    return arguments.length ? (domain = arr, logarithmic2) : domain;
  };
  logarithmic2.x = function(fn) {
    return arguments.length ? (x = fn, logarithmic2) : x;
  };
  logarithmic2.y = function(fn) {
    return arguments.length ? (y = fn, logarithmic2) : y;
  };
  logarithmic2.base = function(n) {
    return arguments.length ? (base = n, logarithmic2) : base;
  };
  return logarithmic2;
}
function quad() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function quadratic(data2) {
    var _points = points(data2, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length;
    var X2 = 0, X3 = 0, X4 = 0, XY = 0, X2Y = 0, i, dx, dy, x2;
    for (i = 0; i < n; ) {
      dx = xv[i];
      dy = yv[i++];
      x2 = dx * dx;
      X2 += (x2 - X2) / i;
      X3 += (x2 * dx - X3) / i;
      X4 += (x2 * x2 - X4) / i;
      XY += (dx * dy - XY) / i;
      X2Y += (x2 * dy - X2Y) / i;
    }
    var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x, y, function(dx2, dy2) {
      n0++;
      Y += (dy2 - Y) / n0;
      if (!domain) {
        if (dx2 < xmin)
          xmin = dx2;
        if (dx2 > xmax)
          xmax = dx2;
      }
    });
    var X2X2 = X4 - X2 * X2, d = X2 * X2X2 - X3 * X3, a = (X2Y * X2 - XY * X3) / d, b = (XY * X2X2 - X2Y * X3) / d, c = -a * X2, fn = function fn2(x3) {
      x3 = x3 - ux;
      return a * x3 * x3 + b * x3 + c + uy;
    };
    var out = interpose(xmin, xmax, fn);
    out.a = a;
    out.b = b - 2 * a * ux;
    out.c = c - b * ux + a * ux * ux + uy;
    out.predict = fn;
    out.rSquared = determination(data2, x, y, Y, fn);
    return out;
  }
  quadratic.domain = function(arr) {
    return arguments.length ? (domain = arr, quadratic) : domain;
  };
  quadratic.x = function(fn) {
    return arguments.length ? (x = fn, quadratic) : x;
  };
  quadratic.y = function(fn) {
    return arguments.length ? (y = fn, quadratic) : y;
  };
  return quadratic;
}
function polynomial() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, order = 3, domain;
  function polynomial2(data2) {
    if (order === 1) {
      var o = linear().x(x).y(y).domain(domain)(data2);
      o.coefficients = [o.b, o.a];
      delete o.a;
      delete o.b;
      return o;
    }
    if (order === 2) {
      var _o = quad().x(x).y(y).domain(domain)(data2);
      _o.coefficients = [_o.c, _o.b, _o.a];
      delete _o.a;
      delete _o.b;
      delete _o.c;
      return _o;
    }
    var _points = points(data2, x, y), _points2 = _slicedToArray(_points, 4), xv = _points2[0], yv = _points2[1], ux = _points2[2], uy = _points2[3], n = xv.length, lhs = [], rhs = [], k = order + 1;
    var Y = 0, n0 = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x, y, function(dx, dy) {
      ++n0;
      Y += (dy - Y) / n0;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var i, j, l, v, c;
    for (i = 0; i < k; ++i) {
      for (l = 0, v = 0; l < n; ++l) {
        v += Math.pow(xv[l], i) * yv[l];
      }
      lhs.push(v);
      c = new Float64Array(k);
      for (j = 0; j < k; ++j) {
        for (l = 0, v = 0; l < n; ++l) {
          v += Math.pow(xv[l], i + j);
        }
        c[j] = v;
      }
      rhs.push(c);
    }
    rhs.push(lhs);
    var coef = gaussianElimination(rhs), fn = function fn2(x2) {
      x2 -= ux;
      var y2 = uy + coef[0] + coef[1] * x2 + coef[2] * x2 * x2;
      for (i = 3; i < k; ++i) {
        y2 += coef[i] * Math.pow(x2, i);
      }
      return y2;
    }, out = interpose(xmin, xmax, fn);
    out.coefficients = uncenter(k, coef, -ux, uy);
    out.predict = fn;
    out.rSquared = determination(data2, x, y, Y, fn);
    return out;
  }
  polynomial2.domain = function(arr) {
    return arguments.length ? (domain = arr, polynomial2) : domain;
  };
  polynomial2.x = function(fn) {
    return arguments.length ? (x = fn, polynomial2) : x;
  };
  polynomial2.y = function(fn) {
    return arguments.length ? (y = fn, polynomial2) : y;
  };
  polynomial2.order = function(n) {
    return arguments.length ? (order = n, polynomial2) : order;
  };
  return polynomial2;
}
function uncenter(k, a, x, y) {
  var z = Array(k);
  var i, j, v, c;
  for (i = 0; i < k; ++i) {
    z[i] = 0;
  }
  for (i = k - 1; i >= 0; --i) {
    v = a[i];
    c = 1;
    z[i] += v;
    for (j = 1; j <= i; ++j) {
      c *= (i + 1 - j) / j;
      z[i - j] += v * Math.pow(x, j) * c;
    }
  }
  z[0] += y;
  return z;
}
function gaussianElimination(matrix) {
  var n = matrix.length - 1, coef = [];
  var i, j, k, r, t;
  for (i = 0; i < n; ++i) {
    r = i;
    for (j = i + 1; j < n; ++j) {
      if (Math.abs(matrix[i][j]) > Math.abs(matrix[i][r])) {
        r = j;
      }
    }
    for (k = i; k < n + 1; ++k) {
      t = matrix[k][i];
      matrix[k][i] = matrix[k][r];
      matrix[k][r] = t;
    }
    for (j = i + 1; j < n; ++j) {
      for (k = n; k >= i; k--) {
        matrix[k][j] -= matrix[k][i] * matrix[i][j] / matrix[i][i];
      }
    }
  }
  for (j = n - 1; j >= 0; --j) {
    t = 0;
    for (k = j + 1; k < n; ++k) {
      t += matrix[k][j] * coef[k];
    }
    coef[j] = (matrix[n][j] - t) / matrix[j][j];
  }
  return coef;
}
function power() {
  var x = function x2(d) {
    return d[0];
  }, y = function y2(d) {
    return d[1];
  }, domain;
  function power2(data2) {
    var n = 0, X = 0, Y = 0, XY = 0, X2 = 0, YS = 0, xmin = domain ? +domain[0] : Infinity, xmax = domain ? +domain[1] : -Infinity;
    visitPoints(data2, x, y, function(dx, dy) {
      var lx = Math.log(dx), ly = Math.log(dy);
      ++n;
      X += (lx - X) / n;
      Y += (ly - Y) / n;
      XY += (lx * ly - XY) / n;
      X2 += (lx * lx - X2) / n;
      YS += (dy - YS) / n;
      if (!domain) {
        if (dx < xmin)
          xmin = dx;
        if (dx > xmax)
          xmax = dx;
      }
    });
    var _ols = ols(X, Y, XY, X2), _ols2 = _slicedToArray(_ols, 2), a = _ols2[0], b = _ols2[1];
    a = Math.exp(a);
    var fn = function fn2(x2) {
      return a * Math.pow(x2, b);
    }, out = interpose(xmin, xmax, fn);
    out.a = a;
    out.b = b;
    out.predict = fn;
    out.rSquared = determination(data2, x, y, YS, fn);
    return out;
  }
  power2.domain = function(arr) {
    return arguments.length ? (domain = arr, power2) : domain;
  };
  power2.x = function(fn) {
    return arguments.length ? (x = fn, power2) : x;
  };
  power2.y = function(fn) {
    return arguments.length ? (y = fn, power2) : y;
  };
  return power2;
}
var REGRESSION_MAP = {
  exp: exponential,
  linear,
  loess,
  log: logarithmic,
  poly: polynomial,
  pow: power,
  quad
};
function getQuadrantDefaultConfig(xBaseline, yBaseline) {
  var textOffset = 10;
  var defaultConfig = {
    regionStyle: [
      {
        position: {
          start: [xBaseline, "max"],
          end: ["max", yBaseline]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", "max"],
          end: [xBaseline, yBaseline]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      },
      {
        position: {
          start: ["min", yBaseline],
          end: [xBaseline, "min"]
        },
        style: {
          fill: "#d8d0c0",
          opacity: 0.4
        }
      },
      {
        position: {
          start: [xBaseline, yBaseline],
          end: ["max", "min"]
        },
        style: {
          fill: "#a3dda1",
          opacity: 0.4
        }
      }
    ],
    lineStyle: {
      stroke: "#9ba29a",
      lineWidth: 1
    },
    labelStyle: [
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "right",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: -textOffset,
        style: {
          textAlign: "left",
          textBaseline: "bottom",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["min", yBaseline],
        offsetX: textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "left",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      },
      {
        position: ["max", yBaseline],
        offsetX: -textOffset,
        offsetY: textOffset,
        style: {
          textAlign: "right",
          textBaseline: "top",
          fontSize: 14,
          fill: "#ccc"
        }
      }
    ]
  };
  return defaultConfig;
}
var splinePath = function(data2, config) {
  var view = config.view, _a2 = config.options, xField = _a2.xField, yField = _a2.yField;
  var xScaleView = view.getScaleByField(xField);
  var yScaleView = view.getScaleByField(yField);
  var pathData = data2.map(function(d) {
    return view.getCoordinate().convert({ x: xScaleView.scale(d[0]), y: yScaleView.scale(d[1]) });
  });
  return getSplinePath(pathData, false);
};
var getPath = function(config) {
  var options = config.options;
  var xField = options.xField, yField = options.yField, data2 = options.data, regressionLine2 = options.regressionLine;
  var _a2 = regressionLine2.type, type = _a2 === void 0 ? "linear" : _a2, algorithm = regressionLine2.algorithm, customEquation = regressionLine2.equation;
  var pathData;
  var equation = null;
  if (algorithm) {
    pathData = isArray$1(algorithm) ? algorithm : algorithm(data2);
    equation = customEquation;
  } else {
    var reg = REGRESSION_MAP[type]().x(function(d) {
      return d[xField];
    }).y(function(d) {
      return d[yField];
    });
    pathData = reg(data2);
    equation = getRegressionEquation(type, pathData);
  }
  return [splinePath(pathData, config), equation];
};
var getMeta = function(options) {
  var _a2;
  var _b = options.meta, meta2 = _b === void 0 ? {} : _b, xField = options.xField, yField = options.yField, data2 = options.data;
  var xFieldValue = data2[0][xField];
  var yFieldValue = data2[0][yField];
  var xIsPositiveNumber = xFieldValue > 0;
  var yIsPositiveNumber = yFieldValue > 0;
  function getMetaMinMax(field2, axis2) {
    var fieldMeta = get(meta2, [field2]);
    function getCustomValue(type) {
      return get(fieldMeta, type);
    }
    var range = {};
    if (axis2 === "x") {
      if (isNumber$1(xFieldValue)) {
        if (!isNumber$1(getCustomValue("min"))) {
          range["min"] = xIsPositiveNumber ? 0 : xFieldValue * 2;
        }
        if (!isNumber$1(getCustomValue("max"))) {
          range["max"] = xIsPositiveNumber ? xFieldValue * 2 : 0;
        }
      }
      return range;
    }
    if (isNumber$1(yFieldValue)) {
      if (!isNumber$1(getCustomValue("min"))) {
        range["min"] = yIsPositiveNumber ? 0 : yFieldValue * 2;
      }
      if (!isNumber$1(getCustomValue("max"))) {
        range["max"] = yIsPositiveNumber ? yFieldValue * 2 : 0;
      }
    }
    return range;
  }
  return __assign$1(__assign$1({}, meta2), (_a2 = {}, _a2[xField] = __assign$1(__assign$1({}, meta2[xField]), getMetaMinMax(xField, "x")), _a2[yField] = __assign$1(__assign$1({}, meta2[yField]), getMetaMinMax(yField, "y")), _a2));
};
function getRegressionEquation(type, res) {
  var _a2, _b, _c;
  var roundByPrecision = function(n, p) {
    if (p === void 0) {
      p = 4;
    }
    return Math.round(n * Math.pow(10, p)) / Math.pow(10, p);
  };
  var safeFormat = function(value2) {
    return Number.isFinite(value2) ? roundByPrecision(value2) : "?";
  };
  switch (type) {
    case "linear":
      return "y = ".concat(safeFormat(res.a), "x + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
    case "exp":
      return "y = ".concat(safeFormat(res.a), "e^(").concat(safeFormat(res.b), "x), R^2 = ").concat(safeFormat(res.rSquared));
    case "log":
      return "y = ".concat(safeFormat(res.a), "ln(x) + ").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
    case "quad":
      return "y = ".concat(safeFormat(res.a), "x^2 + ").concat(safeFormat(res.b), "x + ").concat(safeFormat(res.c), ", R^2 = ").concat(safeFormat(res.rSquared));
    case "poly":
      var temp = "y = ".concat(safeFormat((_a2 = res.coefficients) === null || _a2 === void 0 ? void 0 : _a2[0]), " + ").concat(safeFormat((_b = res.coefficients) === null || _b === void 0 ? void 0 : _b[1]), "x + ").concat(safeFormat((_c = res.coefficients) === null || _c === void 0 ? void 0 : _c[2]), "x^2");
      for (var i = 3; i < res.coefficients.length; ++i) {
        temp += " + ".concat(safeFormat(res.coefficients[i]), "x^").concat(i);
      }
      return "".concat(temp, ", R^2 = ").concat(safeFormat(res.rSquared));
    case "pow":
      return "y = ".concat(safeFormat(res.a), "x^").concat(safeFormat(res.b), ", R^2 = ").concat(safeFormat(res.rSquared));
  }
  return null;
}
function transformOptions$1(options) {
  var _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2, xField = options.xField, yField = options.yField;
  if (data2.length) {
    var isOneX = true;
    var isOneY = true;
    var prev = data2[0];
    var curr = void 0;
    for (var i = 1; i < data2.length; i++) {
      curr = data2[i];
      if (prev[xField] !== curr[xField]) {
        isOneX = false;
      }
      if (prev[yField] !== curr[yField]) {
        isOneY = false;
      }
      if (!isOneX && !isOneY) {
        break;
      }
      prev = curr;
    }
    var keys2 = [];
    isOneX && keys2.push(xField);
    isOneY && keys2.push(yField);
    var meta_1 = pick(getMeta(options), keys2);
    return deepAssign({}, options, { meta: meta_1 });
  }
  return options;
}
function geometry$j(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, type = options.type, color2 = options.color, shape = options.shape, pointStyle = options.pointStyle, shapeField = options.shapeField, colorField = options.colorField, xField = options.xField, yField = options.yField, sizeField = options.sizeField;
  var size2 = options.size;
  var tooltip2 = options.tooltip;
  if (sizeField) {
    if (!size2) {
      size2 = [2, 8];
    }
    if (isNumber$1(size2)) {
      size2 = [size2, size2];
    }
  }
  if (tooltip2 && !tooltip2.fields) {
    tooltip2 = __assign$1(__assign$1({}, tooltip2), { fields: [xField, yField, colorField, sizeField, shapeField] });
  }
  chart.data(data2);
  point(deepAssign({}, params, {
    options: {
      seriesField: colorField,
      point: {
        color: color2,
        shape,
        size: size2,
        style: pointStyle
      },
      tooltip: tooltip2
    }
  }));
  var geometry2 = findGeometry(chart, "point");
  if (type) {
    geometry2.adjust(type);
  }
  return params;
}
function meta$f(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var newOptions = transformOptions$1(options);
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(deepAssign({}, params, { options: newOptions }));
}
function axis$g(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function legend$b(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, shapeField = options.shapeField, sizeField = options.sizeField, shapeLegend = options.shapeLegend, sizeLegend = options.sizeLegend;
  var showLegend = legend2 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend2 : false);
  }
  if (shapeField) {
    if (shapeLegend) {
      chart.legend(shapeField, shapeLegend);
    } else {
      chart.legend(shapeField, shapeLegend === false ? false : legend2);
    }
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend ? sizeLegend : false);
  }
  if (!showLegend && !shapeLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label$9(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var scatterGeometry = findGeometry(chart, "point");
  if (!label2) {
    scatterGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    scatterGeometry.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function scatterAnnotation(params) {
  var options = params.options;
  var quadrant = options.quadrant;
  var annotationOptions = [];
  if (quadrant) {
    var _a2 = quadrant.xBaseline, xBaseline = _a2 === void 0 ? 0 : _a2, _b = quadrant.yBaseline, yBaseline = _b === void 0 ? 0 : _b, labels_1 = quadrant.labels, regionStyle_1 = quadrant.regionStyle, lineStyle = quadrant.lineStyle;
    var defaultConfig_1 = getQuadrantDefaultConfig(xBaseline, yBaseline);
    var quadrants = new Array(4).join(",").split(",");
    quadrants.forEach(function(_, index2) {
      annotationOptions.push(__assign$1(__assign$1({ type: "region", top: false }, defaultConfig_1.regionStyle[index2].position), { style: deepAssign({}, defaultConfig_1.regionStyle[index2].style, regionStyle_1 === null || regionStyle_1 === void 0 ? void 0 : regionStyle_1[index2]) }), __assign$1({ type: "text", top: true }, deepAssign({}, defaultConfig_1.labelStyle[index2], labels_1 === null || labels_1 === void 0 ? void 0 : labels_1[index2])));
    });
    annotationOptions.push({
      type: "line",
      top: false,
      start: ["min", yBaseline],
      end: ["max", yBaseline],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    }, {
      type: "line",
      top: false,
      start: [xBaseline, "min"],
      end: [xBaseline, "max"],
      style: deepAssign({}, defaultConfig_1.lineStyle, lineStyle)
    });
  }
  return flow(annotation$2(annotationOptions))(params);
}
function regressionLine(params) {
  var options = params.options, chart = params.chart;
  var regressionLine2 = options.regressionLine;
  if (regressionLine2) {
    var style_1 = regressionLine2.style, _a2 = regressionLine2.equationStyle, equationStyle_1 = _a2 === void 0 ? {} : _a2, _b = regressionLine2.top, top_1 = _b === void 0 ? false : _b, _c = regressionLine2.showEquation, showEquation_1 = _c === void 0 ? false : _c;
    var defaultStyle_1 = {
      stroke: "#9ba29a",
      lineWidth: 2,
      opacity: 0.5
    };
    var defaulEquationStyle_1 = {
      x: 20,
      y: 20,
      textAlign: "left",
      textBaseline: "middle",
      fontSize: 14,
      fillOpacity: 0.5
    };
    chart.annotation().shape({
      top: top_1,
      render: function(container, view) {
        var group2 = container.addGroup({
          id: "".concat(chart.id, "-regression-line"),
          name: "regression-line-group"
        });
        var _a3 = getPath({
          view,
          options
        }), path2 = _a3[0], equation = _a3[1];
        group2.addShape("path", {
          name: "regression-line",
          attrs: __assign$1(__assign$1({ path: path2 }, defaultStyle_1), style_1)
        });
        if (showEquation_1) {
          group2.addShape("text", {
            name: "regression-equation",
            attrs: __assign$1(__assign$1(__assign$1({}, defaulEquationStyle_1), equationStyle_1), { text: equation })
          });
        }
      }
    });
  }
  return params;
}
function tooltip$6(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2) {
    chart.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    chart.tooltip(false);
  }
  return params;
}
function adaptor$o(params) {
  return flow(
    geometry$j,
    meta$f,
    axis$g,
    legend$b,
    tooltip$6,
    label$9,
    //  interaction 
    brushInteraction,
    slider$2,
    scrollbar,
    interaction$8,
    scatterAnnotation,
    animation$5,
    theme$2,
    regressionLine
  )(params);
}
var DEFAULT_OPTIONS$p = deepAssign({}, Plot.getDefaultOptions(), {
  size: 4,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: true,
    crosshairs: {
      type: "xy"
    }
  }
});
registerInteraction("drag-move", {
  start: [{ trigger: "plot:mousedown", action: "scale-translate:start" }],
  processing: [
    {
      trigger: "plot:mousemove",
      action: "scale-translate:translate",
      throttle: { wait: 100, leading: true, trailing: false }
    }
  ],
  end: [{ trigger: "plot:mouseup", action: "scale-translate:end" }]
});
var Scatter = (
  /** @class */
  function(_super) {
    __extends$1(Scatter2, _super);
    function Scatter2(container, options) {
      var _this = _super.call(this, container, options) || this;
      _this.type = "scatter";
      _this.on(VIEW_LIFE_CIRCLE.BEFORE_RENDER, function(evt) {
        var _a2, _b;
        var _c = _this, options2 = _c.options, chart = _c.chart;
        if (((_a2 = evt.data) === null || _a2 === void 0 ? void 0 : _a2.source) === EVENTS.FILTER) {
          var filteredData = _this.chart.filterData(_this.chart.getData());
          meta$f({ chart, options: __assign$1(__assign$1({}, options2), { data: filteredData }) });
        }
        if (((_b = evt.data) === null || _b === void 0 ? void 0 : _b.source) === EVENTS.RESET) {
          meta$f({ chart, options: options2 });
        }
      });
      return _this;
    }
    Scatter2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$p;
    };
    Scatter2.prototype.changeData = function(data2) {
      this.updateOption(transformOptions$1(deepAssign({}, this.options, { data: data2 })));
      var _a2 = this, options = _a2.options, chart = _a2.chart;
      meta$f({ chart, options });
      this.chart.changeData(data2);
    };
    Scatter2.prototype.getSchemaAdaptor = function() {
      return adaptor$o;
    };
    Scatter2.prototype.getDefaultOptions = function() {
      return Scatter2.getDefaultOptions();
    };
    return Scatter2;
  }(Plot)
);
var Y_FIELD$4 = "$$stock-range$$";
var TREND_FIELD = "trend";
var TREND_UP = "up";
var TREND_DOWN = "down";
var DEFAULT_TOOLTIP_OPTIONS$2 = {
  showMarkers: false,
  showCrosshairs: true,
  shared: true,
  crosshairs: {
    type: "xy",
    follow: true,
    text: function(type, defaultContent, items) {
      var textContent;
      if (type === "x") {
        var item = items[0];
        textContent = item ? item.title : defaultContent;
      } else {
        textContent = defaultContent;
      }
      return {
        position: type === "y" ? "start" : "end",
        content: textContent,
        style: {
          fill: "#dfdfdf"
        }
      };
    },
    //  crosshairs textBackground 
    textBackground: {
      padding: [2, 4],
      style: {
        fill: "#666"
      }
    }
  }
};
var DEFAULT_OPTIONS$o = deepAssign({}, Plot.getDefaultOptions(), {
  //  tooltips
  tooltip: DEFAULT_TOOLTIP_OPTIONS$2,
  interactions: [{ type: "tooltip" }],
  legend: {
    position: "top-left"
  },
  risingFill: "#ef5350",
  fallingFill: "#26a69a"
});
function getStockData(data2, yField) {
  return map$2(data2, function(item) {
    var obj = item && __assign$1({}, item);
    if (isArray$1(yField) && obj) {
      var open_1 = yField[0], close_1 = yField[1], high = yField[2], low = yField[3];
      obj[TREND_FIELD] = obj[open_1] <= obj[close_1] ? TREND_UP : TREND_DOWN;
      obj[Y_FIELD$4] = [obj[open_1], obj[close_1], obj[high], obj[low]];
    }
    return obj;
  });
}
function geometry$i(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField;
  var data2 = options.data, risingFill = options.risingFill, fallingFill = options.fallingFill, tooltip2 = options.tooltip, stockStyle = options.stockStyle;
  chart.data(getStockData(data2, yField));
  var tooltipOptions = tooltip2;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: yField }, tooltipOptions);
  }
  schema(deepAssign({}, params, {
    options: {
      schema: {
        shape: "candle",
        color: [risingFill, fallingFill],
        style: stockStyle
      },
      yField: Y_FIELD$4,
      seriesField: TREND_FIELD,
      rawFields: yField,
      tooltip: tooltipOptions
    }
  }));
  return params;
}
function meta$e(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  var baseMeta = (_a2 = {}, _a2[xField] = {
    type: "timeCat",
    tickCount: 6
  }, _a2[TREND_FIELD] = {
    values: [TREND_UP, TREND_DOWN]
  }, _a2);
  var scales = deepAssign(baseMeta, meta2, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[Y_FIELD$4] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis$f(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(Y_FIELD$4, false);
  } else {
    chart.axis(Y_FIELD$4, yAxis);
  }
  return params;
}
function tooltip$5(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 !== false) {
    chart.tooltip(tooltip2);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function legend$a(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  if (legend2) {
    chart.legend(TREND_FIELD, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  return params;
}
function adaptor$n(params) {
  flow(theme$2, geometry$i, meta$e, axis$f, tooltip$5, legend$a, interaction$8, animation$5, annotation$2(), slider$2)(params);
}
var Stock = (
  /** @class */
  function(_super) {
    __extends$1(Stock2, _super);
    function Stock2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "stock";
      return _this;
    }
    Stock2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$o;
    };
    Stock2.prototype.getDefaultOptions = function() {
      return Stock2.getDefaultOptions();
    };
    Stock2.prototype.getSchemaAdaptor = function() {
      return adaptor$n;
    };
    Stock2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var yField = this.options.yField;
      this.chart.changeData(getStockData(data2, yField));
    };
    return Stock2;
  }(Plot)
);
function getTinyData(data2) {
  return map$2(data2 || [], function(y, x) {
    return { x: "".concat(x), y };
  });
}
var X_FIELD$3 = "x";
var Y_FIELD$3 = "y";
var DEFAULT_TOOLTIP_OPTIONS$1 = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x, data2) {
    return "".concat(get(data2, [0, "data", "y"], 0));
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  },
  showCrosshairs: true,
  crosshairs: {
    type: "x"
  }
};
var DEFAULT_OPTIONS$n = {
  appendPadding: 2,
  tooltip: __assign$1({}, DEFAULT_TOOLTIP_OPTIONS$1),
  animation: {}
};
function geometry$h(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, areaStyle = options.areaStyle, pointOptions = options.point, lineOptions = options.line;
  var pointState = pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$3,
      area: { color: color2, style: areaStyle },
      line: lineOptions,
      point: pointOptions
    }
  });
  var second = deepAssign({}, primary, { options: { tooltip: false } });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  area(primary);
  line(second);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function meta$d(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, data2 = options.data;
  var seriesData = getTinyData(data2);
  return flow(scale$2((_a2 = {}, _a2[X_FIELD$3] = xAxis, _a2[Y_FIELD$3] = yAxis, _a2), (_b = {}, _b[X_FIELD$3] = {
    type: "cat"
  }, _b[Y_FIELD$3] = adjustYMetaByZero(seriesData, Y_FIELD$3), _b)))(params);
}
function adaptor$m(params) {
  return flow(pattern("areaStyle"), geometry$h, meta$d, tooltip$9, theme$2, animation$5, annotation$2())(params);
}
var DEFAULT_OPTIONS$m = {
  appendPadding: 2,
  tooltip: __assign$1({}, DEFAULT_TOOLTIP_OPTIONS$1),
  // 
  color: "l(90) 0:#E5EDFE 1:#ffffff",
  areaStyle: {
    fillOpacity: 0.6
  },
  line: {
    size: 1,
    color: "#5B8FF9"
  },
  animation: {}
};
var TinyArea = (
  /** @class */
  function(_super) {
    __extends$1(TinyArea2, _super);
    function TinyArea2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "tiny-area";
      return _this;
    }
    TinyArea2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$m;
    };
    TinyArea2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this, chart = _a2.chart, options = _a2.options;
      meta$d({ chart, options });
      chart.changeData(getTinyData(data2));
    };
    TinyArea2.prototype.getDefaultOptions = function() {
      return TinyArea2.getDefaultOptions();
    };
    TinyArea2.prototype.getSchemaAdaptor = function() {
      return adaptor$m;
    };
    return TinyArea2;
  }(Plot)
);
function geometry$g(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, columnStyle = options.columnStyle, columnWidthRatio = options.columnWidthRatio;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var p = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$3,
      widthRatio: columnWidthRatio,
      interval: {
        style: columnStyle,
        color: color2
      }
    }
  });
  interval(p);
  chart.axis(false);
  chart.legend(false);
  chart.interaction("element-active");
  return params;
}
function adaptor$l(params) {
  return flow(theme$2, pattern("columnStyle"), geometry$g, meta$d, tooltip$9, animation$5, annotation$2())(params);
}
var DEFAULT_TOOLTIP_OPTIONS = {
  showTitle: false,
  shared: true,
  showMarkers: false,
  customContent: function(x, data2) {
    return "".concat(get(data2, [0, "data", "y"], 0));
  },
  containerTpl: '<div class="g2-tooltip"><div class="g2-tooltip-list"></div></div>',
  itemTpl: "<span>{value}</span>",
  domStyles: {
    "g2-tooltip": {
      padding: "2px 4px",
      fontSize: "10px"
    }
  }
};
var DEFAULT_OPTIONS$l = {
  appendPadding: 2,
  tooltip: __assign$1({}, DEFAULT_TOOLTIP_OPTIONS),
  animation: {}
};
var TinyColumn = (
  /** @class */
  function(_super) {
    __extends$1(TinyColumn2, _super);
    function TinyColumn2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "tiny-column";
      return _this;
    }
    TinyColumn2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$l;
    };
    TinyColumn2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this, chart = _a2.chart, options = _a2.options;
      meta$d({ chart, options });
      chart.changeData(getTinyData(data2));
    };
    TinyColumn2.prototype.getDefaultOptions = function() {
      return TinyColumn2.getDefaultOptions();
    };
    TinyColumn2.prototype.getSchemaAdaptor = function() {
      return adaptor$l;
    };
    return TinyColumn2;
  }(Plot)
);
function geometry$f(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, color2 = options.color, lineStyle = options.lineStyle, pointMapping = options.point;
  var pointState = pointMapping === null || pointMapping === void 0 ? void 0 : pointMapping.state;
  var seriesData = getTinyData(data2);
  chart.data(seriesData);
  var primary = deepAssign({}, params, {
    options: {
      xField: X_FIELD$3,
      yField: Y_FIELD$3,
      line: {
        color: color2,
        style: lineStyle
      },
      point: pointMapping
    }
  });
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  chart.axis(false);
  chart.legend(false);
  return params;
}
function adaptor$k(params) {
  return flow(geometry$f, meta$d, theme$2, tooltip$9, animation$5, annotation$2())(params);
}
var TinyLine = (
  /** @class */
  function(_super) {
    __extends$1(TinyLine2, _super);
    function TinyLine2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "tiny-line";
      return _this;
    }
    TinyLine2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$n;
    };
    TinyLine2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      var _a2 = this, chart = _a2.chart, options = _a2.options;
      meta$d({ chart, options });
      chart.changeData(getTinyData(data2));
    };
    TinyLine2.prototype.getDefaultOptions = function() {
      return TinyLine2.getDefaultOptions();
    };
    TinyLine2.prototype.getSchemaAdaptor = function() {
      return adaptor$k;
    };
    return TinyLine2;
  }(Plot)
);
var PLOT_ADAPTORS = {
  line: adaptor$y,
  pie: adaptor$r,
  column: adaptor$w,
  bar: adaptor$v,
  area: adaptor$x,
  gauge: adaptor$t,
  "tiny-line": adaptor$k,
  "tiny-column": adaptor$l,
  "tiny-area": adaptor$m,
  "ring-progress": adaptor$p,
  progress: adaptor$q,
  scatter: adaptor$o,
  histogram: adaptor$s,
  funnel: adaptor$u,
  stock: adaptor$n
};
var PLOT_CONSTRUCTOR = {
  line: Line,
  pie: Pie,
  column: Column,
  bar: Bar,
  area: Area,
  gauge: Gauge,
  "tiny-line": TinyLine,
  "tiny-column": TinyColumn,
  "tiny-area": TinyArea,
  "ring-progress": RingProgress,
  progress: Progress,
  scatter: Scatter,
  histogram: Histogram,
  funnel: Funnel,
  stock: Stock
};
var DEFAULT_OPTIONS_MAP = {
  pie: { label: false },
  column: { tooltip: { showMarkers: false } },
  bar: { tooltip: { showMarkers: false } }
};
function execPlotAdaptor(plot, view, options) {
  var cls = PLOT_CONSTRUCTOR[plot];
  if (!cls) {
    console.error("could not find ".concat(plot, " plot"));
    return;
  }
  var module = PLOT_ADAPTORS[plot];
  module({
    chart: view,
    options: deepAssign({}, cls.getDefaultOptions(), get(DEFAULT_OPTIONS_MAP, plot, {}), options)
  });
}
function multiView(params) {
  var chart = params.chart, options = params.options;
  var views = options.views, legend2 = options.legend;
  each$1(views, function(v) {
    var region = v.region, data2 = v.data, meta2 = v.meta, axes = v.axes, coordinate2 = v.coordinate, interactions = v.interactions, annotations = v.annotations, tooltip2 = v.tooltip, geometries = v.geometries;
    var viewOfG2 = chart.createView({
      region
    });
    viewOfG2.data(data2);
    var scales = {};
    if (axes) {
      each$1(axes, function(axis2, field2) {
        scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
      });
    }
    scales = deepAssign({}, meta2, scales);
    viewOfG2.scale(scales);
    if (!axes) {
      viewOfG2.axis(false);
    } else {
      each$1(axes, function(axis2, field2) {
        viewOfG2.axis(field2, axis2);
      });
    }
    viewOfG2.coordinate(coordinate2);
    each$1(geometries, function(geometry2) {
      var ext = geometry$x({
        chart: viewOfG2,
        options: geometry2
      }).ext;
      var adjust2 = geometry2.adjust;
      if (adjust2) {
        ext.geometry.adjust(adjust2);
      }
    });
    each$1(interactions, function(interaction2) {
      if (interaction2.enable === false) {
        viewOfG2.removeInteraction(interaction2.type);
      } else {
        viewOfG2.interaction(interaction2.type, interaction2.cfg);
      }
    });
    each$1(annotations, function(annotation2) {
      viewOfG2.annotation()[annotation2.type](__assign$1({}, annotation2));
    });
    if (typeof v.animation === "boolean") {
      viewOfG2.animate(false);
    } else {
      viewOfG2.animate(true);
      each$1(viewOfG2.geometries, function(g) {
        g.animate(v.animation);
      });
    }
    if (tooltip2) {
      viewOfG2.interaction("tooltip");
      viewOfG2.tooltip(tooltip2);
    }
  });
  if (!legend2) {
    chart.legend(false);
  } else {
    each$1(legend2, function(l, field2) {
      chart.legend(field2, l);
    });
  }
  chart.tooltip(options.tooltip);
  return params;
}
function multiPlot(params) {
  var chart = params.chart, options = params.options;
  var plots = options.plots, _a2 = options.data, data2 = _a2 === void 0 ? [] : _a2;
  each$1(plots, function(plot) {
    var type = plot.type, region = plot.region, _a3 = plot.options, options2 = _a3 === void 0 ? {} : _a3, top = plot.top;
    var tooltip2 = options2.tooltip;
    if (top) {
      execPlotAdaptor(type, chart, __assign$1(__assign$1({}, options2), { data: data2 }));
      return;
    }
    var viewOfG2 = chart.createView(__assign$1({ region }, pick(options2, PLOT_CONTAINER_OPTIONS)));
    if (tooltip2) {
      viewOfG2.interaction("tooltip");
    }
    execPlotAdaptor(type, viewOfG2, __assign$1({ data: data2 }, options2));
  });
  return params;
}
function slider$1(params) {
  var chart = params.chart, options = params.options;
  chart.option("slider", options.slider);
  return params;
}
function adaptor$j(params) {
  return flow(
    animation$5,
    //  view 
    multiView,
    multiPlot,
    interaction$8,
    animation$5,
    theme$2,
    tooltip$9,
    slider$1,
    annotation$2()
    // ...  adaptor flow
  )(params);
}
function getElementValue(element, field2) {
  var model = element.getModel();
  var record = model.data;
  var value2;
  if (isArray$1(record)) {
    value2 = record[0][field2];
  } else {
    value2 = record[field2];
  }
  return value2;
}
function clearHighlight(view) {
  var elements = getAllElements(view);
  each$1(elements, function(el) {
    if (el.hasState("active")) {
      el.setState("active", false);
    }
    if (el.hasState("selected")) {
      el.setState("selected", false);
    }
    if (el.hasState("inactive")) {
      el.setState("inactive", false);
    }
  });
}
var Association = (
  /** @class */
  function(_super) {
    __extends$1(Association2, _super);
    function Association2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Association2.prototype.getAssociationItems = function(views, params) {
      var _a2;
      var event = this.context.event;
      var _b = params || {}, linkField = _b.linkField, dim = _b.dim;
      var items = [];
      if ((_a2 = event.data) === null || _a2 === void 0 ? void 0 : _a2.data) {
        var data_1 = event.data.data;
        each$1(views, function(v) {
          var _a3, _b2;
          var field2 = linkField;
          if (dim === "x") {
            field2 = v.getXScale().field;
          } else if (dim === "y") {
            field2 = (_a3 = v.getYScales().find(function(s) {
              return s.field === field2;
            })) === null || _a3 === void 0 ? void 0 : _a3.field;
          } else if (!field2) {
            field2 = (_b2 = v.getGroupScales()[0]) === null || _b2 === void 0 ? void 0 : _b2.field;
          }
          if (!field2) {
            return;
          }
          var elements = map$2(getAllElements(v), function(ele) {
            var active = false;
            var inactive = false;
            var dataValue = isArray$1(data_1) ? get(data_1[0], field2) : get(data_1, field2);
            if (getElementValue(ele, field2) === dataValue) {
              active = true;
            } else {
              inactive = true;
            }
            return { element: ele, view: v, active, inactive };
          });
          items.push.apply(items, elements);
        });
      }
      return items;
    };
    Association2.prototype.showTooltip = function(params) {
      var siblings2 = getSiblingViews(this.context.view);
      var elements = this.getAssociationItems(siblings2, params);
      each$1(elements, function(ele) {
        if (ele.active) {
          var box2 = ele.element.shape.getCanvasBBox();
          ele.view.showTooltip({ x: box2.minX + box2.width / 2, y: box2.minY + box2.height / 2 });
        }
      });
    };
    Association2.prototype.hideTooltip = function() {
      var siblings2 = getSiblingViews(this.context.view);
      each$1(siblings2, function(sibling) {
        sibling.hideTooltip();
      });
    };
    Association2.prototype.active = function(params) {
      var views = getViews(this.context.view);
      var items = this.getAssociationItems(views, params);
      each$1(items, function(item) {
        var active = item.active, element = item.element;
        if (active) {
          element.setState("active", true);
        }
      });
    };
    Association2.prototype.selected = function(params) {
      var views = getViews(this.context.view);
      var items = this.getAssociationItems(views, params);
      each$1(items, function(item) {
        var active = item.active, element = item.element;
        if (active) {
          element.setState("selected", true);
        }
      });
    };
    Association2.prototype.highlight = function(params) {
      var views = getViews(this.context.view);
      var items = this.getAssociationItems(views, params);
      each$1(items, function(item) {
        var inactive = item.inactive, element = item.element;
        if (inactive) {
          element.setState("inactive", true);
        }
      });
    };
    Association2.prototype.reset = function() {
      var views = getViews(this.context.view);
      each$1(views, function(v) {
        clearHighlight(v);
      });
    };
    return Association2;
  }(Action)
);
registerAction("association", Association);
registerInteraction("association-active", {
  start: [{ trigger: "element:mouseenter", action: "association:active" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-selected", {
  start: [{ trigger: "element:mouseenter", action: "association:selected" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-highlight", {
  start: [{ trigger: "element:mouseenter", action: "association:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "association:reset" }]
});
registerInteraction("association-tooltip", {
  start: [{ trigger: "element:mousemove", action: "association:showTooltip" }],
  end: [{ trigger: "element:mouseleave", action: "association:hideTooltip" }]
});
(function(_super) {
  __extends$1(Mix, _super);
  function Mix() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "mix";
    return _this;
  }
  Mix.prototype.getSchemaAdaptor = function() {
    return adaptor$j;
  };
  return Mix;
})(Plot);
var Stage;
(function(Stage2) {
  Stage2["DEV"] = "DEV";
  Stage2["BETA"] = "BETA";
  Stage2["STABLE"] = "STABLE";
})(Stage || (Stage = {}));
var FIRST_AXES_VIEW = "first-axes-view";
var SECOND_AXES_VIEW = "second-axes-view";
var SERIES_FIELD_KEY = "series-field-key";
function transformData$7(xField, yField, seriesField, data2, reverse) {
  var hopeData = [];
  yField.forEach(function(d) {
    data2.forEach(function(k) {
      var _a3;
      var obj = (_a3 = {}, _a3[xField] = k[xField], _a3[seriesField] = d, _a3[d] = k[d], _a3);
      hopeData.push(obj);
    });
  });
  var groupData = Object.values(groupBy(hopeData, seriesField));
  var _a2 = groupData[0], data1 = _a2 === void 0 ? [] : _a2, _b = groupData[1], data22 = _b === void 0 ? [] : _b;
  return reverse ? [data1.reverse(), data22.reverse()] : [data1, data22];
}
function isHorizontal(layout2) {
  return layout2 !== "vertical";
}
function syncViewPadding(chart, views, p) {
  var v1 = views[0], v2 = views[1];
  var p1 = v1.autoPadding;
  var p2 = v2.autoPadding;
  var _a2 = chart.__axisPosition, layout2 = _a2.layout, position = _a2.position;
  if (isHorizontal(layout2) && position === "top") {
    v1.autoPadding = p.instance(p1.top, 0, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p1.left, p2.bottom, 0);
  }
  if (isHorizontal(layout2) && position === "bottom") {
    v1.autoPadding = p.instance(p1.top, p1.right / 2 + 5, p1.bottom, p1.left);
    v2.autoPadding = p.instance(p2.top, p2.right, p2.bottom, p1.right / 2 + 5);
  }
  if (!isHorizontal(layout2) && position === "bottom") {
    var left2 = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, p1.bottom / 2 + 5, left2);
    v2.autoPadding = p.instance(p1.bottom / 2 + 5, p2.right, p2.bottom, left2);
  }
  if (!isHorizontal(layout2) && position === "top") {
    var left2 = p1.left >= p2.left ? p1.left : p2.left;
    v1.autoPadding = p.instance(p1.top, p1.right, 0, left2);
    v2.autoPadding = p.instance(0, p2.right, p1.top, left2);
  }
}
function geometry$e(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, color2 = options.color, barStyle = options.barStyle, widthRatio = options.widthRatio, legend2 = options.legend, layout2 = options.layout;
  var groupData = transformData$7(xField, yField, SERIES_FIELD_KEY, data2, isHorizontal(layout2));
  if (legend2) {
    chart.legend(SERIES_FIELD_KEY, legend2);
  } else if (legend2 === false) {
    chart.legend(false);
  }
  var firstView;
  var secondView;
  var firstViewData = groupData[0], secondViewData = groupData[1];
  if (isHorizontal(layout2)) {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 0.5, y: 1 }
      },
      id: FIRST_AXES_VIEW
    });
    firstView.coordinate().transpose().reflect("x");
    secondView = chart.createView({
      region: {
        start: { x: 0.5, y: 0 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().transpose();
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  } else {
    firstView = chart.createView({
      region: {
        start: { x: 0, y: 0 },
        end: { x: 1, y: 0.5 }
      },
      id: FIRST_AXES_VIEW
    });
    secondView = chart.createView({
      region: {
        start: { x: 0, y: 0.5 },
        end: { x: 1, y: 1 }
      },
      id: SECOND_AXES_VIEW
    });
    secondView.coordinate().reflect("y");
    firstView.data(firstViewData);
    secondView.data(secondViewData);
  }
  var left2 = deepAssign({}, params, {
    chart: firstView,
    options: {
      widthRatio,
      xField,
      yField: yField[0],
      seriesField: SERIES_FIELD_KEY,
      interval: {
        color: color2,
        style: barStyle
      }
    }
  });
  interval(left2);
  var right2 = deepAssign({}, params, {
    chart: secondView,
    options: {
      xField,
      yField: yField[1],
      seriesField: SERIES_FIELD_KEY,
      widthRatio,
      interval: {
        color: color2,
        style: barStyle
      }
    }
  });
  interval(right2);
  return params;
}
function meta$c(params) {
  var _a2, _b, _c;
  var options = params.options, chart = params.chart;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var aliasMap = {};
  keys((options === null || options === void 0 ? void 0 : options.meta) || {}).map(function(metaKey) {
    if (get(options === null || options === void 0 ? void 0 : options.meta, [metaKey, "alias"])) {
      aliasMap[metaKey] = options.meta[metaKey].alias;
    }
  });
  chart.scale((_a2 = {}, _a2[SERIES_FIELD_KEY] = {
    sync: true,
    formatter: function(v) {
      return get(aliasMap, v, v);
    }
  }, _a2));
  scale$2((_b = {}, _b[xField] = xAxis, _b[yField[0]] = yAxis[yField[0]], _b))(deepAssign({}, params, { chart: firstView }));
  scale$2((_c = {}, _c[xField] = xAxis, _c[yField[1]] = yAxis[yField[1]], _c))(deepAssign({}, params, { chart: secondView }));
  return params;
}
function axis$e(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, layout2 = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  if ((xAxis === null || xAxis === void 0 ? void 0 : xAxis.position) === "bottom") {
    secondView.axis(xField, __assign$1(__assign$1({}, xAxis), { label: { formatter: function() {
      return "";
    } } }));
  } else {
    secondView.axis(xField, false);
  }
  if (xAxis === false) {
    firstView.axis(xField, false);
  } else {
    firstView.axis(xField, __assign$1({
      //  firstView 
      position: isHorizontal(layout2) ? "top" : "bottom"
    }, xAxis));
  }
  if (yAxis === false) {
    firstView.axis(yField[0], false);
    secondView.axis(yField[1], false);
  } else {
    firstView.axis(yField[0], yAxis[yField[0]]);
    secondView.axis(yField[1], yAxis[yField[1]]);
  }
  chart.__axisPosition = {
    position: firstView.getOptions().axes[xField].position,
    layout: layout2
  };
  return params;
}
function interaction$5(params) {
  var chart = params.chart;
  interaction$8(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  interaction$8(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function limitInPlot$1(params) {
  var chart = params.chart, options = params.options;
  var yField = options.yField, yAxis = options.yAxis;
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, FIRST_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[0]]
    }
  }));
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, SECOND_AXES_VIEW),
    options: {
      yAxis: yAxis[yField[1]]
    }
  }));
  return params;
}
function theme$1(params) {
  var chart = params.chart;
  theme$2(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  theme$2(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  theme$2(params);
  return params;
}
function animation$4(params) {
  var chart = params.chart;
  animation$5(deepAssign({}, params, { chart: findViewById(chart, FIRST_AXES_VIEW) }));
  animation$5(deepAssign({}, params, { chart: findViewById(chart, SECOND_AXES_VIEW) }));
  return params;
}
function label$8(params) {
  var _this = this;
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField, layout2 = options.layout;
  var firstView = findViewById(chart, FIRST_AXES_VIEW);
  var secondView = findViewById(chart, SECOND_AXES_VIEW);
  var leftGeometry = findGeometry(firstView, "interval");
  var rightGeometry = findGeometry(secondView, "interval");
  if (!label2) {
    leftGeometry.label(false);
    rightGeometry.label(false);
  } else {
    var callback = label2.callback, cfg_1 = __rest(label2, ["callback"]);
    if (!cfg_1.position) {
      cfg_1.position = "middle";
    }
    if (cfg_1.offset === void 0) {
      cfg_1.offset = 2;
    }
    var leftLabelCfg = __assign$1({}, cfg_1);
    if (isHorizontal(layout2)) {
      var textAlign = ((_a2 = leftLabelCfg.style) === null || _a2 === void 0 ? void 0 : _a2.textAlign) || (cfg_1.position === "middle" ? "center" : "left");
      cfg_1.style = deepAssign({}, cfg_1.style, { textAlign });
      var textAlignMap = { left: "right", right: "left", center: "center" };
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textAlign: textAlignMap[textAlign] });
    } else {
      var positionMap_1 = { top: "bottom", bottom: "top", middle: "middle" };
      if (typeof cfg_1.position === "string") {
        cfg_1.position = positionMap_1[cfg_1.position];
      } else if (typeof cfg_1.position === "function") {
        cfg_1.position = function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          return positionMap_1[cfg_1.position.apply(_this, args)];
        };
      }
      var textBaseline = ((_b = leftLabelCfg.style) === null || _b === void 0 ? void 0 : _b.textBaseline) || "bottom";
      leftLabelCfg.style = deepAssign({}, leftLabelCfg.style, { textBaseline });
      var textBaselineMap = { top: "bottom", bottom: "top", middle: "middle" };
      cfg_1.style = deepAssign({}, cfg_1.style, { textBaseline: textBaselineMap[textBaseline] });
    }
    leftGeometry.label({
      fields: [yField[0]],
      callback,
      cfg: transformLabel(leftLabelCfg)
    });
    rightGeometry.label({
      fields: [yField[1]],
      callback,
      cfg: transformLabel(cfg_1)
    });
  }
  return params;
}
function adaptor$i(params) {
  return flow(geometry$e, meta$c, axis$e, limitInPlot$1, theme$1, label$8, tooltip$9, interaction$5, animation$4)(params);
}
(function(_super) {
  __extends$1(BidirectionalBar, _super);
  function BidirectionalBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bidirectional-bar";
    return _this;
  }
  BidirectionalBar.getDefaultOptions = function() {
    return deepAssign({}, _super.getDefaultOptions.call(this), {
      syncViewPadding
    });
  };
  BidirectionalBar.prototype.changeData = function(data2) {
    if (data2 === void 0) {
      data2 = [];
    }
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ data: data2 });
    var _a2 = this.options, xField = _a2.xField, yField = _a2.yField, layout2 = _a2.layout;
    var groupData = transformData$7(xField, yField, SERIES_FIELD_KEY, data2, isHorizontal(layout2));
    var firstViewData = groupData[0], secondViewData = groupData[1];
    var firstView = findViewById(this.chart, FIRST_AXES_VIEW);
    var secondView = findViewById(this.chart, SECOND_AXES_VIEW);
    firstView.data(firstViewData);
    secondView.data(secondViewData);
    this.chart.render(true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  BidirectionalBar.prototype.getDefaultOptions = function() {
    return BidirectionalBar.getDefaultOptions();
  };
  BidirectionalBar.prototype.getSchemaAdaptor = function() {
    return adaptor$i;
  };
  BidirectionalBar.SERIES_FIELD_KEY = SERIES_FIELD_KEY;
  return BidirectionalBar;
})(Plot);
var _a;
var BOX_RANGE = "$$range$$";
var BOX_RANGE_ALIAS = "low-q1-median-q3-high";
var BOX_SYNC_NAME = "$$y_outliers$$";
var OUTLIERS_VIEW_ID = "outliers_view";
var DEFAULT_OPTIONS$k = deepAssign({}, Plot.getDefaultOptions(), {
  meta: (_a = {}, _a[BOX_RANGE] = { min: 0, alias: BOX_RANGE_ALIAS }, _a),
  // 
  interactions: [{ type: "active-region" }],
  //  tooltips  markers
  tooltip: {
    showMarkers: false,
    shared: true
  },
  boxStyle: {
    lineWidth: 1
  }
});
var transformData$6 = function(data2, yField) {
  var newData = data2;
  if (Array.isArray(yField)) {
    var low_1 = yField[0], q1_1 = yField[1], median_1 = yField[2], q3_1 = yField[3], high_1 = yField[4];
    newData = map$2(data2, function(obj) {
      obj[BOX_RANGE] = [obj[low_1], obj[q1_1], obj[median_1], obj[q3_1], obj[high_1]];
      return obj;
    });
  }
  return newData;
};
function field(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, groupField = options.groupField, color2 = options.color, tooltip2 = options.tooltip, boxStyle = options.boxStyle;
  chart.data(transformData$6(options.data, yField));
  var yFieldName = isArray$1(yField) ? BOX_RANGE : yField;
  var rawFields = yField ? isArray$1(yField) ? yField : [yField] : [];
  var tooltipOptions = tooltip2;
  if (tooltipOptions !== false) {
    tooltipOptions = deepAssign({}, { fields: isArray$1(yField) ? yField : [] }, tooltipOptions);
  }
  var ext = schema(deepAssign({}, params, {
    options: {
      xField,
      yField: yFieldName,
      seriesField: groupField,
      tooltip: tooltipOptions,
      rawFields,
      //  label
      label: false,
      schema: {
        shape: "box",
        color: color2,
        style: boxStyle
      }
    }
  })).ext;
  if (groupField) {
    ext.geometry.adjust("dodge");
  }
  return params;
}
function outliersPoint(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, data2 = options.data, outliersField = options.outliersField, outliersStyle = options.outliersStyle, padding2 = options.padding, label2 = options.label;
  if (!outliersField)
    return params;
  var outliersView = chart.createView({ padding: padding2, id: OUTLIERS_VIEW_ID });
  var outliersViewData = data2.reduce(function(ret, datum) {
    var outliersData = datum[outliersField];
    outliersData.forEach(function(d) {
      var _a2;
      return ret.push(__assign$1(__assign$1({}, datum), (_a2 = {}, _a2[outliersField] = d, _a2)));
    });
    return ret;
  }, []);
  outliersView.data(outliersViewData);
  point({
    chart: outliersView,
    options: {
      xField,
      yField: outliersField,
      point: { shape: "circle", style: outliersStyle },
      label: label2
    }
  });
  outliersView.axis(false);
  return params;
}
function meta$b(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, outliersField = options.outliersField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  var baseMeta = {};
  if (outliersField) {
    var syncName = BOX_SYNC_NAME;
    baseMeta = (_a2 = {}, _a2[outliersField] = { sync: syncName, nice: true }, _a2[yFieldName] = { sync: syncName, nice: true }, _a2);
  }
  var scales = deepAssign(baseMeta, meta2, (_b = {}, _b[xField] = pick(xAxis, AXIS_META_CONFIG_KEYS), _b[yFieldName] = pick(yAxis, AXIS_META_CONFIG_KEYS), _b));
  chart.scale(scales);
  return params;
}
function axis$d(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  var yFieldName = Array.isArray(yField) ? BOX_RANGE : yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(BOX_RANGE, false);
  } else {
    chart.axis(yFieldName, yAxis);
  }
  return params;
}
function legend$9(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, groupField = options.groupField;
  if (groupField) {
    if (legend2) {
      chart.legend(groupField, legend2);
    } else {
      chart.legend(groupField, { position: "bottom" });
    }
  } else {
    chart.legend(false);
  }
  return params;
}
function adaptor$h(params) {
  return flow(field, outliersPoint, meta$b, axis$d, legend$9, tooltip$9, annotation$2(), interaction$8, animation$5, theme$2)(params);
}
(function(_super) {
  __extends$1(Box, _super);
  function Box() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "box";
    return _this;
  }
  Box.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$k;
  };
  Box.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var yField = this.options.yField;
    var outliersView = this.chart.views.find(function(v) {
      return v.id === OUTLIERS_VIEW_ID;
    });
    if (outliersView) {
      outliersView.data(data2);
    }
    this.chart.changeData(transformData$6(data2, yField));
  };
  Box.prototype.getDefaultOptions = function() {
    return Box.getDefaultOptions();
  };
  Box.prototype.getSchemaAdaptor = function() {
    return adaptor$h;
  };
  return Box;
})(Plot);
function getSeriesFieldKey(values2, field2, index2) {
  return values2.length > 1 ? "".concat(field2, "_").concat(index2) : "".concat(field2);
}
function transformData$5(options) {
  var data2 = options.data, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField, layout2 = options.layout;
  var ds = [];
  var scales = [];
  data2.forEach(function(item, index2) {
    var rangeValues = [item[rangeField]].flat();
    rangeValues.sort(function(a, b) {
      return a - b;
    });
    rangeValues.forEach(function(d, i) {
      var _a2;
      var range = i === 0 ? d : rangeValues[i] - rangeValues[i - 1];
      ds.push((_a2 = {
        rKey: "".concat(rangeField, "_").concat(i)
      }, _a2[xField] = xField ? item[xField] : String(index2), _a2[rangeField] = range, _a2));
    });
    var measureValues = [item[measureField]].flat();
    measureValues.forEach(function(d, i) {
      var _a2;
      ds.push((_a2 = {
        mKey: getSeriesFieldKey(measureValues, measureField, i)
      }, _a2[xField] = xField ? item[xField] : String(index2), _a2[measureField] = d, _a2));
    });
    var targetValues = [item[targetField]].flat();
    targetValues.forEach(function(d, i) {
      var _a2;
      ds.push((_a2 = {
        tKey: getSeriesFieldKey(targetValues, targetField, i)
      }, _a2[xField] = xField ? item[xField] : String(index2), _a2[targetField] = d, _a2));
    });
    scales.push(item[rangeField], item[measureField], item[targetField]);
  });
  var min2 = Math.min.apply(Math, scales.flat(Infinity));
  var max2 = Math.max.apply(Math, scales.flat(Infinity));
  min2 = min2 > 0 ? 0 : min2;
  if (layout2 === "vertical") {
    ds.reverse();
  }
  return { min: min2, max: max2, ds };
}
function geometry$d(params) {
  var chart = params.chart, options = params.options;
  var bulletStyle = options.bulletStyle, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField, color2 = options.color, layout2 = options.layout, size2 = options.size, label2 = options.label;
  var _a2 = transformData$5(options), min2 = _a2.min, max2 = _a2.max, ds = _a2.ds;
  chart.data(ds);
  var r = deepAssign({}, params, {
    options: {
      xField,
      yField: rangeField,
      seriesField: "rKey",
      isStack: true,
      label: get(label2, "range"),
      interval: {
        color: get(color2, "range"),
        style: get(bulletStyle, "range"),
        size: get(size2, "range")
      }
    }
  });
  interval(r);
  chart.geometries[0].tooltip(false);
  var m = deepAssign({}, params, {
    options: {
      xField,
      yField: measureField,
      seriesField: "mKey",
      isStack: true,
      label: get(label2, "measure"),
      interval: {
        color: get(color2, "measure"),
        style: get(bulletStyle, "measure"),
        size: get(size2, "measure")
      }
    }
  });
  interval(m);
  var t = deepAssign({}, params, {
    options: {
      xField,
      yField: targetField,
      seriesField: "tKey",
      label: get(label2, "target"),
      point: {
        color: get(color2, "target"),
        style: get(bulletStyle, "target"),
        size: isFunction(get(size2, "target")) ? function(data2) {
          return get(size2, "target")(data2) / 2;
        } : get(size2, "target") / 2,
        shape: layout2 === "horizontal" ? "line" : "hyphen"
      }
    }
  });
  point(t);
  if (layout2 === "horizontal") {
    chart.coordinate().transpose();
  }
  return __assign$1(__assign$1({}, params), { ext: { data: { min: min2, max: max2 } } });
}
function meta$a(params) {
  var _a2, _b;
  var options = params.options, ext = params.ext;
  var xAxis = options.xAxis, yAxis = options.yAxis, targetField = options.targetField, rangeField = options.rangeField, measureField = options.measureField, xField = options.xField;
  var extData = ext.data;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[measureField] = yAxis, _a2), (_b = {}, _b[measureField] = { min: extData === null || extData === void 0 ? void 0 : extData.min, max: extData === null || extData === void 0 ? void 0 : extData.max, sync: true }, _b[targetField] = {
    sync: "".concat(measureField)
  }, _b[rangeField] = {
    sync: "".concat(measureField)
  }, _b)))(params);
}
function axis$c(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, measureField = options.measureField, rangeField = options.rangeField, targetField = options.targetField;
  chart.axis("".concat(rangeField), false);
  chart.axis("".concat(targetField), false);
  if (xAxis === false) {
    chart.axis("".concat(xField), false);
  } else {
    chart.axis("".concat(xField), xAxis);
  }
  if (yAxis === false) {
    chart.axis("".concat(measureField), false);
  } else {
    chart.axis("".concat(measureField), yAxis);
  }
  return params;
}
function legend$8(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend;
  chart.removeInteraction("legend-filter");
  chart.legend(legend2);
  chart.legend("rKey", false);
  chart.legend("mKey", false);
  chart.legend("tKey", false);
  return params;
}
function label$7(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, measureField = options.measureField, targetField = options.targetField, rangeField = options.rangeField;
  var _a2 = chart.geometries, rangeGeometry = _a2[0], measureGeometry = _a2[1], targetGeometry = _a2[2];
  if (get(label2, "range")) {
    rangeGeometry.label("".concat(rangeField), __assign$1({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.range)));
  } else {
    rangeGeometry.label(false);
  }
  if (get(label2, "measure")) {
    measureGeometry.label("".concat(measureField), __assign$1({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.measure)));
  } else {
    measureGeometry.label(false);
  }
  if (get(label2, "target")) {
    targetGeometry.label("".concat(targetField), __assign$1({ layout: [{ type: "limit-in-plot" }] }, transformLabel(label2.target)));
  } else {
    targetGeometry.label(false);
  }
  return params;
}
function adaptor$g(params) {
  flow(geometry$d, meta$a, axis$c, legend$8, theme$2, label$7, tooltip$9, interaction$8, animation$5)(params);
}
var DEFAULT_OPTIONS$j = deepAssign({}, Plot.getDefaultOptions(), {
  layout: "horizontal",
  size: {
    range: 30,
    measure: 20,
    target: 20
  },
  xAxis: {
    tickLine: false,
    line: null
  },
  bulletStyle: {
    range: {
      fillOpacity: 0.5
    }
  },
  label: {
    measure: {
      position: "right"
    }
  },
  tooltip: {
    // 
    showMarkers: false
  }
});
(function(_super) {
  __extends$1(Bullet, _super);
  function Bullet() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "bullet";
    return _this;
  }
  Bullet.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$j;
  };
  Bullet.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = transformData$5(this.options), min2 = _a2.min, max2 = _a2.max, ds = _a2.ds;
    meta$a({ options: this.options, ext: { data: { min: min2, max: max2 } }, chart: this.chart });
    this.chart.changeData(ds);
  };
  Bullet.prototype.getSchemaAdaptor = function() {
    return adaptor$g;
  };
  Bullet.prototype.getDefaultOptions = function() {
    return Bullet.getDefaultOptions();
  };
  return Bullet;
})(Plot);
var DEFAULT_OPTIONS$i = {
  y: 0,
  nodeWidthRatio: 0.05,
  weight: false,
  nodePaddingRatio: 0.1,
  id: function(node) {
    return node.id;
  },
  source: function(edge2) {
    return edge2.source;
  },
  target: function(edge2) {
    return edge2.target;
  },
  sourceWeight: function(edge2) {
    return edge2.value || 1;
  },
  targetWeight: function(edge2) {
    return edge2.value || 1;
  },
  sortBy: null
  // optional, id | weight | frequency | {function}
};
function processGraph(nodeById, edges, options) {
  each$1(nodeById, function(node, id2) {
    node.inEdges = edges.filter(function(edge2) {
      return "".concat(options.target(edge2)) === "".concat(id2);
    });
    node.outEdges = edges.filter(function(edge2) {
      return "".concat(options.source(edge2)) === "".concat(id2);
    });
    node.edges = node.outEdges.concat(node.inEdges);
    node.frequency = node.edges.length;
    node.value = 0;
    node.inEdges.forEach(function(edge2) {
      node.value += options.targetWeight(edge2);
    });
    node.outEdges.forEach(function(edge2) {
      node.value += options.sourceWeight(edge2);
    });
  });
}
function sortNodes(nodes, options) {
  var sortMethods = {
    weight: function(a, b) {
      return b.value - a.value;
    },
    frequency: function(a, b) {
      return b.frequency - a.frequency;
    },
    id: function(a, b) {
      return "".concat(options.id(a)).localeCompare("".concat(options.id(b)));
    }
  };
  var method = sortMethods[options.sortBy];
  if (!method && isFunction(options.sortBy)) {
    method = options.sortBy;
  }
  if (method) {
    nodes.sort(method);
  }
}
function layoutNodes(nodes, options) {
  var len = nodes.length;
  if (!len) {
    throw new TypeError("Invalid nodes: it's empty!");
  }
  if (options.weight) {
    var nodePaddingRatio_1 = options.nodePaddingRatio;
    if (nodePaddingRatio_1 < 0 || nodePaddingRatio_1 >= 1) {
      throw new TypeError("Invalid nodePaddingRatio: it must be in range [0, 1)!");
    }
    var margin_1 = nodePaddingRatio_1 / (2 * len);
    var nodeWidthRatio_1 = options.nodeWidthRatio;
    if (nodeWidthRatio_1 <= 0 || nodeWidthRatio_1 >= 1) {
      throw new TypeError("Invalid nodeWidthRatio: it must be in range (0, 1)!");
    }
    var totalValue_1 = 0;
    nodes.forEach(function(node) {
      totalValue_1 += node.value;
    });
    nodes.forEach(function(node) {
      node.weight = node.value / totalValue_1;
      node.width = node.weight * (1 - nodePaddingRatio_1);
      node.height = nodeWidthRatio_1;
    });
    nodes.forEach(function(node, index2) {
      var deltaX = 0;
      for (var i = index2 - 1; i >= 0; i--) {
        deltaX += nodes[i].width + 2 * margin_1;
      }
      var minX = node.minX = margin_1 + deltaX;
      var maxX = node.maxX = node.minX + node.width;
      var minY = node.minY = options.y - nodeWidthRatio_1 / 2;
      var maxY2 = node.maxY = minY + nodeWidthRatio_1;
      node.x = [minX, maxX, maxX, minX];
      node.y = [minY, minY, maxY2, maxY2];
    });
  } else {
    var deltaX_1 = 1 / len;
    nodes.forEach(function(node, index2) {
      node.x = (index2 + 0.5) * deltaX_1;
      node.y = options.y;
    });
  }
  return nodes;
}
function locatingEdges(nodeById, edges, options) {
  if (options.weight) {
    var valueById_1 = {};
    each$1(nodeById, function(node, id2) {
      valueById_1[id2] = node.value;
    });
    edges.forEach(function(edge2) {
      var sId = options.source(edge2);
      var tId = options.target(edge2);
      var sNode = nodeById[sId];
      var tNode = nodeById[tId];
      if (sNode && tNode) {
        var sValue = valueById_1[sId];
        var currentSValue = options.sourceWeight(edge2);
        var sStart = sNode.minX + (sNode.value - sValue) / sNode.value * sNode.width;
        var sEnd = sStart + currentSValue / sNode.value * sNode.width;
        valueById_1[sId] -= currentSValue;
        var tValue = valueById_1[tId];
        var currentTValue = options.targetWeight(edge2);
        var tStart = tNode.minX + (tNode.value - tValue) / tNode.value * tNode.width;
        var tEnd = tStart + currentTValue / tNode.value * tNode.width;
        valueById_1[tId] -= currentTValue;
        var y = options.y;
        edge2.x = [sStart, sEnd, tStart, tEnd];
        edge2.y = [y, y, y, y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  } else {
    edges.forEach(function(edge2) {
      var sNode = nodeById[options.source(edge2)];
      var tNode = nodeById[options.target(edge2)];
      if (sNode && tNode) {
        edge2.x = [sNode.x, tNode.x];
        edge2.y = [sNode.y, tNode.y];
        edge2.source = sNode;
        edge2.target = tNode;
      }
    });
  }
  return edges;
}
function getDefaultOptions$1(options) {
  return mix({}, DEFAULT_OPTIONS$i, options);
}
function chordLayout(chordLayoutOptions, chordLayoutInputData) {
  var options = getDefaultOptions$1(chordLayoutOptions);
  var nodeById = {};
  var nodes = chordLayoutInputData.nodes;
  var links = chordLayoutInputData.links;
  nodes.forEach(function(node) {
    var id2 = options.id(node);
    nodeById[id2] = node;
  });
  processGraph(nodeById, links, options);
  sortNodes(nodes, options);
  var outputNodes = layoutNodes(nodes, options);
  var outputLinks = locatingEdges(nodeById, links, options);
  return {
    nodes: outputNodes,
    links: outputLinks
  };
}
var X_FIELD$2 = "x";
var Y_FIELD$2 = "y";
var NODE_COLOR_FIELD = "name";
var EDGE_COLOR_FIELD = "source";
var DEFAULT_OPTIONS$h = {
  nodeStyle: {
    opacity: 1,
    fillOpacity: 1,
    lineWidth: 1
  },
  edgeStyle: {
    opacity: 0.5,
    lineWidth: 2
  },
  label: {
    fields: ["x", "name"],
    callback: function(x, name) {
      var centerX = (x[0] + x[1]) / 2;
      var offsetX = centerX > 0.5 ? -4 : 4;
      return {
        offsetX,
        content: name
      };
    },
    labelEmit: true,
    style: {
      fill: "#8c8c8c"
    }
  },
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["source", "target", "value", "isNode"],
    // node  tooltip ()edge  tooltip
    showContent: function(items) {
      return !get(items, [0, "data", "isNode"]);
    },
    formatter: function(datum) {
      var source = datum.source, target2 = datum.target, value2 = datum.value;
      return {
        name: "".concat(source, " -> ").concat(target2),
        value: value2
      };
    }
  },
  interactions: [
    {
      type: "element-active"
    }
  ],
  weight: true,
  nodePaddingRatio: 0.1,
  nodeWidthRatio: 0.05
};
function transformData$4(params) {
  var options = params.options;
  var data2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodePaddingRatio = options.nodePaddingRatio, nodeWidthRatio = options.nodeWidthRatio, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var chordLayoutInputData = transformDataToNodeLinkData(data2, sourceField, targetField, weightField);
  var _b = chordLayout({ weight: true, nodePaddingRatio, nodeWidthRatio }, chordLayoutInputData), nodes = _b.nodes, links = _b.links;
  var nodesData = nodes.map(function(node) {
    return __assign$1(__assign$1({}, pick(node, __spreadArray$1(["id", "x", "y", "name"], rawFields, true))), { isNode: true });
  });
  var edgesData = links.map(function(link) {
    return __assign$1(__assign$1({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArray$1(["x", "y", "value"], rawFields, true))), { isNode: false });
  });
  return __assign$1(__assign$1({}, params), { ext: __assign$1(__assign$1({}, params.ext), {
    // chordDataextgeometry
    chordData: { nodesData, edgesData }
  }) });
}
function scale$1(params) {
  var _a2;
  var chart = params.chart;
  chart.scale((_a2 = {
    x: { sync: true, nice: true },
    y: { sync: true, nice: true, max: 1 }
  }, _a2[NODE_COLOR_FIELD] = { sync: "color" }, _a2[EDGE_COLOR_FIELD] = { sync: "color" }, _a2));
  return params;
}
function axis$b(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function legend$7(params) {
  var chart = params.chart;
  chart.legend(false);
  return params;
}
function tooltip$4(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  chart.tooltip(tooltip2);
  return params;
}
function coordinate$4(params) {
  var chart = params.chart;
  chart.coordinate("polar").reflect("y");
  return params;
}
function nodeGeometry(params) {
  var chart = params.chart, options = params.options;
  var nodesData = params.ext.chordData.nodesData;
  var nodeStyle = options.nodeStyle, label2 = options.label, tooltip2 = options.tooltip;
  var nodeView = chart.createView();
  nodeView.data(nodesData);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD$2,
      yField: Y_FIELD$2,
      seriesField: NODE_COLOR_FIELD,
      polygon: {
        style: nodeStyle
      },
      label: label2,
      tooltip: tooltip2
    }
  });
  return params;
}
function edgeGeometry(params) {
  var chart = params.chart, options = params.options;
  var edgesData = params.ext.chordData.edgesData;
  var edgeStyle = options.edgeStyle, tooltip2 = options.tooltip;
  var edgeView = chart.createView();
  edgeView.data(edgesData);
  var edgeOptions = {
    xField: X_FIELD$2,
    yField: Y_FIELD$2,
    seriesField: EDGE_COLOR_FIELD,
    edge: {
      style: edgeStyle,
      shape: "arc"
    },
    tooltip: tooltip2
  };
  edge({
    chart: edgeView,
    options: edgeOptions
  });
  return params;
}
function animation$3(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  addViewAnimation(chart, animation2, getAllGeometriesRecursively(chart));
  return params;
}
function adaptor$f(params) {
  return flow(theme$2, transformData$4, coordinate$4, scale$1, axis$b, legend$7, tooltip$4, edgeGeometry, nodeGeometry, interaction$8, state, animation$3)(params);
}
(function(_super) {
  __extends$1(Chord, _super);
  function Chord() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "chord";
    return _this;
  }
  Chord.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$h;
  };
  Chord.prototype.getDefaultOptions = function() {
    return Chord.getDefaultOptions();
  };
  Chord.prototype.getSchemaAdaptor = function() {
    return adaptor$f;
  };
  return Chord;
})(Plot);
var RAW_FIELDS$1 = ["x", "y", "r", "name", "value", "path", "depth"];
var DEFAULT_OPTIONS$g = {
  //  name 
  colorField: "name",
  autoFit: true,
  pointStyle: {
    lineWidth: 0,
    stroke: "#fff"
  },
  // 
  legend: false,
  hierarchyConfig: {
    size: [1, 1],
    padding: 0
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  // 
  drilldown: { enabled: false }
};
var PADDING = 4;
var PADDING_LEFT = 0;
var PADDING_TOP = 5;
var BREAD_CRUMB_NAME = "drilldown-bread-crumb";
var DEFAULT_BREAD_CRUMB_CONFIG = {
  /**  */
  position: "top-left",
  dividerText: "/",
  textStyle: {
    fontSize: 12,
    fill: "rgba(0, 0, 0, 0.65)",
    cursor: "pointer"
  },
  activeTextStyle: {
    fill: "#87B5FF"
  }
};
var HIERARCHY_DATA_TRANSFORM_PARAMS = "hierarchy-data-transform-params";
var DrillDownAction = (
  /** @class */
  function(_super) {
    __extends$1(DrillDownAction2, _super);
    function DrillDownAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.name = "drill-down";
      _this.historyCache = [];
      _this.breadCrumbGroup = null;
      _this.breadCrumbCfg = DEFAULT_BREAD_CRUMB_CONFIG;
      return _this;
    }
    DrillDownAction2.prototype.click = function() {
      var data2 = get(this.context, ["event", "data", "data"]);
      if (!data2)
        return false;
      this.drill(data2);
      this.drawBreadCrumb();
    };
    DrillDownAction2.prototype.resetPosition = function() {
      if (!this.breadCrumbGroup)
        return;
      var coordinate2 = this.context.view.getCoordinate();
      var breadCrumbGroup = this.breadCrumbGroup;
      var bbox = breadCrumbGroup.getBBox();
      var position = this.getButtonCfg().position;
      var point2 = { x: coordinate2.start.x, y: coordinate2.end.y - (bbox.height + PADDING_TOP * 2) };
      if (coordinate2.isPolar) {
        point2 = { x: 0, y: 0 };
      }
      if (position === "bottom-left") {
        point2 = { x: coordinate2.start.x, y: coordinate2.start.y };
      }
      var matrix = Util.transform(null, [["t", point2.x + PADDING_LEFT, point2.y + bbox.height + PADDING_TOP]]);
      breadCrumbGroup.setMatrix(matrix);
    };
    DrillDownAction2.prototype.back = function() {
      if (size(this.historyCache)) {
        this.backTo(this.historyCache.slice(0, -1));
      }
    };
    DrillDownAction2.prototype.reset = function() {
      if (this.historyCache[0]) {
        this.backTo(this.historyCache.slice(0, 1));
      }
      this.historyCache = [];
      this.hideCrumbGroup();
    };
    DrillDownAction2.prototype.drill = function(nodeInfo) {
      var view = this.context.view;
      var transformData2 = get(view, ["interactions", "drill-down", "cfg", "transformData"], function(v) {
        return v;
      });
      var drillData = transformData2(__assign$1({ data: nodeInfo.data }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]));
      view.changeData(drillData);
      var historyCache = [];
      var node = nodeInfo;
      while (node) {
        var nodeData = node.data;
        historyCache.unshift({
          id: "".concat(nodeData.name, "_").concat(node.height, "_").concat(node.depth),
          name: nodeData.name,
          // children 
          children: transformData2(__assign$1({ data: nodeData }, nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS]))
        });
        node = node.parent;
      }
      this.historyCache = (this.historyCache || []).slice(0, -1).concat(historyCache);
    };
    DrillDownAction2.prototype.backTo = function(historyCache) {
      if (!historyCache || historyCache.length <= 0) {
        return;
      }
      var view = this.context.view;
      var data2 = last(historyCache).children;
      view.changeData(data2);
      if (historyCache.length > 1) {
        this.historyCache = historyCache;
        this.drawBreadCrumb();
      } else {
        this.historyCache = [];
        this.hideCrumbGroup();
      }
    };
    DrillDownAction2.prototype.getButtonCfg = function() {
      var view = this.context.view;
      var drillDownConfig = get(view, ["interactions", "drill-down", "cfg", "drillDownConfig"]);
      return deepAssign(this.breadCrumbCfg, drillDownConfig === null || drillDownConfig === void 0 ? void 0 : drillDownConfig.breadCrumb, this.cfg);
    };
    DrillDownAction2.prototype.drawBreadCrumb = function() {
      this.drawBreadCrumbGroup();
      this.resetPosition();
      this.breadCrumbGroup.show();
    };
    DrillDownAction2.prototype.drawBreadCrumbGroup = function() {
      var _this = this;
      var config = this.getButtonCfg();
      var cache2 = this.historyCache;
      if (!this.breadCrumbGroup) {
        this.breadCrumbGroup = this.context.view.foregroundGroup.addGroup({
          name: BREAD_CRUMB_NAME
        });
      } else {
        this.breadCrumbGroup.clear();
      }
      var left2 = 0;
      cache2.forEach(function(record, index2) {
        var textShape = _this.breadCrumbGroup.addShape({
          type: "text",
          id: record.id,
          name: "".concat(BREAD_CRUMB_NAME, "_").concat(record.name, "_text"),
          attrs: __assign$1(__assign$1({ text: index2 === 0 && !isNil(config.rootText) ? config.rootText : record.name }, config.textStyle), { x: left2, y: 0 })
        });
        var textShapeBox = textShape.getBBox();
        left2 += textShapeBox.width + PADDING;
        textShape.on("click", function(event) {
          var _a2;
          var targetId = event.target.get("id");
          if (targetId !== ((_a2 = last(cache2)) === null || _a2 === void 0 ? void 0 : _a2.id)) {
            var newHistoryCache = cache2.slice(0, cache2.findIndex(function(d) {
              return d.id === targetId;
            }) + 1);
            _this.backTo(newHistoryCache);
          }
        });
        textShape.on("mouseenter", function(event) {
          var _a2;
          var targetId = event.target.get("id");
          if (targetId !== ((_a2 = last(cache2)) === null || _a2 === void 0 ? void 0 : _a2.id)) {
            textShape.attr(config.activeTextStyle);
          } else {
            textShape.attr({ cursor: "default" });
          }
        });
        textShape.on("mouseleave", function() {
          textShape.attr(config.textStyle);
        });
        if (index2 < cache2.length - 1) {
          var dividerShape = _this.breadCrumbGroup.addShape({
            type: "text",
            name: "".concat(config.name, "_").concat(record.name, "_divider"),
            attrs: __assign$1(__assign$1({ text: config.dividerText }, config.textStyle), { x: left2, y: 0 })
          });
          var dividerBox = dividerShape.getBBox();
          left2 += dividerBox.width + PADDING;
        }
      });
    };
    DrillDownAction2.prototype.hideCrumbGroup = function() {
      if (this.breadCrumbGroup) {
        this.breadCrumbGroup.hide();
      }
    };
    DrillDownAction2.prototype.destroy = function() {
      if (this.breadCrumbGroup) {
        this.breadCrumbGroup.remove();
      }
      _super.prototype.destroy.call(this);
    };
    return DrillDownAction2;
  }(Action)
);
function defaultSeparation$1(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function meanX(children) {
  return children.reduce(meanXReduce, 0) / children.length;
}
function meanXReduce(x, c) {
  return x + c.x;
}
function maxY(children) {
  return 1 + children.reduce(maxYReduce, 0);
}
function maxYReduce(y, c) {
  return Math.max(y, c.y);
}
function leafLeft(node) {
  var children;
  while (children = node.children)
    node = children[0];
  return node;
}
function leafRight(node) {
  var children;
  while (children = node.children)
    node = children[children.length - 1];
  return node;
}
function cluster() {
  var separation = defaultSeparation$1, dx = 1, dy = 1, nodeSize = false;
  function cluster2(root) {
    var previousNode, x = 0;
    root.eachAfter(function(node) {
      var children = node.children;
      if (children) {
        node.x = meanX(children);
        node.y = maxY(children);
      } else {
        node.x = previousNode ? x += separation(node, previousNode) : 0;
        node.y = 0;
        previousNode = node;
      }
    });
    var left2 = leafLeft(root), right2 = leafRight(root), x0 = left2.x - separation(left2, right2) / 2, x1 = right2.x + separation(right2, left2) / 2;
    return root.eachAfter(nodeSize ? function(node) {
      node.x = (node.x - root.x) * dx;
      node.y = (root.y - node.y) * dy;
    } : function(node) {
      node.x = (node.x - x0) / (x1 - x0) * dx;
      node.y = (1 - (root.y ? node.y / root.y : 1)) * dy;
    });
  }
  cluster2.separation = function(x) {
    return arguments.length ? (separation = x, cluster2) : separation;
  };
  cluster2.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], cluster2) : nodeSize ? null : [dx, dy];
  };
  cluster2.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], cluster2) : nodeSize ? [dx, dy] : null;
  };
  return cluster2;
}
function count(node) {
  var sum = 0, children = node.children, i = children && children.length;
  if (!i)
    sum = 1;
  else
    while (--i >= 0)
      sum += children[i].value;
  node.value = sum;
}
function node_count() {
  return this.eachAfter(count);
}
function node_each(callback, that) {
  let index2 = -1;
  for (const node of this) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_eachBefore(callback, that) {
  var node = this, nodes = [node], children, i, index2 = -1;
  while (node = nodes.pop()) {
    callback.call(that, node, ++index2, this);
    if (children = node.children) {
      for (i = children.length - 1; i >= 0; --i) {
        nodes.push(children[i]);
      }
    }
  }
  return this;
}
function node_eachAfter(callback, that) {
  var node = this, nodes = [node], next = [], children, i, n, index2 = -1;
  while (node = nodes.pop()) {
    next.push(node);
    if (children = node.children) {
      for (i = 0, n = children.length; i < n; ++i) {
        nodes.push(children[i]);
      }
    }
  }
  while (node = next.pop()) {
    callback.call(that, node, ++index2, this);
  }
  return this;
}
function node_find(callback, that) {
  let index2 = -1;
  for (const node of this) {
    if (callback.call(that, node, ++index2, this)) {
      return node;
    }
  }
}
function node_sum(value2) {
  return this.eachAfter(function(node) {
    var sum = +value2(node.data) || 0, children = node.children, i = children && children.length;
    while (--i >= 0)
      sum += children[i].value;
    node.value = sum;
  });
}
function node_sort(compare2) {
  return this.eachBefore(function(node) {
    if (node.children) {
      node.children.sort(compare2);
    }
  });
}
function node_path(end) {
  var start = this, ancestor = leastCommonAncestor(start, end), nodes = [start];
  while (start !== ancestor) {
    start = start.parent;
    nodes.push(start);
  }
  var k = nodes.length;
  while (end !== ancestor) {
    nodes.splice(k, 0, end);
    end = end.parent;
  }
  return nodes;
}
function leastCommonAncestor(a, b) {
  if (a === b)
    return a;
  var aNodes = a.ancestors(), bNodes = b.ancestors(), c = null;
  a = aNodes.pop();
  b = bNodes.pop();
  while (a === b) {
    c = a;
    a = aNodes.pop();
    b = bNodes.pop();
  }
  return c;
}
function node_ancestors() {
  var node = this, nodes = [node];
  while (node = node.parent) {
    nodes.push(node);
  }
  return nodes;
}
function node_descendants() {
  return Array.from(this);
}
function node_leaves() {
  var leaves = [];
  this.eachBefore(function(node) {
    if (!node.children) {
      leaves.push(node);
    }
  });
  return leaves;
}
function node_links() {
  var root = this, links = [];
  root.each(function(node) {
    if (node !== root) {
      links.push({ source: node.parent, target: node });
    }
  });
  return links;
}
function* node_iterator() {
  var node = this, current, next = [node], children, i, n;
  do {
    current = next.reverse(), next = [];
    while (node = current.pop()) {
      yield node;
      if (children = node.children) {
        for (i = 0, n = children.length; i < n; ++i) {
          next.push(children[i]);
        }
      }
    }
  } while (next.length);
}
function hierarchy(data2, children) {
  if (data2 instanceof Map) {
    data2 = [void 0, data2];
    if (children === void 0)
      children = mapChildren;
  } else if (children === void 0) {
    children = objectChildren;
  }
  var root = new Node$1(data2), node, nodes = [root], child, childs, i, n;
  while (node = nodes.pop()) {
    if ((childs = children(node.data)) && (n = (childs = Array.from(childs)).length)) {
      node.children = childs;
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = childs[i] = new Node$1(childs[i]));
        child.parent = node;
        child.depth = node.depth + 1;
      }
    }
  }
  return root.eachBefore(computeHeight);
}
function node_copy() {
  return hierarchy(this).eachBefore(copyData);
}
function objectChildren(d) {
  return d.children;
}
function mapChildren(d) {
  return Array.isArray(d) ? d[1] : null;
}
function copyData(node) {
  if (node.data.value !== void 0)
    node.value = node.data.value;
  node.data = node.data.data;
}
function computeHeight(node) {
  var height = 0;
  do
    node.height = height;
  while ((node = node.parent) && node.height < ++height);
}
function Node$1(data2) {
  this.data = data2;
  this.depth = this.height = 0;
  this.parent = null;
}
Node$1.prototype = hierarchy.prototype = {
  constructor: Node$1,
  count: node_count,
  each: node_each,
  eachAfter: node_eachAfter,
  eachBefore: node_eachBefore,
  find: node_find,
  sum: node_sum,
  sort: node_sort,
  path: node_path,
  ancestors: node_ancestors,
  descendants: node_descendants,
  leaves: node_leaves,
  links: node_links,
  copy: node_copy,
  [Symbol.iterator]: node_iterator
};
function array(x) {
  return typeof x === "object" && "length" in x ? x : Array.from(x);
}
function shuffle(array2) {
  var m = array2.length, t, i;
  while (m) {
    i = Math.random() * m-- | 0;
    t = array2[m];
    array2[m] = array2[i];
    array2[i] = t;
  }
  return array2;
}
function enclose(circles) {
  var i = 0, n = (circles = shuffle(Array.from(circles))).length, B = [], p, e;
  while (i < n) {
    p = circles[i];
    if (e && enclosesWeak(e, p))
      ++i;
    else
      e = encloseBasis(B = extendBasis(B, p)), i = 0;
  }
  return e;
}
function extendBasis(B, p) {
  var i, j;
  if (enclosesWeakAll(p, B))
    return [p];
  for (i = 0; i < B.length; ++i) {
    if (enclosesNot(p, B[i]) && enclosesWeakAll(encloseBasis2(B[i], p), B)) {
      return [B[i], p];
    }
  }
  for (i = 0; i < B.length - 1; ++i) {
    for (j = i + 1; j < B.length; ++j) {
      if (enclosesNot(encloseBasis2(B[i], B[j]), p) && enclosesNot(encloseBasis2(B[i], p), B[j]) && enclosesNot(encloseBasis2(B[j], p), B[i]) && enclosesWeakAll(encloseBasis3(B[i], B[j], p), B)) {
        return [B[i], B[j], p];
      }
    }
  }
  throw new Error();
}
function enclosesNot(a, b) {
  var dr = a.r - b.r, dx = b.x - a.x, dy = b.y - a.y;
  return dr < 0 || dr * dr < dx * dx + dy * dy;
}
function enclosesWeak(a, b) {
  var dr = a.r - b.r + Math.max(a.r, b.r, 1) * 1e-9, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function enclosesWeakAll(a, B) {
  for (var i = 0; i < B.length; ++i) {
    if (!enclosesWeak(a, B[i])) {
      return false;
    }
  }
  return true;
}
function encloseBasis(B) {
  switch (B.length) {
    case 1:
      return encloseBasis1(B[0]);
    case 2:
      return encloseBasis2(B[0], B[1]);
    case 3:
      return encloseBasis3(B[0], B[1], B[2]);
  }
}
function encloseBasis1(a) {
  return {
    x: a.x,
    y: a.y,
    r: a.r
  };
}
function encloseBasis2(a, b) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x21 = x2 - x1, y21 = y2 - y1, r21 = r2 - r1, l = Math.sqrt(x21 * x21 + y21 * y21);
  return {
    x: (x1 + x2 + x21 / l * r21) / 2,
    y: (y1 + y2 + y21 / l * r21) / 2,
    r: (l + r1 + r2) / 2
  };
}
function encloseBasis3(a, b, c) {
  var x1 = a.x, y1 = a.y, r1 = a.r, x2 = b.x, y2 = b.y, r2 = b.r, x3 = c.x, y3 = c.y, r3 = c.r, a2 = x1 - x2, a3 = x1 - x3, b22 = y1 - y2, b32 = y1 - y3, c2 = r2 - r1, c3 = r3 - r1, d1 = x1 * x1 + y1 * y1 - r1 * r1, d2 = d1 - x2 * x2 - y2 * y2 + r2 * r2, d3 = d1 - x3 * x3 - y3 * y3 + r3 * r3, ab = a3 * b22 - a2 * b32, xa = (b22 * d3 - b32 * d2) / (ab * 2) - x1, xb = (b32 * c2 - b22 * c3) / ab, ya = (a3 * d2 - a2 * d3) / (ab * 2) - y1, yb = (a2 * c3 - a3 * c2) / ab, A = xb * xb + yb * yb - 1, B = 2 * (r1 + xa * xb + ya * yb), C = xa * xa + ya * ya - r1 * r1, r = -(A ? (B + Math.sqrt(B * B - 4 * A * C)) / (2 * A) : C / B);
  return {
    x: x1 + xa + xb * r,
    y: y1 + ya + yb * r,
    r
  };
}
function place(b, a, c) {
  var dx = b.x - a.x, x, a2, dy = b.y - a.y, y, b22, d2 = dx * dx + dy * dy;
  if (d2) {
    a2 = a.r + c.r, a2 *= a2;
    b22 = b.r + c.r, b22 *= b22;
    if (a2 > b22) {
      x = (d2 + b22 - a2) / (2 * d2);
      y = Math.sqrt(Math.max(0, b22 / d2 - x * x));
      c.x = b.x - x * dx - y * dy;
      c.y = b.y - x * dy + y * dx;
    } else {
      x = (d2 + a2 - b22) / (2 * d2);
      y = Math.sqrt(Math.max(0, a2 / d2 - x * x));
      c.x = a.x + x * dx - y * dy;
      c.y = a.y + x * dy + y * dx;
    }
  } else {
    c.x = a.x + c.r;
    c.y = a.y;
  }
}
function intersects(a, b) {
  var dr = a.r + b.r - 1e-6, dx = b.x - a.x, dy = b.y - a.y;
  return dr > 0 && dr * dr > dx * dx + dy * dy;
}
function score(node) {
  var a = node._, b = node.next._, ab = a.r + b.r, dx = (a.x * b.r + b.x * a.r) / ab, dy = (a.y * b.r + b.y * a.r) / ab;
  return dx * dx + dy * dy;
}
function Node(circle2) {
  this._ = circle2;
  this.next = null;
  this.previous = null;
}
function packEnclose(circles) {
  if (!(n = (circles = array(circles)).length))
    return 0;
  var a, b, c, n, aa, ca, i, j, k, sj, sk;
  a = circles[0], a.x = 0, a.y = 0;
  if (!(n > 1))
    return a.r;
  b = circles[1], a.x = -b.r, b.x = a.r, b.y = 0;
  if (!(n > 2))
    return a.r + b.r;
  place(b, a, c = circles[2]);
  a = new Node(a), b = new Node(b), c = new Node(c);
  a.next = c.previous = b;
  b.next = a.previous = c;
  c.next = b.previous = a;
  pack:
    for (i = 3; i < n; ++i) {
      place(a._, b._, c = circles[i]), c = new Node(c);
      j = b.next, k = a.previous, sj = b._.r, sk = a._.r;
      do {
        if (sj <= sk) {
          if (intersects(j._, c._)) {
            b = j, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sj += j._.r, j = j.next;
        } else {
          if (intersects(k._, c._)) {
            a = k, a.next = b, b.previous = a, --i;
            continue pack;
          }
          sk += k._.r, k = k.previous;
        }
      } while (j !== k.next);
      c.previous = a, c.next = b, a.next = b.previous = b = c;
      aa = score(a);
      while ((c = c.next) !== b) {
        if ((ca = score(c)) < aa) {
          a = c, aa = ca;
        }
      }
      b = a.next;
    }
  a = [b._], c = b;
  while ((c = c.next) !== b)
    a.push(c._);
  c = enclose(a);
  for (i = 0; i < n; ++i)
    a = circles[i], a.x -= c.x, a.y -= c.y;
  return c.r;
}
function siblings(circles) {
  packEnclose(circles);
  return circles;
}
function optional(f) {
  return f == null ? null : required(f);
}
function required(f) {
  if (typeof f !== "function")
    throw new Error();
  return f;
}
function constantZero() {
  return 0;
}
function constant$1(x) {
  return function() {
    return x;
  };
}
function defaultRadius(d) {
  return Math.sqrt(d.value);
}
function index$1() {
  var radius = null, dx = 1, dy = 1, padding2 = constantZero;
  function pack2(root) {
    root.x = dx / 2, root.y = dy / 2;
    if (radius) {
      root.eachBefore(radiusLeaf(radius)).eachAfter(packChildren(padding2, 0.5)).eachBefore(translateChild(1));
    } else {
      root.eachBefore(radiusLeaf(defaultRadius)).eachAfter(packChildren(constantZero, 1)).eachAfter(packChildren(padding2, root.r / Math.min(dx, dy))).eachBefore(translateChild(Math.min(dx, dy) / (2 * root.r)));
    }
    return root;
  }
  pack2.radius = function(x) {
    return arguments.length ? (radius = optional(x), pack2) : radius;
  };
  pack2.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], pack2) : [dx, dy];
  };
  pack2.padding = function(x) {
    return arguments.length ? (padding2 = typeof x === "function" ? x : constant$1(+x), pack2) : padding2;
  };
  return pack2;
}
function radiusLeaf(radius) {
  return function(node) {
    if (!node.children) {
      node.r = Math.max(0, +radius(node) || 0);
    }
  };
}
function packChildren(padding2, k) {
  return function(node) {
    if (children = node.children) {
      var children, i, n = children.length, r = padding2(node) * k || 0, e;
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r += r;
      e = packEnclose(children);
      if (r)
        for (i = 0; i < n; ++i)
          children[i].r -= r;
      node.r = e + r;
    }
  };
}
function translateChild(k) {
  return function(node) {
    var parent = node.parent;
    node.r *= k;
    if (parent) {
      node.x = parent.x + k * node.x;
      node.y = parent.y + k * node.y;
    }
  };
}
function roundNode(node) {
  node.x0 = Math.round(node.x0);
  node.y0 = Math.round(node.y0);
  node.x1 = Math.round(node.x1);
  node.y1 = Math.round(node.y1);
}
function treemapDice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (x1 - x0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.y0 = y0, node.y1 = y1;
    node.x0 = x0, node.x1 = x0 += node.value * k;
  }
}
function partition$1() {
  var dx = 1, dy = 1, padding2 = 0, round2 = false;
  function partition2(root) {
    var n = root.height + 1;
    root.x0 = root.y0 = padding2;
    root.x1 = dx;
    root.y1 = dy / n;
    root.eachBefore(positionNode(dy, n));
    if (round2)
      root.eachBefore(roundNode);
    return root;
  }
  function positionNode(dy2, n) {
    return function(node) {
      if (node.children) {
        treemapDice(node, node.x0, dy2 * (node.depth + 1) / n, node.x1, dy2 * (node.depth + 2) / n);
      }
      var x0 = node.x0, y0 = node.y0, x1 = node.x1 - padding2, y1 = node.y1 - padding2;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      node.x0 = x0;
      node.y0 = y0;
      node.x1 = x1;
      node.y1 = y1;
    };
  }
  partition2.round = function(x) {
    return arguments.length ? (round2 = !!x, partition2) : round2;
  };
  partition2.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], partition2) : [dx, dy];
  };
  partition2.padding = function(x) {
    return arguments.length ? (padding2 = +x, partition2) : padding2;
  };
  return partition2;
}
var preroot = { depth: -1 }, ambiguous = {};
function defaultId$1(d) {
  return d.id;
}
function defaultParentId(d) {
  return d.parentId;
}
function stratify() {
  var id2 = defaultId$1, parentId = defaultParentId;
  function stratify2(data2) {
    var nodes = Array.from(data2), n = nodes.length, d, i, root, parent, node, nodeId, nodeKey, nodeByKey = /* @__PURE__ */ new Map();
    for (i = 0; i < n; ++i) {
      d = nodes[i], node = nodes[i] = new Node$1(d);
      if ((nodeId = id2(d, i, data2)) != null && (nodeId += "")) {
        nodeKey = node.id = nodeId;
        nodeByKey.set(nodeKey, nodeByKey.has(nodeKey) ? ambiguous : node);
      }
      if ((nodeId = parentId(d, i, data2)) != null && (nodeId += "")) {
        node.parent = nodeId;
      }
    }
    for (i = 0; i < n; ++i) {
      node = nodes[i];
      if (nodeId = node.parent) {
        parent = nodeByKey.get(nodeId);
        if (!parent)
          throw new Error("missing: " + nodeId);
        if (parent === ambiguous)
          throw new Error("ambiguous: " + nodeId);
        if (parent.children)
          parent.children.push(node);
        else
          parent.children = [node];
        node.parent = parent;
      } else {
        if (root)
          throw new Error("multiple roots");
        root = node;
      }
    }
    if (!root)
      throw new Error("no root");
    root.parent = preroot;
    root.eachBefore(function(node2) {
      node2.depth = node2.parent.depth + 1;
      --n;
    }).eachBefore(computeHeight);
    root.parent = null;
    if (n > 0)
      throw new Error("cycle");
    return root;
  }
  stratify2.id = function(x) {
    return arguments.length ? (id2 = required(x), stratify2) : id2;
  };
  stratify2.parentId = function(x) {
    return arguments.length ? (parentId = required(x), stratify2) : parentId;
  };
  return stratify2;
}
function defaultSeparation(a, b) {
  return a.parent === b.parent ? 1 : 2;
}
function nextLeft(v) {
  var children = v.children;
  return children ? children[0] : v.t;
}
function nextRight(v) {
  var children = v.children;
  return children ? children[children.length - 1] : v.t;
}
function moveSubtree(wm, wp, shift) {
  var change = shift / (wp.i - wm.i);
  wp.c -= change;
  wp.s += shift;
  wm.c += change;
  wp.z += shift;
  wp.m += shift;
}
function executeShifts(v) {
  var shift = 0, change = 0, children = v.children, i = children.length, w;
  while (--i >= 0) {
    w = children[i];
    w.z += shift;
    w.m += shift;
    shift += w.s + (change += w.c);
  }
}
function nextAncestor(vim, v, ancestor) {
  return vim.a.parent === v.parent ? vim.a : ancestor;
}
function TreeNode(node, i) {
  this._ = node;
  this.parent = null;
  this.children = null;
  this.A = null;
  this.a = this;
  this.z = 0;
  this.m = 0;
  this.c = 0;
  this.s = 0;
  this.t = null;
  this.i = i;
}
TreeNode.prototype = Object.create(Node$1.prototype);
function treeRoot(root) {
  var tree2 = new TreeNode(root, 0), node, nodes = [tree2], child, children, i, n;
  while (node = nodes.pop()) {
    if (children = node._.children) {
      node.children = new Array(n = children.length);
      for (i = n - 1; i >= 0; --i) {
        nodes.push(child = node.children[i] = new TreeNode(children[i], i));
        child.parent = node;
      }
    }
  }
  (tree2.parent = new TreeNode(null, 0)).children = [tree2];
  return tree2;
}
function tree() {
  var separation = defaultSeparation, dx = 1, dy = 1, nodeSize = null;
  function tree2(root) {
    var t = treeRoot(root);
    t.eachAfter(firstWalk), t.parent.m = -t.z;
    t.eachBefore(secondWalk);
    if (nodeSize)
      root.eachBefore(sizeNode);
    else {
      var left2 = root, right2 = root, bottom = root;
      root.eachBefore(function(node) {
        if (node.x < left2.x)
          left2 = node;
        if (node.x > right2.x)
          right2 = node;
        if (node.depth > bottom.depth)
          bottom = node;
      });
      var s = left2 === right2 ? 1 : separation(left2, right2) / 2, tx = s - left2.x, kx = dx / (right2.x + s + tx), ky = dy / (bottom.depth || 1);
      root.eachBefore(function(node) {
        node.x = (node.x + tx) * kx;
        node.y = node.depth * ky;
      });
    }
    return root;
  }
  function firstWalk(v) {
    var children = v.children, siblings2 = v.parent.children, w = v.i ? siblings2[v.i - 1] : null;
    if (children) {
      executeShifts(v);
      var midpoint2 = (children[0].z + children[children.length - 1].z) / 2;
      if (w) {
        v.z = w.z + separation(v._, w._);
        v.m = v.z - midpoint2;
      } else {
        v.z = midpoint2;
      }
    } else if (w) {
      v.z = w.z + separation(v._, w._);
    }
    v.parent.A = apportion(v, w, v.parent.A || siblings2[0]);
  }
  function secondWalk(v) {
    v._.x = v.z + v.parent.m;
    v.m += v.parent.m;
  }
  function apportion(v, w, ancestor) {
    if (w) {
      var vip = v, vop = v, vim = w, vom = vip.parent.children[0], sip = vip.m, sop = vop.m, sim = vim.m, som = vom.m, shift;
      while (vim = nextRight(vim), vip = nextLeft(vip), vim && vip) {
        vom = nextLeft(vom);
        vop = nextRight(vop);
        vop.a = v;
        shift = vim.z + sim - vip.z - sip + separation(vim._, vip._);
        if (shift > 0) {
          moveSubtree(nextAncestor(vim, v, ancestor), v, shift);
          sip += shift;
          sop += shift;
        }
        sim += vim.m;
        sip += vip.m;
        som += vom.m;
        sop += vop.m;
      }
      if (vim && !nextRight(vop)) {
        vop.t = vim;
        vop.m += sim - sop;
      }
      if (vip && !nextLeft(vom)) {
        vom.t = vip;
        vom.m += sip - som;
        ancestor = v;
      }
    }
    return ancestor;
  }
  function sizeNode(node) {
    node.x *= dx;
    node.y = node.depth * dy;
  }
  tree2.separation = function(x) {
    return arguments.length ? (separation = x, tree2) : separation;
  };
  tree2.size = function(x) {
    return arguments.length ? (nodeSize = false, dx = +x[0], dy = +x[1], tree2) : nodeSize ? null : [dx, dy];
  };
  tree2.nodeSize = function(x) {
    return arguments.length ? (nodeSize = true, dx = +x[0], dy = +x[1], tree2) : nodeSize ? [dx, dy] : null;
  };
  return tree2;
}
function treemapSlice(parent, x0, y0, x1, y1) {
  var nodes = parent.children, node, i = -1, n = nodes.length, k = parent.value && (y1 - y0) / parent.value;
  while (++i < n) {
    node = nodes[i], node.x0 = x0, node.x1 = x1;
    node.y0 = y0, node.y1 = y0 += node.value * k;
  }
}
var phi = (1 + Math.sqrt(5)) / 2;
function squarifyRatio(ratio, parent, x0, y0, x1, y1) {
  var rows = [], nodes = parent.children, row, nodeValue, i0 = 0, i1 = 0, n = nodes.length, dx, dy, value2 = parent.value, sumValue, minValue, maxValue, newRatio, minRatio, alpha, beta;
  while (i0 < n) {
    dx = x1 - x0, dy = y1 - y0;
    do
      sumValue = nodes[i1++].value;
    while (!sumValue && i1 < n);
    minValue = maxValue = sumValue;
    alpha = Math.max(dy / dx, dx / dy) / (value2 * ratio);
    beta = sumValue * sumValue * alpha;
    minRatio = Math.max(maxValue / beta, beta / minValue);
    for (; i1 < n; ++i1) {
      sumValue += nodeValue = nodes[i1].value;
      if (nodeValue < minValue)
        minValue = nodeValue;
      if (nodeValue > maxValue)
        maxValue = nodeValue;
      beta = sumValue * sumValue * alpha;
      newRatio = Math.max(maxValue / beta, beta / minValue);
      if (newRatio > minRatio) {
        sumValue -= nodeValue;
        break;
      }
      minRatio = newRatio;
    }
    rows.push(row = { value: sumValue, dice: dx < dy, children: nodes.slice(i0, i1) });
    if (row.dice)
      treemapDice(row, x0, y0, x1, value2 ? y0 += dy * sumValue / value2 : y1);
    else
      treemapSlice(row, x0, y0, value2 ? x0 += dx * sumValue / value2 : x1, y1);
    value2 -= sumValue, i0 = i1;
  }
  return rows;
}
const squarify = function custom10(ratio) {
  function squarify2(parent, x0, y0, x1, y1) {
    squarifyRatio(ratio, parent, x0, y0, x1, y1);
  }
  squarify2.ratio = function(x) {
    return custom10((x = +x) > 1 ? x : 1);
  };
  return squarify2;
}(phi);
function index() {
  var tile = squarify, round2 = false, dx = 1, dy = 1, paddingStack = [0], paddingInner = constantZero, paddingTop = constantZero, paddingRight = constantZero, paddingBottom = constantZero, paddingLeft = constantZero;
  function treemap2(root) {
    root.x0 = root.y0 = 0;
    root.x1 = dx;
    root.y1 = dy;
    root.eachBefore(positionNode);
    paddingStack = [0];
    if (round2)
      root.eachBefore(roundNode);
    return root;
  }
  function positionNode(node) {
    var p = paddingStack[node.depth], x0 = node.x0 + p, y0 = node.y0 + p, x1 = node.x1 - p, y1 = node.y1 - p;
    if (x1 < x0)
      x0 = x1 = (x0 + x1) / 2;
    if (y1 < y0)
      y0 = y1 = (y0 + y1) / 2;
    node.x0 = x0;
    node.y0 = y0;
    node.x1 = x1;
    node.y1 = y1;
    if (node.children) {
      p = paddingStack[node.depth + 1] = paddingInner(node) / 2;
      x0 += paddingLeft(node) - p;
      y0 += paddingTop(node) - p;
      x1 -= paddingRight(node) - p;
      y1 -= paddingBottom(node) - p;
      if (x1 < x0)
        x0 = x1 = (x0 + x1) / 2;
      if (y1 < y0)
        y0 = y1 = (y0 + y1) / 2;
      tile(node, x0, y0, x1, y1);
    }
  }
  treemap2.round = function(x) {
    return arguments.length ? (round2 = !!x, treemap2) : round2;
  };
  treemap2.size = function(x) {
    return arguments.length ? (dx = +x[0], dy = +x[1], treemap2) : [dx, dy];
  };
  treemap2.tile = function(x) {
    return arguments.length ? (tile = required(x), treemap2) : tile;
  };
  treemap2.padding = function(x) {
    return arguments.length ? treemap2.paddingInner(x).paddingOuter(x) : treemap2.paddingInner();
  };
  treemap2.paddingInner = function(x) {
    return arguments.length ? (paddingInner = typeof x === "function" ? x : constant$1(+x), treemap2) : paddingInner;
  };
  treemap2.paddingOuter = function(x) {
    return arguments.length ? treemap2.paddingTop(x).paddingRight(x).paddingBottom(x).paddingLeft(x) : treemap2.paddingTop();
  };
  treemap2.paddingTop = function(x) {
    return arguments.length ? (paddingTop = typeof x === "function" ? x : constant$1(+x), treemap2) : paddingTop;
  };
  treemap2.paddingRight = function(x) {
    return arguments.length ? (paddingRight = typeof x === "function" ? x : constant$1(+x), treemap2) : paddingRight;
  };
  treemap2.paddingBottom = function(x) {
    return arguments.length ? (paddingBottom = typeof x === "function" ? x : constant$1(+x), treemap2) : paddingBottom;
  };
  treemap2.paddingLeft = function(x) {
    return arguments.length ? (paddingLeft = typeof x === "function" ? x : constant$1(+x), treemap2) : paddingLeft;
  };
  return treemap2;
}
function binary(parent, x0, y0, x1, y1) {
  var nodes = parent.children, i, n = nodes.length, sum, sums = new Array(n + 1);
  for (sums[0] = sum = i = 0; i < n; ++i) {
    sums[i + 1] = sum += nodes[i].value;
  }
  partition2(0, n, parent.value, x0, y0, x1, y1);
  function partition2(i2, j, value2, x02, y02, x12, y12) {
    if (i2 >= j - 1) {
      var node = nodes[i2];
      node.x0 = x02, node.y0 = y02;
      node.x1 = x12, node.y1 = y12;
      return;
    }
    var valueOffset = sums[i2], valueTarget = value2 / 2 + valueOffset, k = i2 + 1, hi = j - 1;
    while (k < hi) {
      var mid2 = k + hi >>> 1;
      if (sums[mid2] < valueTarget)
        k = mid2 + 1;
      else
        hi = mid2;
    }
    if (valueTarget - sums[k - 1] < sums[k] - valueTarget && i2 + 1 < k)
      --k;
    var valueLeft = sums[k] - valueOffset, valueRight = value2 - valueLeft;
    if (x12 - x02 > y12 - y02) {
      var xk = value2 ? (x02 * valueRight + x12 * valueLeft) / value2 : x12;
      partition2(i2, k, valueLeft, x02, y02, xk, y12);
      partition2(k, j, valueRight, xk, y02, x12, y12);
    } else {
      var yk = value2 ? (y02 * valueRight + y12 * valueLeft) / value2 : y12;
      partition2(i2, k, valueLeft, x02, y02, x12, yk);
      partition2(k, j, valueRight, x02, yk, x12, y12);
    }
  }
}
function sliceDice(parent, x0, y0, x1, y1) {
  (parent.depth & 1 ? treemapSlice : treemapDice)(parent, x0, y0, x1, y1);
}
const resquarify = function custom11(ratio) {
  function resquarify2(parent, x0, y0, x1, y1) {
    if ((rows = parent._squarify) && rows.ratio === ratio) {
      var rows, row, nodes, i, j = -1, n, m = rows.length, value2 = parent.value;
      while (++j < m) {
        row = rows[j], nodes = row.children;
        for (i = row.value = 0, n = nodes.length; i < n; ++i)
          row.value += nodes[i].value;
        if (row.dice)
          treemapDice(row, x0, y0, x1, value2 ? y0 += (y1 - y0) * row.value / value2 : y1);
        else
          treemapSlice(row, x0, y0, value2 ? x0 += (x1 - x0) * row.value / value2 : x1, y1);
        value2 -= row.value;
      }
    } else {
      parent._squarify = rows = squarifyRatio(ratio, parent, x0, y0, x1, y1);
      rows.ratio = ratio;
    }
  }
  resquarify2.ratio = function(x) {
    return custom11((x = +x) > 1 ? x : 1);
  };
  return resquarify2;
}(phi);
const d3Hierarchy = /* @__PURE__ */ Object.freeze(/* @__PURE__ */ Object.defineProperty({
  __proto__: null,
  cluster,
  hierarchy,
  pack: index$1,
  packEnclose: enclose,
  packSiblings: siblings,
  partition: partition$1,
  stratify,
  tree,
  treemap: index,
  treemapBinary: binary,
  treemapDice,
  treemapResquarify: resquarify,
  treemapSlice,
  treemapSliceDice: sliceDice,
  treemapSquarify: squarify
}, Symbol.toStringTag, { value: "Module" }));
var NODE_INDEX_FIELD = "nodeIndex";
var CHILD_NODE_COUNT = "childNodeCount";
var NODE_ANCESTORS_FIELD = "nodeAncestor";
var INVALID_FIELD_ERR_MSG = "Invalid field: it must be a string!";
function getField(options, defaultField) {
  var field2 = options.field, fields = options.fields;
  if (isString(field2)) {
    return field2;
  }
  if (isArray$1(field2)) {
    console.warn(INVALID_FIELD_ERR_MSG);
    return field2[0];
  }
  console.warn("".concat(INVALID_FIELD_ERR_MSG, " will try to get fields instead."));
  if (isString(fields)) {
    return fields;
  }
  if (isArray$1(fields) && fields.length) {
    return fields[0];
  }
  if (defaultField) {
    return defaultField;
  }
  throw new TypeError(INVALID_FIELD_ERR_MSG);
}
function getAllNodes(root) {
  var nodes = [];
  if (root && root.each) {
    var parent_1;
    var index_1;
    root.each(function(node) {
      var _a2, _b;
      if (node.parent !== parent_1) {
        parent_1 = node.parent;
        index_1 = 0;
      } else {
        index_1 += 1;
      }
      var ancestors = filter((((_a2 = node.ancestors) === null || _a2 === void 0 ? void 0 : _a2.call(node)) || []).map(function(d) {
        return nodes.find(function(n) {
          return n.name === d.name;
        }) || d;
      }), function(_a3) {
        var depth = _a3.depth;
        return depth > 0 && depth < node.depth;
      });
      node[NODE_ANCESTORS_FIELD] = ancestors;
      node[CHILD_NODE_COUNT] = ((_b = node.children) === null || _b === void 0 ? void 0 : _b.length) || 0;
      node[NODE_INDEX_FIELD] = index_1;
      nodes.push(node);
    });
  } else if (root && root.eachNode) {
    root.eachNode(function(node) {
      nodes.push(node);
    });
  }
  return nodes;
}
var DEFAULT_OPTIONS$f = {
  field: "value",
  as: ["x", "y", "r"],
  // 
  sort: function(a, b) {
    return b.value - a.value;
  }
};
function pack(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$f, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 3) {
    throw new TypeError('Invalid as: it must be an array with 3 strings (e.g. [ "x", "y", "r" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var packLayout = function(data3) {
    return index$1().size(options.size).padding(options.padding)(hierarchy(data3).sum(function(d) {
      return d[field2];
    }).sort(options.sort));
  };
  var root = packLayout(data2);
  var x = as[0];
  var y = as[1];
  var r = as[2];
  root.each(function(node) {
    node[x] = node.x;
    node[y] = node.y;
    node[r] = node.r;
  });
  return getAllNodes(root);
}
function transformData$3(options) {
  var data2 = options.data, hierarchyConfig = options.hierarchyConfig, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2, enableDrillDown = options.enableDrillDown;
  var nodes = pack(data2, __assign$1(__assign$1({}, hierarchyConfig), { field: "value", as: ["x", "y", "r"] }));
  var result = [];
  nodes.forEach(function(node) {
    var _a3;
    var path2 = node.data.name;
    var ancestorNode = __assign$1({}, node);
    while (ancestorNode.depth > 1) {
      path2 = "".concat((_a3 = ancestorNode.parent.data) === null || _a3 === void 0 ? void 0 : _a3.name, " / ").concat(path2);
      ancestorNode = ancestorNode.parent;
    }
    if (enableDrillDown && node.depth > 2) {
      return null;
    }
    var nodeInfo = deepAssign({}, node.data, __assign$1(__assign$1(__assign$1({}, pick(node.data, rawFields)), { path: path2 }), node));
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, rawFields, enableDrillDown };
    result.push(nodeInfo);
  });
  return result;
}
function resolvePaddingForCircle(padding2, appendPadding, containerSize) {
  var tempPadding = resolveAllPadding([padding2, appendPadding]);
  var top = tempPadding[0], right2 = tempPadding[1], bottom = tempPadding[2], left2 = tempPadding[3];
  var width = containerSize.width, height = containerSize.height;
  var wSize = width - (left2 + right2);
  var hSize = height - (top + bottom);
  var minSize = Math.min(wSize, hSize);
  var restWidthPadding = (wSize - minSize) / 2;
  var restHeightPadding = (hSize - minSize) / 2;
  var finalTop = top + restHeightPadding;
  var finalRight = right2 + restWidthPadding;
  var finalBottom = bottom + restHeightPadding;
  var finalLeft = left2 + restWidthPadding;
  var finalPadding = [finalTop, finalRight, finalBottom, finalLeft];
  var finalSize = minSize < 0 ? 0 : minSize;
  return { finalPadding, finalSize };
}
function defaultOptions$3(params) {
  var chart = params.chart;
  var diameter = Math.min(chart.viewBBox.width, chart.viewBBox.height);
  return deepAssign({
    options: {
      size: function(_a2) {
        var r = _a2.r;
        return r * diameter;
      }
      // autofitfalse
    }
  }, params);
}
function padding$1(params) {
  var options = params.options, chart = params.chart;
  var containerSize = chart.viewBBox;
  var padding2 = options.padding, appendPadding = options.appendPadding, drilldown = options.drilldown;
  var tempAppendPadding = appendPadding;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    var appendPaddingByDrilldown = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
    tempAppendPadding = resolveAllPadding([appendPaddingByDrilldown, appendPadding]);
  }
  var finalPadding = resolvePaddingForCircle(padding2, tempAppendPadding, containerSize).finalPadding;
  chart.padding = finalPadding;
  chart.appendPadding = 0;
  return params;
}
function geometry$c(params) {
  var chart = params.chart, options = params.options;
  var padding2 = chart.padding, appendPadding = chart.appendPadding;
  var color2 = options.color, colorField = options.colorField, pointStyle = options.pointStyle, hierarchyConfig = options.hierarchyConfig, sizeField = options.sizeField, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2, drilldown = options.drilldown;
  var data2 = transformData$3({
    data: options.data,
    hierarchyConfig,
    enableDrillDown: drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled,
    rawFields
  });
  chart.data(data2);
  var containerSize = chart.viewBBox;
  var finalSize = resolvePaddingForCircle(padding2, appendPadding, containerSize).finalSize;
  var circleSize = function(_a3) {
    var r = _a3.r;
    return r * finalSize;
  };
  if (sizeField) {
    circleSize = function(d) {
      return d[sizeField] * finalSize;
    };
  }
  point(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      sizeField,
      rawFields: __spreadArray$1(__spreadArray$1([], RAW_FIELDS$1, true), rawFields, true),
      point: {
        color: color2,
        style: pointStyle,
        shape: "circle",
        size: circleSize
      }
    }
  }));
  return params;
}
function meta$9(params) {
  return flow(scale$2({}, {
    //  nice
    x: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true },
    y: { min: 0, max: 1, minLimit: 0, maxLimit: 1, nice: true }
  }))(params);
}
function tooltip$3(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (!get(tooltip2, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get(chart.getOptions(), "scales");
            var nameFormatter = get(scales, ["name", "formatter"], function(v) {
              return v;
            });
            var valueFormatter = get(scales, ["value", "formatter"], function(v) {
              return v;
            });
            return __assign$1(__assign$1({}, item), { name: nameFormatter(item.data.name), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function axis$a(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction$2(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArray$1(__spreadArray$1([], interactions, true), [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData$3, enableDrillDown: true }
        }
      ], false)
    });
  }
  return options;
}
function interaction$4(params) {
  var chart = params.chart, options = params.options;
  interaction$8({
    chart,
    options: adaptorInteraction$2(options)
  });
  return params;
}
function adaptor$e(params) {
  return flow(pattern("pointStyle"), defaultOptions$3, padding$1, theme$2, meta$9, geometry$c, axis$a, legend$g, tooltip$3, interaction$4, animation$5, annotation$2())(params);
}
function isParentNode(context) {
  var data2 = get(context, ["event", "data", "data"], {});
  return isArray$1(data2.children) && data2.children.length > 0;
}
function inCenter(context) {
  var coordinate2 = context.view.getCoordinate();
  var innerRadius = coordinate2.innerRadius;
  if (innerRadius) {
    var _a2 = context.event, x = _a2.x, y = _a2.y;
    var _b = coordinate2.center, centerX = _b.x, centerY = _b.y;
    var r = coordinate2.getRadius() * innerRadius;
    var distance2 = Math.sqrt(Math.pow(centerX - x, 2) + Math.pow(centerY - y, 2));
    return distance2 < r;
  }
  return false;
}
registerAction("drill-down-action", DrillDownAction);
registerInteraction("drill-down", {
  showEnable: [
    { trigger: "element:mouseenter", action: "cursor:pointer", isEnable: isParentNode },
    { trigger: "element:mouseleave", action: "cursor:default" },
    //  element:mouseleave 
    { trigger: "element:mouseleave", action: "cursor:pointer", isEnable: inCenter }
  ],
  start: [
    {
      trigger: "element:click",
      isEnable: isParentNode,
      action: ["drill-down-action:click"]
    },
    {
      trigger: "afterchangesize",
      action: ["drill-down-action:resetPosition"]
    },
    {
      // 
      trigger: "click",
      isEnable: inCenter,
      action: ["drill-down-action:back"]
    }
  ]
});
(function(_super) {
  __extends$1(CirclePacking, _super);
  function CirclePacking() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "circle-packing";
    return _this;
  }
  CirclePacking.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$g;
  };
  CirclePacking.prototype.getDefaultOptions = function() {
    return CirclePacking.getDefaultOptions();
  };
  CirclePacking.prototype.getSchemaAdaptor = function() {
    return adaptor$e;
  };
  CirclePacking.prototype.triggerResize = function() {
    if (!this.chart.destroyed) {
      this.chart.forceFit();
      this.chart.clear();
      this.execAdaptor();
      this.chart.render(true);
    }
  };
  return CirclePacking;
})(Plot);
var LEFT_AXES_VIEW = "left-axes-view";
var RIGHT_AXES_VIEW = "right-axes-view";
var DEFAULT_YAXIS_CONFIG = {
  nice: true,
  label: {
    autoHide: true,
    autoRotate: false
  }
};
var DEFAULT_LEFT_YAXIS_CONFIG = __assign$1(__assign$1({}, DEFAULT_YAXIS_CONFIG), { position: "left" });
var DEFAULT_RIGHT_YAXIS_CONFIG = __assign$1(__assign$1({}, DEFAULT_YAXIS_CONFIG), { position: "right", grid: null });
var AxisType;
(function(AxisType2) {
  AxisType2["Left"] = "Left";
  AxisType2["Right"] = "Right";
})(AxisType || (AxisType = {}));
var DualAxesGeometry;
(function(DualAxesGeometry2) {
  DualAxesGeometry2["Line"] = "line";
  DualAxesGeometry2["Column"] = "column";
})(DualAxesGeometry || (DualAxesGeometry = {}));
function isLine(geometryOption) {
  return get(geometryOption, "geometry") === DualAxesGeometry.Line;
}
function isColumn(geometryOption) {
  return get(geometryOption, "geometry") === DualAxesGeometry.Column;
}
function getGeometryOption(xField, yField, geometryOption) {
  return isColumn(geometryOption) ? deepAssign({}, {
    geometry: DualAxesGeometry.Column,
    label: geometryOption.label && geometryOption.isRange ? {
      content: function(item) {
        var _a2;
        return (_a2 = item[yField]) === null || _a2 === void 0 ? void 0 : _a2.join("-");
      }
    } : void 0
  }, geometryOption) : __assign$1({ geometry: DualAxesGeometry.Line }, geometryOption);
}
function transformObjectToArray(yField, transformAttribute) {
  var y1 = yField[0], y2 = yField[1];
  if (isArray$1(transformAttribute)) {
    var a1_1 = transformAttribute[0], a2_1 = transformAttribute[1];
    return [a1_1, a2_1];
  }
  var a1 = get(transformAttribute, y1);
  var a2 = get(transformAttribute, y2);
  return [a1, a2];
}
function getYAxisWithDefault(yAxis, axisType) {
  if (axisType === AxisType.Left) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_LEFT_YAXIS_CONFIG, yAxis);
  } else if (axisType === AxisType.Right) {
    return yAxis === false ? false : deepAssign({}, DEFAULT_RIGHT_YAXIS_CONFIG, yAxis);
  }
  return yAxis;
}
function drawSingleGeometry(params) {
  var options = params.options, chart = params.chart;
  var geometryOption = options.geometryOption;
  var isStack = geometryOption.isStack, color2 = geometryOption.color, seriesField = geometryOption.seriesField, groupField = geometryOption.groupField, isGroup = geometryOption.isGroup;
  var FIELD_KEY = ["xField", "yField"];
  if (isLine(geometryOption)) {
    line(deepAssign({}, params, {
      options: __assign$1(__assign$1(__assign$1({}, pick(options, FIELD_KEY)), geometryOption), { line: {
        color: geometryOption.color,
        style: geometryOption.lineStyle
      } })
    }));
    point(deepAssign({}, params, {
      options: __assign$1(__assign$1(__assign$1({}, pick(options, FIELD_KEY)), geometryOption), { point: geometryOption.point && __assign$1({ color: color2, shape: "circle" }, geometryOption.point) })
    }));
    var adjust_1 = [];
    if (isGroup) {
      adjust_1.push({
        type: "dodge",
        dodgeBy: groupField || seriesField,
        customOffset: 0
      });
    }
    if (isStack) {
      adjust_1.push({
        type: "stack"
      });
    }
    if (adjust_1.length) {
      each$1(chart.geometries, function(g) {
        g.adjust(adjust_1);
      });
    }
  }
  if (isColumn(geometryOption)) {
    adaptor$w(deepAssign({}, params, {
      options: __assign$1(__assign$1(__assign$1({}, pick(options, FIELD_KEY)), geometryOption), { widthRatio: geometryOption.columnWidthRatio, interval: __assign$1(__assign$1({}, pick(geometryOption, ["color"])), { style: geometryOption.columnStyle }) })
    }));
  }
  return params;
}
function getViewLegendItems(params) {
  var view = params.view, geometryOption = params.geometryOption, yField = params.yField, legend2 = params.legend;
  var userMarker = get(legend2, "marker");
  var geometry2 = findGeometry(view, isLine(geometryOption) ? "line" : "interval");
  if (!geometryOption.seriesField) {
    var legendItemName = get(view, "options.scales.".concat(yField, ".alias")) || yField;
    var colorAttribute = geometry2.getAttribute("color");
    var color2 = view.getTheme().defaultColor;
    if (colorAttribute) {
      color2 = Util.getMappingValue(colorAttribute, legendItemName, get(colorAttribute, ["values", 0], color2));
    }
    var marker = (isFunction(userMarker) ? userMarker : !isEmpty(userMarker) && deepAssign({}, {
      style: {
        stroke: color2,
        fill: color2
      }
    }, userMarker)) || (isLine(geometryOption) ? {
      symbol: function(x, y, r) {
        return [
          ["M", x - r, y],
          ["L", x + r, y]
        ];
      },
      style: {
        lineWidth: 2,
        r: 6,
        stroke: color2
      }
    } : {
      symbol: "square",
      style: {
        fill: color2
      }
    });
    return [
      {
        value: yField,
        name: legendItemName,
        marker,
        isGeometry: true,
        viewId: view.id
      }
    ];
  }
  var attributes = geometry2.getGroupAttributes();
  return reduce(attributes, function(items, attr) {
    var attrItems = Util.getLegendItems(view, geometry2, attr, view.getTheme(), userMarker);
    return items.concat(attrItems);
  }, []);
}
var doSliderFilter = function(view, sliderValue) {
  var min2 = sliderValue[0], max2 = sliderValue[1];
  var data2 = view.getOptions().data;
  var xScale = view.getXScale();
  var dataSize = size(data2);
  if (!xScale || !dataSize) {
    return;
  }
  var values2 = valuesOfKey(data2, xScale.field);
  var xValues = values2;
  var xTickCount = size(xValues);
  var minIndex = Math.floor(min2 * (xTickCount - 1));
  var maxIndex = Math.floor(max2 * (xTickCount - 1));
  view.filter(xScale.field, function(value2) {
    var idx = xValues.indexOf(value2);
    return idx > -1 ? isBetween(idx, minIndex, maxIndex) : true;
  });
  view.getRootView().render(true);
};
function transformOptions(params) {
  var _a2;
  var options = params.options;
  var _b = options.geometryOptions, geometryOptions = _b === void 0 ? [] : _b, xField = options.xField, yField = options.yField;
  var allLine = every(geometryOptions, function(_a3) {
    var geometry2 = _a3.geometry;
    return geometry2 === DualAxesGeometry.Line || geometry2 === void 0;
  });
  return deepAssign({}, {
    options: {
      geometryOptions: [],
      meta: (_a2 = {}, _a2[xField] = {
        //  cat 
        type: "cat",
        // x  scale 
        sync: true,
        // 
        range: allLine ? [0, 1] : void 0
      }, _a2),
      tooltip: {
        showMarkers: allLine,
        //  crosshairs
        showCrosshairs: allLine,
        shared: true,
        crosshairs: {
          type: "x"
        }
      },
      interactions: !allLine ? [{ type: "legend-visible-filter" }, { type: "active-region" }] : [{ type: "legend-visible-filter" }],
      legend: {
        position: "top-left"
      }
    }
  }, params, {
    options: {
      // yAxis
      yAxis: transformObjectToArray(yField, options.yAxis),
      // geometryOptions
      geometryOptions: [
        getGeometryOption(xField, yField[0], geometryOptions[0]),
        getGeometryOption(xField, yField[1], geometryOptions[1])
      ],
      // annotations
      annotations: transformObjectToArray(yField, options.annotations)
    }
  });
}
function createViews(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var SORT_MAP = { line: 0, column: 1 };
  var geometries = [
    { type: (_a2 = geometryOptions[0]) === null || _a2 === void 0 ? void 0 : _a2.geometry, id: LEFT_AXES_VIEW },
    { type: (_b = geometryOptions[1]) === null || _b === void 0 ? void 0 : _b.geometry, id: RIGHT_AXES_VIEW }
  ];
  geometries.sort(function(a, b) {
    return -SORT_MAP[a.type] + SORT_MAP[b.type];
  }).forEach(function(g) {
    return chart.createView({ id: g.id });
  });
  return params;
}
function geometry$b(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, yField = options.yField, geometryOptions = options.geometryOptions, data2 = options.data, tooltip2 = options.tooltip;
  var geometries = [
    __assign$1(__assign$1({}, geometryOptions[0]), { id: LEFT_AXES_VIEW, data: data2[0], yField: yField[0] }),
    __assign$1(__assign$1({}, geometryOptions[1]), { id: RIGHT_AXES_VIEW, data: data2[1], yField: yField[1] })
  ];
  geometries.forEach(function(geometry2) {
    var id2 = geometry2.id, data3 = geometry2.data, yField2 = geometry2.yField;
    var isPercent = isColumn(geometry2) && geometry2.isPercent;
    var formatData = isPercent ? percent(data3, yField2, xField, yField2) : data3;
    var view = findViewById(chart, id2).data(formatData);
    var tooltipOptions = isPercent ? __assign$1({ formatter: function(datum) {
      return {
        name: datum[geometry2.seriesField] || yField2,
        value: (Number(datum[yField2]) * 100).toFixed(2) + "%"
      };
    } }, tooltip2) : tooltip2;
    drawSingleGeometry({
      chart: view,
      options: {
        xField,
        yField: yField2,
        tooltip: tooltipOptions,
        geometryOption: geometry2
      }
    });
  });
  return params;
}
function color(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var geometryOptions = options.geometryOptions;
  var themeColor = ((_a2 = chart.getTheme()) === null || _a2 === void 0 ? void 0 : _a2.colors10) || [];
  var start = 0;
  chart.once("beforepaint", function() {
    each$1(geometryOptions, function(geometryOption, index2) {
      var view = findViewById(chart, index2 === 0 ? LEFT_AXES_VIEW : RIGHT_AXES_VIEW);
      if (geometryOption.color)
        return;
      var groupScale = view.getGroupScales();
      var count2 = get(groupScale, [0, "values", "length"], 1);
      var color2 = themeColor.slice(start, start + count2).concat(index2 === 0 ? [] : themeColor);
      view.geometries.forEach(function(geometry2) {
        if (geometryOption.seriesField) {
          geometry2.color(geometryOption.seriesField, color2);
        } else {
          geometry2.color(color2[0]);
        }
      });
      start += count2;
    });
    chart.render(true);
  });
  return params;
}
function meta$8(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField[0]] = yAxis[0], _a2))(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  scale$2((_b = {}, _b[xField] = xAxis, _b[yField[1]] = yAxis[1], _b))(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function axis$9(params) {
  var chart = params.chart, options = params.options;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  var xField = options.xField, yField = options.yField, xAxis = options.xAxis, yAxis = options.yAxis;
  chart.axis(xField, false);
  chart.axis(yField[0], false);
  chart.axis(yField[1], false);
  leftView.axis(xField, xAxis);
  leftView.axis(yField[0], getYAxisWithDefault(yAxis[0], AxisType.Left));
  rightView.axis(xField, false);
  rightView.axis(yField[1], getYAxisWithDefault(yAxis[1], AxisType.Right));
  return params;
}
function tooltip$2(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  chart.tooltip(tooltip2);
  leftView.tooltip({
    shared: true
  });
  rightView.tooltip({
    shared: true
  });
  return params;
}
function interaction$3(params) {
  var chart = params.chart;
  interaction$8(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  interaction$8(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function annotation$1(params) {
  var chart = params.chart, options = params.options;
  var annotations = options.annotations;
  var a1 = get(annotations, [0]);
  var a2 = get(annotations, [1]);
  annotation$2(a1)(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      annotations: a1
    }
  }));
  annotation$2(a2)(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      annotations: a2
    }
  }));
  return params;
}
function theme(params) {
  var chart = params.chart;
  theme$2(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  theme$2(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  theme$2(params);
  return params;
}
function animation$2(params) {
  var chart = params.chart;
  animation$5(deepAssign({}, params, { chart: findViewById(chart, LEFT_AXES_VIEW) }));
  animation$5(deepAssign({}, params, { chart: findViewById(chart, RIGHT_AXES_VIEW) }));
  return params;
}
function limitInPlot(params) {
  var chart = params.chart, options = params.options;
  var yAxis = options.yAxis;
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, LEFT_AXES_VIEW),
    options: {
      yAxis: yAxis[0]
    }
  }));
  limitInPlot$2(deepAssign({}, params, {
    chart: findViewById(chart, RIGHT_AXES_VIEW),
    options: {
      yAxis: yAxis[1]
    }
  }));
  return params;
}
function legend$6(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, geometryOptions = options.geometryOptions, yField = options.yField, data2 = options.data;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (legend2 === false) {
    chart.legend(false);
  } else if (isObject(legend2) && legend2.custom === true) {
    chart.legend(legend2);
  } else {
    var leftLegend_1 = get(geometryOptions, [0, "legend"], legend2);
    var rightLegend_1 = get(geometryOptions, [1, "legend"], legend2);
    chart.once("beforepaint", function() {
      var leftItems = data2[0].length ? getViewLegendItems({
        view: leftView,
        geometryOption: geometryOptions[0],
        yField: yField[0],
        legend: leftLegend_1
      }) : [];
      var rightItems = data2[1].length ? getViewLegendItems({
        view: rightView,
        geometryOption: geometryOptions[1],
        yField: yField[1],
        legend: rightLegend_1
      }) : [];
      chart.legend(deepAssign({}, legend2, {
        custom: true,
        // todo 
        // @ts-ignore
        items: leftItems.concat(rightItems)
      }));
    });
    if (geometryOptions[0].seriesField) {
      leftView.legend(geometryOptions[0].seriesField, leftLegend_1);
    }
    if (geometryOptions[1].seriesField) {
      rightView.legend(geometryOptions[1].seriesField, rightLegend_1);
    }
    chart.on("legend-item:click", function(evt) {
      var delegateObject = get(evt, "gEvent.delegateObject", {});
      if (delegateObject && delegateObject.item) {
        var _a2 = delegateObject.item, field_1 = _a2.value, isGeometry = _a2.isGeometry, viewId = _a2.viewId;
        if (isGeometry) {
          var idx = findIndex(yField, function(yF) {
            return yF === field_1;
          });
          if (idx > -1) {
            var geometries = get(findViewById(chart, viewId), "geometries");
            each$1(geometries, function(g) {
              g.changeVisible(!delegateObject.item.unchecked);
            });
          }
        } else {
          var legendItem_1 = get(chart.getController("legend"), "option.items", []);
          each$1(chart.views, function(view) {
            var groupScale = view.getGroupScales();
            each$1(groupScale, function(scale2) {
              if (scale2.values && scale2.values.indexOf(field_1) > -1) {
                view.filter(scale2.field, function(value2) {
                  var curLegendItem = find$1(legendItem_1, function(item) {
                    return item.value === value2;
                  });
                  return !curLegendItem.unchecked;
                });
              }
            });
            chart.render(true);
          });
        }
      }
    });
  }
  return params;
}
function slider(params) {
  var chart = params.chart, options = params.options;
  var slider2 = options.slider;
  var leftView = findViewById(chart, LEFT_AXES_VIEW);
  var rightView = findViewById(chart, RIGHT_AXES_VIEW);
  if (slider2) {
    leftView.option("slider", slider2);
    leftView.on("slider:valuechanged", function(evt) {
      var _a2 = evt.event, value2 = _a2.value, originValue = _a2.originValue;
      if (isEqual$1(value2, originValue)) {
        return;
      }
      doSliderFilter(rightView, value2);
    });
    chart.once("afterpaint", function() {
      if (!isBoolean(slider2)) {
        var start = slider2.start, end = slider2.end;
        if (start || end) {
          doSliderFilter(rightView, [start, end]);
        }
      }
    });
  }
  return params;
}
function adaptor$d(params) {
  return flow(
    transformOptions,
    createViews,
    // 
    theme,
    geometry$b,
    meta$8,
    axis$9,
    limitInPlot,
    tooltip$2,
    interaction$3,
    annotation$1,
    animation$2,
    color,
    legend$6,
    slider
  )(params);
}
(function(_super) {
  __extends$1(DualAxes, _super);
  function DualAxes() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "dual-axes";
    return _this;
  }
  DualAxes.prototype.getDefaultOptions = function() {
    return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      yAxis: [],
      syncViewPadding: true
    });
  };
  DualAxes.prototype.getSchemaAdaptor = function() {
    return adaptor$d;
  };
  return DualAxes;
})(Plot);
function execViewAdaptor(viewOfG2, options) {
  var data2 = options.data, coordinate2 = options.coordinate, interactions = options.interactions, annotations = options.annotations, animation2 = options.animation, tooltip2 = options.tooltip, axes = options.axes, meta2 = options.meta, geometries = options.geometries;
  if (data2) {
    viewOfG2.data(data2);
  }
  var scales = {};
  if (axes) {
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta2, scales);
  viewOfG2.scale(scales);
  if (coordinate2) {
    viewOfG2.coordinate(coordinate2);
  }
  if (axes === false) {
    viewOfG2.axis(false);
  } else {
    each$1(axes, function(axis2, field2) {
      viewOfG2.axis(field2, axis2);
    });
  }
  each$1(geometries, function(geometry2) {
    var ext = geometry$x({
      chart: viewOfG2,
      options: geometry2
    }).ext;
    var adjust2 = geometry2.adjust;
    if (adjust2) {
      ext.geometry.adjust(adjust2);
    }
  });
  each$1(interactions, function(interaction2) {
    if (interaction2.enable === false) {
      viewOfG2.removeInteraction(interaction2.type);
    } else {
      viewOfG2.interaction(interaction2.type, interaction2.cfg);
    }
  });
  each$1(annotations, function(annotation2) {
    viewOfG2.annotation()[annotation2.type](__assign$1({}, annotation2));
  });
  addViewAnimation(viewOfG2, animation2);
  if (tooltip2) {
    viewOfG2.interaction("tooltip");
    viewOfG2.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    viewOfG2.removeInteraction("tooltip");
  }
}
function facetAdaptor(params) {
  var chart = params.chart, options = params.options;
  var facetType = options.type, data2 = options.data, fields = options.fields, eachView = options.eachView;
  var restFacetCfg = omit$1(options, [
    "type",
    "data",
    "fields",
    "eachView",
    "axes",
    "meta",
    "tooltip",
    "coordinate",
    "theme",
    "legend",
    "interactions",
    "annotations"
  ]);
  chart.data(data2);
  chart.facet(facetType, __assign$1(__assign$1({}, restFacetCfg), { fields, eachView: function(viewOfG2, facet) {
    var viewOptions = eachView(viewOfG2, facet);
    if (viewOptions.geometries) {
      execViewAdaptor(viewOfG2, viewOptions);
    } else {
      var plot = viewOptions;
      var plotOptions = plot.options;
      if (plotOptions.tooltip) {
        viewOfG2.interaction("tooltip");
      }
      execPlotAdaptor(plot.type, viewOfG2, plotOptions);
    }
  } }));
  return params;
}
function component(params) {
  var chart = params.chart, options = params.options;
  var axes = options.axes, meta2 = options.meta, tooltip2 = options.tooltip, coordinate2 = options.coordinate, theme2 = options.theme, legend2 = options.legend, interactions = options.interactions, annotations = options.annotations;
  var scales = {};
  if (axes) {
    each$1(axes, function(axis2, field2) {
      scales[field2] = pick(axis2, AXIS_META_CONFIG_KEYS);
    });
  }
  scales = deepAssign({}, meta2, scales);
  chart.scale(scales);
  chart.coordinate(coordinate2);
  if (!axes) {
    chart.axis(false);
  } else {
    each$1(axes, function(axis2, field2) {
      chart.axis(field2, axis2);
    });
  }
  if (tooltip2) {
    chart.interaction("tooltip");
    chart.tooltip(tooltip2);
  } else if (tooltip2 === false) {
    chart.removeInteraction("tooltip");
  }
  chart.legend(legend2);
  if (theme2) {
    chart.theme(theme2);
  }
  each$1(interactions, function(interaction2) {
    if (interaction2.enable === false) {
      chart.removeInteraction(interaction2.type);
    } else {
      chart.interaction(interaction2.type, interaction2.cfg);
    }
  });
  each$1(annotations, function(annotation2) {
    chart.annotation()[annotation2.type](__assign$1({}, annotation2));
  });
  return params;
}
function adaptor$c(params) {
  return flow(theme$2, facetAdaptor, component)(params);
}
var DEFAULT_OPTIONS$e = {
  title: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  rowTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  },
  columnTitle: {
    style: {
      fontSize: 12,
      fill: "rgba(0,0,0,0.65)"
    }
  }
};
(function(_super) {
  __extends$1(Facet2, _super);
  function Facet2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "area";
    return _this;
  }
  Facet2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$e;
  };
  Facet2.prototype.getDefaultOptions = function() {
    return Facet2.getDefaultOptions();
  };
  Facet2.prototype.getSchemaAdaptor = function() {
    return adaptor$c;
  };
  return Facet2;
})(Plot);
function geometry$a(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, type = options.type, xField = options.xField, yField = options.yField, colorField = options.colorField, sizeField = options.sizeField, sizeRatio = options.sizeRatio, shape = options.shape, color2 = options.color, tooltip2 = options.tooltip, heatmapStyle = options.heatmapStyle, meta2 = options.meta;
  chart.data(data2);
  var geometryType = "polygon";
  if (type === "density") {
    geometryType = "heatmap";
  }
  var _a2 = getTooltipMapping(tooltip2, [xField, yField, colorField]), fields = _a2.fields, formatter = _a2.formatter;
  var checkedSizeRatio = 1;
  if (sizeRatio || sizeRatio === 0) {
    if (!shape && !sizeField) {
      console.warn("sizeRatio is not in effect: Must define shape or sizeField first");
    } else if (sizeRatio < 0 || sizeRatio > 1) {
      console.warn("sizeRatio is not in effect: It must be a number in [0,1]");
    } else {
      checkedSizeRatio = sizeRatio;
    }
  }
  geometry$x(deepAssign({}, params, {
    options: {
      type: geometryType,
      colorField,
      tooltipFields: fields,
      shapeField: sizeField || "",
      label: void 0,
      mapping: {
        tooltip: formatter,
        shape: shape && (sizeField ? function(dautm) {
          var field2 = data2.map(function(row) {
            return row[sizeField];
          });
          var _a3 = (meta2 === null || meta2 === void 0 ? void 0 : meta2[sizeField]) || {}, min2 = _a3.min, max2 = _a3.max;
          min2 = isNumber$1(min2) ? min2 : Math.min.apply(Math, field2);
          max2 = isNumber$1(max2) ? max2 : Math.max.apply(Math, field2);
          return [shape, (get(dautm, sizeField) - min2) / (max2 - min2), checkedSizeRatio];
        } : function() {
          return [shape, 1, checkedSizeRatio];
        }),
        color: color2 || colorField && chart.getTheme().sequenceColors.join("-"),
        style: heatmapStyle
      }
    }
  }));
  return params;
}
function meta$7(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$8(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function legend$5(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField, sizeField = options.sizeField, sizeLegend = options.sizeLegend;
  var showLegend = legend2 !== false;
  if (colorField) {
    chart.legend(colorField, showLegend ? legend2 : false);
  }
  if (sizeField) {
    chart.legend(sizeField, sizeLegend === void 0 ? legend2 : sizeLegend);
  }
  if (!showLegend && !sizeLegend) {
    chart.legend(false);
  }
  return params;
}
function label$6(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, colorField = options.colorField, type = options.type;
  var geometry2 = findGeometry(chart, type === "density" ? "heatmap" : "polygon");
  if (!label2) {
    geometry2.label(false);
  } else if (colorField) {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [colorField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate$3(params) {
  var _a2, _b;
  var chart = params.chart, options = params.options;
  var coordinate2 = options.coordinate, reflect = options.reflect;
  var coordinateOption = deepAssign({ actions: [] }, coordinate2 !== null && coordinate2 !== void 0 ? coordinate2 : { type: "rect" });
  if (reflect) {
    (_b = (_a2 = coordinateOption.actions) === null || _a2 === void 0 ? void 0 : _a2.push) === null || _b === void 0 ? void 0 : _b.call(_a2, ["reflect", reflect]);
  }
  chart.coordinate(coordinateOption);
  return params;
}
function adaptor$b(params) {
  return flow(theme$2, pattern("heatmapStyle"), meta$7, coordinate$3, geometry$a, axis$8, legend$5, tooltip$9, label$6, annotation$2(), interaction$8, animation$5, state)(params);
}
var DEFAULT_OPTIONS$d = deepAssign({}, Plot.getDefaultOptions(), {
  type: "polygon",
  legend: false,
  coordinate: {
    type: "rect"
  },
  xAxis: {
    tickLine: null,
    line: null,
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  },
  yAxis: {
    grid: {
      alignTick: false,
      line: {
        style: {
          lineWidth: 1,
          lineDash: null,
          stroke: "#f0f0f0"
        }
      }
    }
  }
});
registerShape("polygon", "circle", {
  draw: function(cfg, group2) {
    var _a2, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points2 = this.parsePoints(cfg.points);
    var width = Math.abs(points2[2].x - points2[1].x);
    var height = Math.abs(points2[1].y - points2[0].y);
    var maxRadius = Math.min(width, height) / 2;
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var radiusRatio = Math.sqrt(sizeRatio);
    var radius = maxRadius * radiusRatio * Math.sqrt(value2);
    var fill = ((_a2 = cfg.style) === null || _a2 === void 0 ? void 0 : _a2.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("circle", {
      attrs: __assign$1(__assign$1(__assign$1({ x: cx, y: cy, r: radius }, cfg.defaultStyle), cfg.style), { fill })
    });
    return polygon2;
  }
});
registerShape("polygon", "square", {
  draw: function(cfg, group2) {
    var _a2, _b;
    var cx = cfg.x;
    var cy = cfg.y;
    var points2 = this.parsePoints(cfg.points);
    var width = Math.abs(points2[2].x - points2[1].x);
    var height = Math.abs(points2[1].y - points2[0].y);
    var maxSideLength = Math.min(width, height);
    var value2 = Number(cfg.shape[1]);
    var sizeRatio = Number(cfg.shape[2]);
    var lenRatio = Math.sqrt(sizeRatio);
    var sideLength = maxSideLength * lenRatio * Math.sqrt(value2);
    var fill = ((_a2 = cfg.style) === null || _a2 === void 0 ? void 0 : _a2.fill) || cfg.color || ((_b = cfg.defaultStyle) === null || _b === void 0 ? void 0 : _b.fill);
    var polygon2 = group2.addShape("rect", {
      attrs: __assign$1(__assign$1(__assign$1({ x: cx - sideLength / 2, y: cy - sideLength / 2, width: sideLength, height: sideLength }, cfg.defaultStyle), cfg.style), { fill })
    });
    return polygon2;
  }
});
(function(_super) {
  __extends$1(Heatmap2, _super);
  function Heatmap2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "heatmap";
    return _this;
  }
  Heatmap2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$d;
  };
  Heatmap2.prototype.getSchemaAdaptor = function() {
    return adaptor$b;
  };
  Heatmap2.prototype.getDefaultOptions = function() {
    return Heatmap2.getDefaultOptions();
  };
  return Heatmap2;
})(Plot);
var CAT_VALUE = "liquid";
function getLiquidData(percent2) {
  return [{ percent: percent2, type: CAT_VALUE }];
}
function geometry$9(params) {
  var chart = params.chart, options = params.options;
  var percent2 = options.percent, liquidStyle = options.liquidStyle, radius = options.radius, outline = options.outline, wave = options.wave, shape = options.shape, shapeStyle = options.shapeStyle, animation2 = options.animation;
  chart.scale({
    percent: {
      min: 0,
      max: 1
    }
  });
  chart.data(getLiquidData(percent2));
  var color2 = options.color || chart.getTheme().defaultColor;
  var p = deepAssign({}, params, {
    options: {
      xField: "type",
      yField: "percent",
      // radius  columnWidthRatio 
      //   radius 
      widthRatio: radius,
      interval: {
        color: color2,
        style: liquidStyle,
        shape: "liquid-fill-gauge"
      }
    }
  });
  var ext = interval(p).ext;
  var geometry2 = ext.geometry;
  var background = chart.getTheme().background;
  var customInfo = {
    percent: percent2,
    radius,
    outline,
    wave,
    shape,
    shapeStyle,
    background,
    animation: animation2
  };
  geometry2.customInfo(customInfo);
  chart.legend(false);
  chart.axis(false);
  chart.tooltip(false);
  return params;
}
function statistic(params, updated) {
  var chart = params.chart, options = params.options;
  var statistic2 = options.statistic, percent2 = options.percent, meta2 = options.meta;
  chart.getController("annotation").clear(true);
  var metaFormatter = get(meta2, ["percent", "formatter"]) || function(v) {
    return "".concat((v * 100).toFixed(2), "%");
  };
  var contentOpt = statistic2.content;
  if (contentOpt) {
    contentOpt = deepAssign({}, contentOpt, {
      content: !isNil(contentOpt.content) ? contentOpt.content : metaFormatter(percent2)
    });
  }
  renderStatistic(chart, { statistic: __assign$1(__assign$1({}, statistic2), { content: contentOpt }), plotType: "liquid" }, { percent: percent2 });
  if (updated) {
    chart.render(true);
  }
  return params;
}
function adaptor$a(params) {
  return flow(theme$2, pattern("liquidStyle"), geometry$9, statistic, scale$2({}), animation$5, interaction$8)(params);
}
var DEFAULT_OPTIONS$c = {
  radius: 0.9,
  statistic: {
    title: false,
    content: {
      style: {
        opacity: 0.75,
        fontSize: "30px",
        lineHeight: "30px",
        textAlign: "center"
      }
    }
  },
  outline: {
    border: 2,
    distance: 0
  },
  wave: {
    count: 3,
    length: 192
  },
  shape: "circle"
};
var DURATION = 5e3;
function lerp(min2, max2, factor) {
  return min2 + (max2 - min2) * factor;
}
function getFillAttrs$2(cfg) {
  var attrs = __assign$1({ opacity: 1 }, cfg.style);
  if (cfg.color && !attrs.fill) {
    attrs.fill = cfg.color;
  }
  return attrs;
}
function getLineAttrs(cfg) {
  var defaultAttrs = {
    fill: "#fff",
    fillOpacity: 0,
    lineWidth: 4
  };
  var attrs = mix({}, defaultAttrs, cfg.style);
  if (cfg.color && !attrs.stroke) {
    attrs.stroke = cfg.color;
  }
  if (isNumber$1(cfg.opacity)) {
    attrs.opacity = attrs.strokeOpacity = cfg.opacity;
  }
  return attrs;
}
function getWaterWavePositions(x, stage, waveLength, amplitude2) {
  if (stage === 0) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, amplitude2 / 2],
      [x + 1 / 2 * waveLength / Math.PI, amplitude2],
      [x + waveLength / 4, amplitude2]
    ];
  }
  if (stage === 1) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), amplitude2],
      [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), amplitude2 / 2],
      [x + waveLength / 4, 0]
    ];
  }
  if (stage === 2) {
    return [
      [x + 1 / 2 * waveLength / Math.PI / 2, -amplitude2 / 2],
      [x + 1 / 2 * waveLength / Math.PI, -amplitude2],
      [x + waveLength / 4, -amplitude2]
    ];
  }
  return [
    [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 2), -amplitude2],
    [x + 1 / 2 * waveLength / Math.PI / 2 * (Math.PI - 1), -amplitude2 / 2],
    [x + waveLength / 4, 0]
  ];
}
function getWaterWavePath(radius, waterLevel, waveLength, phase, amplitude2, cx, cy) {
  var curves = Math.ceil(2 * radius / waveLength * 4) * 4;
  var path2 = [];
  var _phase = phase;
  while (_phase < -Math.PI * 2) {
    _phase += Math.PI * 2;
  }
  while (_phase > 0) {
    _phase -= Math.PI * 2;
  }
  _phase = _phase / Math.PI / 2 * waveLength;
  var left2 = cx - radius + _phase - radius * 2;
  path2.push(["M", left2, waterLevel]);
  var waveRight = 0;
  for (var c = 0; c < curves; ++c) {
    var stage = c % 4;
    var pos = getWaterWavePositions(c * waveLength / 4, stage, waveLength, amplitude2);
    path2.push([
      "C",
      pos[0][0] + left2,
      -pos[0][1] + waterLevel,
      pos[1][0] + left2,
      -pos[1][1] + waterLevel,
      pos[2][0] + left2,
      -pos[2][1] + waterLevel
    ]);
    if (c === curves - 1) {
      waveRight = pos[2][0];
    }
  }
  path2.push(["L", waveRight + left2, cy + radius]);
  path2.push(["L", left2, cy + radius]);
  path2.push(["Z"]);
  return path2;
}
function addWaterWave(x, y, level, waveCount, waveAttrs, group2, clip, radius, waveLength, animation2) {
  var fill = waveAttrs.fill, opacity = waveAttrs.opacity;
  var bbox = clip.getBBox();
  var width = bbox.maxX - bbox.minX;
  var height = bbox.maxY - bbox.minY;
  for (var idx = 0; idx < waveCount; idx++) {
    var factor = waveCount <= 1 ? 1 : idx / (waveCount - 1);
    var wave = group2.addShape("path", {
      name: "waterwave-path",
      attrs: {
        // 
        path: getWaterWavePath(
          radius,
          bbox.minY + height * level,
          waveLength,
          0,
          width / 32,
          // 
          x,
          y
        ),
        fill,
        opacity: lerp(0.2, 0.9, factor) * opacity
      }
    });
    try {
      if (animation2 === false)
        return;
      var matrix = transform$2([["t", waveLength, 0]]);
      wave.stopAnimate();
      wave.animate({ matrix }, {
        duration: lerp(0.5 * DURATION, DURATION, factor),
        repeat: true
      });
    } catch (e) {
      console.warn("off-screen group animate error!");
    }
  }
}
function pin(x, y, width, height) {
  var w = width * 2 / 3;
  var h = Math.max(w, height);
  var r = w / 2;
  var cx = x;
  var cy = r + y - h / 2;
  var theta = Math.asin(r / ((h - r) * 0.85));
  var dy = Math.sin(theta) * r;
  var dx = Math.cos(theta) * r;
  var x0 = cx - dx;
  var y0 = cy + dy;
  var cpX = x;
  var cpY = cy + r / Math.sin(theta);
  return "\n      M ".concat(x0, " ").concat(y0, "\n      A ").concat(r, " ").concat(r, " 0 1 1 ").concat(x0 + dx * 2, " ").concat(y0, "\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x, " ").concat(y + h / 2, "\n      Q ").concat(cpX, " ").concat(cpY, " ").concat(x0, " ").concat(y0, "\n      Z \n    ");
}
function circle(x, y, width, height) {
  var rx = width / 2;
  var ry = height / 2;
  return "\n      M ".concat(x, " ").concat(y - ry, " \n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(ry * 2, "\n      a ").concat(rx, " ").concat(ry, " 0 1 0 0 ").concat(-ry * 2, "\n      Z\n    ");
}
function diamond(x, y, width, height) {
  var h = height / 2;
  var w = width / 2;
  return "\n      M ".concat(x, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y, "\n      L ").concat(x, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y, "\n      Z\n    ");
}
function triangle(x, y, width, height) {
  var h = height / 2;
  var w = width / 2;
  return "\n      M ".concat(x, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y + h, "\n      Z\n    ");
}
function rect(x, y, width, height) {
  var GOLDEN_SECTION_RATIO = 0.618;
  var h = height / 2;
  var w = width / 2 * GOLDEN_SECTION_RATIO;
  return "\n      M ".concat(x - w, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y - h, "\n      L ").concat(x + w, " ").concat(y + h, "\n      L ").concat(x - w, " ").concat(y + h, "\n      Z\n    ");
}
var builtInShapeByName = {
  pin,
  circle,
  diamond,
  triangle,
  rect
};
registerShape("interval", "liquid-fill-gauge", {
  draw: function(cfg, container) {
    var cx = 0.5;
    var cy = 0.5;
    var customInfo = cfg.customInfo;
    var _a2 = customInfo, percent2 = _a2.percent, radio = _a2.radius, shape = _a2.shape, shapeStyle = _a2.shapeStyle, background = _a2.background, animation2 = _a2.animation;
    var outline = customInfo.outline;
    var wave = customInfo.wave;
    var border = outline.border, distance2 = outline.distance;
    var waveCount = wave.count, waveLength = wave.length;
    var minX = reduce(cfg.points, function(r, p) {
      return Math.min(r, p.x);
    }, Infinity);
    var center2 = this.parsePoint({ x: cx, y: cy });
    var minXPoint = this.parsePoint({ x: minX, y: cy });
    var halfWidth = center2.x - minXPoint.x;
    var radius = Math.min(halfWidth, minXPoint.y * radio);
    var waveAttrs = getFillAttrs$2(cfg);
    var outlineAttrs = getLineAttrs(mix({}, cfg, outline));
    var innerRadius = radius - border / 2;
    var buildPath = typeof shape === "function" ? shape : builtInShapeByName[shape] || builtInShapeByName["circle"];
    var shapePath = buildPath(center2.x, center2.y, innerRadius * 2, innerRadius * 2);
    if (shapeStyle) {
      container.addShape("path", {
        name: "shape",
        attrs: __assign$1({ path: shapePath }, shapeStyle)
      });
    }
    if (percent2 > 0) {
      var waves = container.addGroup({
        name: "waves"
      });
      var clipPath = waves.setClip({
        type: "path",
        attrs: {
          path: shapePath
        }
      });
      addWaterWave(center2.x, center2.y, 1 - cfg.points[1].y, waveCount, waveAttrs, waves, clipPath, radius * 2, waveLength, animation2);
    }
    container.addShape("path", {
      name: "distance",
      attrs: {
        path: shapePath,
        fill: "transparent",
        lineWidth: border + distance2 * 2,
        stroke: background === "transparent" ? "#fff" : background
      }
    });
    container.addShape("path", {
      name: "wrap",
      attrs: mix(outlineAttrs, {
        path: shapePath,
        fill: "transparent",
        lineWidth: border
      })
    });
    return container;
  }
});
(function(_super) {
  __extends$1(Liquid, _super);
  function Liquid() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "liquid";
    return _this;
  }
  Liquid.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$c;
  };
  Liquid.prototype.getDefaultOptions = function() {
    return Liquid.getDefaultOptions();
  };
  Liquid.prototype.changeData = function(percent2) {
    this.chart.emit(VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.BEFORE_CHANGE_DATA, null));
    this.updateOption({ percent: percent2 });
    this.chart.data(getLiquidData(percent2));
    statistic({ chart: this.chart, options: this.options }, true);
    this.chart.emit(VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, Event.fromData(this.chart, VIEW_LIFE_CIRCLE.AFTER_CHANGE_DATA, null));
  };
  Liquid.prototype.getSchemaAdaptor = function() {
    return adaptor$a;
  };
  return Liquid;
})(Plot);
function geometry$8(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, lineStyle = options.lineStyle, color2 = options.color, pointOptions = options.point, areaOptions = options.area;
  chart.data(data2);
  var primary = deepAssign({}, params, {
    options: {
      line: {
        style: lineStyle,
        color: color2
      },
      point: pointOptions ? __assign$1({ color: color2 }, pointOptions) : pointOptions,
      area: areaOptions ? __assign$1({ color: color2 }, areaOptions) : areaOptions,
      // label  geometry adaptor label adaptor 
      label: void 0
    }
  });
  var second = deepAssign({}, primary, {
    options: {
      tooltip: false
    }
  });
  var pointState = (pointOptions === null || pointOptions === void 0 ? void 0 : pointOptions.state) || options.state;
  var pointParams = deepAssign({}, primary, { options: { tooltip: false, state: pointState } });
  line(primary);
  point(pointParams);
  area(second);
  return params;
}
function meta$6(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function coord(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate("polar", {
    radius,
    startAngle,
    endAngle
  });
  return params;
}
function axis$7(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis, yField = options.yField, yAxis = options.yAxis;
  chart.axis(xField, xAxis);
  chart.axis(yField, yAxis);
  return params;
}
function label$5(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var geometry2 = findGeometry(chart, "line");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: [yField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function adaptor$9(params) {
  return flow(geometry$8, meta$6, theme$2, coord, axis$7, legend$g, tooltip$9, label$5, interaction$8, animation$5, annotation$2())(params);
}
var RadarTooltipController = (
  /** @class */
  function(_super) {
    __extends$1(RadarTooltipController2, _super);
    function RadarTooltipController2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(RadarTooltipController2.prototype, "name", {
      get: function() {
        return "radar-tooltip";
      },
      enumerable: false,
      configurable: true
    });
    RadarTooltipController2.prototype.getTooltipItems = function(point2) {
      var _a2 = this.getTooltipCfg(), shared = _a2.shared, cfgTitle = _a2.title;
      var hintItems = _super.prototype.getTooltipItems.call(this, point2);
      if (hintItems.length > 0) {
        var geometry_1 = this.view.geometries[0];
        var dataArray = geometry_1.dataArray;
        var title_1 = hintItems[0].name;
        var result_1 = [];
        dataArray.forEach(function(mappingData) {
          mappingData.forEach(function(d) {
            var items = Util.getTooltipItems(d, geometry_1);
            var item = items[0];
            if (!shared && item && item.name === title_1) {
              var displayTitle = isNil(cfgTitle) ? title_1 : cfgTitle;
              result_1.push(__assign$1(__assign$1({}, item), { name: item.title, title: displayTitle }));
            } else if (shared && item) {
              var displayTitle = isNil(cfgTitle) ? item.name || title_1 : cfgTitle;
              result_1.push(__assign$1(__assign$1({}, item), { name: item.title, title: displayTitle }));
            }
          });
        });
        return result_1;
      }
      return [];
    };
    return RadarTooltipController2;
  }(Tooltip)
);
registerComponentController("radar-tooltip", RadarTooltipController);
var RadarTooltipAction = (
  /** @class */
  function(_super) {
    __extends$1(RadarTooltipAction2, _super);
    function RadarTooltipAction2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    RadarTooltipAction2.prototype.init = function() {
      var view = this.context.view;
      view.removeInteraction("tooltip");
    };
    RadarTooltipAction2.prototype.show = function() {
      var event = this.context.event;
      var controller = this.getTooltipController();
      controller.showTooltip({ x: event.x, y: event.y });
    };
    RadarTooltipAction2.prototype.hide = function() {
      var controller = this.getTooltipController();
      controller.hideTooltip();
    };
    RadarTooltipAction2.prototype.getTooltipController = function() {
      var view = this.context.view;
      return view.getController("radar-tooltip");
    };
    return RadarTooltipAction2;
  }(Action)
);
registerAction("radar-tooltip", RadarTooltipAction);
registerInteraction("radar-tooltip", {
  start: [{ trigger: "plot:mousemove", action: "radar-tooltip:show" }],
  end: [{ trigger: "plot:mouseleave", action: "radar-tooltip:hide" }]
});
(function(_super) {
  __extends$1(Radar, _super);
  function Radar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radar";
    return _this;
  }
  Radar.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(data2);
  };
  Radar.prototype.getDefaultOptions = function() {
    return deepAssign({}, _super.prototype.getDefaultOptions.call(this), {
      xAxis: {
        label: {
          offset: 15
        },
        grid: {
          line: {
            type: "line"
          }
        }
      },
      yAxis: {
        grid: {
          line: {
            type: "circle"
          }
        }
      },
      legend: {
        position: "top"
      },
      tooltip: {
        shared: true,
        showCrosshairs: true,
        showMarkers: true,
        crosshairs: {
          type: "xy",
          line: {
            style: {
              stroke: "#565656",
              lineDash: [4]
            }
          },
          follow: true
        }
      }
    });
  };
  Radar.prototype.getSchemaAdaptor = function() {
    return adaptor$9;
  };
  return Radar;
})(Plot);
function getScaleMax(maxAngle, yField, data2) {
  var yData = data2.map(function(item) {
    return item[yField];
  }).filter(function(v) {
    return v !== void 0;
  });
  var maxValue = yData.length > 0 ? Math.max.apply(Math, yData) : 0;
  var formatRadian = Math.abs(maxAngle) % 360;
  if (!formatRadian) {
    return maxValue;
  }
  return maxValue * 360 / formatRadian;
}
function getStackedData(data2, xField, yField) {
  var stackedData = [];
  data2.forEach(function(item) {
    var valueItem = stackedData.find(function(v) {
      return v[xField] === item[xField];
    });
    if (valueItem) {
      valueItem[yField] += item[yField] || null;
    } else {
      stackedData.push(__assign$1({}, item));
    }
  });
  return stackedData;
}
function geometry$7(params) {
  var chart = params.chart, options = params.options;
  var style = options.barStyle, color2 = options.color, tooltip2 = options.tooltip, colorField = options.colorField, type = options.type, xField = options.xField, yField = options.yField, data2 = options.data, shape = options.shape;
  var processData2 = processIllegalData(data2, yField);
  chart.data(processData2);
  var p = deepAssign({}, params, {
    options: {
      tooltip: tooltip2,
      seriesField: colorField,
      interval: {
        style,
        color: color2,
        shape: shape || (type === "line" ? "line" : "intervel")
      },
      // 
      minColumnWidth: options.minBarWidth,
      maxColumnWidth: options.maxBarWidth,
      columnBackground: options.barBackground
    }
  });
  interval(p);
  if (type === "line") {
    point({
      chart,
      options: { xField, yField, seriesField: colorField, point: { shape: "circle", color: color2 } }
    });
  }
  return params;
}
function meta$5(params) {
  var _a2;
  var options = params.options;
  var yField = options.yField, xField = options.xField, data2 = options.data, isStack = options.isStack, isGroup = options.isGroup, colorField = options.colorField, maxAngle = options.maxAngle;
  var actualData = isStack && !isGroup && colorField ? getStackedData(data2, xField, yField) : data2;
  var processData2 = processIllegalData(actualData, yField);
  return flow(scale$2((_a2 = {}, _a2[yField] = {
    min: 0,
    max: getScaleMax(maxAngle, yField, processData2)
  }, _a2)))(params);
}
function coordinate$2(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  }).transpose();
  return params;
}
function axis$6(params) {
  var chart = params.chart, options = params.options;
  var xField = options.xField, xAxis = options.xAxis;
  chart.axis(xField, xAxis);
  return params;
}
function label$4(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, yField = options.yField;
  var intervalGeometry = findGeometry(chart, "interval");
  if (!label2) {
    intervalGeometry.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    intervalGeometry.label({
      fields: [yField],
      callback,
      cfg: __assign$1(__assign$1({}, transformLabel(cfg)), { type: "polar" })
    });
  }
  return params;
}
function adaptor$8(params) {
  return flow(pattern("barStyle"), geometry$7, meta$5, axis$6, coordinate$2, interaction$8, animation$5, theme$2, tooltip$9, legend$g, annotation$2(), label$4)(params);
}
var DEFAULT_OPTIONS$b = deepAssign({}, Plot.getDefaultOptions(), {
  interactions: [{ type: "element-active" }],
  legend: false,
  tooltip: {
    showMarkers: false
  },
  xAxis: {
    grid: null,
    tickLine: null,
    line: null
  },
  maxAngle: 240
});
(function(_super) {
  __extends$1(RadialBar, _super);
  function RadialBar() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "radial-bar";
    return _this;
  }
  RadialBar.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$b;
  };
  RadialBar.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    meta$5({ chart: this.chart, options: this.options });
    this.chart.changeData(data2);
  };
  RadialBar.prototype.getDefaultOptions = function() {
    return RadialBar.getDefaultOptions();
  };
  RadialBar.prototype.getSchemaAdaptor = function() {
    return adaptor$8;
  };
  return RadialBar;
})(Plot);
function geometry$6(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, sectorStyle = options.sectorStyle, shape = options.shape, color2 = options.color;
  chart.data(data2);
  flow(interval)(deepAssign({}, params, {
    options: {
      marginRatio: 1,
      interval: {
        style: sectorStyle,
        color: color2,
        shape
      }
    }
  }));
  return params;
}
function label$3(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, xField = options.xField;
  var geometry2 = findGeometry(chart, "interval");
  if (label2 === false) {
    geometry2.label(false);
  } else if (isObject(label2)) {
    var callback = label2.callback, fields = label2.fields, cfg = __rest(label2, ["callback", "fields"]);
    var offset = cfg.offset;
    var layout2 = cfg.layout;
    if (offset === void 0 || offset >= 0) {
      layout2 = layout2 ? isArray$1(layout2) ? layout2 : [layout2] : [];
      cfg.layout = filter(layout2, function(v) {
        return v.type !== "limit-in-shape";
      });
      cfg.layout.length || delete cfg.layout;
    }
    geometry2.label({
      fields: fields || [xField],
      callback,
      cfg: transformLabel(cfg)
    });
  } else {
    log(LEVEL.WARN, label2 === null, "the label option must be an Object.");
    geometry2.label({ fields: [xField] });
  }
  return params;
}
function legend$4(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (seriesField) {
    chart.legend(seriesField, legend2);
  }
  return params;
}
function coordinate$1(params) {
  var chart = params.chart, options = params.options;
  var radius = options.radius, innerRadius = options.innerRadius, startAngle = options.startAngle, endAngle = options.endAngle;
  chart.coordinate({
    type: "polar",
    cfg: {
      radius,
      innerRadius,
      startAngle,
      endAngle
    }
  });
  return params;
}
function meta$4(params) {
  var _a2;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2)))(params);
}
function axis$5(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (!xAxis) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (!yAxis) {
    chart.axis(yField, false);
  } else {
    chart.axis(yField, yAxis);
  }
  return params;
}
function adaptor$7(params) {
  flow(pattern("sectorStyle"), geometry$6, meta$4, label$3, coordinate$1, axis$5, legend$4, tooltip$9, interaction$8, animation$5, theme$2, annotation$2(), state)(params);
}
var DEFAULT_OPTIONS$a = deepAssign({}, Plot.getDefaultOptions(), {
  xAxis: false,
  yAxis: false,
  legend: {
    position: "right",
    radio: {}
  },
  sectorStyle: {
    stroke: "#fff",
    lineWidth: 1
  },
  label: {
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    shared: true,
    showMarkers: false
  },
  interactions: [{ type: "active-region" }]
});
(function(_super) {
  __extends$1(Rose, _super);
  function Rose() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "rose";
    return _this;
  }
  Rose.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$a;
  };
  Rose.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(data2);
  };
  Rose.prototype.getDefaultOptions = function() {
    return Rose.getDefaultOptions();
  };
  Rose.prototype.getSchemaAdaptor = function() {
    return adaptor$7;
  };
  return Rose;
})(Plot);
var X_FIELD$1 = "x";
var Y_FIELD$1 = "y";
var COLOR_FIELD = "name";
var NODES_VIEW_ID = "nodes";
var EDGES_VIEW_ID = "edges";
function getNodes(edges, sourceField, targetField) {
  var nodes = [];
  edges.forEach(function(e) {
    var source = e[sourceField];
    var target2 = e[targetField];
    if (!nodes.includes(source)) {
      nodes.push(source);
    }
    if (!nodes.includes(target2)) {
      nodes.push(target2);
    }
  });
  return nodes;
}
function getMatrix(edges, nodes, sourceField, targetField) {
  var graphMatrix = {};
  nodes.forEach(function(pre) {
    graphMatrix[pre] = {};
    nodes.forEach(function(next) {
      graphMatrix[pre][next] = 0;
    });
  });
  edges.forEach(function(edge2) {
    graphMatrix[edge2[sourceField]][edge2[targetField]] = 1;
  });
  return graphMatrix;
}
function cutoffCircle(edges, sourceField, targetField) {
  if (!isArray$1(edges))
    return [];
  var removedData = [];
  var nodes = getNodes(edges, sourceField, targetField);
  var graphMatrix = getMatrix(edges, nodes, sourceField, targetField);
  var visited = {};
  nodes.forEach(function(node) {
    visited[node] = 0;
  });
  function DFS(dfsNode) {
    visited[dfsNode] = 1;
    nodes.forEach(function(node) {
      if (graphMatrix[dfsNode][node] != 0) {
        if (visited[node] == 1) {
          removedData.push("".concat(dfsNode, "_").concat(node));
        } else if (visited[node] == -1) {
          return;
        } else {
          DFS(node);
        }
      }
    });
    visited[dfsNode] = -1;
  }
  nodes.forEach(function(node) {
    if (visited[node] == -1) {
      return;
    }
    DFS(node);
  });
  if (removedData.length !== 0) {
    console.warn("sankey data contains circle, ".concat(removedData.length, " records removed."), removedData);
  }
  return edges.filter(function(edge2) {
    return removedData.findIndex(function(i) {
      return i === "".concat(edge2[sourceField], "_").concat(edge2[targetField]);
    }) < 0;
  });
}
function targetDepth(d) {
  return d.target.depth;
}
function left(node) {
  return node.depth;
}
function right(node, n) {
  return n - 1 - node.height;
}
function justify(node, n) {
  return node.sourceLinks.length ? node.depth : n - 1;
}
function center(node) {
  return node.targetLinks.length ? node.depth : node.sourceLinks.length ? minBy(node.sourceLinks, targetDepth) - 1 : 0;
}
function constant(x) {
  return function() {
    return x;
  };
}
function sumBy(arr, func) {
  var r = 0;
  for (var i = 0; i < arr.length; i++) {
    r += func(arr[i]);
  }
  return r;
}
function maxValueBy(arr, func) {
  var r = -Infinity;
  for (var i = 0; i < arr.length; i++) {
    r = Math.max(func(arr[i]), r);
  }
  return r;
}
function minValueBy(arr, func) {
  var r = Infinity;
  for (var i = 0; i < arr.length; i++) {
    r = Math.min(func(arr[i]), r);
  }
  return r;
}
function ascendingSourceBreadth(a, b) {
  return ascendingBreadth(a.source, b.source) || a.index - b.index;
}
function ascendingTargetBreadth(a, b) {
  return ascendingBreadth(a.target, b.target) || a.index - b.index;
}
function ascendingBreadth(a, b) {
  return a.y0 - b.y0;
}
function value(d) {
  return d.value;
}
function defaultId(d) {
  return d.index;
}
function defaultNodes(graph) {
  return graph.nodes;
}
function defaultLinks(graph) {
  return graph.links;
}
function find(nodeById, id2) {
  var node = nodeById.get(id2);
  if (!node)
    throw new Error("missing: " + id2);
  return node;
}
function computeLinkBreadths(_a2) {
  var nodes = _a2.nodes;
  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {
    var node = nodes_1[_i];
    var y0 = node.y0;
    var y1 = y0;
    for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
      var link = _c[_b];
      link.y0 = y0 + link.width / 2;
      y0 += link.width;
    }
    for (var _d = 0, _e = node.targetLinks; _d < _e.length; _d++) {
      var link = _e[_d];
      link.y1 = y1 + link.width / 2;
      y1 += link.width;
    }
  }
}
function Sankey() {
  var x0 = 0, y0 = 0, x1 = 1, y1 = 1;
  var dx = 24;
  var dy = 8, py;
  var id2 = defaultId;
  var align = justify;
  var depth;
  var sort;
  var linkSort;
  var nodes = defaultNodes;
  var links = defaultLinks;
  var iterations = 6;
  function sankey(arg) {
    var graph = {
      nodes: nodes(arg),
      links: links(arg)
    };
    computeNodeLinks(graph);
    computeNodeValues(graph);
    computeNodeDepths(graph);
    computeNodeHeights(graph);
    computeNodeBreadths(graph);
    computeLinkBreadths(graph);
    return graph;
  }
  sankey.update = function(graph) {
    computeLinkBreadths(graph);
    return graph;
  };
  sankey.nodeId = function(_) {
    return arguments.length ? (id2 = typeof _ === "function" ? _ : constant(_), sankey) : id2;
  };
  sankey.nodeAlign = function(_) {
    return arguments.length ? (align = typeof _ === "function" ? _ : constant(_), sankey) : align;
  };
  sankey.nodeDepth = function(_) {
    return arguments.length ? (depth = typeof _ === "function" ? _ : _, sankey) : depth;
  };
  sankey.nodeSort = function(_) {
    return arguments.length ? (sort = _, sankey) : sort;
  };
  sankey.nodeWidth = function(_) {
    return arguments.length ? (dx = +_, sankey) : dx;
  };
  sankey.nodePadding = function(_) {
    return arguments.length ? (dy = py = +_, sankey) : dy;
  };
  sankey.nodes = function(_) {
    return arguments.length ? (nodes = typeof _ === "function" ? _ : constant(_), sankey) : nodes;
  };
  sankey.links = function(_) {
    return arguments.length ? (links = typeof _ === "function" ? _ : constant(_), sankey) : links;
  };
  sankey.linkSort = function(_) {
    return arguments.length ? (linkSort = _, sankey) : linkSort;
  };
  sankey.size = function(_) {
    return arguments.length ? (x0 = y0 = 0, x1 = +_[0], y1 = +_[1], sankey) : [x1 - x0, y1 - y0];
  };
  sankey.extent = function(_) {
    return arguments.length ? (x0 = +_[0][0], x1 = +_[1][0], y0 = +_[0][1], y1 = +_[1][1], sankey) : [
      [x0, y0],
      [x1, y1]
    ];
  };
  sankey.iterations = function(_) {
    return arguments.length ? (iterations = +_, sankey) : iterations;
  };
  function computeNodeLinks(_a2) {
    var nodes2 = _a2.nodes, links2 = _a2.links;
    nodes2.forEach(function(node, idx) {
      node.index = idx;
      node.sourceLinks = [];
      node.targetLinks = [];
    });
    var nodeById = new Map(nodes2.map(function(d) {
      return [id2(d), d];
    }));
    links2.forEach(function(link, idx) {
      link.index = idx;
      var source = link.source, target2 = link.target;
      if (typeof source !== "object")
        source = link.source = find(nodeById, source);
      if (typeof target2 !== "object")
        target2 = link.target = find(nodeById, target2);
      source.sourceLinks.push(link);
      target2.targetLinks.push(link);
    });
    if (linkSort != null) {
      for (var _i = 0, nodes_2 = nodes2; _i < nodes_2.length; _i++) {
        var _b = nodes_2[_i], sourceLinks = _b.sourceLinks, targetLinks = _b.targetLinks;
        sourceLinks.sort(linkSort);
        targetLinks.sort(linkSort);
      }
    }
  }
  function computeNodeValues(_a2) {
    var nodes2 = _a2.nodes;
    for (var _i = 0, nodes_3 = nodes2; _i < nodes_3.length; _i++) {
      var node = nodes_3[_i];
      node.value = node.fixedValue === void 0 ? Math.max(sumBy(node.sourceLinks, value), sumBy(node.targetLinks, value)) : node.fixedValue;
    }
  }
  function computeNodeDepths(_a2) {
    var nodes2 = _a2.nodes;
    var n = nodes2.length;
    var current = new Set(nodes2);
    var next = /* @__PURE__ */ new Set();
    var x = 0;
    while (current.size) {
      current.forEach(function(node2) {
        node2.depth = x;
        for (var _i = 0, _a3 = node2.sourceLinks; _i < _a3.length; _i++) {
          var target2 = _a3[_i].target;
          next.add(target2);
        }
      });
      if (++x > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
    if (depth) {
      var maxDepth = Math.max(maxValueBy(nodes2, function(d) {
        return d.depth;
      }) + 1, 0);
      var node = void 0;
      for (var i = 0; i < nodes2.length; i++) {
        node = nodes2[i];
        node.depth = depth.call(null, node, maxDepth);
      }
    }
  }
  function computeNodeHeights(_a2) {
    var nodes2 = _a2.nodes;
    var n = nodes2.length;
    var current = new Set(nodes2);
    var next = /* @__PURE__ */ new Set();
    var x = 0;
    while (current.size) {
      current.forEach(function(node) {
        node.height = x;
        for (var _i = 0, _a3 = node.targetLinks; _i < _a3.length; _i++) {
          var source = _a3[_i].source;
          next.add(source);
        }
      });
      if (++x > n)
        throw new Error("circular link");
      current = next;
      next = /* @__PURE__ */ new Set();
    }
  }
  function computeNodeLayers(_a2) {
    var nodes2 = _a2.nodes;
    var x = Math.max(maxValueBy(nodes2, function(d) {
      return d.depth;
    }) + 1, 0);
    var kx = (x1 - x0 - dx) / (x - 1);
    var columns = new Array(x).fill(0).map(function() {
      return [];
    });
    for (var _i = 0, nodes_4 = nodes2; _i < nodes_4.length; _i++) {
      var node = nodes_4[_i];
      var i = Math.max(0, Math.min(x - 1, Math.floor(align.call(null, node, x))));
      node.layer = i;
      node.x0 = x0 + i * kx;
      node.x1 = node.x0 + dx;
      if (columns[i])
        columns[i].push(node);
      else
        columns[i] = [node];
    }
    if (sort)
      for (var _b = 0, columns_1 = columns; _b < columns_1.length; _b++) {
        var column = columns_1[_b];
        column.sort(sort);
      }
    return columns;
  }
  function initializeNodeBreadths(columns) {
    var ky = minValueBy(columns, function(c) {
      return (y1 - y0 - (c.length - 1) * py) / sumBy(c, value);
    });
    for (var _i = 0, columns_2 = columns; _i < columns_2.length; _i++) {
      var nodes_6 = columns_2[_i];
      var y = y0;
      for (var _a2 = 0, nodes_5 = nodes_6; _a2 < nodes_5.length; _a2++) {
        var node = nodes_5[_a2];
        node.y0 = y;
        node.y1 = y + node.value * ky;
        y = node.y1 + py;
        for (var _b = 0, _c = node.sourceLinks; _b < _c.length; _b++) {
          var link = _c[_b];
          link.width = link.value * ky;
        }
      }
      y = (y1 - y + py) / (nodes_6.length + 1);
      for (var i = 0; i < nodes_6.length; ++i) {
        var node = nodes_6[i];
        node.y0 += y * (i + 1);
        node.y1 += y * (i + 1);
      }
      reorderLinks(nodes_6);
    }
  }
  function computeNodeBreadths(graph) {
    var columns = computeNodeLayers(graph);
    py = Math.min(dy, (y1 - y0) / (maxValueBy(columns, function(c) {
      return c.length;
    }) - 1));
    initializeNodeBreadths(columns);
    for (var i = 0; i < iterations; ++i) {
      var alpha = Math.pow(0.99, i);
      var beta = Math.max(1 - alpha, (i + 1) / iterations);
      relaxRightToLeft(columns, alpha, beta);
      relaxLeftToRight(columns, alpha, beta);
    }
  }
  function relaxLeftToRight(columns, alpha, beta) {
    for (var i = 1, n = columns.length; i < n; ++i) {
      var column = columns[i];
      for (var _i = 0, column_1 = column; _i < column_1.length; _i++) {
        var target2 = column_1[_i];
        var y = 0;
        var w = 0;
        for (var _a2 = 0, _b = target2.targetLinks; _a2 < _b.length; _a2++) {
          var _c = _b[_a2], source = _c.source, value_1 = _c.value;
          var v = value_1 * (target2.layer - source.layer);
          y += targetTop(source, target2) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        var dy_1 = (y / w - target2.y0) * alpha;
        target2.y0 += dy_1;
        target2.y1 += dy_1;
        reorderNodeLinks(target2);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function relaxRightToLeft(columns, alpha, beta) {
    for (var n = columns.length, i = n - 2; i >= 0; --i) {
      var column = columns[i];
      for (var _i = 0, column_2 = column; _i < column_2.length; _i++) {
        var source = column_2[_i];
        var y = 0;
        var w = 0;
        for (var _a2 = 0, _b = source.sourceLinks; _a2 < _b.length; _a2++) {
          var _c = _b[_a2], target2 = _c.target, value_2 = _c.value;
          var v = value_2 * (target2.layer - source.layer);
          y += sourceTop(source, target2) * v;
          w += v;
        }
        if (!(w > 0))
          continue;
        var dy_2 = (y / w - source.y0) * alpha;
        source.y0 += dy_2;
        source.y1 += dy_2;
        reorderNodeLinks(source);
      }
      if (sort === void 0)
        column.sort(ascendingBreadth);
      if (column.length)
        resolveCollisions(column, beta);
    }
  }
  function resolveCollisions(nodes2, alpha) {
    var i = nodes2.length >> 1;
    var subject = nodes2[i];
    resolveCollisionsBottomToTop(nodes2, subject.y0 - py, i - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, subject.y1 + py, i + 1, alpha);
    resolveCollisionsBottomToTop(nodes2, y1, nodes2.length - 1, alpha);
    resolveCollisionsTopToBottom(nodes2, y0, 0, alpha);
  }
  function resolveCollisionsTopToBottom(nodes2, y, i, alpha) {
    for (; i < nodes2.length; ++i) {
      var node = nodes2[i];
      var dy_3 = (y - node.y0) * alpha;
      if (dy_3 > 1e-6)
        node.y0 += dy_3, node.y1 += dy_3;
      y = node.y1 + py;
    }
  }
  function resolveCollisionsBottomToTop(nodes2, y, i, alpha) {
    for (; i >= 0; --i) {
      var node = nodes2[i];
      var dy_4 = (node.y1 - y) * alpha;
      if (dy_4 > 1e-6)
        node.y0 -= dy_4, node.y1 -= dy_4;
      y = node.y0 - py;
    }
  }
  function reorderNodeLinks(_a2) {
    var sourceLinks = _a2.sourceLinks, targetLinks = _a2.targetLinks;
    if (linkSort === void 0) {
      for (var _i = 0, targetLinks_1 = targetLinks; _i < targetLinks_1.length; _i++) {
        var sourceLinks_2 = targetLinks_1[_i].source.sourceLinks;
        sourceLinks_2.sort(ascendingTargetBreadth);
      }
      for (var _b = 0, sourceLinks_1 = sourceLinks; _b < sourceLinks_1.length; _b++) {
        var targetLinks_2 = sourceLinks_1[_b].target.targetLinks;
        targetLinks_2.sort(ascendingSourceBreadth);
      }
    }
  }
  function reorderLinks(nodes2) {
    if (linkSort === void 0) {
      for (var _i = 0, nodes_7 = nodes2; _i < nodes_7.length; _i++) {
        var _a2 = nodes_7[_i], sourceLinks = _a2.sourceLinks, targetLinks = _a2.targetLinks;
        sourceLinks.sort(ascendingTargetBreadth);
        targetLinks.sort(ascendingSourceBreadth);
      }
    }
  }
  function targetTop(source, target2) {
    var y = source.y0 - (source.sourceLinks.length - 1) * py / 2;
    for (var _i = 0, _a2 = source.sourceLinks; _i < _a2.length; _i++) {
      var _b = _a2[_i], node = _b.target, width = _b.width;
      if (node === target2)
        break;
      y += width + py;
    }
    for (var _c = 0, _d = target2.targetLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.source, width = _e.width;
      if (node === source)
        break;
      y -= width;
    }
    return y;
  }
  function sourceTop(source, target2) {
    var y = target2.y0 - (target2.targetLinks.length - 1) * py / 2;
    for (var _i = 0, _a2 = target2.targetLinks; _i < _a2.length; _i++) {
      var _b = _a2[_i], node = _b.source, width = _b.width;
      if (node === source)
        break;
      y += width + py;
    }
    for (var _c = 0, _d = source.sourceLinks; _c < _d.length; _c++) {
      var _e = _d[_c], node = _e.target, width = _e.width;
      if (node === target2)
        break;
      y -= width;
    }
    return y;
  }
  return sankey;
}
var ALIGN_METHOD = {
  left,
  right,
  center,
  justify
};
var DEFAULT_OPTIONS$9 = {
  nodeId: function(node) {
    return node.index;
  },
  nodeAlign: "justify",
  nodeWidth: 8e-3,
  nodePadding: 0.03,
  nodeSort: void 0
};
function getNodeAlignFunction(nodeAlign) {
  var func = isString(nodeAlign) ? ALIGN_METHOD[nodeAlign] : isFunction(nodeAlign) ? nodeAlign : null;
  return func || justify;
}
function getDefaultOptions(sankeyLayoutOptions) {
  return mix({}, DEFAULT_OPTIONS$9, sankeyLayoutOptions);
}
function sankeyLayout(sankeyLayoutOptions, data2) {
  var options = getDefaultOptions(sankeyLayoutOptions);
  var nodeId = options.nodeId, nodeSort = options.nodeSort, nodeAlign = options.nodeAlign, nodeWidth = options.nodeWidth, nodePadding = options.nodePadding, nodeDepth = options.nodeDepth;
  var sankeyProcessor = Sankey().nodeSort(nodeSort).nodeWidth(nodeWidth).nodePadding(nodePadding).nodeDepth(nodeDepth).nodeAlign(getNodeAlignFunction(nodeAlign)).extent([
    [0, 0],
    [1, 1]
  ]).nodeId(nodeId);
  var layoutData = sankeyProcessor(data2);
  var nodes = layoutData.nodes.map(function(node) {
    var x0 = node.x0, x1 = node.x1, y0 = node.y0, y1 = node.y1;
    node.x = [x0, x1, x1, x0];
    node.y = [y0, y0, y1, y1];
    return node;
  }).filter(function(node) {
    return node.name !== null;
  });
  var links = layoutData.links.map(function(edge2) {
    var source = edge2.source, target2 = edge2.target;
    var sx = source.x1;
    var tx = target2.x0;
    edge2.x = [sx, sx, tx, tx];
    var offset = edge2.width / 2;
    edge2.y = [edge2.y0 + offset, edge2.y0 - offset, edge2.y1 + offset, edge2.y1 - offset];
    return edge2;
  }).filter(function(edge2) {
    var source = edge2.source, target2 = edge2.target;
    return source.name !== null && target2.name !== null;
  });
  return { nodes, links };
}
function isNodeLink(dataType) {
  return dataType === "node-link";
}
function getNodeWidthRatio(nodeWidth, nodeWidthRatio, width) {
  return isRealNumber(nodeWidth) ? nodeWidth / width : nodeWidthRatio;
}
function getNodePaddingRatio(nodePadding, nodePaddingRatio, height) {
  return isRealNumber(nodePadding) ? nodePadding / height : nodePaddingRatio;
}
function transformToViewsData(options, width, height) {
  var dataType = options.dataType, data2 = options.data, sourceField = options.sourceField, targetField = options.targetField, weightField = options.weightField, nodeAlign = options.nodeAlign, nodeSort = options.nodeSort, nodePadding = options.nodePadding, nodePaddingRatio = options.nodePaddingRatio, nodeWidth = options.nodeWidth, nodeWidthRatio = options.nodeWidthRatio, nodeDepth = options.nodeDepth, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  var sankeyLayoutInputData;
  if (!isNodeLink(dataType)) {
    sankeyLayoutInputData = transformDataToNodeLinkData(cutoffCircle(data2, sourceField, targetField), sourceField, targetField, weightField, rawFields);
  } else {
    sankeyLayoutInputData = data2;
  }
  var _b = sankeyLayout({
    nodeAlign,
    nodePadding: getNodePaddingRatio(nodePadding, nodePaddingRatio, height),
    nodeWidth: getNodeWidthRatio(nodeWidth, nodeWidthRatio, width),
    nodeSort,
    nodeDepth
  }, sankeyLayoutInputData), nodes = _b.nodes, links = _b.links;
  return {
    nodes: nodes.map(function(node) {
      return __assign$1(__assign$1({}, pick(node, __spreadArray$1(["x", "y", "name"], rawFields, true))), { isNode: true });
    }),
    edges: links.map(function(link) {
      return __assign$1(__assign$1({ source: link.source.name, target: link.target.name, name: link.source.name || link.target.name }, pick(link, __spreadArray$1(["x", "y", "value"], rawFields, true))), { isNode: false });
    })
  };
}
function defaultOptions$2(params) {
  var options = params.options;
  var _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  return deepAssign({}, {
    options: {
      tooltip: {
        fields: uniq$2(__spreadArray$1(["name", "source", "target", "value", "isNode"], rawFields, true))
      },
      label: {
        fields: uniq$2(__spreadArray$1(["x", "name"], rawFields, true))
      }
    }
  }, params);
}
function geometry$5(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, nodeStyle = options.nodeStyle, edgeStyle = options.edgeStyle, label2 = options.label, tooltip2 = options.tooltip, nodeState = options.nodeState, edgeState = options.edgeState, _a2 = options.rawFields, rawFields = _a2 === void 0 ? [] : _a2;
  chart.legend(false);
  chart.tooltip(tooltip2);
  chart.axis(false);
  chart.coordinate().reflect("y");
  var _b = transformToViewsData(options, chart.width, chart.height), nodes = _b.nodes, edges = _b.edges;
  var edgeView = chart.createView({ id: EDGES_VIEW_ID });
  edgeView.data(edges);
  edge({
    chart: edgeView,
    // @ts-ignore
    options: {
      xField: X_FIELD$1,
      yField: Y_FIELD$1,
      seriesField: COLOR_FIELD,
      rawFields: __spreadArray$1(["source", "target"], rawFields, true),
      edge: {
        color: color2,
        style: edgeStyle,
        shape: "arc"
      },
      tooltip: tooltip2,
      state: edgeState
    }
  });
  var nodeView = chart.createView({ id: NODES_VIEW_ID });
  nodeView.data(nodes);
  polygon({
    chart: nodeView,
    options: {
      xField: X_FIELD$1,
      yField: Y_FIELD$1,
      seriesField: COLOR_FIELD,
      polygon: {
        color: color2,
        style: nodeStyle
      },
      label: label2,
      tooltip: tooltip2,
      state: nodeState
    }
  });
  chart.interaction("element-active");
  chart.scale({
    x: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    y: { sync: true, nice: true, min: 0, max: 1, minLimit: 0, maxLimit: 1 },
    name: { sync: "color", type: "cat" }
  });
  return params;
}
function animation$1(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  var geometries = __spreadArray$1(__spreadArray$1([], chart.views[0].geometries, true), chart.views[1].geometries, true);
  addViewAnimation(chart, animation2, geometries);
  return params;
}
function nodeDraggable(params) {
  var chart = params.chart, options = params.options;
  var nodeDraggable2 = options.nodeDraggable;
  var DRAG_INTERACTION = "sankey-node-draggable";
  if (nodeDraggable2) {
    chart.interaction(DRAG_INTERACTION);
  } else {
    chart.removeInteraction(DRAG_INTERACTION);
  }
  return params;
}
function interaction$2(params) {
  var chart = params.chart, options = params.options;
  var _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  var nodeInteractions = [].concat(interactions, options.nodeInteractions || []);
  var edgeInteractions = [].concat(interactions, options.edgeInteractions || []);
  var nodeView = findViewById(chart, NODES_VIEW_ID);
  var edgeView = findViewById(chart, EDGES_VIEW_ID);
  nodeInteractions.forEach(function(i) {
    if ((i === null || i === void 0 ? void 0 : i.enable) === false) {
      nodeView.removeInteraction(i.type);
    } else {
      nodeView.interaction(i.type, i.cfg || {});
    }
  });
  edgeInteractions.forEach(function(i) {
    if ((i === null || i === void 0 ? void 0 : i.enable) === false) {
      edgeView.removeInteraction(i.type);
    } else {
      edgeView.interaction(i.type, i.cfg || {});
    }
  });
  return params;
}
function adaptor$6(params) {
  return flow(
    defaultOptions$2,
    geometry$5,
    interaction$2,
    nodeDraggable,
    animation$1,
    theme$2
    // ...  adaptor flow
  )(params);
}
var SankeyNodeDragAction = (
  /** @class */
  function(_super) {
    __extends$1(SankeyNodeDragAction2, _super);
    function SankeyNodeDragAction2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.isDragging = false;
      return _this;
    }
    SankeyNodeDragAction2.prototype.isNodeElement = function() {
      var shape = get(this.context, "event.target");
      if (shape) {
        var element = shape.get("element");
        return element && element.getModel().data.isNode;
      }
      return false;
    };
    SankeyNodeDragAction2.prototype.getNodeView = function() {
      return findViewById(this.context.view, NODES_VIEW_ID);
    };
    SankeyNodeDragAction2.prototype.getEdgeView = function() {
      return findViewById(this.context.view, EDGES_VIEW_ID);
    };
    SankeyNodeDragAction2.prototype.getCurrentDatumIdx = function(element) {
      return this.getNodeView().geometries[0].elements.indexOf(element);
    };
    SankeyNodeDragAction2.prototype.start = function() {
      if (this.isNodeElement()) {
        this.prevPoint = {
          x: get(this.context, "event.x"),
          y: get(this.context, "event.y")
        };
        var element = this.context.event.target.get("element");
        var idx = this.getCurrentDatumIdx(element);
        if (idx === -1) {
          return;
        }
        this.currentElementIdx = idx;
        this.context.isDragging = true;
        this.isDragging = true;
        this.prevNodeAnimateCfg = this.getNodeView().getOptions().animate;
        this.prevEdgeAnimateCfg = this.getEdgeView().getOptions().animate;
        this.getNodeView().animate(false);
        this.getEdgeView().animate(false);
      }
    };
    SankeyNodeDragAction2.prototype.translate = function() {
      if (this.isDragging) {
        var chart = this.context.view;
        var currentPoint = {
          x: get(this.context, "event.x"),
          y: get(this.context, "event.y")
        };
        var x = currentPoint.x - this.prevPoint.x;
        var y = currentPoint.y - this.prevPoint.y;
        var nodeView = this.getNodeView();
        var element = nodeView.geometries[0].elements[this.currentElementIdx];
        if (element && element.getModel()) {
          var prevDatum = element.getModel().data;
          var data2 = nodeView.getOptions().data;
          var coordinate2 = nodeView.getCoordinate();
          var datumGap_1 = {
            x: x / coordinate2.getWidth(),
            y: y / coordinate2.getHeight()
          };
          var nextDatum = __assign$1(__assign$1({}, prevDatum), { x: prevDatum.x.map(function(x2) {
            return x2 += datumGap_1.x;
          }), y: prevDatum.y.map(function(y2) {
            return y2 += datumGap_1.y;
          }) });
          var newData = __spreadArray$1([], data2, true);
          newData[this.currentElementIdx] = nextDatum;
          nodeView.data(newData);
          var name_1 = prevDatum.name;
          var edgeView = this.getEdgeView();
          var edgeData = edgeView.getOptions().data;
          edgeData.forEach(function(datum) {
            if (datum.source === name_1) {
              datum.x[0] += datumGap_1.x;
              datum.x[1] += datumGap_1.x;
              datum.y[0] += datumGap_1.y;
              datum.y[1] += datumGap_1.y;
            }
            if (datum.target === name_1) {
              datum.x[2] += datumGap_1.x;
              datum.x[3] += datumGap_1.x;
              datum.y[2] += datumGap_1.y;
              datum.y[3] += datumGap_1.y;
            }
          });
          edgeView.data(edgeData);
          this.prevPoint = currentPoint;
          chart.render(true);
        }
      }
    };
    SankeyNodeDragAction2.prototype.end = function() {
      this.isDragging = false;
      this.context.isDragging = false;
      this.prevPoint = null;
      this.currentElementIdx = null;
      this.getNodeView().animate(this.prevNodeAnimateCfg);
      this.getEdgeView().animate(this.prevEdgeAnimateCfg);
    };
    return SankeyNodeDragAction2;
  }(Action)
);
registerAction("sankey-node-drag", SankeyNodeDragAction);
registerInteraction("sankey-node-draggable", {
  showEnable: [
    { trigger: "polygon:mouseenter", action: "cursor:pointer" },
    { trigger: "polygon:mouseleave", action: "cursor:default" }
  ],
  start: [{ trigger: "polygon:mousedown", action: "sankey-node-drag:start" }],
  processing: [
    { trigger: "plot:mousemove", action: "sankey-node-drag:translate" },
    { isEnable: function(context) {
      return context.isDragging;
    }, trigger: "plot:mousemove", action: "cursor:move" }
  ],
  end: [{ trigger: "plot:mouseup", action: "sankey-node-drag:end" }]
});
(function(_super) {
  __extends$1(Sankey2, _super);
  function Sankey2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "sankey";
    return _this;
  }
  Sankey2.getDefaultOptions = function() {
    return {
      appendPadding: 8,
      syncViewPadding: true,
      nodeStyle: {
        opacity: 1,
        fillOpacity: 1,
        lineWidth: 1
      },
      edgeStyle: {
        opacity: 0.3,
        lineWidth: 0
      },
      edgeState: {
        active: {
          style: {
            opacity: 0.8,
            lineWidth: 0
          }
        }
      },
      label: {
        formatter: function(_a2) {
          var name = _a2.name;
          return name;
        },
        callback: function(x) {
          var isLast = x[1] === 1;
          return {
            style: {
              fill: "#545454",
              textAlign: isLast ? "end" : "start"
            },
            offsetX: isLast ? -8 : 8
          };
        },
        layout: [
          {
            type: "hide-overlap"
          }
        ]
      },
      tooltip: {
        showTitle: false,
        showMarkers: false,
        shared: false,
        // node  tooltipedge  tooltip
        showContent: function(items) {
          return !get(items, [0, "data", "isNode"]);
        },
        formatter: function(datum) {
          var source = datum.source, target2 = datum.target, value2 = datum.value;
          return {
            name: source + " -> " + target2,
            value: value2
          };
        }
      },
      nodeWidthRatio: 8e-3,
      nodePaddingRatio: 0.01,
      animation: {
        appear: {
          animation: "wave-in"
        },
        enter: {
          animation: "wave-in"
        }
      }
    };
  };
  Sankey2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    var _a2 = transformToViewsData(this.options, this.chart.width, this.chart.height), nodes = _a2.nodes, edges = _a2.edges;
    var nodesView = findViewById(this.chart, NODES_VIEW_ID);
    var edgesView = findViewById(this.chart, EDGES_VIEW_ID);
    nodesView.changeData(nodes);
    edgesView.changeData(edges);
  };
  Sankey2.prototype.getSchemaAdaptor = function() {
    return adaptor$6;
  };
  Sankey2.prototype.getDefaultOptions = function() {
    return Sankey2.getDefaultOptions();
  };
  return Sankey2;
})(Plot);
var SUNBURST_ANCESTOR_FIELD = "ancestor-node";
var SUNBURST_Y_FIELD = "value";
var SUNBURST_PATH_FIELD = "path";
var RAW_FIELDS = [
  SUNBURST_PATH_FIELD,
  NODE_INDEX_FIELD,
  NODE_ANCESTORS_FIELD,
  CHILD_NODE_COUNT,
  "name",
  "depth",
  "height"
];
var DEFAULT_OPTIONS$8 = deepAssign({}, Plot.getDefaultOptions(), {
  innerRadius: 0,
  radius: 0.85,
  // 
  hierarchyConfig: {
    //  value
    field: "value"
  },
  // 
  tooltip: {
    shared: true,
    showMarkers: false,
    offset: 20,
    showTitle: false
  },
  legend: false,
  // 
  sunburstStyle: {
    lineWidth: 0.5,
    stroke: "#FFF"
  },
  // 
  drilldown: { enabled: true }
});
var DEFAULT_OPTIONS$7 = {
  field: "value",
  size: [1, 1],
  round: false,
  padding: 0,
  // 
  sort: function(a, b) {
    return b.value - a.value;
  },
  as: ["x", "y"],
  //  parentValue,  true 
  ignoreParentValue: true
};
function partition(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$7, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var partition2 = function(data3) {
    return partition$1().size(options.size).round(options.round).padding(options.padding)(
      /**
       * d3Hierarchy  sum  node  node  post-order traversal  value  node
       * for example:
       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
       * parent  sum(node(parent)) + sum(node(child1)) + sum(node(child2))
       * sum d  data, children 
       */
      hierarchy(data3).sum(function(d) {
        return size(d.children) ? options.ignoreParentValue ? 0 : d[field2] - reduce(d.children, function(a, b) {
          return a + b[field2];
        }, 0) : d[field2];
      }).sort(options.sort)
    );
  };
  var root = partition2(data2);
  var x = as[0];
  var y = as[1];
  root.each(function(node) {
    var _a2, _b;
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    node.name = node.name || ((_a2 = node.data) === null || _a2 === void 0 ? void 0 : _a2.name) || ((_b = node.data) === null || _b === void 0 ? void 0 : _b.label);
    node.data.name = node.name;
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root);
}
var DEFAULT_OPTIONS$6 = {
  field: "value",
  tile: "treemapSquarify",
  size: [1, 1],
  round: false,
  ignoreParentValue: true,
  padding: 0,
  paddingInner: 0,
  paddingOuter: 0,
  paddingTop: 0,
  paddingRight: 0,
  paddingBottom: 0,
  paddingLeft: 0,
  as: ["x", "y"],
  // 
  sort: function(a, b) {
    return b.value - a.value;
  },
  // , treemapSquarify 
  ratio: 0.5 * (1 + Math.sqrt(5))
};
function getTileMethod(tile, ratio) {
  return tile === "treemapSquarify" ? d3Hierarchy[tile].ratio(ratio) : d3Hierarchy[tile];
}
function treemap(data2, options) {
  options = mix({}, DEFAULT_OPTIONS$6, options);
  var as = options.as;
  if (!isArray$1(as) || as.length !== 2) {
    throw new TypeError('Invalid as: it must be an array with 2 strings (e.g. [ "x", "y" ])!');
  }
  var field2;
  try {
    field2 = getField(options);
  } catch (e) {
    console.warn(e);
  }
  var tileMethod = getTileMethod(options.tile, options.ratio);
  var partition2 = function(data3) {
    return index().tile(tileMethod).size(options.size).round(options.round).padding(options.padding).paddingInner(options.paddingInner).paddingOuter(options.paddingOuter).paddingTop(options.paddingTop).paddingRight(options.paddingRight).paddingBottom(options.paddingBottom).paddingLeft(options.paddingLeft)(
      /**
       * d3Hierarchy  sum  node  node  post-order traversal  value  node
       * for example:
       * { node: 'parent', value: 10, children: [{node: 'child1', value: 5}, {node: 'child2', value: 5}, ]}
       * parent  sum(node(parent)) + sum(node(child1)) + sum(node(child2))
       * ignoreParentValue  true()  0 + 5 + 5 = 10
       * ignoreParentValue  false   10 + 5 + 5 = 20
       * sum d  data, children 
       */
      hierarchy(data3).sum(function(d) {
        return options.ignoreParentValue && d.children ? 0 : d[field2];
      }).sort(options.sort)
    );
  };
  var root = partition2(data2);
  var x = as[0];
  var y = as[1];
  root.each(function(node) {
    node[x] = [node.x0, node.x1, node.x1, node.x0];
    node[y] = [node.y1, node.y1, node.y0, node.y0];
    ["x0", "x1", "y0", "y1"].forEach(function(prop) {
      if (as.indexOf(prop) === -1) {
        delete node[prop];
      }
    });
  });
  return getAllNodes(root);
}
function transformData$2(options) {
  var data2 = options.data, colorField = options.colorField, rawFields = options.rawFields, _a2 = options.hierarchyConfig, hierarchyConfig = _a2 === void 0 ? {} : _a2;
  var activeDepth = hierarchyConfig.activeDepth;
  var transform2 = {
    partition,
    treemap
  };
  var seriesField = options.seriesField;
  var type = options.type || "partition";
  var nodes = transform2[type](data2, __assign$1(__assign$1({ field: seriesField || "value" }, omit$1(hierarchyConfig, ["activeDepth"])), {
    // @ts-ignore
    type: "hierarchy.".concat(type),
    as: ["x", "y"]
  }));
  var result = [];
  nodes.forEach(function(node) {
    var _a3;
    var _b, _c, _d, _e, _f;
    if (node.depth === 0) {
      return null;
    }
    if (activeDepth > 0 && node.depth > activeDepth) {
      return null;
    }
    var path2 = node.data.name;
    var ancestorNode = __assign$1({}, node);
    while (ancestorNode.depth > 1) {
      path2 = "".concat((_b = ancestorNode.parent.data) === null || _b === void 0 ? void 0 : _b.name, " / ").concat(path2);
      ancestorNode = ancestorNode.parent;
    }
    var nodeInfo = __assign$1(__assign$1(__assign$1({}, pick(node.data, __spreadArray$1(__spreadArray$1([], rawFields || [], true), [hierarchyConfig.field], false))), (_a3 = {}, _a3[SUNBURST_PATH_FIELD] = path2, _a3[SUNBURST_ANCESTOR_FIELD] = ancestorNode.data.name, _a3)), node);
    if (seriesField) {
      nodeInfo[seriesField] = node.data[seriesField] || ((_d = (_c = node.parent) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d[seriesField]);
    }
    if (colorField) {
      nodeInfo[colorField] = node.data[colorField] || ((_f = (_e = node.parent) === null || _e === void 0 ? void 0 : _e.data) === null || _f === void 0 ? void 0 : _f[colorField]);
    }
    nodeInfo.ext = hierarchyConfig;
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, rawFields };
    result.push(nodeInfo);
  });
  return result;
}
function geometry$4(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, _a2 = options.colorField, colorField = _a2 === void 0 ? SUNBURST_ANCESTOR_FIELD : _a2, sunburstStyle = options.sunburstStyle, _b = options.rawFields, rawFields = _b === void 0 ? [] : _b, shape = options.shape;
  var data2 = transformData$2(options);
  chart.data(data2);
  var style;
  if (sunburstStyle) {
    style = function(datum) {
      return deepAssign({}, {
        fillOpacity: Math.pow(0.85, datum.depth)
      }, isFunction(sunburstStyle) ? sunburstStyle(datum) : sunburstStyle);
    };
  }
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields: uniq$2(__spreadArray$1(__spreadArray$1([], RAW_FIELDS, true), rawFields, true)),
      polygon: {
        color: color2,
        style,
        shape
      }
    }
  }));
  return params;
}
function axis$4(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function label$2(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var geometry2 = findGeometry(chart, "polygon");
  if (!label2) {
    geometry2.label(false);
  } else {
    var _a2 = label2.fields, fields = _a2 === void 0 ? ["name"] : _a2, callback = label2.callback, cfg = __rest(label2, ["fields", "callback"]);
    geometry2.label({
      fields,
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function coordinate(params) {
  var chart = params.chart, options = params.options;
  var innerRadius = options.innerRadius, radius = options.radius, reflect = options.reflect;
  var coord2 = chart.coordinate({
    type: "polar",
    cfg: {
      innerRadius,
      radius
    }
  });
  if (reflect) {
    coord2.reflect(reflect);
  }
  return params;
}
function meta$3(params) {
  var _a2;
  var options = params.options;
  var hierarchyConfig = options.hierarchyConfig, meta2 = options.meta;
  return flow(scale$2({}, (_a2 = {}, _a2[SUNBURST_Y_FIELD] = get(meta2, get(hierarchyConfig, ["field"], "value")), _a2)))(params);
}
function tooltip$1(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip;
  if (tooltip2 === false) {
    chart.tooltip(false);
  } else {
    var tooltipOptions = tooltip2;
    if (!get(tooltip2, "fields")) {
      tooltipOptions = deepAssign({}, {
        customItems: function(items) {
          return items.map(function(item) {
            var scales = get(chart.getOptions(), "scales");
            var pathFormatter = get(scales, [SUNBURST_PATH_FIELD, "formatter"], function(v) {
              return v;
            });
            var valueFormatter = get(scales, [SUNBURST_Y_FIELD, "formatter"], function(v) {
              return v;
            });
            return __assign$1(__assign$1({}, item), { name: pathFormatter(item.data[SUNBURST_PATH_FIELD]), value: valueFormatter(item.data.value) });
          });
        }
      }, tooltipOptions);
    }
    chart.tooltip(tooltipOptions);
  }
  return params;
}
function adaptorInteraction$1(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    return deepAssign({}, options, {
      interactions: __spreadArray$1(__spreadArray$1([], interactions, true), [
        {
          type: "drill-down",
          cfg: { drillDownConfig: drilldown, transformData: transformData$2 }
        }
      ], false)
    });
  }
  return options;
}
function interaction$1(params) {
  var chart = params.chart, options = params.options;
  var drilldown = options.drilldown;
  interaction$8({
    chart,
    options: adaptorInteraction$1(options)
  });
  if (drilldown === null || drilldown === void 0 ? void 0 : drilldown.enabled) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor$5(params) {
  return flow(theme$2, pattern("sunburstStyle"), geometry$4, axis$4, meta$3, legend$g, coordinate, tooltip$1, label$2, interaction$1, animation$5, annotation$2())(params);
}
(function(_super) {
  __extends$1(Sunburst, _super);
  function Sunburst() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "sunburst";
    return _this;
  }
  Sunburst.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$8;
  };
  Sunburst.prototype.getDefaultOptions = function() {
    return Sunburst.getDefaultOptions();
  };
  Sunburst.prototype.getSchemaAdaptor = function() {
    return adaptor$5;
  };
  Sunburst.SUNBURST_ANCESTOR_FIELD = SUNBURST_ANCESTOR_FIELD;
  Sunburst.SUNBURST_PATH_FIELD = SUNBURST_PATH_FIELD;
  Sunburst.NODE_ANCESTORS_FIELD = NODE_ANCESTORS_FIELD;
  return Sunburst;
})(Plot);
function findInteraction(interactions, interactionType) {
  if (!isArray$1(interactions))
    return void 0;
  return interactions.find(function(i) {
    return i.type === interactionType;
  });
}
function enableInteraction(interactions, interactionType) {
  var interaction2 = findInteraction(interactions, interactionType);
  return interaction2 && interaction2.enable !== false;
}
function enableDrillInteraction(options) {
  var interactions = options.interactions, drilldown = options.drilldown;
  return get(drilldown, "enabled") || enableInteraction(interactions, "treemap-drill-down");
}
function resetDrillDown(chart) {
  var drillDownInteraction = chart.interactions["drill-down"];
  if (!drillDownInteraction)
    return;
  var drillDownAction = drillDownInteraction.context.actions.find(function(i) {
    return i.name === "drill-down-action";
  });
  drillDownAction.reset();
}
function transformData$1(options) {
  var data2 = options.data, colorField = options.colorField, enableDrillDown = options.enableDrillDown, hierarchyConfig = options.hierarchyConfig;
  var nodes = treemap(data2, __assign$1(__assign$1({}, hierarchyConfig), {
    // @ts-ignore
    type: "hierarchy.treemap",
    field: "value",
    as: ["x", "y"]
  }));
  var result = [];
  nodes.forEach(function(node) {
    if (node.depth === 0) {
      return null;
    }
    if (enableDrillDown && node.depth !== 1) {
      return null;
    }
    if (!enableDrillDown && node.children) {
      return null;
    }
    var curPath = node.ancestors().map(function(n) {
      return {
        data: n.data,
        height: n.height,
        value: n.value
      };
    });
    var path2 = enableDrillDown && isArray$1(data2.path) ? curPath.concat(data2.path.slice(1)) : curPath;
    var nodeInfo = Object.assign({}, node.data, __assign$1({ x: node.x, y: node.y, depth: node.depth, value: node.value, path: path2 }, node));
    if (!node.data[colorField] && node.parent) {
      var ancestorNode = node.ancestors().find(function(n) {
        return n.data[colorField];
      });
      nodeInfo[colorField] = ancestorNode === null || ancestorNode === void 0 ? void 0 : ancestorNode.data[colorField];
    } else {
      nodeInfo[colorField] = node.data[colorField];
    }
    nodeInfo[HIERARCHY_DATA_TRANSFORM_PARAMS] = { hierarchyConfig, colorField, enableDrillDown };
    result.push(nodeInfo);
  });
  return result;
}
function defaultOptions$1(params) {
  var options = params.options;
  var colorField = options.colorField;
  return deepAssign({
    options: {
      rawFields: ["value"],
      tooltip: {
        fields: ["name", "value", colorField, "path"],
        formatter: function(data2) {
          return {
            name: data2.name,
            value: data2.value
          };
        }
      }
    }
  }, params);
}
function geometry$3(params) {
  var chart = params.chart, options = params.options;
  var color2 = options.color, colorField = options.colorField, rectStyle = options.rectStyle, hierarchyConfig = options.hierarchyConfig, rawFields = options.rawFields;
  var data2 = transformData$1({
    data: options.data,
    colorField: options.colorField,
    enableDrillDown: enableDrillInteraction(options),
    hierarchyConfig
  });
  chart.data(data2);
  polygon(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField,
      rawFields,
      polygon: {
        color: color2,
        style: rectStyle
      }
    }
  }));
  chart.coordinate().reflect("y");
  return params;
}
function axis$3(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function adaptorInteraction(options) {
  var drilldown = options.drilldown, _a2 = options.interactions, interactions = _a2 === void 0 ? [] : _a2;
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    return deepAssign({}, options, {
      interactions: __spreadArray$1(__spreadArray$1([], interactions, true), [
        {
          type: "drill-down",
          //   API
          cfg: { drillDownConfig: drilldown, transformData: transformData$1 }
        }
      ], false)
    });
  }
  return options;
}
function interaction(params) {
  var chart = params.chart, options = params.options;
  var interactions = options.interactions, drilldown = options.drilldown;
  interaction$8({
    chart,
    options: adaptorInteraction(options)
  });
  var viewZoomInteraction = findInteraction(interactions, "view-zoom");
  if (viewZoomInteraction) {
    if (viewZoomInteraction.enable !== false) {
      chart.getCanvas().on("mousewheel", function(ev) {
        ev.preventDefault();
      });
    } else {
      chart.getCanvas().off("mousewheel");
    }
  }
  var enableDrillDown = enableDrillInteraction(options);
  if (enableDrillDown) {
    chart.appendPadding = getAdjustAppendPadding(chart.appendPadding, get(drilldown, ["breadCrumb", "position"]));
  }
  return params;
}
function adaptor$4(params) {
  return flow(defaultOptions$1, theme$2, pattern("rectStyle"), geometry$3, axis$3, legend$g, tooltip$9, interaction, animation$5, annotation$2())(params);
}
var DEFAULT_OPTIONS$5 = {
  //  name 
  colorField: "name",
  rectStyle: {
    lineWidth: 1,
    stroke: "#fff"
  },
  hierarchyConfig: {
    tile: "treemapSquarify"
  },
  label: {
    fields: ["name"],
    layout: {
      type: "limit-in-shape"
    }
  },
  tooltip: {
    showMarkers: false,
    showTitle: false
  },
  // 
  drilldown: {
    enabled: false,
    breadCrumb: {
      position: "bottom-left",
      rootText: "",
      dividerText: "/",
      textStyle: {
        fontSize: 12,
        fill: "rgba(0, 0, 0, 0.65)",
        cursor: "pointer"
      },
      activeTextStyle: {
        fill: "#87B5FF"
      }
    }
  }
};
(function(_super) {
  __extends$1(Treemap, _super);
  function Treemap() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "treemap";
    return _this;
  }
  Treemap.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$5;
  };
  Treemap.prototype.changeData = function(data2) {
    var _a2 = this.options, colorField = _a2.colorField, interactions = _a2.interactions, hierarchyConfig = _a2.hierarchyConfig;
    this.updateOption({ data: data2 });
    var transData = transformData$1({
      data: data2,
      colorField,
      enableDrillDown: enableInteraction(interactions, "treemap-drill-down"),
      hierarchyConfig
    });
    this.chart.changeData(transData);
    resetDrillDown(this.chart);
  };
  Treemap.prototype.getDefaultOptions = function() {
    return Treemap.getDefaultOptions();
  };
  Treemap.prototype.getSchemaAdaptor = function() {
    return adaptor$4;
  };
  return Treemap;
})(Plot);
var ID_FIELD = "id";
var PATH_FIELD = "path";
var DEFAULT_OPTIONS$4 = {
  appendPadding: [10, 0, 20, 0],
  blendMode: "multiply",
  tooltip: {
    showTitle: false,
    showMarkers: false,
    fields: ["id", "size"],
    formatter: function(datum) {
      return { name: datum.id, value: datum.size };
    }
  },
  legend: { position: "top-left" },
  label: {
    style: {
      textAlign: "center",
      fill: "#fff"
    }
  },
  //  
  interactions: [{ type: "legend-filter", enable: false }],
  state: {
    active: {
      style: {
        stroke: "#000"
      }
    },
    selected: {
      style: {
        stroke: "#000",
        lineWidth: 2
      }
    },
    inactive: {
      style: {
        fillOpacity: 0.3,
        strokeOpacity: 0.3
      }
    }
  },
  // 
  defaultInteractions: ["tooltip", "venn-legend-active"]
};
function placeElementsOrdered(view) {
  if (!view) {
    return;
  }
  var elements = view.geometries[0].elements;
  elements.forEach(function(elem) {
    elem.shape.toFront();
  });
}
var ElementActiveAction = getActionClass("element-active");
var VennElementActive = (
  /** @class */
  function(_super) {
    __extends$1(VennElementActive2, _super);
    function VennElementActive2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementActive2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementActive2.prototype.active = function() {
      _super.prototype.active.call(this);
      this.syncElementsPos();
    };
    VennElementActive2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementActive2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementActive2;
  }(ElementActiveAction)
);
var ElementHighlightAction = getActionClass("element-highlight");
var VennElementHighlight = (
  /** @class */
  function(_super) {
    __extends$1(VennElementHighlight2, _super);
    function VennElementHighlight2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementHighlight2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementHighlight2.prototype.highlight = function() {
      _super.prototype.highlight.call(this);
      this.syncElementsPos();
    };
    VennElementHighlight2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementHighlight2.prototype.clear = function() {
      _super.prototype.clear.call(this);
      this.syncElementsPos();
    };
    VennElementHighlight2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementHighlight2;
  }(ElementHighlightAction)
);
var ElementSelectedAction = getActionClass("element-selected");
var ElementSingleSelectedAction = getActionClass("element-single-selected");
var VennElementSelected = (
  /** @class */
  function(_super) {
    __extends$1(VennElementSelected2, _super);
    function VennElementSelected2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementSelected2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementSelected2.prototype.selected = function() {
      _super.prototype.selected.call(this);
      this.syncElementsPos();
    };
    VennElementSelected2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementSelected2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementSelected2;
  }(ElementSelectedAction)
);
var VennElementSingleSelected = (
  /** @class */
  function(_super) {
    __extends$1(VennElementSingleSelected2, _super);
    function VennElementSingleSelected2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennElementSingleSelected2.prototype.syncElementsPos = function() {
      placeElementsOrdered(this.context.view);
    };
    VennElementSingleSelected2.prototype.selected = function() {
      _super.prototype.selected.call(this);
      this.syncElementsPos();
    };
    VennElementSingleSelected2.prototype.toggle = function() {
      _super.prototype.toggle.call(this);
      this.syncElementsPos();
    };
    VennElementSingleSelected2.prototype.reset = function() {
      _super.prototype.reset.call(this);
      this.syncElementsPos();
    };
    return VennElementSingleSelected2;
  }(ElementSingleSelectedAction)
);
registerAction("venn-element-active", VennElementActive);
registerAction("venn-element-highlight", VennElementHighlight);
registerAction("venn-element-selected", VennElementSelected);
registerAction("venn-element-single-selected", VennElementSingleSelected);
registerInteraction("venn-element-active", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-active:active" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-active:reset" }]
});
registerInteraction("venn-element-highlight", {
  start: [{ trigger: "element:mouseenter", action: "venn-element-highlight:highlight" }],
  end: [{ trigger: "element:mouseleave", action: "venn-element-highlight:reset" }]
});
registerInteraction("venn-element-selected", {
  start: [{ trigger: "element:click", action: "venn-element-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-selected:reset"] }]
});
registerInteraction("venn-element-single-selected", {
  start: [{ trigger: "element:click", action: "venn-element-single-selected:toggle" }],
  rollback: [{ trigger: "dblclick", action: ["venn-element-single-selected:reset"] }]
});
registerInteraction("venn-legend-active", {
  start: [{ trigger: "legend-item:mouseenter", action: ["list-active:active", "venn-element-active:active"] }],
  end: [{ trigger: "legend-item:mouseleave", action: ["list-active:reset", "venn-element-active:reset"] }]
});
registerInteraction("venn-legend-highlight", {
  start: [
    {
      trigger: "legend-item:mouseenter",
      action: ["legend-item-highlight:highlight", "venn-element-highlight:highlight"]
    }
  ],
  end: [{ trigger: "legend-item:mouseleave", action: ["legend-item-highlight:reset", "venn-element-highlight:reset"] }]
});
var VennLabel = (
  /** @class */
  function(_super) {
    __extends$1(VennLabel2, _super);
    function VennLabel2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    VennLabel2.prototype.getLabelPoint = function(labelCfg, mappingData, index2) {
      var _a2 = labelCfg.data, x = _a2.x, y = _a2.y;
      var _b = labelCfg.customLabelInfo, offsetX = _b.offsetX, offsetY = _b.offsetY;
      return {
        content: labelCfg.content[index2],
        x: x + offsetX,
        y: y + offsetY
      };
    };
    return VennLabel2;
  }(GeometryLabel)
);
registerGeometryLabel("venn", VennLabel);
function getFillAttrs$1(cfg) {
  return deepAssign({}, cfg.defaultStyle, { fill: cfg.color }, cfg.style);
}
registerShape("schema", "venn", {
  draw: function(cfg, container) {
    var data2 = cfg.data;
    var segments = parsePathString(data2[PATH_FIELD]);
    var fillAttrs = getFillAttrs$1(cfg);
    var group2 = container.addGroup({ name: "venn-shape" });
    group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, fillAttrs), { path: segments }),
      name: "venn-path"
    });
    var _a2 = cfg.customInfo, offsetX = _a2.offsetX, offsetY = _a2.offsetY;
    var matrix = Util.transform(null, [["t", offsetX, offsetY]]);
    group2.setMatrix(matrix);
    return group2;
  },
  getMarker: function(markerCfg) {
    var color2 = markerCfg.color;
    return {
      symbol: "circle",
      style: {
        lineWidth: 0,
        stroke: color2,
        fill: color2,
        r: 4
      }
    };
  }
});
var each = function(f) {
  return function(c0, c1) {
    var out = [];
    out[0] = f(c0[0], c1[0]);
    out[1] = f(c0[1], c1[1]);
    out[2] = f(c0[2], c1[2]);
    return out;
  };
};
var blendObject = {
  normal: function(a) {
    return a;
  },
  multiply: function(a, b) {
    return a * b / 255;
  },
  screen: function(a, b) {
    return 255 * (1 - (1 - a / 255) * (1 - b / 255));
  },
  overlay: function(a, b) {
    return b < 128 ? 2 * a * b / 255 : 255 * (1 - 2 * (1 - a / 255) * (1 - b / 255));
  },
  darken: function(a, b) {
    return a > b ? b : a;
  },
  lighten: function(a, b) {
    return a > b ? a : b;
  },
  dodge: function(a, b) {
    if (a === 255)
      return 255;
    a = 255 * (b / 255) / (1 - a / 255);
    return a > 255 ? 255 : a;
  },
  burn: function(a, b) {
    if (b === 255)
      return 255;
    else if (a === 0)
      return 0;
    else
      return 255 * (1 - Math.min(1, (1 - b / 255) / (a / 255)));
  }
};
var innerBlend = function(mode) {
  if (!blendObject[mode]) {
    throw new Error("unknown blend mode " + mode);
  }
  return blendObject[mode];
};
function blend(c0, c1, mode) {
  if (mode === void 0) {
    mode = "normal";
  }
  var blendRgbArr = each(innerBlend(mode))(colorToArr(c0), colorToArr(c1));
  var _a2 = colorToArr(c0), r0 = _a2[0], g0 = _a2[1], b02 = _a2[2], a0 = _a2[3];
  var _b = colorToArr(c1), r1 = _b[0], g1 = _b[1], b12 = _b[2], a1 = _b[3];
  var a = Number((a0 + a1 * (1 - a0)).toFixed(2));
  var r = Math.round((a0 * (1 - a1) * (r0 / 255) + a0 * a1 * (blendRgbArr[0] / 255) + (1 - a0) * a1 * (r1 / 255)) / a * 255);
  var g = Math.round((a0 * (1 - a1) * (g0 / 255) + a0 * a1 * (blendRgbArr[1] / 255) + (1 - a0) * a1 * (g1 / 255)) / a * 255);
  var b = Math.round((a0 * (1 - a1) * (b02 / 255) + a0 * a1 * (blendRgbArr[2] / 255) + (1 - a0) * a1 * (b12 / 255)) / a * 255);
  return "rgba(".concat(r, ", ").concat(g, ", ").concat(b, ", ").concat(a, ")");
}
function colorToArr(c) {
  var color2 = c.replace("/s+/g", "");
  var rgbaArr;
  if (typeof color2 === "string" && !color2.startsWith("rgba") && !color2.startsWith("#")) {
    return rgbaArr = colorUtil.rgb2arr(colorUtil.toRGB(color2)).concat([1]);
  }
  if (color2.startsWith("rgba"))
    rgbaArr = color2.replace("rgba(", "").replace(")", "").split(",");
  if (color2.startsWith("#"))
    rgbaArr = colorUtil.rgb2arr(color2).concat([1]);
  return rgbaArr.map(function(item, index2) {
    return index2 === 3 ? Number(item) : item | 0;
  });
}
function bisect(f, a, b, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || 100, tolerance2 = parameters.tolerance || 1e-10, fA = f(a), fB = f(b), delta = b - a;
  if (fA * fB > 0) {
    throw "Initial bisect points must have opposite signs";
  }
  if (fA === 0)
    return a;
  if (fB === 0)
    return b;
  for (var i = 0; i < maxIterations; ++i) {
    delta /= 2;
    var mid2 = a + delta, fMid = f(mid2);
    if (fMid * fA >= 0) {
      a = mid2;
    }
    if (Math.abs(delta) < tolerance2 || fMid === 0) {
      return mid2;
    }
  }
  return a + delta;
}
function zeros(x) {
  var r = new Array(x);
  for (var i = 0; i < x; ++i) {
    r[i] = 0;
  }
  return r;
}
function zerosM(x, y) {
  return zeros(x).map(function() {
    return zeros(y);
  });
}
function dot(a, b) {
  var ret = 0;
  for (var i = 0; i < a.length; ++i) {
    ret += a[i] * b[i];
  }
  return ret;
}
function norm2(a) {
  return Math.sqrt(dot(a, a));
}
function scale(ret, value2, c) {
  for (var i = 0; i < value2.length; ++i) {
    ret[i] = value2[i] * c;
  }
}
function weightedSum(ret, w1, v1, w2, v2) {
  for (var j = 0; j < ret.length; ++j) {
    ret[j] = w1 * v1[j] + w2 * v2[j];
  }
}
function nelderMead(f, x0, parameters) {
  parameters = parameters || {};
  var maxIterations = parameters.maxIterations || x0.length * 200, nonZeroDelta = parameters.nonZeroDelta || 1.05, zeroDelta = parameters.zeroDelta || 1e-3, minErrorDelta = parameters.minErrorDelta || 1e-6, minTolerance = parameters.minErrorDelta || 1e-5, rho = parameters.rho !== void 0 ? parameters.rho : 1, chi = parameters.chi !== void 0 ? parameters.chi : 2, psi = parameters.psi !== void 0 ? parameters.psi : -0.5, sigma = parameters.sigma !== void 0 ? parameters.sigma : 0.5, maxDiff;
  var N = x0.length, simplex = new Array(N + 1);
  simplex[0] = x0;
  simplex[0].fx = f(x0);
  simplex[0].id = 0;
  for (var i = 0; i < N; ++i) {
    var point2 = x0.slice();
    point2[i] = point2[i] ? point2[i] * nonZeroDelta : zeroDelta;
    simplex[i + 1] = point2;
    simplex[i + 1].fx = f(point2);
    simplex[i + 1].id = i + 1;
  }
  function updateSimplex(value2) {
    for (var i2 = 0; i2 < value2.length; i2++) {
      simplex[N][i2] = value2[i2];
    }
    simplex[N].fx = value2.fx;
  }
  var sortOrder = function(a, b) {
    return a.fx - b.fx;
  };
  var centroid = x0.slice(), reflected = x0.slice(), contracted = x0.slice(), expanded = x0.slice();
  for (var iteration = 0; iteration < maxIterations; ++iteration) {
    simplex.sort(sortOrder);
    if (parameters.history) {
      var sortedSimplex = simplex.map(function(x) {
        var state2 = x.slice();
        state2.fx = x.fx;
        state2.id = x.id;
        return state2;
      });
      sortedSimplex.sort(function(a, b) {
        return a.id - b.id;
      });
      parameters.history.push({
        x: simplex[0].slice(),
        fx: simplex[0].fx,
        simplex: sortedSimplex
      });
    }
    maxDiff = 0;
    for (i = 0; i < N; ++i) {
      maxDiff = Math.max(maxDiff, Math.abs(simplex[0][i] - simplex[1][i]));
    }
    if (Math.abs(simplex[0].fx - simplex[N].fx) < minErrorDelta && maxDiff < minTolerance) {
      break;
    }
    for (i = 0; i < N; ++i) {
      centroid[i] = 0;
      for (var j = 0; j < N; ++j) {
        centroid[i] += simplex[j][i];
      }
      centroid[i] /= N;
    }
    var worst = simplex[N];
    weightedSum(reflected, 1 + rho, centroid, -rho, worst);
    reflected.fx = f(reflected);
    if (reflected.fx < simplex[0].fx) {
      weightedSum(expanded, 1 + chi, centroid, -chi, worst);
      expanded.fx = f(expanded);
      if (expanded.fx < reflected.fx) {
        updateSimplex(expanded);
      } else {
        updateSimplex(reflected);
      }
    } else if (reflected.fx >= simplex[N - 1].fx) {
      var shouldReduce = false;
      if (reflected.fx > worst.fx) {
        weightedSum(contracted, 1 + psi, centroid, -psi, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < worst.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      } else {
        weightedSum(contracted, 1 - psi * rho, centroid, psi * rho, worst);
        contracted.fx = f(contracted);
        if (contracted.fx < reflected.fx) {
          updateSimplex(contracted);
        } else {
          shouldReduce = true;
        }
      }
      if (shouldReduce) {
        if (sigma >= 1)
          break;
        for (i = 1; i < simplex.length; ++i) {
          weightedSum(simplex[i], 1 - sigma, simplex[0], sigma, simplex[i]);
          simplex[i].fx = f(simplex[i]);
        }
      }
    } else {
      updateSimplex(reflected);
    }
  }
  simplex.sort(sortOrder);
  return {
    fx: simplex[0].fx,
    x: simplex[0]
  };
}
function wolfeLineSearch(f, pk, current, next, a, c1, c2) {
  var phi0 = current.fx, phiPrime0 = dot(current.fxprime, pk), phi2 = phi0, phi_old = phi0, phiPrime = phiPrime0, a0 = 0;
  a = a || 1;
  c1 = c1 || 1e-6;
  c2 = c2 || 0.1;
  function zoom2(a_lo, a_high, phi_lo) {
    for (var iteration2 = 0; iteration2 < 16; ++iteration2) {
      a = (a_lo + a_high) / 2;
      weightedSum(next.x, 1, current.x, a, pk);
      phi2 = next.fx = f(next.x, next.fxprime);
      phiPrime = dot(next.fxprime, pk);
      if (phi2 > phi0 + c1 * a * phiPrime0 || phi2 >= phi_lo) {
        a_high = a;
      } else {
        if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
          return a;
        }
        if (phiPrime * (a_high - a_lo) >= 0) {
          a_high = a_lo;
        }
        a_lo = a;
        phi_lo = phi2;
      }
    }
    return 0;
  }
  for (var iteration = 0; iteration < 10; ++iteration) {
    weightedSum(next.x, 1, current.x, a, pk);
    phi2 = next.fx = f(next.x, next.fxprime);
    phiPrime = dot(next.fxprime, pk);
    if (phi2 > phi0 + c1 * a * phiPrime0 || iteration && phi2 >= phi_old) {
      return zoom2(a0, a, phi_old);
    }
    if (Math.abs(phiPrime) <= -c2 * phiPrime0) {
      return a;
    }
    if (phiPrime >= 0) {
      return zoom2(a, a0, phi2);
    }
    phi_old = phi2;
    a0 = a;
    a *= 2;
  }
  return a;
}
function conjugateGradient(f, initial, params) {
  var current = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, next = { x: initial.slice(), fx: 0, fxprime: initial.slice() }, yk = initial.slice(), pk, temp, a = 1, maxIterations;
  params = params || {};
  maxIterations = params.maxIterations || initial.length * 20;
  current.fx = f(current.x, current.fxprime);
  pk = current.fxprime.slice();
  scale(pk, current.fxprime, -1);
  for (var i = 0; i < maxIterations; ++i) {
    a = wolfeLineSearch(f, pk, current, next, a);
    if (params.history) {
      params.history.push({
        x: current.x.slice(),
        fx: current.fx,
        fxprime: current.fxprime.slice(),
        alpha: a
      });
    }
    if (!a) {
      scale(pk, current.fxprime, -1);
    } else {
      weightedSum(yk, 1, next.fxprime, -1, current.fxprime);
      var delta_k = dot(current.fxprime, current.fxprime), beta_k = Math.max(0, dot(yk, next.fxprime) / delta_k);
      weightedSum(pk, beta_k, pk, -1, next.fxprime);
      temp = current;
      current = next;
      next = temp;
    }
    if (norm2(current.fxprime) <= 1e-5) {
      break;
    }
  }
  if (params.history) {
    params.history.push({
      x: current.x.slice(),
      fx: current.fx,
      fxprime: current.fxprime.slice(),
      alpha: a
    });
  }
  return current;
}
var SMALL$1 = 1e-10;
function intersectionArea(circles, stats) {
  var intersectionPoints = getIntersectionPoints(circles);
  var innerPoints = intersectionPoints.filter(function(p3) {
    return containedInCircles(p3, circles);
  });
  var arcArea = 0, polygonArea = 0, i;
  var arcs = [];
  if (innerPoints.length > 1) {
    var center2 = getCenter(innerPoints);
    for (i = 0; i < innerPoints.length; ++i) {
      var p = innerPoints[i];
      p.angle = Math.atan2(p.x - center2.x, p.y - center2.y);
    }
    innerPoints.sort(function(a3, b) {
      return b.angle - a3.angle;
    });
    var p2 = innerPoints[innerPoints.length - 1];
    for (i = 0; i < innerPoints.length; ++i) {
      var p1 = innerPoints[i];
      polygonArea += (p2.x + p1.x) * (p1.y - p2.y);
      var midPoint = { x: (p1.x + p2.x) / 2, y: (p1.y + p2.y) / 2 };
      var arc2 = null;
      for (var j = 0; j < p1.parentIndex.length; ++j) {
        if (p2.parentIndex.indexOf(p1.parentIndex[j]) > -1) {
          var circle2 = circles[p1.parentIndex[j]], a1 = Math.atan2(p1.x - circle2.x, p1.y - circle2.y), a2 = Math.atan2(p2.x - circle2.x, p2.y - circle2.y);
          var angleDiff = a2 - a1;
          if (angleDiff < 0) {
            angleDiff += 2 * Math.PI;
          }
          var a = a2 - angleDiff / 2;
          var width = distance(midPoint, {
            x: circle2.x + circle2.radius * Math.sin(a),
            y: circle2.y + circle2.radius * Math.cos(a)
          });
          if (width > circle2.radius * 2) {
            width = circle2.radius * 2;
          }
          if (arc2 === null || arc2.width > width) {
            arc2 = { circle: circle2, width, p1, p2 };
          }
        }
      }
      if (arc2 !== null) {
        arcs.push(arc2);
        arcArea += circleArea(arc2.circle.radius, arc2.width);
        p2 = p1;
      }
    }
  } else {
    var smallest = circles[0];
    for (i = 1; i < circles.length; ++i) {
      if (circles[i].radius < smallest.radius) {
        smallest = circles[i];
      }
    }
    var disjoint = false;
    for (i = 0; i < circles.length; ++i) {
      if (distance(circles[i], smallest) > Math.abs(smallest.radius - circles[i].radius)) {
        disjoint = true;
        break;
      }
    }
    if (disjoint) {
      arcArea = polygonArea = 0;
    } else {
      arcArea = smallest.radius * smallest.radius * Math.PI;
      arcs.push({
        circle: smallest,
        p1: { x: smallest.x, y: smallest.y + smallest.radius },
        p2: { x: smallest.x - SMALL$1, y: smallest.y + smallest.radius },
        width: smallest.radius * 2
      });
    }
  }
  polygonArea /= 2;
  if (stats) {
    stats.area = arcArea + polygonArea;
    stats.arcArea = arcArea;
    stats.polygonArea = polygonArea;
    stats.arcs = arcs;
    stats.innerPoints = innerPoints;
    stats.intersectionPoints = intersectionPoints;
  }
  return arcArea + polygonArea;
}
function containedInCircles(point2, circles) {
  for (var i = 0; i < circles.length; ++i) {
    if (distance(point2, circles[i]) > circles[i].radius + SMALL$1) {
      return false;
    }
  }
  return true;
}
function getIntersectionPoints(circles) {
  var ret = [];
  for (var i = 0; i < circles.length; ++i) {
    for (var j = i + 1; j < circles.length; ++j) {
      var intersect2 = circleCircleIntersection(circles[i], circles[j]);
      for (var k = 0; k < intersect2.length; ++k) {
        var p = intersect2[k];
        p.parentIndex = [i, j];
        ret.push(p);
      }
    }
  }
  return ret;
}
function circleArea(r, width) {
  return r * r * Math.acos(1 - width / r) - (r - width) * Math.sqrt(width * (2 * r - width));
}
function distance(p1, p2) {
  return Math.sqrt((p1.x - p2.x) * (p1.x - p2.x) + (p1.y - p2.y) * (p1.y - p2.y));
}
function circleOverlap(r1, r2, d) {
  if (d >= r1 + r2) {
    return 0;
  }
  if (d <= Math.abs(r1 - r2)) {
    return Math.PI * Math.min(r1, r2) * Math.min(r1, r2);
  }
  var w1 = r1 - (d * d - r2 * r2 + r1 * r1) / (2 * d), w2 = r2 - (d * d - r1 * r1 + r2 * r2) / (2 * d);
  return circleArea(r1, w1) + circleArea(r2, w2);
}
function circleCircleIntersection(p1, p2) {
  var d = distance(p1, p2), r1 = p1.radius, r2 = p2.radius;
  if (d >= r1 + r2 || d <= Math.abs(r1 - r2)) {
    return [];
  }
  var a = (r1 * r1 - r2 * r2 + d * d) / (2 * d), h = Math.sqrt(r1 * r1 - a * a), x0 = p1.x + a * (p2.x - p1.x) / d, y0 = p1.y + a * (p2.y - p1.y) / d, rx = -(p2.y - p1.y) * (h / d), ry = -(p2.x - p1.x) * (h / d);
  return [
    { x: x0 + rx, y: y0 - ry },
    { x: x0 - rx, y: y0 + ry }
  ];
}
function getCenter(points2) {
  var center2 = { x: 0, y: 0 };
  for (var i = 0; i < points2.length; ++i) {
    center2.x += points2[i].x;
    center2.y += points2[i].y;
  }
  center2.x /= points2.length;
  center2.y /= points2.length;
  return center2;
}
function circleMargin(current, interior, exterior) {
  var margin = interior[0].radius - distance(interior[0], current), i, m;
  for (i = 1; i < interior.length; ++i) {
    m = interior[i].radius - distance(interior[i], current);
    if (m <= margin) {
      margin = m;
    }
  }
  for (i = 0; i < exterior.length; ++i) {
    m = distance(exterior[i], current) - exterior[i].radius;
    if (m <= margin) {
      margin = m;
    }
  }
  return margin;
}
function computeTextCentre(interior, exterior) {
  var points2 = [];
  var i;
  for (i = 0; i < interior.length; ++i) {
    var c = interior[i];
    points2.push({ x: c.x, y: c.y });
    points2.push({ x: c.x + c.radius / 2, y: c.y });
    points2.push({ x: c.x - c.radius / 2, y: c.y });
    points2.push({ x: c.x, y: c.y + c.radius / 2 });
    points2.push({ x: c.x, y: c.y - c.radius / 2 });
  }
  var initial = points2[0], margin = circleMargin(points2[0], interior, exterior);
  for (i = 1; i < points2.length; ++i) {
    var m = circleMargin(points2[i], interior, exterior);
    if (m >= margin) {
      initial = points2[i];
      margin = m;
    }
  }
  var solution = nelderMead(function(p) {
    return -1 * circleMargin({ x: p[0], y: p[1] }, interior, exterior);
  }, [initial.x, initial.y], { maxIterations: 500, minErrorDelta: 1e-10 }).x;
  var ret = { x: solution[0], y: solution[1] };
  var valid = true;
  for (i = 0; i < interior.length; ++i) {
    if (distance(ret, interior[i]) > interior[i].radius) {
      valid = false;
      break;
    }
  }
  for (i = 0; i < exterior.length; ++i) {
    if (distance(ret, exterior[i]) < exterior[i].radius) {
      valid = false;
      break;
    }
  }
  if (!valid) {
    if (interior.length == 1) {
      ret = { x: interior[0].x, y: interior[0].y };
    } else {
      var areaStats = {};
      intersectionArea(interior, areaStats);
      if (areaStats.arcs.length === 0) {
        ret = { x: 0, y: -1e3, disjoint: true };
      } else if (areaStats.arcs.length == 1) {
        ret = { x: areaStats.arcs[0].circle.x, y: areaStats.arcs[0].circle.y };
      } else if (exterior.length) {
        ret = computeTextCentre(interior, []);
      } else {
        ret = getCenter(areaStats.arcs.map(function(a) {
          return a.p1;
        }));
      }
    }
  }
  return ret;
}
function getOverlappingCircles(circles) {
  var ret = {}, circleids = [];
  for (var circleid in circles) {
    circleids.push(circleid);
    ret[circleid] = [];
  }
  for (var i = 0; i < circleids.length; i++) {
    var a = circles[circleids[i]];
    for (var j = i + 1; j < circleids.length; ++j) {
      var b = circles[circleids[j]], d = distance(a, b);
      if (d + b.radius <= a.radius + 1e-10) {
        ret[circleids[j]].push(circleids[i]);
      } else if (d + a.radius <= b.radius + 1e-10) {
        ret[circleids[i]].push(circleids[j]);
      }
    }
  }
  return ret;
}
function computeTextCentres(circles, areas) {
  var ret = {}, overlapped = getOverlappingCircles(circles);
  for (var i = 0; i < areas.length; ++i) {
    var area2 = areas[i].sets, areaids = {}, exclude = {};
    for (var j = 0; j < area2.length; ++j) {
      areaids[area2[j]] = true;
      var overlaps = overlapped[area2[j]];
      for (var k = 0; k < overlaps.length; ++k) {
        exclude[overlaps[k]] = true;
      }
    }
    var interior = [], exterior = [];
    for (var setid in circles) {
      if (setid in areaids) {
        interior.push(circles[setid]);
      } else if (!(setid in exclude)) {
        exterior.push(circles[setid]);
      }
    }
    var centre = computeTextCentre(interior, exterior);
    ret[area2] = centre;
    if (centre.disjoint && areas[i].size > 0) {
      console.log("WARNING: area " + area2 + " not represented on screen");
    }
  }
  return ret;
}
function circlePath(x, y, r) {
  var ret = [];
  var x0 = x - r;
  var y0 = y;
  ret.push("M", x0, y0);
  ret.push("A", r, r, 0, 1, 0, x0 + 2 * r, y0);
  ret.push("A", r, r, 0, 1, 0, x0, y0);
  return ret.join(" ");
}
function intersectionAreaPath(circles) {
  var stats = {};
  intersectionArea(circles, stats);
  var arcs = stats.arcs;
  if (arcs.length === 0) {
    return "M 0 0";
  } else if (arcs.length == 1) {
    var circle2 = arcs[0].circle;
    return circlePath(circle2.x, circle2.y, circle2.radius);
  } else {
    var ret = ["\nM", arcs[0].p2.x, arcs[0].p2.y];
    for (var i = 0; i < arcs.length; ++i) {
      var arc2 = arcs[i], r = arc2.circle.radius, wide = arc2.width > r;
      ret.push("\nA", r, r, 0, wide ? 1 : 0, 1, arc2.p1.x, arc2.p1.y);
    }
    return ret.join(" ");
  }
}
function venn(areas, parameters) {
  parameters = parameters || {};
  parameters.maxIterations = parameters.maxIterations || 500;
  var initialLayout = parameters.initialLayout || bestInitialLayout;
  var loss = parameters.lossFunction || lossFunction;
  areas = addMissingAreas(areas);
  var circles = initialLayout(areas, parameters);
  var initial = [], setids = [];
  var setid;
  for (setid in circles) {
    if (circles.hasOwnProperty(setid)) {
      initial.push(circles[setid].x);
      initial.push(circles[setid].y);
      setids.push(setid);
    }
  }
  var solution = nelderMead(function(values2) {
    var current = {};
    for (var i2 = 0; i2 < setids.length; ++i2) {
      var setid_1 = setids[i2];
      current[setid_1] = {
        x: values2[2 * i2],
        y: values2[2 * i2 + 1],
        radius: circles[setid_1].radius
        // size : circles[setid].size
      };
    }
    return loss(current, areas);
  }, initial, parameters);
  var positions = solution.x;
  for (var i = 0; i < setids.length; ++i) {
    setid = setids[i];
    circles[setid].x = positions[2 * i];
    circles[setid].y = positions[2 * i + 1];
  }
  return circles;
}
var SMALL = 1e-10;
function distanceFromIntersectArea(r1, r2, overlap2) {
  if (Math.min(r1, r2) * Math.min(r1, r2) * Math.PI <= overlap2 + SMALL) {
    return Math.abs(r1 - r2);
  }
  return bisect(function(distance2) {
    return circleOverlap(r1, r2, distance2) - overlap2;
  }, 0, r1 + r2);
}
function addMissingAreas(areas) {
  areas = areas.slice();
  var ids = [], pairs = {};
  var i, j, a, b;
  for (i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      ids.push(area2.sets[0]);
    } else if (area2.sets.length == 2) {
      a = area2.sets[0];
      b = area2.sets[1];
      pairs[[a, b]] = true;
      pairs[[b, a]] = true;
    }
  }
  ids.sort(function(a2, b10) {
    return a2 > b10 ? 1 : -1;
  });
  for (i = 0; i < ids.length; ++i) {
    a = ids[i];
    for (j = i + 1; j < ids.length; ++j) {
      b = ids[j];
      if (!([a, b] in pairs)) {
        areas.push({ sets: [a, b], size: 0 });
      }
    }
  }
  return areas;
}
function getDistanceMatrices(areas, sets, setids) {
  var distances = zerosM(sets.length, sets.length), constraints = zerosM(sets.length, sets.length);
  areas.filter(function(x) {
    return x.sets.length == 2;
  }).map(function(current) {
    var left2 = setids[current.sets[0]], right2 = setids[current.sets[1]], r1 = Math.sqrt(sets[left2].size / Math.PI), r2 = Math.sqrt(sets[right2].size / Math.PI), distance2 = distanceFromIntersectArea(r1, r2, current.size);
    distances[left2][right2] = distances[right2][left2] = distance2;
    var c = 0;
    if (current.size + 1e-10 >= Math.min(sets[left2].size, sets[right2].size)) {
      c = 1;
    } else if (current.size <= 1e-10) {
      c = -1;
    }
    constraints[left2][right2] = constraints[right2][left2] = c;
  });
  return { distances, constraints };
}
function constrainedMDSGradient(x, fxprime, distances, constraints) {
  var loss = 0, i;
  for (i = 0; i < fxprime.length; ++i) {
    fxprime[i] = 0;
  }
  for (i = 0; i < distances.length; ++i) {
    var xi = x[2 * i], yi = x[2 * i + 1];
    for (var j = i + 1; j < distances.length; ++j) {
      var xj = x[2 * j], yj = x[2 * j + 1], dij = distances[i][j], constraint = constraints[i][j];
      var squaredDistance = (xj - xi) * (xj - xi) + (yj - yi) * (yj - yi), distance_1 = Math.sqrt(squaredDistance), delta = squaredDistance - dij * dij;
      if (constraint > 0 && distance_1 <= dij || constraint < 0 && distance_1 >= dij) {
        continue;
      }
      loss += 2 * delta * delta;
      fxprime[2 * i] += 4 * delta * (xi - xj);
      fxprime[2 * i + 1] += 4 * delta * (yi - yj);
      fxprime[2 * j] += 4 * delta * (xj - xi);
      fxprime[2 * j + 1] += 4 * delta * (yj - yi);
    }
  }
  return loss;
}
function bestInitialLayout(areas, params) {
  var initial = greedyLayout(areas, params);
  var loss = params.lossFunction || lossFunction;
  if (areas.length >= 8) {
    var constrained = constrainedMDSLayout(areas, params), constrainedLoss = loss(constrained, areas), greedyLoss = loss(initial, areas);
    if (constrainedLoss + 1e-8 < greedyLoss) {
      initial = constrained;
    }
  }
  return initial;
}
function constrainedMDSLayout(areas, params) {
  params = params || {};
  var restarts = params.restarts || 10;
  var sets = [], setids = {};
  var i;
  for (i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      setids[area2.sets[0]] = sets.length;
      sets.push(area2);
    }
  }
  var matrices = getDistanceMatrices(areas, sets, setids);
  var distances = matrices.distances;
  var constraints = matrices.constraints;
  var norm = norm2(distances.map(norm2)) / distances.length;
  distances = distances.map(function(row) {
    return row.map(function(value2) {
      return value2 / norm;
    });
  });
  var obj = function(x, fxprime) {
    return constrainedMDSGradient(x, fxprime, distances, constraints);
  };
  var best, current;
  for (i = 0; i < restarts; ++i) {
    var initial = zeros(distances.length * 2).map(Math.random);
    current = conjugateGradient(obj, initial, params);
    if (!best || current.fx < best.fx) {
      best = current;
    }
  }
  var positions = best.x;
  var circles = {};
  for (i = 0; i < sets.length; ++i) {
    var set2 = sets[i];
    circles[set2.sets[0]] = {
      x: positions[2 * i] * norm,
      y: positions[2 * i + 1] * norm,
      radius: Math.sqrt(set2.size / Math.PI)
    };
  }
  if (params.history) {
    for (i = 0; i < params.history.length; ++i) {
      scale(params.history[i].x, norm);
    }
  }
  return circles;
}
function greedyLayout(areas, params) {
  var loss = params && params.lossFunction ? params.lossFunction : lossFunction;
  var circles = {}, setOverlaps = {};
  var set2;
  for (var i = 0; i < areas.length; ++i) {
    var area2 = areas[i];
    if (area2.sets.length == 1) {
      set2 = area2.sets[0];
      circles[set2] = {
        x: 1e10,
        y: 1e10,
        // rowid: circles.length, // fix to ->
        rowid: Object.keys(circles).length,
        size: area2.size,
        radius: Math.sqrt(area2.size / Math.PI)
      };
      setOverlaps[set2] = [];
    }
  }
  areas = areas.filter(function(a) {
    return a.sets.length == 2;
  });
  for (var i = 0; i < areas.length; ++i) {
    var current = areas[i];
    var weight = current.hasOwnProperty("weight") ? current.weight : 1;
    var left2 = current.sets[0], right2 = current.sets[1];
    if (current.size + SMALL >= Math.min(circles[left2].size, circles[right2].size)) {
      weight = 0;
    }
    setOverlaps[left2].push({ set: right2, size: current.size, weight });
    setOverlaps[right2].push({ set: left2, size: current.size, weight });
  }
  var mostOverlapped = [];
  for (set2 in setOverlaps) {
    if (setOverlaps.hasOwnProperty(set2)) {
      var size2 = 0;
      for (var i = 0; i < setOverlaps[set2].length; ++i) {
        size2 += setOverlaps[set2][i].size * setOverlaps[set2][i].weight;
      }
      mostOverlapped.push({ set: set2, size: size2 });
    }
  }
  function sortOrder(a, b) {
    return b.size - a.size;
  }
  mostOverlapped.sort(sortOrder);
  var positioned = {};
  function isPositioned(element) {
    return element.set in positioned;
  }
  function positionSet(point2, index2) {
    circles[index2].x = point2.x;
    circles[index2].y = point2.y;
    positioned[index2] = true;
  }
  positionSet({ x: 0, y: 0 }, mostOverlapped[0].set);
  for (var i = 1; i < mostOverlapped.length; ++i) {
    var setIndex = mostOverlapped[i].set, overlap2 = setOverlaps[setIndex].filter(isPositioned);
    set2 = circles[setIndex];
    overlap2.sort(sortOrder);
    if (overlap2.length === 0) {
      throw "ERROR: missing pairwise overlap information";
    }
    var points2 = [];
    for (var j = 0; j < overlap2.length; ++j) {
      var p1 = circles[overlap2[j].set], d1 = distanceFromIntersectArea(set2.radius, p1.radius, overlap2[j].size);
      points2.push({ x: p1.x + d1, y: p1.y });
      points2.push({ x: p1.x - d1, y: p1.y });
      points2.push({ y: p1.y + d1, x: p1.x });
      points2.push({ y: p1.y - d1, x: p1.x });
      for (var k = j + 1; k < overlap2.length; ++k) {
        var p2 = circles[overlap2[k].set], d2 = distanceFromIntersectArea(set2.radius, p2.radius, overlap2[k].size);
        var extraPoints = circleCircleIntersection({ x: p1.x, y: p1.y, radius: d1 }, { x: p2.x, y: p2.y, radius: d2 });
        for (var l = 0; l < extraPoints.length; ++l) {
          points2.push(extraPoints[l]);
        }
      }
    }
    var bestLoss = 1e50, bestPoint = points2[0];
    for (var j = 0; j < points2.length; ++j) {
      circles[setIndex].x = points2[j].x;
      circles[setIndex].y = points2[j].y;
      var localLoss = loss(circles, areas);
      if (localLoss < bestLoss) {
        bestLoss = localLoss;
        bestPoint = points2[j];
      }
    }
    positionSet(bestPoint, setIndex);
  }
  return circles;
}
function lossFunction(sets, overlaps) {
  var output2 = 0;
  function getCircles(indices) {
    return indices.map(function(i2) {
      return sets[i2];
    });
  }
  for (var i = 0; i < overlaps.length; ++i) {
    var area2 = overlaps[i];
    var overlap2 = void 0;
    if (area2.sets.length == 1) {
      continue;
    } else if (area2.sets.length == 2) {
      var left2 = sets[area2.sets[0]], right2 = sets[area2.sets[1]];
      overlap2 = circleOverlap(left2.radius, right2.radius, distance(left2, right2));
    } else {
      overlap2 = intersectionArea(getCircles(area2.sets));
    }
    var weight = area2.hasOwnProperty("weight") ? area2.weight : 1;
    output2 += weight * (overlap2 - area2.size) * (overlap2 - area2.size);
  }
  return output2;
}
function getBoundingBox(circles) {
  var minMax = function(d) {
    var hi = Math.max.apply(null, circles.map(function(c) {
      return c[d] + c.radius;
    })), lo = Math.min.apply(null, circles.map(function(c) {
      return c[d] - c.radius;
    }));
    return { max: hi, min: lo };
  };
  return { xRange: minMax("x"), yRange: minMax("y") };
}
function scaleSolution(solution, width, height, padding2) {
  var circles = [], setids = [];
  for (var setid in solution) {
    if (solution.hasOwnProperty(setid)) {
      setids.push(setid);
      circles.push(solution[setid]);
    }
  }
  width -= 2 * padding2;
  height -= 2 * padding2;
  var bounds = getBoundingBox(circles), xRange = bounds.xRange, yRange = bounds.yRange;
  if (xRange.max == xRange.min || yRange.max == yRange.min) {
    console.log("not scaling solution: zero size detected");
    return solution;
  }
  var xScaling = width / (xRange.max - xRange.min), yScaling = height / (yRange.max - yRange.min), scaling = Math.min(yScaling, xScaling), xOffset = (width - (xRange.max - xRange.min) * scaling) / 2, yOffset = (height - (yRange.max - yRange.min) * scaling) / 2;
  var scaled = {};
  for (var i = 0; i < circles.length; ++i) {
    var circle2 = circles[i];
    scaled[setids[i]] = {
      radius: scaling * circle2.radius,
      x: padding2 + xOffset + (circle2.x - xRange.min) * scaling,
      y: padding2 + yOffset + (circle2.y - yRange.min) * scaling
    };
  }
  return scaled;
}
var getColorMap = memoize(function(colorPalette, data2, blendMode, setsField) {
  var colorMap2 = /* @__PURE__ */ new Map();
  var colorPaletteLen = colorPalette.length;
  data2.forEach(function(d, idx) {
    if (d[setsField].length === 1) {
      colorMap2.set(d[ID_FIELD], colorPalette[(idx + colorPaletteLen) % colorPaletteLen]);
    } else {
      var colorArr = d[setsField].map(function(id2) {
        return colorMap2.get(id2);
      });
      colorMap2.set(d[ID_FIELD], colorArr.slice(1).reduce(function(a, b) {
        return blend(a, b, blendMode);
      }, colorArr[0]));
    }
  });
  return colorMap2;
}, function() {
  var params = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    params[_i] = arguments[_i];
  }
  return JSON.stringify(params);
});
function layoutVennData(options, width, height, padding2) {
  if (padding2 === void 0) {
    padding2 = 0;
  }
  var data2 = options.data, setsField = options.setsField, sizeField = options.sizeField;
  if (data2.length === 0) {
    log(LEVEL.WARN, false, "warn: %s", "");
    return [];
  }
  var vennData = data2.map(function(d) {
    var _a2;
    return __assign$1(__assign$1({}, d), (_a2 = { sets: d[setsField] || [], size: d[sizeField] }, _a2[PATH_FIELD] = "", _a2[ID_FIELD] = "", _a2));
  });
  vennData.sort(function(a, b) {
    return a.sets.length - b.sets.length;
  });
  var solution = venn(vennData);
  var circles = scaleSolution(solution, width, height, padding2);
  var textCenters = computeTextCentres(circles, vennData);
  vennData.forEach(function(row) {
    var sets = row.sets;
    var id2 = sets.join(",");
    row[ID_FIELD] = id2;
    var setCircles = sets.map(function(set2) {
      return circles[set2];
    });
    var path2 = intersectionAreaPath(setCircles);
    if (!/[zZ]$/.test(path2)) {
      path2 += " Z";
    }
    row[PATH_FIELD] = path2;
    var center2 = textCenters[id2] || { x: 0, y: 0 };
    mix(row, center2);
  });
  return vennData;
}
function islegalSets(legalArr, testArr) {
  for (var i = 0; i < testArr.length; i++) {
    if (!legalArr.includes(testArr[i])) {
      return false;
    }
  }
  return true;
}
var LEGEND_SPACE = 40;
function colorMap(params, data2, colorPalette) {
  var chart = params.chart, options = params.options;
  var blendMode = options.blendMode, setsField = options.setsField;
  var _a2 = chart.getTheme(), colors10 = _a2.colors10, colors20 = _a2.colors20;
  var palette = colorPalette;
  if (!isArray$1(palette)) {
    palette = data2.filter(function(d) {
      return d[setsField].length === 1;
    }).length <= 10 ? colors10 : colors20;
  }
  var map2 = getColorMap(palette, data2, blendMode, setsField);
  return function(id2) {
    return map2.get(id2) || palette[0];
  };
}
function transformColor(params, data2) {
  var options = params.options;
  var color2 = options.color;
  if (typeof color2 !== "function") {
    var colorPalette = typeof color2 === "string" ? [color2] : color2;
    var map_1 = colorMap(params, data2, colorPalette);
    return function(datum) {
      return map_1(datum[ID_FIELD]);
    };
  }
  return color2;
}
function padding(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, appendPadding = options.appendPadding, padding2 = options.padding;
  var tempPadding = normalPadding(appendPadding);
  if (legend2 !== false) {
    tempPadding = getAdjustAppendPadding(appendPadding, get(legend2, "position"), LEGEND_SPACE);
  }
  chart.appendPadding = resolveAllPadding([tempPadding, padding2]);
  return params;
}
function data$1(params) {
  var options = params.options;
  var data2 = options["data"];
  if (!data2) {
    log(LEVEL.WARN, false, "warn: %s", "");
    data2 = [];
  }
  var currSets = data2.filter(function(datum) {
    return datum.sets.length === 1;
  }).map(function(datum) {
    return datum.sets[0];
  });
  var filterSets = data2.filter(function(datum) {
    var sets = datum.sets;
    return islegalSets(currSets, sets);
  });
  if (!isEqual$1(filterSets, data2))
    log(LEVEL.WARN, false, "warn: %s", ", ");
  return deepMix({}, params, {
    options: {
      data: filterSets
    }
  });
}
function geometry$2(params) {
  var chart = params.chart, options = params.options;
  var pointStyle = options.pointStyle, setsField = options.setsField, sizeField = options.sizeField;
  var _a2 = normalPadding(chart.appendPadding), t = _a2[0], r = _a2[1], b = _a2[2], l = _a2[3];
  var customInfo = { offsetX: l, offsetY: t };
  var _b = chart.viewBBox, width = _b.width, height = _b.height;
  var vennData = layoutVennData(options, Math.max(width - (r + l), 0), Math.max(height - (t + b), 0), 0);
  chart.data(vennData);
  var ext = schema(deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      sizeField,
      seriesField: ID_FIELD,
      rawFields: [setsField, sizeField],
      schema: {
        shape: "venn",
        style: pointStyle
      }
    }
  })).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo(customInfo);
  var colorOptions = transformColor(params, vennData);
  if (typeof colorOptions === "function") {
    geometry2.color(ID_FIELD, function(id2) {
      var datum = vennData.find(function(d) {
        return d[ID_FIELD] === id2;
      });
      var defaultColor = colorMap(params, vennData)(id2);
      return colorOptions(datum, defaultColor);
    });
  }
  return params;
}
function label$1(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label;
  var _a2 = normalPadding(chart.appendPadding), t = _a2[0], l = _a2[3];
  var customLabelInfo = { offsetX: l, offsetY: t };
  var geometry2 = findGeometry(chart, "schema");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: ["id"],
      callback,
      cfg: deepMix({}, transformLabel(cfg), {
        //  G2  label 
        type: "venn",
        customLabelInfo
      })
    });
  }
  return params;
}
function legend$3(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, sizeField = options.sizeField;
  chart.legend(ID_FIELD, legend2);
  chart.legend(sizeField, false);
  return params;
}
function axis$2(params) {
  var chart = params.chart;
  chart.axis(false);
  return params;
}
function vennInteraction(params) {
  var options = params.options, chart = params.chart;
  var interactions = options.interactions;
  if (interactions) {
    var MAP_1 = {
      "legend-active": "venn-legend-active",
      "legend-highlight": "venn-legend-highlight"
    };
    interaction$8(deepAssign({}, params, {
      options: {
        interactions: interactions.map(function(i) {
          return __assign$1(__assign$1({}, i), { type: MAP_1[i.type] || i.type });
        })
      }
    }));
  }
  chart.removeInteraction("legend-active");
  chart.removeInteraction("legend-highlight");
  return params;
}
function adaptor$3(params) {
  return flow(
    padding,
    theme$2,
    data$1,
    geometry$2,
    label$1,
    scale$2({}),
    legend$3,
    axis$2,
    tooltip$9,
    vennInteraction,
    animation$5
    // ...  adaptor flow
  )(params);
}
(function(_super) {
  __extends$1(Venn, _super);
  function Venn() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "venn";
    return _this;
  }
  Venn.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$4;
  };
  Venn.prototype.getDefaultOptions = function() {
    return Venn.getDefaultOptions();
  };
  Venn.prototype.getSchemaAdaptor = function() {
    return adaptor$3;
  };
  Venn.prototype.triggerResize = function() {
    if (!this.chart.destroyed) {
      this.chart.forceFit();
      this.chart.clear();
      this.execAdaptor();
      this.chart.render(true);
    }
  };
  return Venn;
})(Plot);
var X_FIELD = "x";
var VIOLIN_Y_FIELD = "violinY";
var VIOLIN_SIZE_FIELD = "violinSize";
var MIN_MAX_FIELD = "minMax";
var QUANTILE_FIELD = "quantile";
var MEDIAN_FIELD = "median";
var VIOLIN_VIEW_ID = "violin_view";
var MIN_MAX_VIEW_ID = "min_max_view";
var QUANTILE_VIEW_ID = "quantile_view";
var MEDIAN_VIEW_ID = "median_view";
var DEFAULT_OPTIONS$3 = deepAssign({}, Plot.getDefaultOptions(), {
  //  view  view padding 
  syncViewPadding: true,
  // 
  kde: {
    type: "triangular",
    sampleSize: 32,
    width: 3
  },
  // 
  violinStyle: {
    lineWidth: 1,
    fillOpacity: 0.3,
    strokeOpacity: 0.75
  },
  // 
  xAxis: {
    grid: {
      line: null
    },
    tickLine: {
      alignTick: false
    }
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineWidth: 0.5,
          lineDash: [4, 4]
        }
      }
    }
  },
  // 
  legend: {
    position: "top-left"
  },
  // Tooltip
  tooltip: {
    showMarkers: false
  }
  // 
  // interactions: [{ type: 'active-region' }],
});
var src = { exports: {} };
var helper = { exports: {} };
(function(module) {
  var self2 = module.exports;
  module.exports.isNumber = function(x) {
    return typeof x === "number";
  };
  module.exports.findMin = function(arr) {
    if (arr.length === 0) {
      return Infinity;
    }
    var curr = arr[0];
    for (var i = 1; i < arr.length; i++) {
      curr = Math.min(curr, arr[i]);
    }
    return curr;
  };
  module.exports.findMax = function(arr) {
    if (arr.length === 0) {
      return -Infinity;
    }
    var curr = arr[0];
    for (var i = 1; i < arr.length; i++) {
      curr = Math.max(curr, arr[i]);
    }
    return curr;
  };
  module.exports.findMinMulti = function(arr) {
    var curr = self2.findMin(arr[0]);
    for (var i = 1; i < arr.length; i++) {
      curr = Math.min(curr, self2.findMin(arr[i]));
    }
    return curr;
  };
  module.exports.findMaxMulti = function(arr) {
    var curr = self2.findMax(arr[0]);
    for (var i = 1; i < arr.length; i++) {
      curr = Math.max(curr, self2.findMax(arr[i]));
    }
    return curr;
  };
  module.exports.inside = function(min2, max2, x) {
    return min2 <= x && x <= max2;
  };
})(helper);
var helperExports = helper.exports;
(function(module) {
  var DEFAULT_SIZE2 = 50;
  var DEFAULT_WIDTH = 2;
  var LN_2 = Math.log(2);
  var self2 = module.exports;
  var helper2 = helperExports;
  function kernel(x) {
    return 1 - Math.abs(x);
  }
  module.exports.getUnifiedMinMax = function(arr, options) {
    return self2.getUnifiedMinMaxMulti([arr], options);
  };
  module.exports.getUnifiedMinMaxMulti = function(arrMulti, options) {
    options = options || {};
    var relaxMin = false;
    var relaxMax = false;
    var width = helper2.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
    var size2 = helper2.isNumber(options.size) ? options.size : DEFAULT_SIZE2;
    var min2 = helper2.isNumber(options.min) ? options.min : (relaxMin = true, helper2.findMinMulti(arrMulti));
    var max2 = helper2.isNumber(options.max) ? options.max : (relaxMax = true, helper2.findMaxMulti(arrMulti));
    var range = max2 - min2;
    var step = range / (size2 - 1);
    if (relaxMin) {
      min2 = min2 - 2 * width * step;
    }
    if (relaxMax) {
      max2 = max2 + 2 * width * step;
    }
    return {
      min: min2,
      max: max2
    };
  };
  module.exports.create = function(arr, options) {
    options = options || {};
    if (!arr || arr.length === 0) {
      return [];
    }
    var size2 = helper2.isNumber(options.size) ? options.size : DEFAULT_SIZE2;
    var width = helper2.isNumber(options.width) ? options.width : DEFAULT_WIDTH;
    var normalizedMinMax = self2.getUnifiedMinMax(arr, {
      size: size2,
      width,
      min: options.min,
      max: options.max
    });
    var min2 = normalizedMinMax.min;
    var max2 = normalizedMinMax.max;
    var range = max2 - min2;
    var step = range / (size2 - 1);
    if (range === 0) {
      return [{ x: min2, y: 1 }];
    }
    var buckets = [];
    for (var i = 0; i < size2; i++) {
      buckets.push({
        x: min2 + i * step,
        y: 0
      });
    }
    var xToBucket = function(x) {
      return Math.floor((x - min2) / step);
    };
    var partialArea = generatePartialAreas(kernel, width);
    var fullArea = partialArea[width];
    var c = partialArea[width - 1] - partialArea[width - 2];
    var initalValue = 0;
    arr.forEach(function(x) {
      var bucket = xToBucket(x);
      if (bucket + width < 0 || bucket - width >= buckets.length) {
        return;
      }
      var start = Math.max(bucket - width, 0);
      var mid2 = bucket;
      var end = Math.min(bucket + width, buckets.length - 1);
      var leftBlockCount = start - (bucket - width);
      var rightBlockCount = bucket + width - end;
      var spilledAreaLeft = partialArea[-width - 1 + leftBlockCount] || 0;
      var spilledAreaRight = partialArea[-width - 1 + rightBlockCount] || 0;
      var weight = fullArea / (fullArea - spilledAreaLeft - spilledAreaRight);
      if (leftBlockCount > 0) {
        initalValue += weight * (leftBlockCount - 1) * c;
      }
      var startGradPos = Math.max(0, bucket - width + 1);
      if (helper2.inside(0, buckets.length - 1, startGradPos)) {
        buckets[startGradPos].y += weight * 1 * c;
      }
      if (helper2.inside(0, buckets.length - 1, mid2 + 1)) {
        buckets[mid2 + 1].y -= weight * 2 * c;
      }
      if (helper2.inside(0, buckets.length - 1, end + 1)) {
        buckets[end + 1].y += weight * 1 * c;
      }
    });
    var accumulator = initalValue;
    var gradAccumulator = 0;
    var area2 = 0;
    buckets.forEach(function(bucket) {
      gradAccumulator += bucket.y;
      accumulator += gradAccumulator;
      bucket.y = accumulator;
      area2 += accumulator;
    });
    if (area2 > 0) {
      buckets.forEach(function(bucket) {
        bucket.y /= area2;
      });
    }
    return buckets;
  };
  function generatePartialAreas(kernel2, width) {
    var partialAreas = {};
    var accumulator = 0;
    for (var i = -width; i <= width; i++) {
      accumulator += kernel2(i / width);
      partialAreas[i] = accumulator;
    }
    return partialAreas;
  }
  module.exports.getExpectedValueFromPdf = function(pdf2) {
    if (!pdf2 || pdf2.length === 0) {
      return void 0;
    }
    var expected = 0;
    pdf2.forEach(function(obj) {
      expected += obj.x * obj.y;
    });
    return expected;
  };
  module.exports.getXWithLeftTailArea = function(pdf2, area2) {
    if (!pdf2 || pdf2.length === 0) {
      return void 0;
    }
    var accumulator = 0;
    var last2 = 0;
    for (var i = 0; i < pdf2.length; i++) {
      last2 = i;
      accumulator += pdf2[i].y;
      if (accumulator >= area2) {
        break;
      }
    }
    return pdf2[last2].x;
  };
  module.exports.getPerplexity = function(pdf2) {
    if (!pdf2 || pdf2.length === 0) {
      return void 0;
    }
    var entropy = 0;
    pdf2.forEach(function(obj) {
      var ln = Math.log(obj.y);
      if (isFinite(ln)) {
        entropy += obj.y * ln;
      }
    });
    entropy = -entropy / LN_2;
    return Math.pow(2, entropy);
  };
})(src);
var srcExports = src.exports;
const pdf = /* @__PURE__ */ getDefaultExportFromCjs(srcExports);
function quantileSorted(x, p) {
  var idx = x.length * p;
  if (x.length === 0) {
    throw new Error("quantile requires at least one data point.");
  } else if (p < 0 || p > 1) {
    throw new Error("quantiles must be between 0 and 1");
  } else if (p === 1) {
    return x[x.length - 1];
  } else if (p === 0) {
    return x[0];
  } else if (idx % 1 !== 0) {
    return x[Math.ceil(idx) - 1];
  } else if (x.length % 2 === 0) {
    return (x[idx - 1] + x[idx]) / 2;
  } else {
    return x[idx];
  }
}
function swap(arr, i, j) {
  var tmp = arr[i];
  arr[i] = arr[j];
  arr[j] = tmp;
}
function quickselect(arr, k, left2, right2) {
  left2 = left2 || 0;
  right2 = right2 || arr.length - 1;
  while (right2 > left2) {
    if (right2 - left2 > 600) {
      var n = right2 - left2 + 1;
      var m = k - left2 + 1;
      var z = Math.log(n);
      var s = 0.5 * Math.exp(2 * z / 3);
      var sd = 0.5 * Math.sqrt(z * s * (n - s) / n);
      if (m - n / 2 < 0)
        sd *= -1;
      var newLeft = Math.max(left2, Math.floor(k - m * s / n + sd));
      var newRight = Math.min(right2, Math.floor(k + (n - m) * s / n + sd));
      quickselect(arr, k, newLeft, newRight);
    }
    var t = arr[k];
    var i = left2;
    var j = right2;
    swap(arr, left2, k);
    if (arr[right2] > t)
      swap(arr, left2, right2);
    while (i < j) {
      swap(arr, i, j);
      i++;
      j--;
      while (arr[i] < t)
        i++;
      while (arr[j] > t)
        j--;
    }
    if (arr[left2] === t)
      swap(arr, left2, j);
    else {
      j++;
      swap(arr, j, right2);
    }
    if (j <= k)
      left2 = j + 1;
    if (k <= j)
      right2 = j - 1;
  }
}
function quantile(x, p) {
  var copy = x.slice();
  if (Array.isArray(p)) {
    multiQuantileSelect(copy, p);
    var results = [];
    for (var i = 0; i < p.length; i++) {
      results[i] = quantileSorted(copy, p[i]);
    }
    return results;
  } else {
    var idx = quantileIndex(copy.length, p);
    quantileSelect(copy, idx, 0, copy.length - 1);
    return quantileSorted(copy, p);
  }
}
function quantileSelect(arr, k, left2, right2) {
  if (k % 1 === 0) {
    quickselect(arr, k, left2, right2);
  } else {
    k = Math.floor(k);
    quickselect(arr, k, left2, right2);
    quickselect(arr, k + 1, k + 1, right2);
  }
}
function multiQuantileSelect(arr, p) {
  var indices = [0];
  for (var i = 0; i < p.length; i++) {
    indices.push(quantileIndex(arr.length, p[i]));
  }
  indices.push(arr.length - 1);
  indices.sort(compare);
  var stack = [0, indices.length - 1];
  while (stack.length) {
    var r = Math.ceil(stack.pop());
    var l = Math.floor(stack.pop());
    if (r - l <= 1)
      continue;
    var m = Math.floor((l + r) / 2);
    quantileSelect(arr, indices[m], Math.floor(indices[l]), Math.ceil(indices[r]));
    stack.push(l, m, m, r);
  }
}
function compare(a, b) {
  return a - b;
}
function quantileIndex(len, p) {
  var idx = len * p;
  if (p === 1) {
    return len - 1;
  } else if (p === 0) {
    return 0;
  } else if (idx % 1 !== 0) {
    return Math.ceil(idx) - 1;
  } else if (len % 2 === 0) {
    return idx - 0.5;
  } else {
    return idx;
  }
}
var toBoxValue = function(values2) {
  return {
    low: min$2(values2),
    high: max$2(values2),
    q1: quantile(values2, 0.25),
    q3: quantile(values2, 0.75),
    median: quantile(values2, [0.5]),
    minMax: [min$2(values2), max$2(values2)],
    quantile: [quantile(values2, 0.25), quantile(values2, 0.75)]
  };
};
var toViolinValue = function(values2, pdfOptions) {
  var pdfResults = pdf.create(values2, pdfOptions);
  return {
    violinSize: pdfResults.map(function(result) {
      return result.y;
    }),
    violinY: pdfResults.map(function(result) {
      return result.x;
    })
  };
};
var transformViolinData = function(options) {
  var xField = options.xField, yField = options.yField, seriesField = options.seriesField, data2 = options.data, kde = options.kde;
  var pdfOptions = {
    min: kde.min,
    max: kde.max,
    size: kde.sampleSize,
    width: kde.width
  };
  if (!seriesField) {
    var group_1 = groupBy(data2, xField);
    return Object.keys(group_1).map(function(x) {
      var records = group_1[x];
      var values2 = records.map(function(record) {
        return record[yField];
      });
      return __assign$1(__assign$1({ x }, toViolinValue(values2, pdfOptions)), toBoxValue(values2));
    });
  }
  var resultList = [];
  var seriesGroup = groupBy(data2, seriesField);
  Object.keys(seriesGroup).forEach(function(series) {
    var group2 = groupBy(seriesGroup[series], xField);
    return Object.keys(group2).forEach(function(key) {
      var _a2;
      var records = group2[key];
      var values2 = records.map(function(record) {
        return record[yField];
      });
      resultList.push(__assign$1(__assign$1((_a2 = { x: key }, _a2[seriesField] = series, _a2), toViolinValue(values2, pdfOptions)), toBoxValue(values2)));
    });
  });
  return resultList;
};
var TOOLTIP_FIELDS = ["low", "high", "q1", "q3", "median"];
var adjustCfg = [
  {
    type: "dodge",
    marginRatio: 1 / 32
  }
];
function data(params) {
  var chart = params.chart, options = params.options;
  chart.data(transformViolinData(options));
  return params;
}
function violinView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color2 = options.color, _a2 = options.shape, shape = _a2 === void 0 ? "violin" : _a2, violinStyle = options.violinStyle, tooltip2 = options.tooltip, state2 = options.state;
  var view = chart.createView({ id: VIOLIN_VIEW_ID });
  violin({
    chart: view,
    options: {
      xField: X_FIELD,
      yField: VIOLIN_Y_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD,
      sizeField: VIOLIN_SIZE_FIELD,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      violin: {
        style: violinStyle,
        color: color2,
        shape
      },
      state: state2
    }
  });
  view.geometries[0].adjust(adjustCfg);
  return params;
}
function boxView(params) {
  var chart = params.chart, options = params.options;
  var seriesField = options.seriesField, color2 = options.color, tooltip2 = options.tooltip, box2 = options.box;
  if (box2 === false)
    return params;
  var minMaxView = chart.createView({ id: MIN_MAX_VIEW_ID });
  interval({
    chart: minMaxView,
    options: {
      xField: X_FIELD,
      yField: MIN_MAX_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color2,
        size: 1,
        style: {
          lineWidth: 0
        }
      }
    }
  });
  minMaxView.geometries[0].adjust(adjustCfg);
  var quantileView = chart.createView({ id: QUANTILE_VIEW_ID });
  interval({
    chart: quantileView,
    options: {
      xField: X_FIELD,
      yField: QUANTILE_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      interval: {
        color: color2,
        size: 8,
        style: {
          fillOpacity: 1
        }
      }
    }
  });
  quantileView.geometries[0].adjust(adjustCfg);
  var medianView = chart.createView({ id: MEDIAN_VIEW_ID });
  point({
    chart: medianView,
    options: {
      xField: X_FIELD,
      yField: MEDIAN_FIELD,
      seriesField: seriesField ? seriesField : X_FIELD,
      tooltip: __assign$1({ fields: TOOLTIP_FIELDS }, tooltip2),
      state: typeof box2 === "object" ? box2.state : {},
      point: {
        color: color2,
        size: 1,
        style: {
          fill: "white",
          lineWidth: 0
        }
      }
    }
  });
  medianView.geometries[0].adjust(adjustCfg);
  quantileView.axis(false);
  minMaxView.axis(false);
  medianView.axis(false);
  medianView.legend(false);
  minMaxView.legend(false);
  quantileView.legend(false);
  return params;
}
function meta$2(params) {
  var _a2;
  var chart = params.chart, options = params.options;
  var meta2 = options.meta, xAxis = options.xAxis, yAxis = options.yAxis;
  var baseMeta = {};
  var scales = deepAssign(baseMeta, meta2, (_a2 = {}, _a2[X_FIELD] = __assign$1(__assign$1({ sync: true }, pick(xAxis, AXIS_META_CONFIG_KEYS)), {
    // fix:  dodge is not support linear attribute, please use category attribute!
    //  x 
    type: "cat"
  }), _a2[VIOLIN_Y_FIELD] = __assign$1({ sync: true }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[MIN_MAX_FIELD] = __assign$1({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[QUANTILE_FIELD] = __assign$1({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2[MEDIAN_FIELD] = __assign$1({ sync: VIOLIN_Y_FIELD }, pick(yAxis, AXIS_META_CONFIG_KEYS)), _a2));
  chart.scale(scales);
  return params;
}
function axis$1(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis;
  var view = findViewById(chart, VIOLIN_VIEW_ID);
  if (xAxis === false) {
    view.axis(X_FIELD, false);
  } else {
    view.axis(X_FIELD, xAxis);
  }
  if (yAxis === false) {
    view.axis(VIOLIN_Y_FIELD, false);
  } else {
    view.axis(VIOLIN_Y_FIELD, yAxis);
  }
  chart.axis(false);
  return params;
}
function legend$2(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, seriesField = options.seriesField, shape = options.shape;
  if (legend2 === false) {
    chart.legend(false);
  } else {
    var legendField_1 = seriesField ? seriesField : X_FIELD;
    var legendOptions = omit$1(legend2, ["selected"]);
    if (!shape || !shape.startsWith("hollow")) {
      if (!get(legendOptions, ["marker", "style", "lineWidth"])) {
        set(legendOptions, ["marker", "style", "lineWidth"], 0);
      }
    }
    chart.legend(legendField_1, legendOptions);
    if (get(legend2, "selected")) {
      each$1(chart.views, function(view) {
        return view.legend(legendField_1, legend2);
      });
    }
  }
  return params;
}
function annotation(params) {
  var chart = params.chart;
  var violinView2 = findViewById(chart, VIOLIN_VIEW_ID);
  annotation$2()(__assign$1(__assign$1({}, params), { chart: violinView2 }));
  return params;
}
function animation(params) {
  var chart = params.chart, options = params.options;
  var animation2 = options.animation;
  each$1(chart.views, function(view) {
    addViewAnimation(view, animation2);
  });
  return params;
}
function adaptor$2(params) {
  return flow(theme$2, data, violinView, boxView, meta$2, tooltip$9, axis$1, legend$2, interaction$8, annotation, animation)(params);
}
(function(_super) {
  __extends$1(Violin2, _super);
  function Violin2() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "violin";
    return _this;
  }
  Violin2.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$3;
  };
  Violin2.prototype.changeData = function(data2) {
    this.updateOption({ data: data2 });
    this.chart.changeData(transformViolinData(this.options));
  };
  Violin2.prototype.getDefaultOptions = function() {
    return Violin2.getDefaultOptions();
  };
  Violin2.prototype.getSchemaAdaptor = function() {
    return adaptor$2;
  };
  return Violin2;
})(Plot);
var Y_FIELD = "$$yField$$";
var DIFF_FIELD = "$$diffField$$";
var ABSOLUTE_FIELD = "$$absoluteField$$";
var IS_TOTAL = "$$isTotal$$";
var DEFAULT_OPTIONS$2 = {
  /** default: show label */
  label: {},
  /** default: show leaderLine */
  leaderLine: {
    style: {
      lineWidth: 1,
      stroke: "#8c8c8c",
      lineDash: [4, 2]
    }
  },
  /** default: show total */
  total: {
    style: {
      fill: "rgba(0, 0, 0, 0.25)"
    }
  },
  interactions: [{ type: "element-active" }],
  risingFill: "#f4664a",
  fallingFill: "#30bf78",
  waterfallStyle: {
    fill: "rgba(0, 0, 0, 0.25)"
  },
  yAxis: {
    grid: {
      line: {
        style: {
          lineDash: [4, 2]
        }
      }
    }
  }
};
function getRectPath(points2) {
  var path2 = [];
  for (var i = 0; i < points2.length; i++) {
    var point2 = points2[i];
    if (point2) {
      var action = i === 0 ? "M" : "L";
      path2.push([action, point2.x, point2.y]);
    }
  }
  var first = points2[0];
  path2.push(["L", first.x, first.y]);
  path2.push(["z"]);
  return path2;
}
function getFillAttrs(cfg) {
  return deepAssign({}, cfg.defaultStyle, cfg.style, { fill: cfg.color });
}
registerShape("interval", "waterfall", {
  draw: function(cfg, container) {
    var customInfo = cfg.customInfo, points2 = cfg.points, nextPoints = cfg.nextPoints;
    var group2 = container.addGroup();
    var rectPath2 = this.parsePath(getRectPath(points2));
    var fillAttrs = getFillAttrs(cfg);
    group2.addShape("path", {
      attrs: __assign$1(__assign$1({}, fillAttrs), { path: rectPath2 })
    });
    var leaderLineCfg = get(customInfo, "leaderLine");
    if (leaderLineCfg && nextPoints) {
      var linkPath = [
        ["M", points2[2].x, points2[2].y],
        ["L", nextPoints[0].x, nextPoints[0].y]
      ];
      if (points2[2].y === nextPoints[1].y) {
        linkPath[1] = ["L", nextPoints[1].x, nextPoints[1].y];
      }
      linkPath = this.parsePath(linkPath);
      group2.addShape("path", {
        attrs: __assign$1({ path: linkPath }, leaderLineCfg.style || {})
      });
    }
    return group2;
  }
});
function processData(data2, xField, yField, newYField, total) {
  var _a2;
  var newData = [];
  reduce(data2, function(r, d) {
    var _a3;
    log(LEVEL.WARN, isNumber$1(d[yField]), "".concat(d[yField], " is not a valid number"));
    var value2 = isUndefined(d[yField]) ? null : d[yField];
    newData.push(__assign$1(__assign$1({}, d), (_a3 = {}, _a3[newYField] = [r, r + value2], _a3)));
    return r + value2;
  }, 0);
  if (newData.length && total) {
    var sum = get(newData, [[data2.length - 1], newYField, [1]]);
    newData.push((_a2 = {}, _a2[xField] = total.label, _a2[yField] = sum, _a2[newYField] = [0, sum], _a2));
  }
  return newData;
}
function transformData(data2, xField, yField, total) {
  var processed = processData(data2, xField, yField, Y_FIELD, total);
  return processed.map(function(d, dIdx) {
    var _a2;
    if (!isObject(d)) {
      return d;
    }
    return __assign$1(__assign$1({}, d), (_a2 = {}, _a2[ABSOLUTE_FIELD] = d[Y_FIELD][1], _a2[DIFF_FIELD] = d[Y_FIELD][1] - d[Y_FIELD][0], _a2[IS_TOTAL] = dIdx === data2.length, _a2));
  });
}
function defaultOptions(params) {
  var _a2 = params.options, locale = _a2.locale, total = _a2.total;
  var localeTotalLabel = getLocale(locale).get(["waterfall", "total"]);
  if (total && typeof total.label !== "string" && localeTotalLabel) {
    params.options.total.label = localeTotalLabel;
  }
  return params;
}
function geometry$1(params) {
  var chart = params.chart, options = params.options;
  var data2 = options.data, xField = options.xField, yField = options.yField, total = options.total, leaderLine = options.leaderLine, columnWidthRatio = options.columnWidthRatio, waterfallStyle = options.waterfallStyle, risingFill = options.risingFill, fallingFill = options.fallingFill, color2 = options.color, shape = options.shape, customInfo = options.customInfo;
  chart.data(transformData(data2, xField, yField, total));
  var colorMapping = color2 || function(datum) {
    if (get(datum, [IS_TOTAL])) {
      return get(total, ["style", "fill"], "");
    }
    return get(datum, [Y_FIELD, 1]) - get(datum, [Y_FIELD, 0]) > 0 ? risingFill : fallingFill;
  };
  var p = deepAssign({}, params, {
    options: {
      xField,
      yField: Y_FIELD,
      seriesField: xField,
      rawFields: [yField, DIFF_FIELD, IS_TOTAL, Y_FIELD],
      widthRatio: columnWidthRatio,
      interval: {
        style: waterfallStyle,
        // 
        shape: shape || "waterfall",
        color: colorMapping
      }
    }
  });
  var ext = interval(p).ext;
  var geometry2 = ext.geometry;
  geometry2.customInfo(__assign$1(__assign$1({}, customInfo), { leaderLine }));
  return params;
}
function meta$1(params) {
  var _a2, _b;
  var options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField, meta2 = options.meta;
  var Y_FIELD_META = deepAssign({}, { alias: yField }, get(meta2, yField));
  return flow(scale$2((_a2 = {}, _a2[xField] = xAxis, _a2[yField] = yAxis, _a2[Y_FIELD] = yAxis, _a2), deepAssign({}, meta2, (_b = {}, _b[Y_FIELD] = Y_FIELD_META, _b[DIFF_FIELD] = Y_FIELD_META, _b[ABSOLUTE_FIELD] = Y_FIELD_META, _b))))(params);
}
function axis(params) {
  var chart = params.chart, options = params.options;
  var xAxis = options.xAxis, yAxis = options.yAxis, xField = options.xField, yField = options.yField;
  if (xAxis === false) {
    chart.axis(xField, false);
  } else {
    chart.axis(xField, xAxis);
  }
  if (yAxis === false) {
    chart.axis(yField, false);
    chart.axis(Y_FIELD, false);
  } else {
    chart.axis(yField, yAxis);
    chart.axis(Y_FIELD, yAxis);
  }
  return params;
}
function legend$1(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, total = options.total, risingFill = options.risingFill, fallingFill = options.fallingFill, locale = options.locale;
  var i18n = getLocale(locale);
  if (legend2 === false) {
    chart.legend(false);
  } else {
    var items = [
      {
        name: i18n.get(["general", "increase"]),
        value: "increase",
        marker: { symbol: "square", style: { r: 5, fill: risingFill } }
      },
      {
        name: i18n.get(["general", "decrease"]),
        value: "decrease",
        marker: { symbol: "square", style: { r: 5, fill: fallingFill } }
      }
    ];
    if (total) {
      items.push({
        name: total.label || "",
        value: "total",
        marker: {
          symbol: "square",
          style: deepAssign({}, { r: 5 }, get(total, "style"))
        }
      });
    }
    chart.legend(deepAssign({}, {
      custom: true,
      position: "top",
      items
    }, legend2));
    chart.removeInteraction("legend-filter");
  }
  return params;
}
function label(params) {
  var chart = params.chart, options = params.options;
  var label2 = options.label, labelMode = options.labelMode, xField = options.xField;
  var geometry2 = findGeometry(chart, "interval");
  if (!label2) {
    geometry2.label(false);
  } else {
    var callback = label2.callback, cfg = __rest(label2, ["callback"]);
    geometry2.label({
      fields: labelMode === "absolute" ? [ABSOLUTE_FIELD, xField] : [DIFF_FIELD, xField],
      callback,
      cfg: transformLabel(cfg)
    });
  }
  return params;
}
function tooltip(params) {
  var chart = params.chart, options = params.options;
  var tooltip2 = options.tooltip, xField = options.xField, yField = options.yField;
  if (tooltip2 !== false) {
    chart.tooltip(__assign$1({
      showCrosshairs: false,
      showMarkers: false,
      shared: true,
      // tooltip  y 
      fields: [yField]
    }, tooltip2));
    var geometry_1 = chart.geometries[0];
    (tooltip2 === null || tooltip2 === void 0 ? void 0 : tooltip2.formatter) ? geometry_1.tooltip("".concat(xField, "*").concat(yField), tooltip2.formatter) : geometry_1.tooltip(yField);
  } else {
    chart.tooltip(false);
  }
  return params;
}
function adaptor$1(params) {
  return flow(defaultOptions, theme$2, geometry$1, meta$1, axis, legend$1, tooltip, label, state, interaction$8, animation$5, annotation$2())(params);
}
(function(_super) {
  __extends$1(Waterfall, _super);
  function Waterfall() {
    var _this = _super !== null && _super.apply(this, arguments) || this;
    _this.type = "waterfall";
    return _this;
  }
  Waterfall.getDefaultOptions = function() {
    return DEFAULT_OPTIONS$2;
  };
  Waterfall.prototype.changeData = function(data2) {
    var _a2 = this.options, xField = _a2.xField, yField = _a2.yField, total = _a2.total;
    this.updateOption({ data: data2 });
    this.chart.changeData(transformData(data2, xField, yField, total));
  };
  Waterfall.prototype.getSchemaAdaptor = function() {
    return adaptor$1;
  };
  Waterfall.prototype.getDefaultOptions = function() {
    return Waterfall.getDefaultOptions();
  };
  return Waterfall;
})(Plot);
var WORD_CLOUD_COLOR_FIELD = "color";
var DEFAULT_OPTIONS$1 = deepAssign({}, Plot.getDefaultOptions(), {
  timeInterval: 2e3,
  legend: false,
  tooltip: {
    showTitle: false,
    showMarkers: false,
    showCrosshairs: false,
    fields: ["text", "value", WORD_CLOUD_COLOR_FIELD],
    formatter: function(datum) {
      return { name: datum.text, value: datum.value };
    }
  },
  wordStyle: {
    fontFamily: "Verdana",
    fontWeight: "normal",
    padding: 1,
    fontSize: [12, 60],
    rotation: [0, 90],
    rotationSteps: 2,
    rotateRatio: 0.5
  }
});
var DEFAULT_OPTIONS = {
  font: function() {
    return "serif";
  },
  padding: 1,
  size: [500, 500],
  spiral: "archimedean",
  // timeInterval: Infinity // max execute time
  timeInterval: 3e3
  // max execute time
  // imageMask: '', // instance of Image, must be loaded
};
function wordCloud(words, options) {
  options = mix({}, DEFAULT_OPTIONS, options);
  return transform$1(words, options);
}
function transform$1(words, options) {
  var layout2 = tagCloud();
  ["font", "fontSize", "fontWeight", "padding", "rotate", "size", "spiral", "timeInterval", "random"].forEach(function(key) {
    if (!isNil(options[key])) {
      layout2[key](options[key]);
    }
  });
  layout2.words(words);
  if (options.imageMask) {
    layout2.createMask(options.imageMask);
  }
  var result = layout2.start();
  var tags2 = result._tags;
  tags2.forEach(function(tag) {
    tag.x += options.size[0] / 2;
    tag.y += options.size[1] / 2;
  });
  var _a2 = options.size, w = _a2[0], h = _a2[1];
  tags2.push({
    text: "",
    value: 0,
    x: 0,
    y: 0,
    opacity: 0
  });
  tags2.push({
    text: "",
    value: 0,
    x: w,
    y: h,
    opacity: 0
  });
  return tags2;
}
var cloudRadians = Math.PI / 180, cw = 1 << 11 >> 5, ch = 1 << 11;
function cloudText(d) {
  return d.text;
}
function cloudFont() {
  return "serif";
}
function cloudFontNormal() {
  return "normal";
}
function cloudFontSize(d) {
  return d.value;
}
function cloudRotate() {
  return ~~(Math.random() * 2) * 90;
}
function cloudPadding() {
  return 1;
}
function cloudSprite(contextAndRatio, d, data2, di) {
  if (d.sprite)
    return;
  var c = contextAndRatio.context, ratio = contextAndRatio.ratio;
  c.clearRect(0, 0, (cw << 5) / ratio, ch / ratio);
  var x = 0, y = 0, maxh = 0;
  var n = data2.length;
  --di;
  while (++di < n) {
    d = data2[di];
    c.save();
    c.font = d.style + " " + d.weight + " " + ~~((d.size + 1) / ratio) + "px " + d.font;
    var w = c.measureText(d.text + "m").width * ratio, h = d.size << 1;
    if (d.rotate) {
      var sr = Math.sin(d.rotate * cloudRadians), cr = Math.cos(d.rotate * cloudRadians), wcr = w * cr, wsr = w * sr, hcr = h * cr, hsr = h * sr;
      w = Math.max(Math.abs(wcr + hsr), Math.abs(wcr - hsr)) + 31 >> 5 << 5;
      h = ~~Math.max(Math.abs(wsr + hcr), Math.abs(wsr - hcr));
    } else {
      w = w + 31 >> 5 << 5;
    }
    if (h > maxh)
      maxh = h;
    if (x + w >= cw << 5) {
      x = 0;
      y += maxh;
      maxh = 0;
    }
    if (y + h >= ch)
      break;
    c.translate((x + (w >> 1)) / ratio, (y + (h >> 1)) / ratio);
    if (d.rotate)
      c.rotate(d.rotate * cloudRadians);
    c.fillText(d.text, 0, 0);
    if (d.padding) {
      c.lineWidth = 2 * d.padding;
      c.strokeText(d.text, 0, 0);
    }
    c.restore();
    d.width = w;
    d.height = h;
    d.xoff = x;
    d.yoff = y;
    d.x1 = w >> 1;
    d.y1 = h >> 1;
    d.x0 = -d.x1;
    d.y0 = -d.y1;
    d.hasText = true;
    x += w;
  }
  var pixels = c.getImageData(0, 0, (cw << 5) / ratio, ch / ratio).data, sprite = [];
  while (--di >= 0) {
    d = data2[di];
    if (!d.hasText)
      continue;
    var w = d.width, w32 = w >> 5;
    var h = d.y1 - d.y0;
    for (var i = 0; i < h * w32; i++)
      sprite[i] = 0;
    x = d.xoff;
    if (x == null)
      return;
    y = d.yoff;
    var seen = 0, seenRow = -1;
    for (var j = 0; j < h; j++) {
      for (var i = 0; i < w; i++) {
        var k = w32 * j + (i >> 5), m = pixels[(y + j) * (cw << 5) + (x + i) << 2] ? 1 << 31 - i % 32 : 0;
        sprite[k] |= m;
        seen |= m;
      }
      if (seen)
        seenRow = j;
      else {
        d.y0++;
        h--;
        j--;
        y++;
      }
    }
    d.y1 = d.y0 + seenRow;
    d.sprite = sprite.slice(0, (d.y1 - d.y0) * w32);
  }
}
function cloudCollide(tag, board, sw) {
  sw >>= 5;
  var sprite = tag.sprite, w = tag.width >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
  var x = (tag.y + tag.y0) * sw + (lx >> 5), last2;
  for (var j = 0; j < h; j++) {
    last2 = 0;
    for (var i = 0; i <= w; i++) {
      if ((last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0)) & board[x + i])
        return true;
    }
    x += sw;
  }
  return false;
}
function cloudBounds(bounds, d) {
  var b02 = bounds[0], b12 = bounds[1];
  if (d.x + d.x0 < b02.x)
    b02.x = d.x + d.x0;
  if (d.y + d.y0 < b02.y)
    b02.y = d.y + d.y0;
  if (d.x + d.x1 > b12.x)
    b12.x = d.x + d.x1;
  if (d.y + d.y1 > b12.y)
    b12.y = d.y + d.y1;
}
function collideRects(a, b) {
  return a.x + a.x1 > b[0].x && a.x + a.x0 < b[1].x && a.y + a.y1 > b[0].y && a.y + a.y0 < b[1].y;
}
function archimedeanSpiral(size2) {
  var e = size2[0] / size2[1];
  return function(t) {
    return [e * (t *= 0.1) * Math.cos(t), t * Math.sin(t)];
  };
}
function rectangularSpiral(size2) {
  var dy = 4, dx = dy * size2[0] / size2[1];
  var x = 0, y = 0;
  return function(t) {
    var sign = t < 0 ? -1 : 1;
    switch (Math.sqrt(1 + 4 * sign * t) - sign & 3) {
      case 0:
        x += dx;
        break;
      case 1:
        y += dy;
        break;
      case 2:
        x -= dx;
        break;
      default:
        y -= dy;
        break;
    }
    return [x, y];
  };
}
function zeroArray(n) {
  var a = [];
  var i = -1;
  while (++i < n)
    a[i] = 0;
  return a;
}
function cloudCanvas() {
  return document.createElement("canvas");
}
function functor(d) {
  return isFunction(d) ? d : function() {
    return d;
  };
}
var spirals = {
  archimedean: archimedeanSpiral,
  rectangular: rectangularSpiral
};
function tagCloud() {
  var size2 = [256, 256], font = cloudFont, fontSize = cloudFontSize, fontWeight = cloudFontNormal, rotate2 = cloudRotate, padding2 = cloudPadding, spiral = archimedeanSpiral, random = Math.random, words = [], timeInterval = Infinity;
  var text2 = cloudText;
  var fontStyle = cloudFontNormal;
  var canvas = cloudCanvas;
  var cloud = {};
  cloud.start = function() {
    var width = size2[0], height = size2[1];
    var contextAndRatio = getContext(canvas()), board = cloud.board ? cloud.board : zeroArray((size2[0] >> 5) * size2[1]), n = words.length, tags2 = [], data2 = words.map(function(d, i2, data3) {
      d.text = text2.call(this, d, i2, data3);
      d.font = font.call(this, d, i2, data3);
      d.style = fontStyle.call(this, d, i2, data3);
      d.weight = fontWeight.call(this, d, i2, data3);
      d.rotate = rotate2.call(this, d, i2, data3);
      d.size = ~~fontSize.call(this, d, i2, data3);
      d.padding = padding2.call(this, d, i2, data3);
      return d;
    }).sort(function(a, b) {
      return b.size - a.size;
    });
    var i = -1, bounds = !cloud.board ? null : [
      {
        x: 0,
        y: 0
      },
      {
        x: width,
        y: height
      }
    ];
    step();
    function step() {
      var start = Date.now();
      while (Date.now() - start < timeInterval && ++i < n) {
        var d = data2[i];
        d.x = width * (random() + 0.5) >> 1;
        d.y = height * (random() + 0.5) >> 1;
        cloudSprite(contextAndRatio, d, data2, i);
        if (d.hasText && place2(board, d, bounds)) {
          tags2.push(d);
          if (bounds) {
            if (!cloud.hasImage) {
              cloudBounds(bounds, d);
            }
          } else {
            bounds = [
              { x: d.x + d.x0, y: d.y + d.y0 },
              { x: d.x + d.x1, y: d.y + d.y1 }
            ];
          }
          d.x -= size2[0] >> 1;
          d.y -= size2[1] >> 1;
        }
      }
      cloud._tags = tags2;
      cloud._bounds = bounds;
    }
    return cloud;
  };
  function getContext(canvas2) {
    canvas2.width = canvas2.height = 1;
    var ratio = Math.sqrt(canvas2.getContext("2d", { willReadFrequently: true }).getImageData(0, 0, 1, 1).data.length >> 2);
    canvas2.width = (cw << 5) / ratio;
    canvas2.height = ch / ratio;
    var context = canvas2.getContext("2d", { willReadFrequently: true });
    context.fillStyle = context.strokeStyle = "red";
    context.textAlign = "center";
    return { context, ratio };
  }
  function place2(board, tag, bounds) {
    var startX = tag.x, startY = tag.y, maxDelta = Math.sqrt(size2[0] * size2[0] + size2[1] * size2[1]), s = spiral(size2), dt = random() < 0.5 ? 1 : -1;
    var dxdy, t = -dt, dx, dy;
    while (dxdy = s(t += dt)) {
      dx = ~~dxdy[0];
      dy = ~~dxdy[1];
      if (Math.min(Math.abs(dx), Math.abs(dy)) >= maxDelta)
        break;
      tag.x = startX + dx;
      tag.y = startY + dy;
      if (tag.x + tag.x0 < 0 || tag.y + tag.y0 < 0 || tag.x + tag.x1 > size2[0] || tag.y + tag.y1 > size2[1])
        continue;
      if (!bounds || !cloudCollide(tag, board, size2[0])) {
        if (!bounds || collideRects(tag, bounds)) {
          var sprite = tag.sprite, w = tag.width >> 5, sw = size2[0] >> 5, lx = tag.x - (w << 4), sx = lx & 127, msx = 32 - sx, h = tag.y1 - tag.y0;
          var last2 = void 0, x = (tag.y + tag.y0) * sw + (lx >> 5);
          for (var j = 0; j < h; j++) {
            last2 = 0;
            for (var i = 0; i <= w; i++) {
              board[x + i] |= last2 << msx | (i < w ? (last2 = sprite[j * w + i]) >>> sx : 0);
            }
            x += sw;
          }
          delete tag.sprite;
          return true;
        }
      }
    }
    return false;
  }
  cloud.createMask = function(img) {
    var can = document.createElement("canvas");
    var width = size2[0], height = size2[1];
    if (!width || !height) {
      return;
    }
    var w32 = width >> 5;
    var board = zeroArray((width >> 5) * height);
    can.width = width;
    can.height = height;
    var cxt = can.getContext("2d");
    cxt.drawImage(img, 0, 0, img.width, img.height, 0, 0, width, height);
    var imageData = cxt.getImageData(0, 0, width, height).data;
    for (var j = 0; j < height; j++) {
      for (var i = 0; i < width; i++) {
        var k = w32 * j + (i >> 5);
        var tmp = j * width + i << 2;
        var flag = imageData[tmp] >= 250 && imageData[tmp + 1] >= 250 && imageData[tmp + 2] >= 250;
        var m = flag ? 1 << 31 - i % 32 : 0;
        board[k] |= m;
      }
    }
    cloud.board = board;
    cloud.hasImage = true;
  };
  cloud.timeInterval = function(_) {
    timeInterval = _ == null ? Infinity : _;
  };
  cloud.words = function(_) {
    words = _;
  };
  cloud.size = function(_) {
    size2 = [+_[0], +_[1]];
  };
  cloud.font = function(_) {
    font = functor(_);
  };
  cloud.fontWeight = function(_) {
    fontWeight = functor(_);
  };
  cloud.rotate = function(_) {
    rotate2 = functor(_);
  };
  cloud.spiral = function(_) {
    spiral = spirals[_] || _;
  };
  cloud.fontSize = function(_) {
    fontSize = functor(_);
  };
  cloud.padding = function(_) {
    padding2 = functor(_);
  };
  cloud.random = function(_) {
    random = functor(_);
  };
  return cloud;
}
function transform(params) {
  var rawOptions = params.options, chart = params.chart;
  var _a2 = chart, width = _a2.width, height = _a2.height, chartPadding = _a2.padding, appendPadding = _a2.appendPadding, ele = _a2.ele;
  var data2 = rawOptions.data, imageMask = rawOptions.imageMask, wordField = rawOptions.wordField, weightField = rawOptions.weightField, colorField = rawOptions.colorField, wordStyle = rawOptions.wordStyle, timeInterval = rawOptions.timeInterval, random = rawOptions.random, spiral = rawOptions.spiral, _b = rawOptions.autoFit, autoFit = _b === void 0 ? true : _b, placementStrategy = rawOptions.placementStrategy;
  if (!data2 || !data2.length) {
    return [];
  }
  var fontFamily = wordStyle.fontFamily, fontWeight = wordStyle.fontWeight, padding2 = wordStyle.padding, fontSize = wordStyle.fontSize;
  var arr = getSingleKeyValues(data2, weightField);
  var range = [min(arr), max(arr)];
  var words = data2.map(function(datum) {
    return {
      text: datum[wordField],
      value: datum[weightField],
      color: datum[colorField],
      datum
    };
  });
  var options = {
    imageMask,
    font: fontFamily,
    fontSize: getFontSizeMapping(fontSize, range),
    fontWeight,
    //  padding 
    size: getSize({
      width,
      height,
      padding: chartPadding,
      appendPadding,
      autoFit,
      container: ele
    }),
    padding: padding2,
    timeInterval,
    random,
    spiral,
    rotate: getRotate(rawOptions)
  };
  if (isFunction(placementStrategy)) {
    var result = words.map(function(word2, index2, words2) {
      return __assign$1(__assign$1(__assign$1({}, word2), { hasText: !!word2.text, font: functor(options.font)(word2, index2, words2), weight: functor(options.fontWeight)(word2, index2, words2), rotate: functor(options.rotate)(word2, index2, words2), size: functor(options.fontSize)(word2, index2, words2), style: "normal" }), placementStrategy.call(chart, word2, index2, words2));
    });
    result.push({
      text: "",
      value: 0,
      x: 0,
      y: 0,
      opacity: 0
    });
    result.push({
      text: "",
      value: 0,
      x: options.size[0],
      y: options.size[1],
      opacity: 0
    });
    return result;
  }
  return wordCloud(words, options);
}
function getSize(options) {
  var width = options.width, height = options.height;
  var container = options.container, autoFit = options.autoFit, padding2 = options.padding, appendPadding = options.appendPadding;
  if (autoFit) {
    var containerSize = getContainerSize(container);
    width = containerSize.width;
    height = containerSize.height;
  }
  width = width || 400;
  height = height || 400;
  var _a2 = resolvePadding({ padding: padding2, appendPadding }), top = _a2[0], right2 = _a2[1], bottom = _a2[2], left2 = _a2[3];
  var result = [width - (left2 + right2), height - (top + bottom)];
  return result;
}
function resolvePadding(options) {
  var padding2 = normalPadding(options.padding);
  var appendPadding = normalPadding(options.appendPadding);
  var top = padding2[0] + appendPadding[0];
  var right2 = padding2[1] + appendPadding[1];
  var bottom = padding2[2] + appendPadding[2];
  var left2 = padding2[3] + appendPadding[3];
  return [top, right2, bottom, left2];
}
function processImageMask(img) {
  return new Promise(function(res, rej) {
    if (img instanceof HTMLImageElement) {
      res(img);
      return;
    }
    if (isString(img)) {
      var image_1 = new Image();
      image_1.crossOrigin = "anonymous";
      image_1.src = img;
      image_1.onload = function() {
        res(image_1);
      };
      image_1.onerror = function() {
        log(LEVEL.ERROR, false, "image %s load failed !!!", img);
        rej();
      };
      return;
    }
    log(LEVEL.WARN, img === void 0, "The type of imageMask option must be String or HTMLImageElement.");
    rej();
  });
}
function getFontSizeMapping(fontSize, range) {
  if (isFunction(fontSize)) {
    return fontSize;
  }
  if (isArray$1(fontSize)) {
    var fMin_1 = fontSize[0], fMax_1 = fontSize[1];
    if (!range) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    var min_1 = range[0], max_1 = range[1];
    if (max_1 === min_1) {
      return function() {
        return (fMax_1 + fMin_1) / 2;
      };
    }
    return function fontSize2(_a2) {
      var value2 = _a2.value;
      return (fMax_1 - fMin_1) / (max_1 - min_1) * (value2 - min_1) + fMin_1;
    };
  }
  return function() {
    return fontSize;
  };
}
function getSingleKeyValues(data2, key) {
  return data2.map(function(v) {
    return v[key];
  }).filter(function(v) {
    if (typeof v === "number" && !isNaN(v))
      return true;
    return false;
  });
}
function getRotate(options) {
  var _a2 = resolveRotate(options), rotation = _a2.rotation, rotationSteps = _a2.rotationSteps;
  if (!isArray$1(rotation))
    return rotation;
  var min2 = rotation[0];
  var max2 = rotation[1];
  var perSize = rotationSteps === 1 ? 0 : (max2 - min2) / (rotationSteps - 1);
  return function rotate2() {
    if (max2 === min2)
      return max2;
    return Math.floor(Math.random() * rotationSteps) * perSize;
  };
}
function resolveRotate(options) {
  var rotationSteps = options.wordStyle.rotationSteps;
  if (rotationSteps < 1) {
    log(LEVEL.WARN, false, "The rotationSteps option must be greater than or equal to 1.");
    rotationSteps = 1;
  }
  return {
    rotation: options.wordStyle.rotation,
    rotationSteps
  };
}
function min(numbers) {
  return Math.min.apply(Math, numbers);
}
function max(numbers) {
  return Math.max.apply(Math, numbers);
}
function geometry(params) {
  var chart = params.chart, options = params.options;
  var colorField = options.colorField, color2 = options.color;
  var data2 = transform(params);
  chart.data(data2);
  var p = deepAssign({}, params, {
    options: {
      xField: "x",
      yField: "y",
      seriesField: colorField && WORD_CLOUD_COLOR_FIELD,
      rawFields: isFunction(color2) && __spreadArray$1(__spreadArray$1([], get(options, "rawFields", []), true), ["datum"], false),
      point: {
        color: color2,
        shape: "word-cloud"
      }
    }
  });
  var ext = point(p).ext;
  ext.geometry.label(false);
  chart.coordinate().reflect("y");
  chart.axis(false);
  return params;
}
function meta(params) {
  return flow(scale$2({
    x: { nice: false },
    y: { nice: false }
  }))(params);
}
function legend(params) {
  var chart = params.chart, options = params.options;
  var legend2 = options.legend, colorField = options.colorField;
  if (legend2 === false) {
    chart.legend(false);
  } else if (colorField) {
    chart.legend(WORD_CLOUD_COLOR_FIELD, legend2);
  }
  return params;
}
function adaptor(params) {
  flow(geometry, meta, tooltip$9, legend, interaction$8, animation$5, theme$2, state)(params);
}
registerShape("point", "word-cloud", {
  draw: function(cfg, group2) {
    var cx = cfg.x;
    var cy = cfg.y;
    var shape = group2.addShape("text", {
      attrs: __assign$1(__assign$1({}, getTextAttrs(cfg)), { x: cx, y: cy })
    });
    var rotate2 = cfg.data.rotate;
    if (typeof rotate2 === "number") {
      Util.rotate(shape, rotate2 * Math.PI / 180);
    }
    return shape;
  }
});
function getTextAttrs(cfg) {
  return {
    fontSize: cfg.data.size,
    text: cfg.data.text,
    textAlign: "center",
    fontFamily: cfg.data.font,
    fontWeight: cfg.data.weight,
    fill: cfg.color || cfg.defaultStyle.stroke,
    textBaseline: "alphabetic"
  };
}
var WordCloud = (
  /** @class */
  function(_super) {
    __extends$1(WordCloud2, _super);
    function WordCloud2() {
      var _this = _super !== null && _super.apply(this, arguments) || this;
      _this.type = "word-cloud";
      return _this;
    }
    WordCloud2.getDefaultOptions = function() {
      return DEFAULT_OPTIONS$1;
    };
    WordCloud2.prototype.changeData = function(data2) {
      this.updateOption({ data: data2 });
      if (this.options.imageMask) {
        this.render();
      } else {
        this.chart.changeData(transform({ chart: this.chart, options: this.options }));
      }
    };
    WordCloud2.prototype.getDefaultOptions = function() {
      return WordCloud2.getDefaultOptions();
    };
    WordCloud2.prototype.render = function() {
      var _this = this;
      return new Promise(function(res) {
        var imageMask = _this.options.imageMask;
        if (!imageMask) {
          _super.prototype.render.call(_this);
          res();
          return;
        }
        var handler = function(img) {
          _this.options = __assign$1(__assign$1({}, _this.options), { imageMask: img || null });
          _super.prototype.render.call(_this);
          res();
        };
        processImageMask(imageMask).then(handler).catch(handler);
      });
    };
    WordCloud2.prototype.getSchemaAdaptor = function() {
      return adaptor;
    };
    WordCloud2.prototype.triggerResize = function() {
      var _this = this;
      if (!this.chart.destroyed) {
        this.execAdaptor();
        window.setTimeout(function() {
          _super.prototype.triggerResize.call(_this);
        });
      }
    };
    return WordCloud2;
  }(Plot)
);
(function(_super) {
  __extends$1(P, _super);
  function P(container, options, adaptor2, defaultOptions2) {
    var _this = _super.call(this, container, deepAssign({}, defaultOptions2, options)) || this;
    _this.type = "g2-plot";
    _this.defaultOptions = defaultOptions2;
    _this.adaptor = adaptor2;
    return _this;
  }
  P.prototype.getDefaultOptions = function() {
    return this.defaultOptions;
  };
  P.prototype.getSchemaAdaptor = function() {
    return this.adaptor;
  };
  return P;
})(Plot);
registerLocale("en-US", EN_US_LOCALE);
registerLocale("zh-CN", ZH_CN_LOCALE);
const _hoisted_1$1 = { id: "wordcloud-container" };
const _sfc_main$2 = /* @__PURE__ */ defineComponent({
  __name: "WordCloud",
  props: {
    dataList: {
      type: Array,
      default: () => []
    }
  },
  setup(__props) {
    const props = __props;
    let wordCloud2;
    onMounted(() => {
      wordCloud2 = new WordCloud("wordcloud-container", {
        data: props.dataList,
        wordField: "name",
        weightField: "value",
        colorField: "name",
        wordStyle: {
          fontFamily: "Verdana",
          fontSize: [14, 35],
          rotation: 0
        },
        //  [0, 1) 
        // 
        random: () => 0.5
      });
      wordCloud2.render();
    });
    onBeforeUnmount(() => {
      wordCloud2.destroy();
    });
    return (_ctx, _cache) => {
      return openBlock(), createElementBlock("div", _hoisted_1$1);
    };
  }
});
var md5$1 = { exports: {} };
(function(module) {
  (function($) {
    function safeAdd(x, y) {
      var lsw = (x & 65535) + (y & 65535);
      var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
      return msw << 16 | lsw & 65535;
    }
    function bitRotateLeft(num, cnt) {
      return num << cnt | num >>> 32 - cnt;
    }
    function md5cmn(q, a, b, x, s, t) {
      return safeAdd(bitRotateLeft(safeAdd(safeAdd(a, q), safeAdd(x, t)), s), b);
    }
    function md5ff(a, b, c, d, x, s, t) {
      return md5cmn(b & c | ~b & d, a, b, x, s, t);
    }
    function md5gg(a, b, c, d, x, s, t) {
      return md5cmn(b & d | c & ~d, a, b, x, s, t);
    }
    function md5hh(a, b, c, d, x, s, t) {
      return md5cmn(b ^ c ^ d, a, b, x, s, t);
    }
    function md5ii(a, b, c, d, x, s, t) {
      return md5cmn(c ^ (b | ~d), a, b, x, s, t);
    }
    function binlMD5(x, len) {
      x[len >> 5] |= 128 << len % 32;
      x[(len + 64 >>> 9 << 4) + 14] = len;
      var i;
      var olda;
      var oldb;
      var oldc;
      var oldd;
      var a = 1732584193;
      var b = -271733879;
      var c = -1732584194;
      var d = 271733878;
      for (i = 0; i < x.length; i += 16) {
        olda = a;
        oldb = b;
        oldc = c;
        oldd = d;
        a = md5ff(a, b, c, d, x[i], 7, -680876936);
        d = md5ff(d, a, b, c, x[i + 1], 12, -389564586);
        c = md5ff(c, d, a, b, x[i + 2], 17, 606105819);
        b = md5ff(b, c, d, a, x[i + 3], 22, -1044525330);
        a = md5ff(a, b, c, d, x[i + 4], 7, -176418897);
        d = md5ff(d, a, b, c, x[i + 5], 12, 1200080426);
        c = md5ff(c, d, a, b, x[i + 6], 17, -1473231341);
        b = md5ff(b, c, d, a, x[i + 7], 22, -45705983);
        a = md5ff(a, b, c, d, x[i + 8], 7, 1770035416);
        d = md5ff(d, a, b, c, x[i + 9], 12, -1958414417);
        c = md5ff(c, d, a, b, x[i + 10], 17, -42063);
        b = md5ff(b, c, d, a, x[i + 11], 22, -1990404162);
        a = md5ff(a, b, c, d, x[i + 12], 7, 1804603682);
        d = md5ff(d, a, b, c, x[i + 13], 12, -40341101);
        c = md5ff(c, d, a, b, x[i + 14], 17, -1502002290);
        b = md5ff(b, c, d, a, x[i + 15], 22, 1236535329);
        a = md5gg(a, b, c, d, x[i + 1], 5, -165796510);
        d = md5gg(d, a, b, c, x[i + 6], 9, -1069501632);
        c = md5gg(c, d, a, b, x[i + 11], 14, 643717713);
        b = md5gg(b, c, d, a, x[i], 20, -373897302);
        a = md5gg(a, b, c, d, x[i + 5], 5, -701558691);
        d = md5gg(d, a, b, c, x[i + 10], 9, 38016083);
        c = md5gg(c, d, a, b, x[i + 15], 14, -660478335);
        b = md5gg(b, c, d, a, x[i + 4], 20, -405537848);
        a = md5gg(a, b, c, d, x[i + 9], 5, 568446438);
        d = md5gg(d, a, b, c, x[i + 14], 9, -1019803690);
        c = md5gg(c, d, a, b, x[i + 3], 14, -187363961);
        b = md5gg(b, c, d, a, x[i + 8], 20, 1163531501);
        a = md5gg(a, b, c, d, x[i + 13], 5, -1444681467);
        d = md5gg(d, a, b, c, x[i + 2], 9, -51403784);
        c = md5gg(c, d, a, b, x[i + 7], 14, 1735328473);
        b = md5gg(b, c, d, a, x[i + 12], 20, -1926607734);
        a = md5hh(a, b, c, d, x[i + 5], 4, -378558);
        d = md5hh(d, a, b, c, x[i + 8], 11, -2022574463);
        c = md5hh(c, d, a, b, x[i + 11], 16, 1839030562);
        b = md5hh(b, c, d, a, x[i + 14], 23, -35309556);
        a = md5hh(a, b, c, d, x[i + 1], 4, -1530992060);
        d = md5hh(d, a, b, c, x[i + 4], 11, 1272893353);
        c = md5hh(c, d, a, b, x[i + 7], 16, -155497632);
        b = md5hh(b, c, d, a, x[i + 10], 23, -1094730640);
        a = md5hh(a, b, c, d, x[i + 13], 4, 681279174);
        d = md5hh(d, a, b, c, x[i], 11, -358537222);
        c = md5hh(c, d, a, b, x[i + 3], 16, -722521979);
        b = md5hh(b, c, d, a, x[i + 6], 23, 76029189);
        a = md5hh(a, b, c, d, x[i + 9], 4, -640364487);
        d = md5hh(d, a, b, c, x[i + 12], 11, -421815835);
        c = md5hh(c, d, a, b, x[i + 15], 16, 530742520);
        b = md5hh(b, c, d, a, x[i + 2], 23, -995338651);
        a = md5ii(a, b, c, d, x[i], 6, -198630844);
        d = md5ii(d, a, b, c, x[i + 7], 10, 1126891415);
        c = md5ii(c, d, a, b, x[i + 14], 15, -1416354905);
        b = md5ii(b, c, d, a, x[i + 5], 21, -57434055);
        a = md5ii(a, b, c, d, x[i + 12], 6, 1700485571);
        d = md5ii(d, a, b, c, x[i + 3], 10, -1894986606);
        c = md5ii(c, d, a, b, x[i + 10], 15, -1051523);
        b = md5ii(b, c, d, a, x[i + 1], 21, -2054922799);
        a = md5ii(a, b, c, d, x[i + 8], 6, 1873313359);
        d = md5ii(d, a, b, c, x[i + 15], 10, -30611744);
        c = md5ii(c, d, a, b, x[i + 6], 15, -1560198380);
        b = md5ii(b, c, d, a, x[i + 13], 21, 1309151649);
        a = md5ii(a, b, c, d, x[i + 4], 6, -145523070);
        d = md5ii(d, a, b, c, x[i + 11], 10, -1120210379);
        c = md5ii(c, d, a, b, x[i + 2], 15, 718787259);
        b = md5ii(b, c, d, a, x[i + 9], 21, -343485551);
        a = safeAdd(a, olda);
        b = safeAdd(b, oldb);
        c = safeAdd(c, oldc);
        d = safeAdd(d, oldd);
      }
      return [a, b, c, d];
    }
    function binl2rstr(input) {
      var i;
      var output2 = "";
      var length32 = input.length * 32;
      for (i = 0; i < length32; i += 8) {
        output2 += String.fromCharCode(input[i >> 5] >>> i % 32 & 255);
      }
      return output2;
    }
    function rstr2binl(input) {
      var i;
      var output2 = [];
      output2[(input.length >> 2) - 1] = void 0;
      for (i = 0; i < output2.length; i += 1) {
        output2[i] = 0;
      }
      var length8 = input.length * 8;
      for (i = 0; i < length8; i += 8) {
        output2[i >> 5] |= (input.charCodeAt(i / 8) & 255) << i % 32;
      }
      return output2;
    }
    function rstrMD5(s) {
      return binl2rstr(binlMD5(rstr2binl(s), s.length * 8));
    }
    function rstrHMACMD5(key, data2) {
      var i;
      var bkey = rstr2binl(key);
      var ipad = [];
      var opad = [];
      var hash;
      ipad[15] = opad[15] = void 0;
      if (bkey.length > 16) {
        bkey = binlMD5(bkey, key.length * 8);
      }
      for (i = 0; i < 16; i += 1) {
        ipad[i] = bkey[i] ^ 909522486;
        opad[i] = bkey[i] ^ 1549556828;
      }
      hash = binlMD5(ipad.concat(rstr2binl(data2)), 512 + data2.length * 8);
      return binl2rstr(binlMD5(opad.concat(hash), 512 + 128));
    }
    function rstr2hex(input) {
      var hexTab = "0123456789abcdef";
      var output2 = "";
      var x;
      var i;
      for (i = 0; i < input.length; i += 1) {
        x = input.charCodeAt(i);
        output2 += hexTab.charAt(x >>> 4 & 15) + hexTab.charAt(x & 15);
      }
      return output2;
    }
    function str2rstrUTF8(input) {
      return unescape(encodeURIComponent(input));
    }
    function rawMD5(s) {
      return rstrMD5(str2rstrUTF8(s));
    }
    function hexMD5(s) {
      return rstr2hex(rawMD5(s));
    }
    function rawHMACMD5(k, d) {
      return rstrHMACMD5(str2rstrUTF8(k), str2rstrUTF8(d));
    }
    function hexHMACMD5(k, d) {
      return rstr2hex(rawHMACMD5(k, d));
    }
    function md52(string2, key, raw) {
      if (!key) {
        if (!raw) {
          return hexMD5(string2);
        }
        return rawMD5(string2);
      }
      if (!raw) {
        return hexHMACMD5(key, string2);
      }
      return rawHMACMD5(key, string2);
    }
    if (module.exports) {
      module.exports = md52;
    } else {
      $.md5 = md52;
    }
  })(commonjsGlobal);
})(md5$1);
var md5Exports = md5$1.exports;
const md5 = /* @__PURE__ */ getDefaultExportFromCjs(md5Exports);
const _withScopeId = (n) => (pushScopeId("data-v-58bf2852"), n = n(), popScopeId(), n);
const _hoisted_1 = { class: "main-container-tag" };
const _hoisted_2 = { class: "tag-header-wrapper" };
const _hoisted_3 = { class: "tag-breadcrumb-icon" };
const _hoisted_4 = {
  role: "img",
  viewBox: "0 0 1024 1024",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  width: "1em",
  height: "1em",
  class: "larkui-icon icon-svg index-module_size_wVASz",
  style: { "width": "16px", "min-width": "16px", "height": "16px" }
};
const _hoisted_5 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("defs", null, null, -1));
const _hoisted_6 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("path", { d: "M527.744 32c20.8 0.192 40.32 8.32 55.04 23.04l386.112 386.24c14.912 14.848 23.104 34.56 23.104 55.68 0 20.992-8.192 40.704-23.04 55.552l-416.512 416.512c-14.784 14.784-34.624 22.976-55.68 22.976a78.08 78.08 0 0 1-55.616-23.04L55.104 582.784A78.272 78.272 0 0 1 32 527.552V110.72C32 67.2 67.2 32 110.72 32h417.024zM267.136 267.136a128.064 128.064 0 1 0 181.184 181.12 128.064 128.064 0 0 0-181.184-181.12z" }, null, -1));
const _hoisted_7 = [
  _hoisted_5,
  _hoisted_6
];
const _hoisted_8 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("span", { class: "tag-breadcrumb-item" }, "", -1));
const _hoisted_9 = { class: "tag-title" };
const _hoisted_10 = { class: "result-item" };
const _hoisted_11 = { class: "result-item-title" };
const _hoisted_12 = ["href"];
const _hoisted_13 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("p", { class: "result-item-description" }, null, -1));
const _hoisted_14 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("svg", {
  role: "img",
  xmlns: "http://www.w3.org/2000/svg",
  "xmlns:xlink": "http://www.w3.org/1999/xlink",
  viewBox: "0 0 480 480"
}, [
  /* @__PURE__ */ createBaseVNode("defs", null, [
    /* @__PURE__ */ createBaseVNode("linearGradient", {
      id: "a",
      x1: "1.128",
      y1: "0.988",
      x2: "0.364",
      y2: "1",
      gradientUnits: "objectBoundingBox"
    }, [
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "0",
        "stop-color": "#e0e5ef",
        "stop-opacity": "0"
      }),
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "1",
        "stop-color": "#e0e5ef"
      })
    ]),
    /* @__PURE__ */ createBaseVNode("linearGradient", {
      id: "c",
      x1: "1",
      y1: "0.5",
      x2: "0.112",
      y2: "1.125",
      gradientUnits: "objectBoundingBox"
    }, [
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "0",
        "stop-color": "#fff",
        "stop-opacity": "0"
      }),
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "1",
        "stop-color": "#747f95"
      })
    ]),
    /* @__PURE__ */ createBaseVNode("linearGradient", {
      id: "d",
      x1: "-0.392",
      y1: "1.114",
      x2: "0.5",
      y2: "0.396",
      gradientUnits: "objectBoundingBox"
    }, [
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "0",
        "stop-color": "#fff",
        "stop-opacity": "0"
      }),
      /* @__PURE__ */ createBaseVNode("stop", {
        offset: "1",
        "stop-color": "#ebedf5"
      })
    ]),
    /* @__PURE__ */ createBaseVNode("linearGradient", {
      id: "e",
      x1: "-0.906",
      y1: "1.646",
      x2: "0.636",
      y2: "0.061",
      "xlink:href": "#d"
    }),
    /* @__PURE__ */ createBaseVNode("linearGradient", {
      id: "f",
      x1: "-0.109",
      y1: "1.931",
      x2: "0.736",
      y2: "0.141",
      "xlink:href": "#d"
    })
  ]),
  /* @__PURE__ */ createBaseVNode("g", { transform: "translate(-135 -375)" }, [
    /* @__PURE__ */ createBaseVNode("circle", {
      cx: "184",
      cy: "184",
      r: "184",
      transform: "translate(191 443)",
      fill: "#f3f3fa"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M2925,350h0c-8.837,0-16-32.235-16-72s7.163-72,16-72c.038,0,11.813.471,18.75-7.529s9-14.486,9-24.469c0-34.257,14.681-58.6,28.25-63.313,3.909-.688,10,.818,16-4.354s8-9.372,8-16.333c0-37.555,12.536-68,28-68s28,30.445,28,68c0,6.961-.667,10.328,5.333,15.5s14.76,4.5,18.667,5.187c13.569,4.714,24,33.055,24,67.312a101.212,101.212,0,0,0,2.333,20s4.485,11.842,11,5.5,9.13-14.885,10.25-22.871C3135.767,157.923,3142.61,142,3149,142c6.519,0,12.127,16.566,14.645,40.566.741,7.066,2.2,11.743,6.521,17.6A14.3,14.3,0,0,0,3180.92,206H3181c6.488,0,12.073,16.409,14.617,40.308.5,4.725.982,7.6,5.3,11.527S3212.884,262,3212.884,262l.116,0c2.16,0,4.255,1.8,6.228,5.344a58.6,58.6,0,0,1,5.086,14.573C3227.336,294.758,3229,311.835,3229,330c0,6.817-.237,13.546-.7,20H2925Zm303.3,0h0Z",
      transform: "translate(-2718 397)",
      fill: "url(#a)"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M117,208H.7c-.466-6.453-.7-13.181-.7-20,0-18.163,1.664-35.24,4.686-48.083a58.6,58.6,0,0,1,5.086-14.573C11.745,121.8,13.84,120,16,120l.116,0s7.651-.242,11.967-4.166,4.8-6.8,5.3-11.527C35.927,80.408,41.513,64,48,64a16.6,16.6,0,0,0,3.3-1.014A6.153,6.153,0,0,0,53.365,61.5c6.515-6.342,9.13-14.884,10.25-22.871C66.8,15.924,73.642,0,80.032,0,86.55,0,92.158,16.566,94.676,40.567c.742,7.065,2.2,11.742,6.521,17.6A14.3,14.3,0,0,0,111.951,64h.081c6.487,0,12.073,16.409,14.617,40.307.5,4.725.983,7.6,5.3,11.527S143.915,120,143.915,120l.116,0c2.16,0,4.255,1.8,6.228,5.344a58.6,58.6,0,0,1,5.086,14.573c3.022,12.844,4.686,29.921,4.686,48.083,0,6.818-.237,13.546-.7,20H117Zm42.328,0h0ZM.7,208h0Z",
      transform: "translate(350.969 539)",
      fill: "url(#a)"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M2989,62c-10.838-4.087-16.3,0-32,0-26.51,0-48-8.954-48-20s21.49-20,48-20h256a16,16,0,1,1,0,32s-15.5,0-27.5,3S3165,68.714,3165,68.714,3127.392,110,3081,110c-38.041,0-70.176-13.246-80.647-31.653C2998.219,74.6,2999.838,66.087,2989,62Z",
      transform: "translate(-2702 701)",
      fill: "#d1d6e2"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M-2493,98s-56.355,45.651-64,16,74.25-17.75-16,72",
      transform: "translate(3044 409)",
      fill: "none",
      stroke: "#909aa9",
      "stroke-linecap": "round",
      "stroke-width": "2",
      "stroke-dasharray": "10"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M4,2.2C7.15-.75,16,0,16,0s-1.5,4-2.6,8-.232,5.942-1.8,8C7.6,21.25,0,21,0,21s.75-3.4,2-8S.85,5.15,4,2.2Z",
      transform: "translate(447 603.085)",
      fill: "#909aa9"
    }),
    /* @__PURE__ */ createBaseVNode("ellipse", {
      cx: "10",
      cy: "4",
      rx: "10",
      ry: "4",
      transform: "translate(294 787)",
      fill: "url(#c)"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M8.44,24s8.115-6,6.94-10S11.51,9.625,9.775,6.125A11.222,11.222,0,0,1,8.44,0S1.767,2.625,1.5,9.375C1.38,12.419,4.436,14.344,6.171,18A32.451,32.451,0,0,1,8.44,24Z",
      transform: "translate(287 794.497) rotate(-90)",
      fill: "#909aa9"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M0,0,57,4.5,136,0l31.5,12,17,10-37,8.5-24.5-5-58,5L4,23Z",
      transform: "translate(191 699)",
      fill: "#fff"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M-1.4,1.2,60,9l58.75-5.25L143,9l36-9V24.5L144.4,29l-16.2-7.25L95.6,23l-5.1,1.5L67.2,21.75,5,23.25S2.8,16.713,1.2,11.2-1.4,1.2-1.4,1.2Z",
      transform: "translate(196 720)",
      fill: "#eceff5"
    }),
    /* @__PURE__ */ createBaseVNode("ellipse", {
      cx: "43",
      cy: "9.5",
      rx: "43",
      ry: "9.5",
      transform: "translate(253 701)",
      fill: "#ebedf5"
    }),
    /* @__PURE__ */ createBaseVNode("g", { transform: "translate(63 354)" }, [
      /* @__PURE__ */ createBaseVNode("g", { transform: "translate(258.49 305.55)" }, [
        /* @__PURE__ */ createBaseVNode("path", {
          d: "M525.021,66.584a31.23,31.23,0,0,1,7.085,10.425c2.772,6.6,5.877,13.459,8.386,14.78s3.695,10.033-8.053,8.185S525.021,66.584,525.021,66.584Z",
          transform: "translate(-524.241 -66.584)",
          fill: "#fff"
        }),
        /* @__PURE__ */ createBaseVNode("path", {
          d: "M525.494,68.3a32.341,32.341,0,0,1,6.953,16.851c.847,8.628,2.933,13.332,5.151,13.016a12.659,12.659,0,0,1-5.991-.025C528.092,97.37,524.074,68.412,525.494,68.3Z",
          transform: "translate(-523.763 -65.64)",
          fill: "url(#d)"
        })
      ]),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M537.949,131.675a34.415,34.415,0,0,0,14.137,1.09c6.9-.975,8.727-13.747-.647-15.059-7.267-1.02-6.026-12.167-7.366-22.433s-6.56-18.848-7.364-23.026,4.251-9.233,3.614-18.062c-.652-9.065-6.3-10.479-8.307-10.074s-3.609,2.392-6.154,3.47-6.292-.673-11.112,1.619-9.377,7.547-9.377,7.547c-2.009,2.561.4,10.648-.938,14.691s-6.694,39.223-6.56,49.062,6.426,16.715,19.952,18.467,19.419-.606,19.856-4.448c.279-2.443,1.905-11.053-7.8-12.535-4.83-.74-7.363-1.347-7.363-1.347",
        transform: "translate(-279.872 225.445)",
        fill: "#fff"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M519.206,44.961s.961-1.578,1.726-1.594c1.313-.026,2.7,1.631,2.7,1.631S519.249,46.731,519.206,44.961Z",
        transform: "translate(-268.363 226.187)",
        fill: "#757f95"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M522.077,37.922c-2.054-.536-2.278,2.085-2.278,2.085s-2.89-.313-2.6,1.743c.357,2.566,5.831,2.443,5.831,2.443S524.583,38.578,522.077,37.922Z",
        transform: "translate(-269.464 223.151)",
        fill: "#757f95"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M505.743,52.715s-6.088-1.338-6.755,3.318,4.181,7.509,7.656.6",
        transform: "translate(-279.292 231.235)",
        fill: "#fff"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M503.084,74.624s-1.45,17.9,1.1,22.385c2.3,4.044,10.662,5.138,16.755,4.63a25.038,25.038,0,0,0,6.013-1.246c6.068-2.157,2.831-6.2,0-8.893s-3.738-10.346-8.593-14.5",
        transform: "translate(-276.501 243.626)",
        fill: "url(#e)"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M514.078,48.635a.6.6,0,0,0-.522.31v0l-.009.014a4.814,4.814,0,0,1-3.228,2.322l-.019,0,0,0a.6.6,0,0,0-.509.5l-.011,0-.406,1.078s.341-.014.842-.088l.057-.307.11-.584v.865c.188-.031.389-.073.6-.121v-.747l.064.454.037.268a5.609,5.609,0,0,0,2.386-1.138,4.083,4.083,0,0,0,1.152-1.977c.04-.155.054-.248.054-.248A.6.6,0,0,0,514.078,48.635Z",
        transform: "translate(-273.668 229.087)",
        fill: "#757f95"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M531.516,76.393c-3.6-3.507-6.766.555-6.766.555s-6.2-4.888-8.5.26C513.373,83.63,528.051,94,528.051,94S535.2,79.982,531.516,76.393Z",
        transform: "translate(-270.216 243.516)",
        fill: "url(#f)"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M504.118,75.051s5.02,15.274,7.571,19.76c3.236,5.688,9.468,8.51,15.533,6.355s2.831-5.527,0-8.223S523.148,81.155,518.293,77",
        transform: "translate(-277.496 242.564)",
        fill: "#fff"
      })
    ]),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M0,9.833l18-9.5,2.667,4v8.2L13,18,8.167,12.532,0,13.671Z",
      transform: "translate(377 777)",
      fill: "#eceff5"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M4,3.167,18,0V10l-5,3.167-4.833-4L0,10Z",
      transform: "translate(377 777)",
      fill: "#fff"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M-.211,18.893,16,12l.246,14.107-2.084,4.646L0,31Z",
      transform: "matrix(1, 0.017, -0.017, 1, 400.376, 734.864)",
      fill: "#eceff5"
    }),
    /* @__PURE__ */ createBaseVNode("path", {
      d: "M9.75,12H16l-3.75,7H0Z",
      transform: "translate(400 735)",
      fill: "#fff"
    }),
    /* @__PURE__ */ createBaseVNode("g", { transform: "translate(447 690)" }, [
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M97,0,63.923,4.5,24.316,0,8.523,12,0,22l18.55,8.5,12.283-5,29.079,5,23.488-5,6.467-12.126Z",
        transform: "translate(-1 12)",
        fill: "#fff"
      }),
      /* @__PURE__ */ createBaseVNode("path", {
        d: "M81.149.607l-28.1,3.945L26.17,1.9l-11.1,2.655L-2.651-1.333V12.391l17.083,2.276L21.846,11l14.917.632,2.334.759L49.759,11l28.991,1.391s-1.4-1.778,0-4.724A43.992,43.992,0,0,0,81.149.607Z",
        transform: "translate(1.651 35.333)",
        fill: "#eceff5"
      })
    ])
  ])
], -1));
const _hoisted_15 = /* @__PURE__ */ _withScopeId(() => /* @__PURE__ */ createBaseVNode("p", null, "", -1));
const _sfc_main$1 = /* @__PURE__ */ defineComponent({
  __name: "Tag",
  setup(__props) {
    const tags2 = computed(() => initTags(data$2));
    function initTags(articleData2) {
      const tags22 = {};
      for (let i = 0; i < articleData2.length; i++) {
        const article = articleData2[i];
        const articleTags = article.tags;
        if (Array.isArray(articleTags)) {
          articleTags.forEach((articleTag) => {
            if (!tags22[articleTag]) {
              tags22[articleTag] = [];
            }
            tags22[articleTag].push(article);
            tags22[articleTag].sort((a, b) => b.date.localeCompare(a.date));
          });
        }
      }
      return tags22;
    }
    let selectTag = ref("");
    const toggleTag = (tagTitle) => {
      if (selectTag.value && selectTag.value == tagTitle) {
        selectTag.value = null;
      } else {
        selectTag.value = tagTitle;
      }
    };
    let tag = getQueryParam("tag");
    if (tag && tag.trim() != "") {
      toggleTag(tag);
    }
    const dataList = computed(() => initWordCloud(tags2));
    function initWordCloud(tags22) {
      const dataList2 = [];
      for (let tag2 in tags22.value) {
        dataList2.push({ name: tag2, value: tags22.value[tag2].length });
      }
      return dataList2;
    }
    return (_ctx, _cache) => {
      const _component_WordCloud = _sfc_main$2;
      const _component_a_tag = Tag;
      const _component_a_card = Card;
      const _component_a_col = Col;
      const _component_ArticleMetadata = __unplugin_components_4;
      const _component_a_list_item = ListItem;
      const _component_a_list = List$1;
      const _component_a_row = Row;
      return openBlock(), createElementBlock("div", _hoisted_1, [
        createBaseVNode("div", _hoisted_2, [
          createBaseVNode("span", _hoisted_3, [
            (openBlock(), createElementBlock("svg", _hoisted_4, _hoisted_7))
          ]),
          _hoisted_8
        ]),
        createBaseVNode("div", null, [
          createVNode(_component_WordCloud, {
            dataList: dataList.value,
            style: { width: "100%", height: "130px" }
          }, null, 8, ["dataList"]),
          createVNode(_component_a_row, { gutter: 24 }, {
            default: withCtx(() => [
              createVNode(_component_a_col, { span: 24 }, {
                default: withCtx(() => [
                  createVNode(_component_a_card, { style: { width: "100%", marginBottom: "20px" } }, {
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(tags2.value, (tag2, tagTitle) => {
                        return openBlock(), createBlock(_component_a_tag, {
                          onClick: ($event) => toggleTag(tagTitle),
                          class: normalizeClass(
                            unref(selectTag) === tagTitle ? "tag-checkable-checked tag-item" : "tag-item"
                          )
                        }, {
                          default: withCtx(() => [
                            createBaseVNode("span", _hoisted_9, toDisplayString(tagTitle), 1),
                            createBaseVNode("span", null, toDisplayString(tag2.length), 1)
                          ]),
                          _: 2
                        }, 1032, ["onClick", "class"]);
                      }), 256))
                    ]),
                    _: 1
                  })
                ]),
                _: 1
              }),
              createVNode(_component_a_col, { span: 24 }, {
                default: withCtx(() => [
                  unref(selectTag) ? (openBlock(), createBlock(_component_a_list, {
                    key: 0,
                    style: { width: "100%" }
                  }, {
                    header: withCtx(() => [
                      createTextVNode("  " + toDisplayString(tags2.value[unref(selectTag)].length) + "  ", 1)
                    ]),
                    default: withCtx(() => [
                      (openBlock(true), createElementBlock(Fragment, null, renderList(tags2.value[unref(selectTag)], (article, index2) => {
                        return openBlock(), createBlock(_component_a_list_item, null, {
                          default: withCtx(() => [
                            createBaseVNode("div", _hoisted_10, [
                              createBaseVNode("h3", _hoisted_11, [
                                createBaseVNode("a", {
                                  href: article.path,
                                  class: "title",
                                  target: "_blank"
                                }, toDisplayString(article.title), 9, _hoisted_12)
                              ]),
                              _hoisted_13,
                              (openBlock(), createBlock(_component_ArticleMetadata, {
                                article,
                                key: unref(md5)(article.date)
                              }, null, 8, ["article"]))
                            ])
                          ]),
                          _: 2
                        }, 1024);
                      }), 256))
                    ]),
                    _: 1
                  })) : createCommentVNode("", true),
                  !unref(selectTag) ? (openBlock(), createBlock(_component_a_card, {
                    key: 1,
                    style: { width: "100%" },
                    class: "no-result"
                  }, {
                    default: withCtx(() => [
                      _hoisted_14,
                      _hoisted_15
                    ]),
                    _: 1
                  })) : createCommentVNode("", true)
                ]),
                _: 1
              })
            ]),
            _: 1
          })
        ])
      ]);
    };
  }
});
const __unplugin_components_0 = /* @__PURE__ */ _export_sfc$1(_sfc_main$1, [["__scopeId", "data-v-58bf2852"]]);
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{"title":"","aside":false,"editLink":false,"lastUpdated":false,"showComment":false},"headers":[],"relativePath":"tags.md","filePath":"tags.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "tags.md" };
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_Tag = __unplugin_components_0;
  const _component_ClientOnly = resolveComponent("ClientOnly");
  return openBlock(), createElementBlock("div", null, [
    createVNode(_component_ClientOnly, null, {
      default: withCtx(() => [
        createVNode(_component_Tag)
      ]),
      _: 1
    })
  ]);
}
const tags = /* @__PURE__ */ _export_sfc$1(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  tags as default
};
