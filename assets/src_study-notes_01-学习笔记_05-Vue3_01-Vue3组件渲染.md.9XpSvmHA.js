import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/05-Vue3/01-Vue3组件渲染.md","filePath":"src/study-notes/01-学习笔记/05-Vue3/01-Vue3组件渲染.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/05-Vue3/01-Vue3组件渲染.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h3 id="_1-vue-3-的响应式系统" tabindex="-1">1. Vue 3 的响应式系统 <a class="header-anchor" href="#_1-vue-3-的响应式系统" aria-label="Permalink to &quot;1. Vue 3 的响应式系统&quot;">​</a></h3><p>Vue 3 引入了全新的响应式系统，基于 Proxy 实现。核心概念包括 <code>ref</code> 和 <code>reactive</code>，这两个 API 用于创建响应式数据。</p><ul><li><strong><code>ref</code></strong>：用于定义单个值的响应式数据。当 <code>ref</code> 的值发生变化时，Vue 会自动追踪这个变化，并更新所有依赖这个值的视图。</li><li><strong><code>reactive</code></strong>：用于定义复杂对象的响应式数据，所有对象属性都被代理，当任何一个属性改变时，Vue 会追踪变化并更新视图。</li></ul><h3 id="_2-setup-函数的执行时机" tabindex="-1">2. <code>setup</code> 函数的执行时机 <a class="header-anchor" href="#_2-setup-函数的执行时机" aria-label="Permalink to &quot;2. `setup` 函数的执行时机&quot;">​</a></h3><ul><li><strong>首次执行</strong>：<code>setup</code> 函数在组件实例创建时执行一次。这个函数主要用于初始化组件的逻辑、状态、以及设置响应式数据。</li><li><strong>返回值的作用</strong>：<code>setup</code> 函数返回一个对象，这个对象中的属性和方法将被暴露给模板或者 <code>render</code> 函数。在组件的整个生命周期中，<code>setup</code> 函数只执行一次。</li></ul><h3 id="_3-组件的更新机制" tabindex="-1">3. 组件的更新机制 <a class="header-anchor" href="#_3-组件的更新机制" aria-label="Permalink to &quot;3. 组件的更新机制&quot;">​</a></h3><p>Vue 3 的更新机制基于响应式数据的依赖追踪和渲染队列。在 <code>setup</code> 函数中，返回的响应式数据会被 Vue 自动追踪，当这些数据发生变化时，Vue 会触发组件更新。</p><h4 id="_3-1-响应式数据更新" tabindex="-1">3.1 响应式数据更新 <a class="header-anchor" href="#_3-1-响应式数据更新" aria-label="Permalink to &quot;3.1 响应式数据更新&quot;">​</a></h4><ul><li><strong>依赖追踪</strong>：当模板或 <code>render</code> 函数中使用了某个响应式数据（如 <code>ref</code> 或 <code>reactive</code>），Vue 会在组件渲染时记录对该数据的依赖。</li><li><strong>数据变化</strong>：当响应式数据发生变化时，Vue 会根据依赖关系重新渲染使用了这些数据的部分。这就是为什么当 <code>ref</code> 或 <code>reactive</code> 数据更新时，视图会自动更新的原因。</li><li><strong>更新优化</strong>：Vue 3 使用了虚拟 DOM 和高效的差分算法，只更新发生变化的部分，而不是重新渲染整个组件。这保证了性能的优化。</li></ul><h4 id="_3-2-渲染函数的重新执行" tabindex="-1">3.2 渲染函数的重新执行 <a class="header-anchor" href="#_3-2-渲染函数的重新执行" aria-label="Permalink to &quot;3.2 渲染函数的重新执行&quot;">​</a></h4><p>在你提到的情况中，当 <code>ref</code> 或 <code>reactive</code> 数据发生变化时，Vue 会重新执行依赖这些数据的 <code>render</code> 函数或模板，这样会生成新的虚拟 DOM 并更新到实际的 DOM 中。</p><h3 id="_4-父子组件的渲染顺序与更新机制" tabindex="-1">4. 父子组件的渲染顺序与更新机制 <a class="header-anchor" href="#_4-父子组件的渲染顺序与更新机制" aria-label="Permalink to &quot;4. 父子组件的渲染顺序与更新机制&quot;">​</a></h3><h4 id="_4-1-父子组件的渲染顺序" tabindex="-1">4.1 父子组件的渲染顺序 <a class="header-anchor" href="#_4-1-父子组件的渲染顺序" aria-label="Permalink to &quot;4.1 父子组件的渲染顺序&quot;">​</a></h4><ul><li><strong>初始渲染</strong>：父组件的 <code>setup</code> 函数会先执行，然后渲染父组件的模板或 <code>render</code> 函数。当父组件渲染到子组件的标签时，会触发子组件的 <code>setup</code> 函数和渲染过程。</li><li><strong>更新过程</strong>：如果父组件的某个响应式数据变化导致父组件重新渲染，子组件也会在其标签位置重新渲染。如果子组件的响应式数据变化，则仅会重新渲染子组件。</li></ul><h4 id="_4-2-局部更新-vs-全量更新" tabindex="-1">4.2 局部更新 vs 全量更新 <a class="header-anchor" href="#_4-2-局部更新-vs-全量更新" aria-label="Permalink to &quot;4.2 局部更新 vs 全量更新&quot;">​</a></h4><ul><li><p><strong>局部更新</strong>：Vue 3 通过虚拟 DOM 的差分算法来进行高效的更新。当某个响应式数据变化时，Vue 只会重新渲染使用了这个数据的部分，而不会重新渲染整个组件。</p><p>例如，在一个组件中有一个 <code>ref</code> 变量 <code>count</code>，这个变量仅用于显示一个数字。当 <code>count</code> 改变时，Vue 只会重新渲染显示这个数字的部分，而不会影响其他未发生变化的部分。</p></li><li><p><strong>全量更新</strong>：全量更新通常发生在依赖变化影响了整个模板或 <code>render</code> 函数的情况下。例如，如果你在 <code>render</code> 函数中直接依赖了多个响应式数据，并且这些数据发生了变化，那么整个 <code>render</code> 函数可能会被重新执行。</p></li></ul><h3 id="_5-状态变化与重新执行" tabindex="-1">5. 状态变化与重新执行 <a class="header-anchor" href="#_5-状态变化与重新执行" aria-label="Permalink to &quot;5. 状态变化与重新执行&quot;">​</a></h3><h4 id="_5-1-重新执行的条件" tabindex="-1">5.1 重新执行的条件 <a class="header-anchor" href="#_5-1-重新执行的条件" aria-label="Permalink to &quot;5.1 重新执行的条件&quot;">​</a></h4><ul><li><strong>数据变化</strong>：当组件依赖的响应式数据发生变化时，Vue 会重新执行与这些数据相关的渲染逻辑。</li><li><strong>父组件更新</strong>：如果父组件的数据变化导致了子组件的重新渲染（例如父组件传递给子组件的 <code>props</code> 发生了变化），那么子组件也会重新渲染。</li><li><strong>强制更新</strong>：你可以通过调用组件实例的 <code>$forceUpdate()</code> 方法，强制 Vue 重新渲染组件，但这在实际开发中不常用，因为响应式系统已经足够处理大部分情况。</li></ul><h4 id="_5-2-生命周期钩子" tabindex="-1">5.2 生命周期钩子 <a class="header-anchor" href="#_5-2-生命周期钩子" aria-label="Permalink to &quot;5.2 生命周期钩子&quot;">​</a></h4><p>在组件的更新过程中，Vue 还提供了多个生命周期钩子，例如 <code>beforeUpdate</code> 和 <code>updated</code>，你可以利用这些钩子来执行一些在组件更新前后需要处理的逻辑。</p><h3 id="_6-代码示例" tabindex="-1">6. 代码示例 <a class="header-anchor" href="#_6-代码示例" aria-label="Permalink to &quot;6. 代码示例&quot;">​</a></h3><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">import</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> { defineComponent, ref, h } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">from</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;vue&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">export</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> default</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> defineComponent</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">({</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">  setup</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">() </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> count</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> ref</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> doubleCount</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> count.value </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">*</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 2</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> increment</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> () </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      count.value</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    };</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      count,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      doubleCount,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      increment</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    };</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">,</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">  </span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">  render</span><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">() </span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">{</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    return</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> h</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;div&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, [</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">      h</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, {}, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">`Count: ${</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">.</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">count</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">),</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">      h</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;p&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, {}, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">`Double Count: ${</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">doubleCount</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">()</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">}`</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">),</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">      h</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;button&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, { onClick: </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">this</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">.increment }, </span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Increment&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    ]);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#F69D50;">})</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span></code></pre></div><p>在这个示例中：</p><ul><li><code>setup</code> 函数初始化了 <code>count</code> 和 <code>doubleCount</code> 的计算方法。</li><li>每次 <code>count</code> 改变时，<code>render</code> 函数会被重新执行，生成新的虚拟 DOM。</li><li>虚拟 DOM 差分算法会检测到只有 <code>Count</code> 和 <code>Double Count</code> 的显示部分需要更新，而按钮本身不会被重新渲染。</li></ul><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong><code>setup</code> 只执行一次</strong>，用于初始化组件的逻辑和状态。</li><li><strong>Vue 通过响应式系统追踪依赖</strong>，当数据发生变化时，仅更新受影响的部分。</li><li><strong>父子组件之间的渲染是有序的</strong>，父组件渲染时会先初始化子组件。</li><li><strong>Vue 的更新机制非常高效</strong>，通过虚拟 DOM 差分算法，只更新必要的部分，避免不必要的全量更新。</li></ul>', 27);
const _hoisted_28 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_28);
}
const _01Vue3____ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _01Vue3____ as default
};
