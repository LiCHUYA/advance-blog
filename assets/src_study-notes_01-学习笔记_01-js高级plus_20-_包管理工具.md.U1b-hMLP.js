import { _ as __unplugin_components_4 } from "./chunks/ArticleMetadata.l7JwFtuX.js";
import { _ as _export_sfc, D as resolveComponent, o as openBlock, c as createElementBlock, I as createVNode, w as withCtx, k as createBaseVNode, a as createTextVNode, R as createStaticVNode, b as createBlock, e as createCommentVNode } from "./chunks/framework.b55ravPP.js";
const _imports_0 = "/advance-blog/assets/image-20240902111112235.2wslr-aa.png";
const _imports_1 = "/advance-blog/assets/image-20240902111128295.xUjUlszA.png";
const _imports_2 = "/advance-blog/assets/image-20240902195134826.qkm_td1B.png";
const __pageData = JSON.parse('{"title":"包管理工具","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/01-js高级plus/20-_包管理工具.md","filePath":"src/study-notes/01-学习笔记/01-js高级plus/20-_包管理工具.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/01-js高级plus/20-_包管理工具.md" };
const _hoisted_1 = /* @__PURE__ */ createBaseVNode("h1", {
  id: "包管理工具",
  tabindex: "-1"
}, [
  /* @__PURE__ */ createTextVNode("包管理工具 "),
  /* @__PURE__ */ createBaseVNode("a", {
    class: "header-anchor",
    href: "#包管理工具",
    "aria-label": 'Permalink to "包管理工具"'
  }, "​")
], -1);
const _hoisted_2 = /* @__PURE__ */ createStaticVNode('<h2 id="常见属性" tabindex="-1">常见属性 <a class="header-anchor" href="#常见属性" aria-label="Permalink to &quot;常见属性&quot;">​</a></h2><p><img src="' + _imports_0 + '" alt="image-20240902111112235"></p><p><img src="' + _imports_1 + '" alt="image-20240902111128295"></p><ul><li>^版本,就是 x为固定版本,如果当前package.json中是vue2.4.1,则npm i之后,即使有3.x.x版本,也会更新2.x.最新的版本</li></ul><h2 id="_2-包管理器发展史" tabindex="-1">2.包管理器发展史 <a class="header-anchor" href="#_2-包管理器发展史" aria-label="Permalink to &quot;2.包管理器发展史&quot;">​</a></h2><h3 id="_1-背景需求-为什么需要包管理工具" tabindex="-1">1. <strong>背景需求：为什么需要包管理工具？</strong> <a class="header-anchor" href="#_1-背景需求-为什么需要包管理工具" aria-label="Permalink to &quot;1. **背景需求：为什么需要包管理工具？**&quot;">​</a></h3><p>在前端开发的早期阶段，开发者通常通过手动方式管理外部库，比如使用 <code>&lt;script&gt;</code> 标签将 jQuery、Bootstrap 等库直接引入 HTML 文件中。然而，随着前端项目复杂性的增加和模块化开发的普及，手动管理依赖变得不可持续。具体的挑战包括：</p><h4 id="_1-依赖管理的挑战" tabindex="-1"><strong>(1) 依赖管理的挑战</strong> <a class="header-anchor" href="#_1-依赖管理的挑战" aria-label="Permalink to &quot;**(1) 依赖管理的挑战**&quot;">​</a></h4><ul><li><strong>依赖的数量和复杂性</strong>：现代前端项目往往依赖多个第三方库，这些库之间存在复杂的嵌套依赖。手动管理这些依赖的版本和更新非常困难。</li><li><strong>版本控制的困难</strong>：不同的库可能依赖于同一个模块的不同版本，导致版本冲突和兼容性问题。例如，A 库需要 lodash 的 4.0 版本，而 B 库需要 lodash 的 4.5 版本，手动解决这些冲突变得复杂。</li><li><strong>开发和生产环境的不一致</strong>：手动管理依赖可能导致开发环境和生产环境之间不一致，从而引发不可预见的问题。</li></ul><h4 id="_2-模块化与现代化开发的需求" tabindex="-1"><strong>(2) 模块化与现代化开发的需求</strong> <a class="header-anchor" href="#_2-模块化与现代化开发的需求" aria-label="Permalink to &quot;**(2) 模块化与现代化开发的需求**&quot;">​</a></h4><p>随着 JavaScript 生态系统的扩展，模块化编程变得越来越重要。CommonJS 和 AMD 是早期的模块化方案，ES6 引入了原生模块 (<code>import/export</code>)，推动了代码的可维护性和重用性。然而，模块化也对依赖管理提出了更高的要求，需要更智能的工具来管理复杂的依赖关系和版本控制。</p><h3 id="_2-关键里程碑-包管理工具的发展历程" tabindex="-1">2. <strong>关键里程碑：包管理工具的发展历程</strong> <a class="header-anchor" href="#_2-关键里程碑-包管理工具的发展历程" aria-label="Permalink to &quot;2. **关键里程碑：包管理工具的发展历程**&quot;">​</a></h3><h4 id="_1-早期-手动管理与cdn" tabindex="-1"><strong>(1) 早期：手动管理与CDN</strong> <a class="header-anchor" href="#_1-早期-手动管理与cdn" aria-label="Permalink to &quot;**(1) 早期：手动管理与CDN**&quot;">​</a></h4><p>在包管理工具出现之前，开发者依赖于手动下载库文件，并通过 <code>&lt;script&gt;</code> 标签加载。这种方式简单但效率低下，且难以管理版本冲突。</p><ul><li><strong>CDN 的普及</strong>：使用 CDN 可以简化文件管理，让开发者从网络加载库文件。这解决了部分问题，但依然无法应对版本冲突和复杂的依赖关系。</li></ul><h4 id="_2-bower-的出现-前端的第一个包管理工具" tabindex="-1"><strong>(2) Bower 的出现：前端的第一个包管理工具</strong> <a class="header-anchor" href="#_2-bower-的出现-前端的第一个包管理工具" aria-label="Permalink to &quot;**(2) Bower 的出现：前端的第一个包管理工具**&quot;">​</a></h4><ul><li><strong>Bower (2012)</strong>: 由 Twitter 团队创建，Bower 专门用于前端依赖管理，通过 <code>bower.json</code> 文件来管理依赖。Bower 的优点在于简单易用，但其缺点也很明显： <ul><li><strong>不支持模块化</strong>：Bower 仅负责下载库文件，没有内置模块化加载支持。</li><li><strong>依赖冲突处理不足</strong>：面对依赖冲突时，Bower 仅提示冲突，而不能自动解决。</li></ul></li></ul><h4 id="_3-npm-的兴起-从-node-js-到前端" tabindex="-1"><strong>(3) npm 的兴起：从 Node.js 到前端</strong> <a class="header-anchor" href="#_3-npm-的兴起-从-node-js-到前端" aria-label="Permalink to &quot;**(3) npm 的兴起：从 Node.js 到前端**&quot;">​</a></h4><ul><li><strong>npm (2009)</strong>: 最初是为 Node.js 设计的包管理工具，但随着 Node.js 在前端的普及，npm 成为了前端开发的主流选择。其优势包括： <ul><li><strong>模块化支持</strong>：npm 支持 CommonJS 模块化标准，并结合工具（如 Browserify）在浏览器中使用。</li><li><strong>丰富的生态系统</strong>：npm 提供了一个庞大的生态系统，拥有数百万个包。</li><li><strong>语义化版本控制</strong>：npm 采用语义化版本控制，便于管理版本更新。</li></ul></li></ul><h4 id="_4-yarn-npm-的改进者" tabindex="-1"><strong>(4) Yarn：npm 的改进者</strong> <a class="header-anchor" href="#_4-yarn-npm-的改进者" aria-label="Permalink to &quot;**(4) Yarn：npm 的改进者**&quot;">​</a></h4><ul><li><strong>Yarn (2016)</strong>: 由 Facebook 开发，旨在解决 npm 的性能和一致性问题。Yarn 的创新包括： <ul><li><strong><code>yarn.lock</code> 文件</strong>：锁定依赖版本，确保团队内的一致性。</li><li><strong>并行安装</strong>：提升安装速度，减少等待时间。</li><li><strong>本地缓存</strong>：提高安装效率，避免重复下载。</li></ul></li></ul><h4 id="_5-pnpm-和其他创新者" tabindex="-1"><strong>(5) pnpm 和其他创新者</strong> <a class="header-anchor" href="#_5-pnpm-和其他创新者" aria-label="Permalink to &quot;**(5) pnpm 和其他创新者**&quot;">​</a></h4><ul><li><strong>pnpm</strong>：通过硬链接和符号链接优化依赖管理，减少磁盘空间浪费，在处理大型项目时表现出色。</li><li><strong>Webpack 和 Rollup</strong>：虽然主要用于打包，但这些工具与包管理工具结合紧密，支持现代化的模块系统和按需加载。</li></ul><h3 id="_3-技术细节-包管理工具如何运作" tabindex="-1">3. <strong>技术细节：包管理工具如何运作</strong> <a class="header-anchor" href="#_3-技术细节-包管理工具如何运作" aria-label="Permalink to &quot;3. **技术细节：包管理工具如何运作**&quot;">​</a></h3><h4 id="_1-package-json-文件" tabindex="-1"><strong>(1) <code>package.json</code> 文件</strong> <a class="header-anchor" href="#_1-package-json-文件" aria-label="Permalink to &quot;**(1) `package.json` 文件**&quot;">​</a></h4><p><code>package.json</code> 文件是包管理工具的核心，包含了项目的基本信息、依赖列表、脚本命令等。主要内容包括：</p><ul><li><strong>依赖列表</strong>：<code>dependencies</code> 和 <code>devDependencies</code>，分别列出运行时和开发时所需的依赖。</li><li><strong>版本控制</strong>：使用符号如 <code>^</code>、<code>~</code> 来指定版本范围。</li></ul><h4 id="_2-锁定文件" tabindex="-1"><strong>(2) 锁定文件</strong> <a class="header-anchor" href="#_2-锁定文件" aria-label="Permalink to &quot;**(2) 锁定文件**&quot;">​</a></h4><p>锁定文件（如 <code>package-lock.json</code> 和 <code>yarn.lock</code>）记录了每个依赖包的确切版本，确保开发环境和生产环境的一致性。</p><h4 id="_3-依赖树" tabindex="-1"><strong>(3) 依赖树</strong> <a class="header-anchor" href="#_3-依赖树" aria-label="Permalink to &quot;**(3) 依赖树**&quot;">​</a></h4><p>包管理工具通过解析 <code>package.json</code> 文件生成依赖树，描述所有依赖包及其子依赖包的关系，帮助工具自动化地下载、安装和管理包。</p><h4 id="_4-本地缓存" tabindex="-1"><strong>(4) 本地缓存</strong> <a class="header-anchor" href="#_4-本地缓存" aria-label="Permalink to &quot;**(4) 本地缓存**&quot;">​</a></h4><p>Yarn 和 pnpm 使用本地缓存机制，避免重复下载依赖包，提高安装效率。</p><h3 id="_4-面临的问题与解决方案" tabindex="-1">4. <strong>面临的问题与解决方案</strong> <a class="header-anchor" href="#_4-面临的问题与解决方案" aria-label="Permalink to &quot;4. **面临的问题与解决方案**&quot;">​</a></h3><h4 id="_1-版本冲突" tabindex="-1"><strong>(1) 版本冲突</strong> <a class="header-anchor" href="#_1-版本冲突" aria-label="Permalink to &quot;**(1) 版本冲突**&quot;">​</a></h4><p>版本冲突是一个常见问题，当不同的模块依赖同一个库的不同版本时，容易导致冲突。</p><ul><li><strong>解决方案</strong>：Yarn 和 pnpm 通过“扁平化依赖树”来减少重复安装，尽可能合并相同依赖。</li></ul><h4 id="_2-依赖的安全性" tabindex="-1"><strong>(2) 依赖的安全性</strong> <a class="header-anchor" href="#_2-依赖的安全性" aria-label="Permalink to &quot;**(2) 依赖的安全性**&quot;">​</a></h4><p>引入第三方库可能带来安全漏洞风险。</p><ul><li><strong>解决方案</strong>：npm 提供 <code>npm audit</code> 命令，自动检测并修复已知漏洞。</li></ul><h4 id="_3-安装速度与资源占用" tabindex="-1"><strong>(3) 安装速度与资源占用</strong> <a class="header-anchor" href="#_3-安装速度与资源占用" aria-label="Permalink to &quot;**(3) 安装速度与资源占用**&quot;">​</a></h4><p>npm 在处理大型项目时速度慢、占用大量磁盘空间。</p><ul><li><strong>解决方案</strong>：Yarn 通过并行安装和本地缓存提升速度，pnpm 通过硬链接技术优化磁盘空间使用。</li></ul><h4 id="_4-去中心化与单点故障" tabindex="-1"><strong>(4) 去中心化与单点故障</strong> <a class="header-anchor" href="#_4-去中心化与单点故障" aria-label="Permalink to &quot;**(4) 去中心化与单点故障**&quot;">​</a></h4><p>npm 注册中心的故障可能影响全球开发者。</p><ul><li><strong>解决方案</strong>：Yarn 和 pnpm 支持私有包管理和镜像服务，减少对单一源的依赖。</li></ul><h2 id="_3-npm-install发生了什么" tabindex="-1">3.npm install发生了什么? <a class="header-anchor" href="#_3-npm-install发生了什么" aria-label="Permalink to &quot;3.npm install发生了什么?&quot;">​</a></h2><p><img src="' + _imports_2 + '" alt="image-20240902195134826"></p><h3 id="_1-npm-install-的详细过程" tabindex="-1">1. <strong><code>npm install</code> 的详细过程</strong> <a class="header-anchor" href="#_1-npm-install-的详细过程" aria-label="Permalink to &quot;1. **`npm install` 的详细过程**&quot;">​</a></h3><p>当你在项目目录中运行 <code>npm install</code> 时，主要会发生以下几个步骤：</p><ol><li><p><strong>读取配置文件</strong>：</p><ul><li><code>npm</code> 会先读取 <code>package.json</code> 文件，其中定义了项目的基本信息和依赖关系。它还会检查是否存在 <code>package-lock.json</code> 文件，这个文件会精确列出已安装的每个包的版本及其依赖的版本。</li></ul></li><li><p><strong>解析依赖</strong>：</p><ul><li>根据 <code>package.json</code> 和 <code>package-lock.json</code> 中的内容，<code>npm</code> 解析出项目需要的依赖版本。<code>package-lock.json</code> 中的内容会优先于 <code>package.json</code> 中的版本信息，确保安装的包与锁文件中指定的版本一致。</li></ul></li><li><p><strong>检查本地缓存</strong>：</p><ul><li>在安装依赖前，<code>npm</code> 会检查本地缓存（通常在 <code>~/.npm</code> 目录下），如果依赖包已经缓存，则直接从缓存中读取。</li></ul></li><li><p><strong>下载和安装依赖</strong>：</p><ul><li>如果依赖包不在本地缓存中，<code>npm</code> 会从远程的 npm 注册表下载包。下载完成后，包会被解压并放置到 <code>node_modules</code> 目录中。</li></ul></li><li><p><strong>更新 <code>package-lock.json</code> 文件</strong>：</p><ul><li>一旦所有依赖都安装完成并确认成功，<code>npm</code> 会根据实际安装的包及其依赖的版本来更新 <code>package-lock.json</code> 文件。这有助于确保将来在相同的项目中运行 <code>npm install</code> 时，安装的依赖包版本保持一致。</li></ul></li></ol><h3 id="_2-package-lock-json-的作用" tabindex="-1">2. <strong><code>package-lock.json</code> 的作用</strong> <a class="header-anchor" href="#_2-package-lock-json-的作用" aria-label="Permalink to &quot;2. **`package-lock.json` 的作用**&quot;">​</a></h3><ul><li><p><strong>精确版本控制</strong>：<code>package-lock.json</code> 文件列出了项目中所有已安装依赖包的精确版本信息（包括嵌套依赖），确保在不同的环境或时间点执行 <code>npm install</code> 时，所安装的依赖版本完全一致。</p></li><li><p><strong>加速安装过程</strong>：在有 <code>package-lock.json</code> 的情况下，<code>npm</code> 可以更快地解析和安装依赖，因为它可以直接按照锁文件中指定的版本和依赖关系安装，而无需解析和选择最佳版本。</p></li><li><p><strong>防止不兼容更新</strong>：由于 <code>package-lock.json</code> 锁定了具体版本，可以防止因依赖包的更新导致项目不兼容问题。即使 <code>package.json</code> 中使用的是版本范围符号（如 <code>^</code> 或 <code>~</code>），锁文件中的精确版本号能避免安装到不兼容的最新版本。</p></li></ul><h3 id="_3-package-json-与-package-lock-json-不一致时会发生什么" tabindex="-1">3. <strong><code>package.json</code> 与 <code>package-lock.json</code> 不一致时会发生什么？</strong> <a class="header-anchor" href="#_3-package-json-与-package-lock-json-不一致时会发生什么" aria-label="Permalink to &quot;3. **`package.json` 与 `package-lock.json` 不一致时会发生什么？**&quot;">​</a></h3><p>如果 <code>package.json</code> 和 <code>package-lock.json</code> 中的版本不一致，<code>npm install</code> 会如何处理：</p><ul><li><p><strong>优先使用 <code>package-lock.json</code></strong>：<code>npm</code> 通常会优先按照 <code>package-lock.json</code> 中列出的版本来安装依赖。这意味着即使 <code>package.json</code> 中定义的版本范围有所变化，只要 <code>package-lock.json</code> 中有锁定版本，<code>npm install</code> 会优先使用锁文件中的版本。</p></li><li><p><strong>更新锁文件</strong>：如果 <code>package.json</code> 中的依赖版本发生了改变（例如手动修改了版本号或新增了依赖），<code>npm install</code> 会安装符合 <code>package.json</code> 中指定的版本要求的依赖，并相应地更新 <code>package-lock.json</code> 文件以反映这些更改。</p></li><li><p><strong>清除锁文件的情况</strong>：如果删除 <code>package-lock.json</code> 并重新运行 <code>npm install</code>，<code>npm</code> 会根据 <code>package.json</code> 中的版本要求来重新解析和安装依赖，并生成一个新的 <code>package-lock.json</code> 文件。</p></li></ul><h3 id="_4-版本不一致时的处理流程" tabindex="-1">4. <strong>版本不一致时的处理流程</strong> <a class="header-anchor" href="#_4-版本不一致时的处理流程" aria-label="Permalink to &quot;4. **版本不一致时的处理流程**&quot;">​</a></h3><ol><li><p><strong>版本检查</strong>：<code>npm</code> 会首先对比 <code>package.json</code> 和 <code>package-lock.json</code> 中的依赖版本。若发现 <code>package-lock.json</code> 有锁定版本且满足 <code>package.json</code> 中定义的版本范围，则优先安装锁文件中的版本。</p></li><li><p><strong>重新解析安装</strong>：若 <code>package-lock.json</code> 无法满足 <code>package.json</code> 中的新版本要求，<code>npm</code> 将根据 <code>package.json</code> 中的版本要求解析并安装新的版本，然后更新锁文件。</p></li><li><p><strong>报错情况</strong>：在某些情况下，如果依赖的特定版本不可用或不兼容，<code>npm</code> 会报错提示，这时可能需要手动调整 <code>package.json</code> 或 <code>package-lock.json</code> 文件中的版本信息，或者使用 <code>npm install --legacy-peer-deps</code> 来绕过版本冲突。</p></li></ol>', 58);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArticleMetadata = __unplugin_components_4;
  const _component_ClientOnly = resolveComponent("ClientOnly");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createVNode(_component_ClientOnly, null, {
      default: withCtx(() => {
        var _a, _b;
        return [
          (((_a = _ctx.$frontmatter) == null ? void 0 : _a.aside) ?? true) && (((_b = _ctx.$frontmatter) == null ? void 0 : _b.showArticleMetadata) ?? true) ? (openBlock(), createBlock(_component_ArticleMetadata, {
            key: 0,
            article: _ctx.$frontmatter
          }, null, 8, ["article"])) : createCommentVNode("", true)
        ];
      }),
      _: 1
    }),
    _hoisted_2
  ]);
}
const _20______ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _20______ as default
};
