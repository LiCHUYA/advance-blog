import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const _imports_0 = "/advance-blog/assets/20210914175010.jpg-33.Ln-TRsmM.jpg";
const _imports_1 = "/advance-blog/assets/20210914220039.jpg-34.wtsVmIKZ.jpg";
const _imports_2 = "/advance-blog/assets/20210915153932.jpg-35.VevnZdXl.jpg";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/09-浏览器缓存1-珠联璧合——熟悉而又陌生的 Memory Cache 与 Disk Cache.md","filePath":"src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/09-浏览器缓存1-珠联璧合——熟悉而又陌生的 Memory Cache 与 Disk Cache.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/02-前端缓存技术与方案解析/09-浏览器缓存1-珠联璧合——熟悉而又陌生的 Memory Cache 与 Disk Cache.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<p>从本文开始，我们将进入浏览器缓存的话题，但是我们尚且不能抛开 HTTP 缓存不管，相反我们需要建立在其基础之上。只有扎实了前面部分的知识，后面的学习之路才能走的更加平坦和顺畅，切勿邯郸学步。正所谓“学而不思则罔，思而不学则殆”，大家最终还是要产生自己的见解和认知，提出疑惑，寻找答案。</p><p>在前面章节介绍 HTTP 缓存的过程中，笔者多次提到了浏览器的 Memory Cache 与 Disk Cache 这两种缓存，但因当时它们并不是“主角”，生怕介绍起来喧宾夺主，因此并没有进行详细的阐述。而从本文开始我们已经步入了浏览器缓存的篇章，笔者将以此作为起点，发挥其承上启下的效果。</p><h2 id="memory-cache-与-disk-cache-介绍" tabindex="-1">Memory Cache 与 Disk Cache 介绍 <a class="header-anchor" href="#memory-cache-与-disk-cache-介绍" aria-label="Permalink to &quot;Memory Cache 与 Disk Cache 介绍&quot;">​</a></h2><p>在了解它们之前，我们不妨先来段“自我介绍”。</p><h3 id="memory-cache" tabindex="-1">Memory Cache <a class="header-anchor" href="#memory-cache" aria-label="Permalink to &quot;Memory Cache&quot;">​</a></h3><p><code>Memory Cache</code> 翻译过来便是“内存缓存”，顾名思义，它是存储在浏览器内存中的。其优点为获取速度快、优先级高，从内存中获取资源耗时为 0 ms，而其缺点也显而易见，比如生命周期短，当网页关闭后内存就会释放，同时虽然内存非常高效，但它也受限制于计算机内存的大小，是有限的。</p><p>那么如果要存储大量的资源，这是还得用到磁盘缓存。</p><h3 id="disk-cache" tabindex="-1">Disk Cache <a class="header-anchor" href="#disk-cache" aria-label="Permalink to &quot;Disk Cache&quot;">​</a></h3><p><code>Disk Cache</code> 翻译过来是“磁盘缓存”的意思，它是存储在计算机硬盘中的一种缓存，它的优缺点与 Memory Cache 正好相反，比如优点是生命周期长，不触发删除操作则一直存在，而缺点则是获取资源的速度相对内存缓存较慢。</p><p>Disk Cache 会根据保存下来的资源的 HTTP 首部字段来判断它们是否需要重新请求，如果重新请求那便是强缓存的失效流程，否则便是生效流程。</p><p><strong>从两者的优缺点中我们可以发现，Memory Cache 与 Disk Cache 珠联璧合，优势互补，共同构成了浏览器本地缓存的左右手。</strong></p><p>介绍完这两位“老朋友”，接下来我们继续来了解下浏览器的缓存机制，因为目前市面上浏览器众多，不同浏览器的缓存机制都可能不同，笔者还是以主流的 Chrome 为例进行介绍。</p><h2 id="浏览器缓存机制" tabindex="-1">浏览器缓存机制 <a class="header-anchor" href="#浏览器缓存机制" aria-label="Permalink to &quot;浏览器缓存机制&quot;">​</a></h2><p>浏览器缓存机制包含了 Http 缓存中强缓存、协商缓存的知识点，这里就不再进行赘述，下面主要介绍与 Memory Cache、 Disk Cache 相关的机制。</p><h3 id="缓存获取顺序" tabindex="-1">缓存获取顺序 <a class="header-anchor" href="#缓存获取顺序" aria-label="Permalink to &quot;缓存获取顺序&quot;">​</a></h3><p>按照缓存顺序来讲，当一个资源准备加载时，浏览器会根据其<strong>三级缓存原理</strong>进行判断。</p><ol><li>浏览器会率先查找内存缓存，如果资源在内存中存在，那么直接从内存中加载</li><li>如果内存中没找到，接下去会去磁盘中查找，找到便从磁盘中获取</li><li>如果磁盘中也没有找到，那么就进行网络请求，并将请求后符合条件的资源存入内存和磁盘中</li></ol><p>按照以上顺序，浏览器缓存与 HTTP 缓存才得以相辅相成，在有效的沟通和判断中尽可能的减少不必要的资源浪费。</p><h3 id="缓存存储优先级" tabindex="-1">缓存存储优先级 <a class="header-anchor" href="#缓存存储优先级" aria-label="Permalink to &quot;缓存存储优先级&quot;">​</a></h3><p>上述我们讲解了缓存资源的获取顺序，那么在获取之前，浏览器又是按照什么优先级来存储资源的？这一问题也可以直接换成“浏览器判断一个资源是存入内存缓存还是磁盘缓存的依据是什么？”。</p><p>其实答案在介绍内存缓存和磁盘缓存时已经有所涉及，我们以掘金首页为例子进行介绍。</p><p>当我们打开开发者工具并在浏览器输入 url 访问后，发现除了 base64 的图片永远从内存加载外，其他大部分资源会从磁盘加载。</p><p><img src="' + _imports_0 + '" alt="20210914175010.jpg"></p><p>磁盘缓存会将命中强缓存的 js、css、图片等资源都收入囊中，也省去我们担心它“挑食”的问题。</p><p>而内存缓存不这样，为了保持“苗条的身材”，它不得不控制“饮食”，尽可能的去挑选适合自己的“食物”。此时我们刷新下页面让内存缓存生效：</p><p><img src="' + _imports_1 + '" alt="20210914220039.jpg"></p><p>我们先过滤下只看 JS 资源的加载情况，发现有些被内存缓存了，有些则没有，这是为什么？</p><p>有些读者可能会猜测是不是没有被缓存的是因为资源比较大，其实不然，上方图片笔者圈出了 <code>Initiator</code> 列，通过该列便可以找到答案。</p><p>Initiator 列表示资源加载发起的位置，我们点击从内存获取资源的该列值后可以发现资源是在 HTML 渲染阶段就被加载的，如以下代码所示：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;zh-CN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;Demo&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">script</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> src</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;https://i.snssdk.com/slardar/sdk.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;加载的 JS 资源大概率会存储到内存中&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>而被内存抛弃的资源我们也可以发现其都是异步加载的资源，这些资源没有被内存缓存，比如像这样：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;zh-CN&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;Demo&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">div</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> id</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;cache&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;异步加载的 JS 资源没有存储到内存中&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">div</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            window.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> () {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">                setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> () {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">                    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> s </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    s.type </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;text/javascript&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    s.async </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> true</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    s.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;https://i.snssdk.com/slardar/sdk.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">                    var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> x </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getElementsByTagName</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)[</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                    x.parentNode.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(s, x);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">                }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">2000</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">            };</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">script</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>根据以上测试代码很容易产生<strong>错误的</strong>判断结论：异步加载的 JS 资源不会存储到内存中。</p><p><strong>其实这里异步函数只是起到了协助性的作用，并不是造成不存内存的根本性原因，就好比“羚羊遇见了狼，羚羊没有被狼吃了并不是因为羚羊会跑，而是因为其跑过了狼”。</strong></p><p>我们可以把 JS 资源看作是“羚羊”，把浏览器内存看作是“狼”，“羚羊没有被狼吃了”便可以理解为异步加载的 JS 资源没有存储到内存中，此时“羚羊跑过了狼”就可以看作是异步资源的加载晚于浏览器内存的生效时间，最终笔者得出的结论便很好理解：</p><blockquote><p>浏览器内存缓存生效的前提下，JS 资源的执行加载时间会影响其是否被内存缓存</p></blockquote><p>我们可以修改上述的 <code>setTimeout</code> 时间为 1 秒后再次进行验证，大家会发现即使异步了，JS 资源还是很容易被内存缓存，原因便是异步 JS 资源加载时浏览器渲染进程可能还没有结束，而进程没结束就有被存入内存的可能。</p><p>此外图片资源（非 base64）也有和 JS 资源同样的现象，而 CSS 资源比较与众不同，其被磁盘缓存的概率远大于被内存缓存。</p><p><img src="' + _imports_2 + '" alt="20210915153932.jpg"></p><p>这一现象目前还没有找到标准的答案，网上给出的非标准解释是：</p><blockquote><p>因为 CSS 文件加载一次就可渲染出来，我们不会频繁读取它，所以它不适合缓存到内存中，但是 JS 之类的脚本却随时可能会执行，如果脚本在磁盘当中，我们在执行脚本的时候需要从磁盘取到内存中来，这样 IO 开销就很大了，有可能导致浏览器失去响应。</p></blockquote><p>以上所述的内存缓存（Memory Cache）在浏览器标准中并没有详尽的描述，笔者也是根据自身实践及总结得出的一些结论，不同的浏览器在加载资源时可能会所有差异，读者还需根据自己的理解和实践进行进一步探索。</p><h3 id="preload-与-prefetch" tabindex="-1">Preload 与 Prefetch <a class="header-anchor" href="#preload-与-prefetch" aria-label="Permalink to &quot;Preload 与 Prefetch&quot;">​</a></h3><p>基于上述现象的前提下，笔者还发现了与资源加载相关的两个功能（<code>Preload</code> 与 <code>Prefetch</code>）也会潜移默化的影响着浏览器缓存。</p><p>preload 也被称为预加载，其用于 link 标签中，可以指明哪些资源是在页面加载完成后即刻需要的，浏览器会在主渲染机制介入前预先加载这些资源，并不阻塞页面的初步渲染。例如：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;preload&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;https://i.snssdk.com/slardar/sdk.js&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> as</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;script&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> /&gt;</span></span></code></pre></div><p>而当使用 preload 预加载资源后，笔者发现该资源一直会从磁盘缓存中读取，JS、CSS 及图片资源都有同样的表现，这主要还是和资源的渲染时机有关，在渲染机制还没有介入前的资源加载不会被内存缓存。</p><p>相反 prefetch 则表示预提取，告诉浏览器加载下一页面可能会用到的资源，浏览器会利用空闲状态进行下载并将资源存储到缓存中。</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> rel</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;prefetch&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> href</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;https://i.snssdk.com/slardar/sdk.js&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> /&gt;</span></span></code></pre></div><p>使用 prefetch 加载的资源，刷新页面时大概率会从磁盘缓存中读取，如果跳转到使用它的页面，则直接会从磁盘中加载该资源。</p><p>利用好 preload 和 prefetch 这“两员大将”，我们可以优化浏览器资源加载的顺序和时机，在页面性能优化环节至关重要。</p><h2 id="结语" tabindex="-1">结语 <a class="header-anchor" href="#结语" aria-label="Permalink to &quot;结语&quot;">​</a></h2><p>相信阅读完本节内容，你会对 Memory Cache 与 Disk Cache 有了新的认识，虽然本文从异步资源的角度阐述了不同资源的缓存优先级，但至于资源到底会被存储在内存还是磁盘，浏览器有它自己的考量，而这一衡量标准并没有官方的文档说明，但“实践出真知”，只有亲自动手实操，才能体会浏览器的“良苦用心”。</p>', 53);
const _hoisted_54 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_54);
}
const _09______1_______________Memory_Cache___Disk_Cache = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _09______1_______________Memory_Cache___Disk_Cache as default
};
