import { _ as __unplugin_components_4 } from "./chunks/ArticleMetadata.l7JwFtuX.js";
import { _ as _export_sfc, D as resolveComponent, o as openBlock, c as createElementBlock, I as createVNode, w as withCtx, k as createBaseVNode, a as createTextVNode, R as createStaticVNode, b as createBlock, e as createCommentVNode } from "./chunks/framework.b55ravPP.js";
const __pageData = JSON.parse('{"title":"HTTP 部分","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/02-基础知识/13-HTTP/01-http部分.md","filePath":"src/study-notes/02-基础知识/13-HTTP/01-http部分.md","lastUpdated":1739501366000}');
const _sfc_main = { name: "src/study-notes/02-基础知识/13-HTTP/01-http部分.md" };
const _hoisted_1 = /* @__PURE__ */ createBaseVNode("h1", {
  id: "http-部分",
  tabindex: "-1"
}, [
  /* @__PURE__ */ createTextVNode("HTTP 部分 "),
  /* @__PURE__ */ createBaseVNode("a", {
    class: "header-anchor",
    href: "#http-部分",
    "aria-label": 'Permalink to "HTTP 部分"'
  }, "​")
], -1);
const _hoisted_2 = /* @__PURE__ */ createStaticVNode('<h2 id="📕-常见的状态码有哪些" tabindex="-1">📕 常见的状态码有哪些 <a class="header-anchor" href="#📕-常见的状态码有哪些" aria-label="Permalink to &quot;📕 常见的状态码有哪些&quot;">​</a></h2><ul><li><code>100</code>：客户端在发送 POST 数据给服务器前，先发送请求头，征询服务器情况，看服务器是否处理 POST 的数据，如果不处理，客户端则不上传 POST 数据，如果处理，则 POST 上传数据。常用于 POST 大数据传输</li><li><code>200</code> 表示从客户端发来的请求在服务器端被正常处理了。</li><li><code>204</code> 表示请求处理成功，但没有资源返回。</li><li><code>301</code> 表示永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。</li><li><code>302</code> 表示临时性重定向。</li><li><code>304</code>：协商缓存，告诉客户端有缓存，直接使用缓存中的数据，返回页面的只有头部信息，是没有内容部分</li><li><code>400</code> 表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。</li><li><code>401</code> 表示未授权（Unauthorized)，当前请求需要用户验证</li><li><code>403</code> 表示对请求资源的访问被服务器拒绝了</li><li><code>404</code> 表示服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</li><li><code>500</code> 表示服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</li><li><code>503</code> 表示服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。</li></ul><hr><h2 id="📕get-和-post-请求的区别" tabindex="-1">📕GET 和 POST 请求的区别 <a class="header-anchor" href="#📕get-和-post-请求的区别" aria-label="Permalink to &quot;📕GET 和 POST 请求的区别&quot;">​</a></h2><p>GET 通常用于请求获取指定资源，而 POST 通常用于将实体提交到指定的资源。本质都是 TCP 连接，但是由于<code>HTTP</code>的规定和浏览器/服务器的限制，导致他们在应用过程中会体现出一些区别。</p><h3 id="区别" tabindex="-1">区别 <a class="header-anchor" href="#区别" aria-label="Permalink to &quot;区别&quot;">​</a></h3><ul><li>GET 在浏览器回退时是无害的，而 POST 会再次提交请求。</li><li>GET 产生的 URL 地址可以被收藏，而 POST 不可以。</li><li>GET 请求会被浏览器主动缓存，而 POST 不会，除非手动设置。</li><li>GET 请求只能进行 url 编码，而 POST 支持多种编码方式。</li><li>GET 参数通过 URL 传递，POST 放在 Request body 中</li><li>对参数的数据类型，GET 只接受<em>ASCII</em>字符，而 POST 没有限制。</li><li>GET 请求参数会被完整保留在浏览器历史记录里，而 POST 中的参数不会被保留。</li><li>GET 请求在 URL 中传送的参数是有长度限制的，而 POST 没有。</li><li>GET 比 POST 更不安全，因为参数直接暴露在 URL 上，所以不能用来传递敏感信息。</li></ul><p><strong>参数长度</strong>：<code>HTTP</code>协议没有<code>Body</code>和  <code>URL</code>  的长度限制，对  <code>URL</code>限制的大多是浏览器和服务器考虑处理较长的<code>url</code>会消耗较多资源，出于性能和安全的考虑限制了 url 长度</p><p><strong>安全</strong>：本质上两者都是不安全的。因为<code>HTTP</code>  在网络上是明文传输的，通过技术手段能完整地获取数据报文，只有使用<code>HTTPS</code>才能加密安全</p><p><strong>数据包</strong> ：于<code>GET</code>方式的请求，浏览器会把<code>http header</code>和<code>data</code>一并发送出去，对于<code>POST</code>，浏览器先发送<code>header</code>，服务器响应 100 <code>continue</code>，浏览器再发送<code>data</code>。但并不是所有浏览器都会在<code>POST</code>中发送两次包</p><hr><h2 id="📕-浏览器的同源策略" tabindex="-1">📕 浏览器的同源策略 <a class="header-anchor" href="#📕-浏览器的同源策略" aria-label="Permalink to &quot;📕 浏览器的同源策略&quot;">​</a></h2><h3 id="什么是源" tabindex="-1">什么是源 <a class="header-anchor" href="#什么是源" aria-label="Permalink to &quot;什么是源&quot;">​</a></h3><p>如果两个 URL 的协议、主机（域名）和端口号都相同的话，则这两个 URL 就是同源。<strong>同源策略</strong>是一个重要的安全策略，它定义了源之间资源如何交互，减少可能被攻击的媒介。</p><h3 id="跨域网络访问" tabindex="-1">跨域网络访问 <a class="header-anchor" href="#跨域网络访问" aria-label="Permalink to &quot;跨域网络访问&quot;">​</a></h3><p>同源策略可以控制不同源之间的交互，例如在发送<code>Ajax</code>、<code>fetch</code>请求 或使用  <code>&lt;img&gt;</code>标签时则会受到同源策略的约束。这些交互通常分为三类：</p><ul><li>跨源<strong>写操作</strong>（Cross-origin writes）一般是被允许的。例如链接、重定向以及表单提交。</li><li>跨源<strong>资源嵌入</strong>（Cross-origin embedding）一般是被允许的（后面会举例说明）。</li><li>跨源<strong>读操作</strong>（Cross-origin reads）一般是不被允许的，但常可以通过内嵌资源来巧妙的进行读取访问</li></ul><p>可能嵌入跨源的资源的一些示例：</p><ul><li>使用  <code>&lt;script src=&quot;…&quot;&gt;&lt;/script&gt;</code>  标签嵌入的 JavaScript 脚本。语法错误信息只能被同源脚本中捕捉到。</li><li>使用  <code>&lt;link rel=&quot;stylesheet&quot; href=&quot;…&quot;&gt;</code>  标签嵌入的 CSS。由于 CSS 的松散的语法规则，CSS 的跨源需要一个设置正确的  <code>Content-Type</code>  标头。</li><li>通过  <code>&lt;img&gt;</code>展示的图片。</li><li>通过  <code>&lt;video&gt;</code>  和  <code>&lt;audio&gt;</code>播放的多媒体资源。</li><li>通过  <code>&lt;object&gt;</code>和  <code>&lt;embed&gt;</code>嵌入的插件。</li><li>通过  <code>@font-face</code>引入的字体。一些浏览器允许跨源字体（cross-origin fonts），另一些需要同源字体（same-origin fonts）。</li><li>通过  <code>&lt;iframe&gt;</code>载入的任何资源。</li></ul><h3 id="如何解决跨域" tabindex="-1">如何解决跨域 <a class="header-anchor" href="#如何解决跨域" aria-label="Permalink to &quot;如何解决跨域&quot;">​</a></h3><p><strong>jsonp 解决同源限制问题</strong></p><p>通过<code>&lt;script&gt;</code>标签的 src 属性实现跨域。<code>&lt;script&gt;</code>属于跨源资源嵌入，因此不受同源策略限制。</p><ul><li><p>实现 jsonp 封装</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> jsonp</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">options</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> script </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">createElement</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;script&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  script.src </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> options.url</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">appendChile</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(srcipt)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  script.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">onload</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> () {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">removeChile</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(srcipt)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div></li><li><p>弊端：</p><ol><li><p>jsonp 只能发送 GET 请求</p></li><li><p>jsonp 没有办法返回后端状态码，没办法改变</p></li><li><p>存在安全隐患，服务端直接调用方法（不能保证服务器的可靠性）</p></li></ol></li></ul><p><strong>CORS 实现跨域请求</strong></p><p>是一种基于  <code>HTTP</code>头的机制，该机制通过允许服务器标示除了它自己以外的其它源（域、协议或端口不同），使得浏览器允许这些源访问加载自己的资源。</p><p>浏览器发出的跨域请求分为两种：</p><ol><li><p>简单请求</p><p>满足所有以下条件：</p><ul><li>请求方法：<code>GET,HEAD,POST</code></li><li>请求头的内容—HTTP 的头信息不超出以下几种字段： <ul><li>Accept</li><li>Accept-Language</li><li>Content-Language</li><li>Last-Event-ID</li><li>Content-Type：只限于三个值<code>application/x-www-form-urlencoded</code>、<code>multipart/form-data</code>、<code>text/plain</code></li></ul></li></ul><p>当浏览器发现发现的 ajax 请求是简单请求时，会在请求头中携带一个字段：<code>Origin``Origin</code>中会指出当前请求 url,服务会根据这个值决定是否允许其跨域。</p><p>如果服务器允许跨域，需要在返回的响应头中携带<code>Access-Control-Allow-Origin</code>：上面<code>Origin</code>中的地址或者*代表任意。</p></li><li><p>特殊请求</p><p>不符合简单请求的条件，会被浏览器判定为特殊请求。</p><p>特殊请求会在正式通信之前，浏览器先询问服务器，当前网页所在的域名是否在服务器的许可名单之中，以及可以使用哪些 HTTP 动词和头信息字段。只有得到肯定答复，浏览器才会发出正式的<code>XMLHttpRequest</code>请求，否则就报错。</p><p>与简单请求相比，除了 Origin 以外，多了两个头：</p><ul><li>Access-Control-Request-Method：接下来会用到的请求方式，比如 PUT</li><li>Access-Control-Request-Headers：会额外用到的头信息</li></ul><p>服务的收到预检请求，如果许可跨域，会发出响应，除了简单请求中的两个，还附加：</p><ul><li>Access-Control-Allow-Methods：允许访问的方式</li><li>Access-Control-Allow-Headers：允许携带的头</li><li>Access-Control-Max-Age：本次许可的有效时长，单位是秒，<strong>过期之前的 ajax 请求就无需再次进行预检了</strong>。</li></ul></li></ol><hr><h2 id="📕dns-协议-是什么-说说-dns-完整的查询过程" tabindex="-1">📕DNS 协议 是什么？说说 DNS 完整的查询过程? <a class="header-anchor" href="#📕dns-协议-是什么-说说-dns-完整的查询过程" aria-label="Permalink to &quot;📕DNS 协议 是什么？说说 DNS 完整的查询过程?&quot;">​</a></h2><p>DNS（Domain Names System）解释为域名系统，属于是应用层的协议，用于将用户提供的主机名（域名）解析为 IP 地址。</p><p>域名是一个具有层次的结构，从上到下依次为<strong>根域名</strong>、<strong>顶级域名</strong>、<strong>二级域名</strong>、<strong>三级域名</strong>等...</p><p>例如<code>www.baidu.com</code>，<code>www</code>为三级域名、<code>baidu</code>为二级域名、<code>com</code>为顶级域名，系统为用户做了兼容，域名末尾的根域名<code>.</code>一般不需要输入,域名的每层都设有一个域名服务器：</p><ul><li><p><strong>根域名服务器（Root DNS Server）</strong>：管理顶级域名服务器，返回“com”“net”“cn”等顶级域名服务器的 IP 地址</p></li><li><p><strong>顶级域名服务器（Top-level DNS Server）</strong>：管理各自域名下的权威域名服务器，比如 com 顶级域名服务器可以返回 baidu.com 域名服务器的 IP 地址</p></li><li><p><strong>权威域名服务器（Authoritative DNS Server）</strong>：管理自己域名下主机的 IP 地址，比如 baidu.com 权威域名服务器可以返回 www.baidu.com的 IP 地址</p></li><li><p><strong>本地域名服务器（Local Name Server，local DNS）</strong>：如果通过 DHCP 配置，由互联网服务提供商（ISP，如联通、电信）提供</p></li></ul><img title="" src="https://static.vue-js.com/9f112780-b78f-11eb-85f6-6fac77c0c9b3.png" alt="" data-align="center"><h3 id="dns-查询方式" tabindex="-1">DNS 查询方式 <a class="header-anchor" href="#dns-查询方式" aria-label="Permalink to &quot;DNS 查询方式&quot;">​</a></h3><p>DNS 查询有两种方式：<strong>递归</strong> 和 <strong>迭代</strong> 。</p><p>客户端与本地域名服务器之间一般采用<strong>递归查询</strong>，它负责全权处理客户端的 DNS 查询请求，直到返回最终结果</p><p>而 DNS 根域名服务器之间一般采用 <strong>迭代查询</strong> 方式，当 DNS 服务器查不到该域名，它不会替客户端完成后续的查询工作，而是回复下一步应当向哪一个域名服务器进行查询</p><ul><li>递归查询</li></ul><img title="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/0845436acd5048698644d9dc8d1e1fe6~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" width="531" data-align="center"><ul><li>迭代查询</li></ul><img title="" src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/30c166d8875d406a98e57f7b81e1211e~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="" width="498" data-align="center"><h3 id="域名缓存" tabindex="-1">域名缓存 <a class="header-anchor" href="#域名缓存" aria-label="Permalink to &quot;域名缓存&quot;">​</a></h3><p>一次完整的 DNS 查询过程需要访问多台 DNS 服务器才能得到最终的结果，这会带来一定的时延。<strong>为了改善时延</strong>，DNS 服务并不是每次请求都要去访问 DNS 服务器，而是访问过一次后将 DNS 记录缓存在本地。</p><p>计算机中 DNS 记录在本地有两种缓存方式：浏览器缓存和操作系统缓存</p><p><strong>浏览器缓存</strong>：浏览器在获取网站域名的实际 IP 地址后会对其进行缓存，减少网络请求的损耗。但是缓存并不是永久有效的，如 Chrome 的过期时间是 1 分钟，在这个期限内不会重新请求 DNS</p><p><strong>操作系统缓存</strong>：操作系统的缓存其实是用户自己配置的 hosts 文件。</p><p><strong>访问顺序为：浏览器缓存 -&gt; 操作系统缓存 -&gt; 路由器缓存 -&gt; local DNS 缓存 -&gt; DNS 查询</strong></p><h3 id="查询过程" tabindex="-1">查询过程 <a class="header-anchor" href="#查询过程" aria-label="Permalink to &quot;查询过程&quot;">​</a></h3><ul><li><p>首先搜索浏览器的 DNS 缓存，缓存中维护一张域名与 IP 地址的对应表</p></li><li><p>若没有命中，则继续搜索操作系统的 DNS 缓存</p></li><li><p>若仍然没有命中，则操作系统将域名发送至本地域名服务器，本地域名服务器采用递归查询自己的 DNS 缓存，查找成功则返回结果</p></li><li><p>若本地域名服务器的 DNS 缓存没有命中，则本地域名服务器向上级域名服务器进行迭代查询</p><ul><li>首先本地域名服务器向根域名服务器发起请求，根域名服务器返回顶级域名服务器的地址给本地服务器</li><li>本地域名服务器拿到这个顶级域名服务器的地址后，就向其发起请求，获取权限域名服务器的地址</li><li>本地域名服务器根据权限域名服务器的地址向其发起请求，最终得到该域名对应的 IP 地址</li></ul></li><li><p>本地域名服务器将得到的 IP 地址返回给操作系统，同时自己将 IP 地址缓存起来</p></li><li><p>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起</p></li><li><p>至此，浏览器就得到了域名对应的 IP 地址，并将 IP 地址缓存起</p></li></ul><hr><h2 id="📕tcp-的三次握手与四次挥手" tabindex="-1">📕TCP 的三次握手与四次挥手 <a class="header-anchor" href="#📕tcp-的三次握手与四次挥手" aria-label="Permalink to &quot;📕TCP 的三次握手与四次挥手&quot;">​</a></h2><p>TCP 提供面向有连接的通信传输，面向有连接是指在传送数据之前必须先建立连接，数据传送完成后要释放连接。连接是通过<strong>三次握手</strong>进行初始化的，并且由于 TCP 是<strong>全双工模式</strong>，所以需要<strong>四次挥手</strong>关闭连接</p><h3 id="tcp-序号和确认号" tabindex="-1">TCP 序号和确认号 <a class="header-anchor" href="#tcp-序号和确认号" aria-label="Permalink to &quot;TCP 序号和确认号&quot;">​</a></h3><p><strong>32 位序号 seq</strong>：TCP 通信过程中某一个传输方向上的字节流的每个字节的序号，通过这个来确认发送的数据<strong>有序</strong>，比如现在序列号为 1000，发送了 1000，下一个序列号就是 2000。<br><strong>32 位确认号 ack</strong>：TCP 对上一次 seq 序号做出的确认号，给收到的 TCP 报文段的序号 seq 加 1，用来响应 TCP 报文段</p><h3 id="tcp-标志位" tabindex="-1">TCP 标志位 <a class="header-anchor" href="#tcp-标志位" aria-label="Permalink to &quot;TCP 标志位&quot;">​</a></h3><p>用的最广泛的标志是  <strong>SYN</strong>，<strong>ACK</strong>  和  <strong>FIN</strong>，用于建立连接，确认成功的段传输，最后终止连接。</p><ul><li><p><strong>SYN</strong>：简写为 S，同步标志位，用于建立会话连接，同步序列号；</p></li><li><p><strong>ACK</strong>： 简写为.，确认标志位，对已接收的数据包进行确认；</p></li><li><p><strong>FIN</strong>： 简写为 F，完成标志位，表示我已经没有数据要发送了，即将关闭连接；</p></li><li><p>PSH：简写为 P，推送标志位，表示该数据包被对方接收后应立即交`给上层应用，而不在缓冲区排队；</p></li><li><p>RST：简写为 R，重置标志位，用于连接复位、拒绝错误和非法的数据包；</p></li><li><p>URG：简写为 U，紧急标志位，表示数据包的紧急指针域有效，用来保证连接不被阻断，并督促中间设备尽快处理；</p></li></ul><h3 id="tcp-三次握手" tabindex="-1">TCP 三次握手 <a class="header-anchor" href="#tcp-三次握手" aria-label="Permalink to &quot;TCP 三次握手&quot;">​</a></h3><p>进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备，TCP 三次握手的过程为：</p><p><strong>第一次握手</strong>：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号。此时客户端处于 SYN_SEND 状态。</p><p>首部的同步位 SYN=1，初始序号 seq=x，SYN=1 的报文段不能携带数据，但要消耗掉一个序号。</p><p><strong>第二次握手</strong>：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN(s)。同时会把客户端的 ISN + 1 作为 ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</p><p>在确认报文段中 SYN=1，ACK=1，确认号 ack=x+1，初始序号 seq=y。</p><p><strong>第三次握手</strong>：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</p><p>确认报文段 ACK=1，确认号 ack=y+1，序号 seq=x+1（初始为 seq=x，第二个报文段所以要+1）</p><p><img src="https://static.vue-js.com/fb489fc0-beb9-11eb-85f6-6fac77c0c9b3.png" alt=""></p><p><strong>为什么是三次握手</strong>：第一次握手服务端确定自己的接收能力正常、客户端的发送能力正常；第二次握手客户端确定自己的接收发送能力正常，服务端接受能力和发送能力正常；至此，虽然客户端已经知道能够正常传输接收数据，但是服务器还并不能确认自己发送的数据对方是否能够接收，因此还需要客户端发送确认报文</p><h3 id="tcp-四次挥手" tabindex="-1">TCP 四次挥手 <a class="header-anchor" href="#tcp-四次挥手" aria-label="Permalink to &quot;TCP 四次挥手&quot;">​</a></h3><p>TCP 提供了连接的一端在结束它的发送后还能接收来自另一端数据的能力，称之为半关闭。这使得终止 TCP 连接需要经历四次挥手，客户端或服务器均可主动发起挥手动作。假如是客户端先发起关闭请求，四次挥手的过程如下：</p><p><strong>第一次挥手</strong> 客户端发出连接释放报文，并且停止发送数据。释放数据报文首部，FIN=1，其序列号为 seq=u，此时，客户端进入 FIN-WAIT-1（终止等待 1）状态</p><p><strong>第二次挥手</strong> 服务器端接收到连接释放报文后，发出确认报文，ACK=1，ack=u+1，并且带上自己的序列号 seq=v，此时，服务端就进入了 CLOSE-WAIT 关闭等待状态</p><p><strong>第三次挥手</strong> 客户端接收到服务器端的确认请求后，客户端就会进入 FIN-WAIT-2（终止等待 2）状态，等待服务器发送连接释放报文，服务器将最后的数据发送完毕后，就向客户端发送连接释放报文(FIN=1，ACK=1，序号 seq=w，确认号 ack=u+1)，服务器就进入了 LAST-ACK（最后确认）状态，等待客户端的确认。</p><p><strong>第四次挥手</strong> 客户端收到服务器的连接释放报文后，必须发出确认，ACK=1，ack=w+1，而自己的序列号是 seq=u+1，此时，客户端就进入了 TIME-WAIT（时间等待）状态，但此时 TCP 连接还未终止，为了确保服务端收到自己的 ACK 报文，客户端必须要经过 2MSL 后（最长报文寿命），才会进入 CLOSED 关闭状态，服务器端接收到确认报文后，会立即进入 CLOSED 关闭状态，到这里 TCP 连接就断开了，四次挥手完成</p><p><img src="https://pic2.zhimg.com/v2-c7d4b5aca66560365593f57385ce9fa9_b.jpg" alt=""></p><hr><h2 id="📕-回流和重绘" tabindex="-1">📕 回流和重绘 <a class="header-anchor" href="#📕-回流和重绘" aria-label="Permalink to &quot;📕 回流和重绘&quot;">​</a></h2><h3 id="回流与重绘" tabindex="-1">回流与重绘 <a class="header-anchor" href="#回流与重绘" aria-label="Permalink to &quot;回流与重绘&quot;">​</a></h3><p><strong>什么是回流</strong>：当我们对 DOM 的修改引发了 DOM <strong>布局或者几何属性</strong>时（比如修改元素的宽、高或隐藏元素等），浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）。</p><ul><li>全局范围：从根节点 html 开始对整个渲染树进行重新布局。</li><li>局部范围：对渲染树的某部分或某一个渲染对象进行重新布局</li></ul><p><strong>什么是重绘</strong>：当我们对 DOM 的修改导致了样式的变化、却并未影响其几何属性（比如修改了颜色或背景色）时，浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式。这个过程叫做重绘。</p><p><strong>回流必将引起重绘，重绘不一定会引起回流</strong></p><h3 id="常见引起回流的设计" tabindex="-1">常见引起回流的设计 <a class="header-anchor" href="#常见引起回流的设计" aria-label="Permalink to &quot;常见引起回流的设计&quot;">​</a></h3><p>场景：</p><ol><li>页面一开始渲染的时候（这肯定避免不了）</li><li>添加或者删除可见的  <code>DOM</code>  元素；</li><li>元素的位置发生变化</li><li>元素尺寸改变——边距、填充、边框、宽度和高度;</li><li>浏览器窗口尺寸改变——resize 事件发生时</li><li>计算 offsetWidth 和 offsetHeight 属性</li></ol><p>属性和方法</p><ul><li>width、height、margin、padding、border</li><li>display、position、overflow</li><li>clientWidth、clientHeight、clientTop、clientLeft</li><li>offsetWidth、offsetHeight、offsetTop、offsetLeft</li><li>scrollWidth、scrollHeight、scrollTop、scrollLeft</li><li>scrollIntoView()、scrollTo()</li><li>getComputedStyle()</li><li>getBoundingClientRect()</li><li>scrollIntoViewIfNeeded()</li></ul><h3 id="常引起重绘的属性和方法" tabindex="-1">常引起重绘的属性和方法 <a class="header-anchor" href="#常引起重绘的属性和方法" aria-label="Permalink to &quot;常引起重绘的属性和方法&quot;">​</a></h3><ul><li>color</li><li>border-style</li><li>visibility</li><li>background</li><li>text-decoration</li><li>background-image</li><li>background-position</li><li>background-repeat</li><li>outline-color</li><li>outline</li><li>outline-style</li><li>border-radius</li><li>outline-width</li><li>box-shadow</li><li>background-size</li></ul><h3 id="浏览器优化机制" tabindex="-1">浏览器优化机制 <a class="header-anchor" href="#浏览器优化机制" aria-label="Permalink to &quot;浏览器优化机制&quot;">​</a></h3><p>由于每次重排都会造成额外的计算消耗，因此大多数浏览器都会通过队列化修改并批量执行来优化重排过程。浏览器会将修改操作放入到队列里，直到过了一段时间或者操作达到了一个阈值，才清空队列 但是你获取布局信息的操作的时候，会强制队列刷新，包括前面讲到的如 offsetTop 等方法都会返回最新的数据，因此浏览器不得不清空队列，触发回流重绘来返回正确的值</p><h3 id="减少回流重绘方案" tabindex="-1">减少回流重绘方案 <a class="header-anchor" href="#减少回流重绘方案" aria-label="Permalink to &quot;减少回流重绘方案&quot;">​</a></h3><ul><li>读写分离操作</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;10px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;10px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;20px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;20px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 分离引用读取</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(div.offsetLeft)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(div.offsetTop)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(div.offsetWidth)</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(div.offsetHeight)</span></span></code></pre></div><ul><li>样式集中操作</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;10px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;10px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.width </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;20px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.height </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;20px&#39;</span></span></code></pre></div><p>虽然现在大部分浏览器有渲染队列优化，不排除有些浏览器以及老版本的浏览器效率仍然低下：建议通过改变 class 或者 csstext 属性集中改变样式</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// bad</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 10</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">el.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">el.style.top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// good</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">el.className </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39; theclassname&#39;</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// good</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">el.style.cssText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;; left: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px; top: &#39;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px;&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">el.style.cssText </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> `; left:${</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">left</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">}px; top:${</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">top</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">}px;`</span></span></code></pre></div><ul><li>缓存布局信息</li></ul><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// bad</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> div.offsetLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> div.offsetTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px&#39;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// good 缓存布局信息 相当于读写分离 ；想深入了解缓存优化参考 《小鹦鹉》</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> curLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> div.offsetLeft</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> curTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> div.offsetTop</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.left </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> curLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">div.style.top </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> curTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &#39;px&#39;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">curLeft </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> curTop </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> null</span></span></code></pre></div><ul><li>&quot;离线&quot;改变 DOM</li></ul><p>（1）隐藏要操作的 dom，在要操作 dom 之前，通过 display 隐藏 dom，当操作完成之后，才将元素的 display 属性为可见，因为不可见的元素不会触发重排和重绘。</p><p>（2）通过使用文档碎片创建一个 dom 碎片,在它上面批量操作 dom，操作完成之后，再添加到文档中，这样只会触发一次重排。<code>document.createDocumentFragment()</code></p><ul><li>优化动画</li></ul><p>动画效果还应牺牲一些平滑，来换取速度，这中间的度自己衡量：比如实现一个动画，以 1 个像素为单位移动这样最平滑，但是回流就会过于频繁，大量消耗 CPU 资源；举例优化如果以 3 个像素为单位移动，则会好很多。</p><ul><li>启用 GPU 加速</li></ul><p>GPU 硬件加速是指应用 GPU 的图形性能对浏览器中的一些图形操作交给 GPU 来完成，它在速度和能耗上更有效率。 GPU 加速通常包括以下几个部分：Canvas2D，布局合成, CSS3 转换（transitions），CSS3 3D 变换（transforms），WebGL 和视频(video)。</p><hr><h2 id="📕-浏览器页面渲染" tabindex="-1">📕 浏览器页面渲染 <a class="header-anchor" href="#📕-浏览器页面渲染" aria-label="Permalink to &quot;📕 浏览器页面渲染&quot;">​</a></h2><h3 id="页面渲染过程" tabindex="-1">页面渲染过程 <a class="header-anchor" href="#页面渲染过程" aria-label="Permalink to &quot;页面渲染过程&quot;">​</a></h3><ul><li><p>解析 HTML，生成 DOM 树，解析 CSS，生成 CSSOM 树</p></li><li><p>将 DOM 树和 CSSOM 树结合，<strong>去除不可见元素(很重要)</strong>，生成渲染树(Render Tree)</p></li><li><p>Layout(回流):根据生成的渲染树，进行回流(Layout)，得到节点的几何信息（位置，大小）</p></li><li><p>Painting(重绘):根据渲染树以及回流得到的几何信息，得到节点的绝对像素</p></li><li><p>Display:将像素发送给 GPU，展示在页面上</p></li></ul><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/e9f37924b4034e5aaccec6a2556502bc~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="渲染流程"></p><p>什么是不可见节点</p><ul><li>一些不会渲染输出的节点，比如 script、meta、link 等。</li><li>一些通过 css 进行隐藏的节点。注意，使用 visibility 和 opacity 隐藏的节点，还是会显示在渲染树上的（因为还占据文档空间），<strong>只有 display : none 的节点才不会显示在渲染树上</strong>。</li></ul><p><strong>渲染树</strong></p><p><img src="https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/5be05f02ba9140a49e74ef6b1707fad5~tplv-k3u1fbpfcp-zoom-in-crop-mark:4536:0:0:0.awebp" alt="渲染树"></p><h3 id="阻塞渲染" tabindex="-1">阻塞渲染 <a class="header-anchor" href="#阻塞渲染" aria-label="Permalink to &quot;阻塞渲染&quot;">​</a></h3><h4 id="css-阻塞" tabindex="-1"><strong>css 阻塞</strong> <a class="header-anchor" href="#css-阻塞" aria-label="Permalink to &quot;**css 阻塞**&quot;">​</a></h4><p><strong>css 阻塞 DOM 解析</strong>：当 JavaScript 中访问了某个元素的样式，那么这时候就需要 等待这个样式被下载 完成才能继续往下执行，从而 css 间接阻塞了 DOM 解析</p><p><strong>css 阻塞渲染树</strong>：CSSOM 树的构建阻塞渲染树的构建</p><h4 id="js-阻塞" tabindex="-1"><strong>js 阻塞</strong> <a class="header-anchor" href="#js-阻塞" aria-label="Permalink to &quot;**js 阻塞**&quot;">​</a></h4><p>当 HTML 解析器遇到一个 script 标记时，它会暂停构建 DOM，将控制权移交给 JS 引擎，直到 JS 引擎运行完毕</p><h4 id="如何解决-css-阻塞" tabindex="-1"><strong>如何解决 css 阻塞</strong> <a class="header-anchor" href="#如何解决-css-阻塞" aria-label="Permalink to &quot;**如何解决 css 阻塞**&quot;">​</a></h4><p><strong>CSS 引入的位置 —— 针对阻塞 DOM 解析</strong></p><p>一般我们把<code>&lt;style&gt;</code>、<code>&lt;link&gt;</code>放在<code>&lt;head&gt;</code>里面，提前加载好 CSS 资源，这样当 JavaScript 请求到样式表时将不必等待 CSS 资源的加载</p><p><strong>媒体查询的方式 —— 针对阻塞 render 树的构建</strong></p><p>有些 CSS 资源在首次渲染中可能不用用到，只是在用户交互（比如改变页面大小）时才会用到，所以我们通过媒体查询的方式来判断是否需要在首次渲染加载。这样从某种程度上会减少首屏加载时间</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;!--</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> 适用于所有情况，始终阻塞渲染 </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">--&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;style.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> rel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;!-- 网页首次加载时，只在打印内容时适用 --&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;print.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> rel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> media</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;print&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;!-- 如果不是在打印内容时，该样式表不阻塞渲染 --&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;!-- 符合条件时浏览器将阻塞渲染，直至样式表下载并处理完毕 --&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">link</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> href</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;other.css&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> rel</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;stylesheet&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> media</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;(max-width: 400px)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;!-- 如果不满足条件，不会阻塞渲染，但依旧会请求下载对应的资源 --&gt;</span></span></code></pre></div><h4 id="如何解决-js-阻塞" tabindex="-1"><strong>如何解决 js 阻塞</strong> <a class="header-anchor" href="#如何解决-js-阻塞" aria-label="Permalink to &quot;**如何解决 js 阻塞**&quot;">​</a></h4><ul><li><code>&lt;script&gt;</code>标签引入位置</li></ul><p>如果页面渲染内容为<code>&lt;script&gt;</code>标签请求的内容，则该<code>&lt;script&gt;</code>标签一般需要放在<code>&lt;head&gt;</code>里面</p><p>如果页面渲染内容跟<code>&lt;script&gt;</code>标签内容无关的话，比如说 <strong>DOM 事件</strong>、加载其他（还未见的）内容，则该<code>&lt;script&gt;</code>标签一般放在<code>&lt;body&gt;</code>标签里的最后位置</p><ul><li>defer 和 async 属性</li></ul><p>如果需要某段 JavaScript 代码需要提前加载，即可能会放在<code>&lt;head&gt;</code>里面或某些 DOM 节点前面，则给<code>&lt;script&gt;</code>标签添加 defer 或 async 属性：</p><ul><li>如果加载完需要 <strong>立刻执行</strong> 则使用 <code>async</code> 属性；</li><li>如果加载完不需要立刻执行，想要在页面结构加载完(<code>window.onload</code>)再立刻执行的话，使用 <code>defer</code> 属性； 值得注意的是：</li></ul><p>没有使用这两种属性之一的话，则 JavaScript 的加载和运行都会阻塞渲染，有的话只有运行会阻塞</p><hr><h2 id="📕-说说地址栏输入-url-敲下回车后发生了什么-从输入-url-的行" tabindex="-1">📕 说说地址栏输入 URL 敲下回车后发生了什么?从输入 URL 的行 <a class="header-anchor" href="#📕-说说地址栏输入-url-敲下回车后发生了什么-从输入-url-的行" aria-label="Permalink to &quot;📕 说说地址栏输入 URL 敲下回车后发生了什么?从输入 URL 的行&quot;">​</a></h2><p>在浏览中输入 URL 并且获取响应的过程，其实就是浏览器和该 URL 对应的服务器的网络通信过程。从输入  <code>URL</code>到回车后发生的行为主要有几个过程：</p><p><code>URL解析</code>—&gt; <code>DNS 查询</code>—&gt;<code>TCP 连接</code>—&gt;<code>HTTP 请求</code>—&gt;<code>响应请求</code>—&gt;<code>页面渲染</code></p><h3 id="url-解析" tabindex="-1">URL 解析 <a class="header-anchor" href="#url-解析" aria-label="Permalink to &quot;URL 解析&quot;">​</a></h3><p>当用户输入一个完整的<code>URL</code>之后，浏览器就开始解析<code>URL</code>的构成。一个<code>URL</code>的结构是由这些部分组成的：</p><p><img src="https://static.vue-js.com/27a0c690-bdf4-11eb-ab90-d9ae814b240d.png" alt=""></p><h3 id="dns-查询" tabindex="-1">DNS 查询 <a class="header-anchor" href="#dns-查询" aria-label="Permalink to &quot;DNS 查询&quot;">​</a></h3><p>在用户输入的<code>URL</code>中包含域名，然而域名并不是目标服务器真正意义上的地址，我们需要通过 DNS 解析获取相对应的 IP 地址，查询过程如下（详见<a href="#📕dns协议-是什么说说dns-完整的查询过程">DNS 协议查询过程</a>，这里不详述）：</p><img src="https://gitee.com/veal98/images/raw/master/img/20210120123619.png" title="" alt="" data-align="center"><h3 id="tcp-连接" tabindex="-1">TCP 连接 <a class="header-anchor" href="#tcp-连接" aria-label="Permalink to &quot;TCP 连接&quot;">​</a></h3><p><code>tcp</code>是一种面向有连接的传输层协议，在确定目标服务器服务器的<code>IP</code>地址后，则经历三次握手建立<code>TCP</code>连接（之前有讲过，这里不细讲），<strong>保证双方都具有可靠的接收和发送能力</strong>（详见<a href="#tcp三次握手">TCP 三次握手</a>）</p><p><img src="https://gitee.com/veal98/images/raw/master/img/20210107175526.png" alt=""></p><h3 id="浏览器发送请求" tabindex="-1">浏览器发送请求 <a class="header-anchor" href="#浏览器发送请求" aria-label="Permalink to &quot;浏览器发送请求&quot;">​</a></h3><p>当建立<code>tcp</code>连接之后，就可以在这基础上进行通信，浏览器发送  <code>http</code>  请求到目标服务器</p><p>请求的内容包括：</p><ul><li>请求行</li><li>请求头</li><li>请求主体</li></ul><img title="" src="https://ask.qcloudimg.com/http-save/yehe-3733321/7xtjn9diju.png?imageView2/2/w/2560/h/7000" alt="" width="632"><h3 id="服务器响应请求" tabindex="-1">服务器响应请求 <a class="header-anchor" href="#服务器响应请求" aria-label="Permalink to &quot;服务器响应请求&quot;">​</a></h3><p>当服务器接收到浏览器的请求之后，就会进行逻辑操作，处理完成之后返回一个<code>HTTP</code>响应消息，包括：</p><ul><li>状态行</li><li>响应头</li><li>响应正文</li></ul><p><img src="https://static.vue-js.com/c5fe0140-bdf4-11eb-ab90-d9ae814b240d.png" alt=""></p><h3 id="断开-tcp-连接" tabindex="-1">断开 TCP 连接 <a class="header-anchor" href="#断开-tcp-连接" aria-label="Permalink to &quot;断开 TCP 连接&quot;">​</a></h3><p>浏览器和服务器都不再需要发送数据后，四次挥手断开 TCP 连接，任意一方都可以发起关闭请求（详见<a href="#tcp四次挥手">TCP 四次挥手</a>）</p><h3 id="页面渲染" tabindex="-1">页面渲染 <a class="header-anchor" href="#页面渲染" aria-label="Permalink to &quot;页面渲染&quot;">​</a></h3><p>关于页面的渲染过程如下（详见<a href="#📕浏览器页面渲染">浏览器页面渲染</a>）：</p><ul><li>解析 HTML，构建 DOM 树</li><li>解析 CSS ，生成 CSS 规则树</li><li>合并 DOM 树和 CSS 规则，生成 render 树</li><li>布局 render 树（ Layout / reflow ），负责各元素尺寸、位置的计算</li><li>绘制 render 树（ paint ），绘制页面像素信息</li><li>浏览器会将各层的信息发送给 GPU，GPU 会将各层合成（ composite ），显示在屏幕上</li></ul><hr><h2 id="📕web-性能优化" tabindex="-1">📕web 性能优化 <a class="header-anchor" href="#📕web-性能优化" aria-label="Permalink to &quot;📕web 性能优化&quot;">​</a></h2><p>web 性能是客观的衡量标准，是用户对加载时间和运行的直观体验。web 性能指页面加载到可交互和可响应所消耗的时间，以及页面在交互时的流畅度。</p><h3 id="web-性能报告" tabindex="-1">web 性能报告 <a class="header-anchor" href="#web-性能报告" aria-label="Permalink to &quot;web 性能报告&quot;">​</a></h3><p>我们可以通过 Chrome 的扩展程序 lighthouse、Pingdom 等工具得到 FCP（First Contentful Paint）白屏时间、SI（Speed Index）页面渲染时间、TBT（Total Blocking Time）用户行为阻塞时间等，从而分析网页每部分的性能问题，同时它们也会给出相应的优化意见可以供我们参考，如果我们想要优化性能可以从以下几个方面入手：</p><h3 id="提高资源响应速度" tabindex="-1">提高资源响应速度 <a class="header-anchor" href="#提高资源响应速度" aria-label="Permalink to &quot;提高资源响应速度&quot;">​</a></h3><p>资源响应速度的主要优化点在于：减少请求数、减少请求资源体积、提升网络传输效率</p><ul><li><p><strong>使用 CDN 加速</strong>：内容分发网络，通过设置边缘结点缩短用户与服务端地理距离，从而来缩短请求静态资源时间。（详见<a href="#📕如何理解cdn-说说实现原理">如何理解 CDN</a>）</p></li><li><p><strong>开启 gzip 压缩</strong>：使用 gzip 压缩编码技术，减小资源体积。gzip 通常需要 web 服务器和客户端(浏览器)必须同时支持 gzip。gzip 压缩效率非常高，通常可达 70% 压缩率</p></li><li><p><strong>浏览器缓存</strong>：前端缓存一般可分为 http 缓存和浏览器缓存，http 缓存还分<strong>强缓存</strong>和<strong>协商缓存</strong>，浏览器缓存，比如<code>localStorage</code>,<code>sessionStorage</code>,<code>cookie</code>等（详见<a href="#📕如何理解浏览器缓存策略（http缓存）">浏览器缓存策略</a>）</p></li><li><p><strong>减少网络请求次数和体积</strong>：通过压缩文件及合并小文件为大文件，减少网络请求次数，但需要找到合理的平衡点。</p></li><li><p><strong>使用 HTTP/2</strong>（HTTP2 的优势见<a href="#📕说说http1.0/http1.1/http2.0的区别">HTTP1.0/HTTP1.1/HTTP2.0 的区别</a>）</p></li></ul><h3 id="资源体积优化" tabindex="-1">资源体积优化 <a class="header-anchor" href="#资源体积优化" aria-label="Permalink to &quot;资源体积优化&quot;">​</a></h3><ul><li><p>文本资源（包括<code>HTML</code>、<code>css</code>、<code>js</code>等）：组件按需加载、代码按需打包、按需引入第三方样式文件等</p></li><li><p>图片资源</p><p><code>字体图标代替图片图标</code> 一些通用的小图标，如箭头，叉，可以使用字体图标，减少请求，渲染更快</p><p><code>精灵图（没有字体图标效果好）</code> 一些带有企业特色的小图标，如淘宝购物车，笑脸娃娃，可以使用精灵图，让一张图上带有多个小图，然后使用 css 背景定位来显示出合适的位子，能大大减少请求</p><p><code>图片懒加载</code> 为了首屏渲染更快，图片可设置一张加载图代替，当页面在可视区域内时在替换为真正的图片 如果有首屏很大的高清图，可先渲染清晰度低的缩略图，在首页基本构建完成下一次事件循环再去替换为高清图</p><p><code>图片预加载</code> 可以在 window.onload 之后请求一些其他地方需要的图片资源 比如我们有一个活动页使用了高清图，我们可以在它的入口前的首页就加载它，当我们进去页面时，浏览器就会从缓存里读取这张图片</p><p><code>使用png格式的图片</code> PNG 格式是 WEB 图像中最通用的格式，它是一种无损压缩格式</p><p><code>小于10k的图片可以打包为base64格式</code> 可以使用 webpack url-loader 处理优化代码质量</p></li></ul><h3 id="提高代码质量" tabindex="-1">提高代码质量 <a class="header-anchor" href="#提高代码质量" aria-label="Permalink to &quot;提高代码质量&quot;">​</a></h3><ul><li>精简代码： <ul><li>使用 <code>lodash</code> 提供的功能函数</li><li>使用 ES6 语法</li><li>去除无效代码、封装共用模块代码提高代码耦合性</li></ul></li><li>代码性能： <ul><li>降低代码时间、空间复杂度、</li><li>减少会引起回流、重绘的代码操作（具体方案见<a href="#📕回流和重绘">回流和重绘</a>）</li><li>使用防抖和节流控制请求频率（<a href="#📕什么是防抖和节流有什么区别如何实现">防抖和节流</a>）等</li></ul></li><li>代码设计： <ul><li>优化长列表—使用<code>virtual-list</code>方案只给 DOM 添加当前屏幕显示的 DOM 节点</li><li>避免 ifarme 嵌套网页</li></ul></li><li>降低内存占用 <ul><li>合理使用闭包，防止内存泄漏</li><li>将使用的定时器及时清除</li><li>避免循环引用</li><li>DOM 删除时解绑事件等</li></ul></li></ul><h3 id="完善用户体验" tabindex="-1">完善用户体验 <a class="header-anchor" href="#完善用户体验" aria-label="Permalink to &quot;完善用户体验&quot;">​</a></h3><p>在设计页面的时候考虑到用户的习惯性行为，在用户操作的过程中给出网页使用的引导，在页面加载遇到问题时给与友好提示、考虑到用户的视觉变化在设计弹窗等网页行为时给一个过渡的效果等等......</p><hr><h2 id="📕-如何理解-cdn-说说实现原理" tabindex="-1">📕 如何理解 CDN 说说实现原理 <a class="header-anchor" href="#📕-如何理解-cdn-说说实现原理" aria-label="Permalink to &quot;📕 如何理解 CDN 说说实现原理&quot;">​</a></h2><p>CDN，即内容分发网络。它是构建在现有网络基础之上的智能虚拟网络，依靠部署在各地的边缘服务器，使用户就近获取所需内容，降低网络拥塞，提高用户访问响应速度和命中率。</p><h3 id="cdn-原理分析" tabindex="-1">CDN 原理分析 <a class="header-anchor" href="#cdn-原理分析" aria-label="Permalink to &quot;CDN 原理分析&quot;">​</a></h3><p>在没有应用<code>CDN</code>时，我们使用域名访问某一个站点时的路径为</p><blockquote><p>用户提交域名 → 浏览器对域名进行解释 →<code>DNS</code> 解析得到目的主机的 IP 地址 → 根据 IP 地址访问发出请求 → 得到请求数据并回复</p></blockquote><p>应用<code>CDN</code>后，<code>DNS</code> 返回的不再是 <code>IP</code> 地址，而是先返回一个<code>CNAME</code>(Canonical Name ) 别名记录，指向<code>CDN</code>的全局负载均衡，这个全局负载均衡系统会综合用户地理位置、运营商网络、边缘结点的负载情况等因素进行智能调度，计算最合适的边缘节点并返回给用户，具体流程如下：</p><p>①、当用户点击 APP 上的内容，APP 会根据 URL 地址去<strong>本地 DNS</strong>（域名解析系统）寻求 IP 地址解析。</p><p>②、本地 DNS 系统会将域名的解析权交给<strong>CDN 专用 DNS 服务器</strong>。</p><p>③、CDN 专用 DNS 服务器，将 CDN 的全局负载均衡设备 IP 地址返回用户。</p><p>④、用户向<strong>CDN 的负载均衡设备</strong>发起内容 URL 访问请求。</p><p>⑤、CDN 负载均衡设备根据用户 IP 地址，以及用户请求的内容 URL，选择一台用户所属区域的<strong>缓存服务器</strong>。</p><p>⑥、负载均衡设备告诉用户这台缓存服务器的 IP 地址，让用户向所选择的缓存服务器发起请求。</p><p>⑦、用户向缓存服务器发起请求，缓存服务器响应用户请求，将用户所需内容传送到用户终端。</p><p>⑧、如果这台缓存服务器上并没有用户想要的内容，那么这台缓存服务器就要网站的<strong>源服务器</strong>请求内容。</p><p>⑨、源服务器返回内容给缓存服务器，缓存服务器发给用户，并根据用户自定义的缓存策略，判断要不要把内容缓存到缓存服务器上。</p><h3 id="cdn-缓存代理" tabindex="-1">CDN 缓存代理 <a class="header-anchor" href="#cdn-缓存代理" aria-label="Permalink to &quot;CDN 缓存代理&quot;">​</a></h3><p>缓存系统是 <code>CDN</code>的另一个关键组成部分，缓存系统会有选择地缓存那些最常用的那些资源，其中有两个衡量<code>CDN</code>服务质量的指标：</p><ul><li><strong>命中率</strong>：用户访问的资源恰好在缓存系统里，可以直接返回给用户，命中次数与所有访问次数之比</li><li><strong>回源率</strong>：缓存里没有，必须用代理的方式回源站取，回源次数与所有访问次数之比</li></ul><p>缓存系统也可以划分出层次，分成<strong>一级缓存节点</strong>和<strong>二级缓存节点</strong>。一级缓存配置高一些，直连源站，二级缓存配置低一些，直连用户</p><p>回源的时候二级缓存只找一级缓存，一级缓存没有才回源站，可以有效地减少真正的回源</p><p>现在的商业 <code>CDN</code>命中率都在 90% 以上，相当于把源站的服务能力放大了 10 倍以上</p><hr><h2 id="📕-如何理解浏览器缓存策略-http-缓存" tabindex="-1">📕 如何理解浏览器缓存策略（HTTP 缓存） <a class="header-anchor" href="#📕-如何理解浏览器缓存策略-http-缓存" aria-label="Permalink to &quot;📕 如何理解浏览器缓存策略（HTTP 缓存）&quot;">​</a></h2><p>HTTP 缓存：缓存命中机制主要分为两个阶段—<strong>强缓存</strong>和**协商缓存。**浏览器是否启动缓存，主要是服务器来设置。当该资源首次被请求时，服务器通过设置 HTTP 响应的响应头来设置该资源的缓存信息</p><p>相同点：<strong>其中无论是哪种缓存命中，最终使用的都是浏览器缓存到本地的资源</strong></p><p>不同点：<strong>强缓存不发生网络请求。</strong></p><h3 id="强缓存" tabindex="-1">强缓存 <a class="header-anchor" href="#强缓存" aria-label="Permalink to &quot;强缓存&quot;">​</a></h3><p><strong>定义</strong>：强缓存主要是浏览器自行判断资源是否过期，如果不过期则直接使用缓存的资源（强缓存命中），不再进行网络请求</p><p><strong>实现</strong>：强缓存是利用<code>Expires</code>、<code>Cache-Control</code>或者<code>Pragma</code>这三个 http response header 实现的</p><p><strong>优先级<code>Pragma</code> &gt; <code>Cache-Control</code> &gt; <code>Expires</code>，其中<code>Pragma</code>不常用</strong></p><h4 id="expires" tabindex="-1">Expires <a class="header-anchor" href="#expires" aria-label="Permalink to &quot;Expires&quot;">​</a></h4><ul><li>HTTP 1.0 用于缓存管理的<code>header</code>字段，由服务器返回值表示一个资源过期的时间，描述的是属于服务端时间系统的一个绝对时间</li><li>判断方法：浏览器发起下一次请求时，当前 HTTP 发起的请求时间 <code>(this http request time) &lt; (expires设置的值)</code>，资源没有过期，缓存命中。</li><li>弊端：<code>Expires</code>遵循的是服务端的时间系统，而请求时间遵循的是客户端的时间系统，如果两者时间不是一致的，就可能产生误差</li></ul><h4 id="cache-control" tabindex="-1">Cache-Control <a class="header-anchor" href="#cache-control" aria-label="Permalink to &quot;Cache-Control&quot;">​</a></h4><p>为了解决 Expires 因为客户端和服务器端时间不统一带来的问题，HTTP 1.1 提出了 <code>Cache-Control</code> ，这个字段使用相对时间以秒为单位、用数值表示，进行比较的时候用的都是客户端的时间，相对来更有效与安全。</p><ul><li>判断方法：浏览器发起下一次请求时，当前 HTTP 发起的请求时间<code>(this http request time) &lt; (last http request time + cache-control 设置的值)</code> ，资源没有过期，缓存命中。</li></ul><p>该<code>header</code>字段的其他取值如下：</p><table><thead><tr><th>字段名</th><th>位置</th><th>说明</th></tr></thead><tbody><tr><td>no-cache</td><td>请求头,响应头</td><td>强制客户端向服务器发送请求（禁止<strong>强缓存</strong>）</td></tr><tr><td>no-store</td><td>请求头,响应头</td><td>禁止一切缓存。客户端和代理服务器都不能缓存响应。</td></tr><tr><td>max-age</td><td>请求头,响应头</td><td>设置资源可以被缓存多长时间，单位是秒。</td></tr><tr><td>no-transform</td><td>请求头,响应头</td><td>代理不可更改媒体类型</td></tr><tr><td>cache-extension</td><td>请求头,响应头</td><td>新指令标记（token）</td></tr><tr><td>s-maxage</td><td>响应头</td><td>和 max-age 同理，只不过是针对代理服务器缓存而言。</td></tr><tr><td>private</td><td>响应头</td><td>不能被代理服务器缓存</td></tr><tr><td>public</td><td>响应头</td><td>响应可以被任何缓存区缓存</td></tr><tr><td>must-revalidate</td><td>响应头</td><td>在缓存过期前可以使用，缓存过期以后必须向服务器验证。</td></tr><tr><td>proxy-revalidate</td><td>响应头</td><td>要求中间缓存服务器对缓存的响应有效性需再次确认（代理服务器需要发送请求给服务器端确认资源有效性，不能直接返回缓存）</td></tr><tr><td>only-if-cached</td><td>请求头</td><td>从缓存中获取资源</td></tr><tr><td>min-fresh</td><td>请求头</td><td>单位：秒，期望在指定的时间内，响应仍有效</td></tr><tr><td>max-stale</td><td>请求头</td><td>单位：秒， 接受已过期的响应</td></tr></tbody></table><p><strong>Pragma 优先级最高，就一个值<code>no-cache</code>等同于<code>Cache-Control</code> 中 <code>no-cache</code></strong></p><p><strong>缓存命中</strong>：当强缓存命中时，HTTP 状态码为 200，资源从缓存中加载（ <code>from memory cache</code> / <code>from disk cache</code>）</p><ul><li><code>from memory cache</code>：是把资源存到内存中，当进程退出时（关闭浏览器），内存中的数据会清空</li><li><code>from disk cache</code>：是把资源缓存在磁盘中，进程退出时不受影响</li></ul><h3 id="协商缓存" tabindex="-1">协商缓存 <a class="header-anchor" href="#协商缓存" aria-label="Permalink to &quot;协商缓存&quot;">​</a></h3><p>在强缓存阶段无法命中的情况下，浏览器发起请求，询问服务器是否可以使用本地缓存资源，如果服务器检查发现浏览器本地的资源没有过期，则返回 304 告诉浏览器可以使用本地的缓存资源（协商缓存命中），否则返回 200 正常响应，协商缓存主要由``Last-Modified<code> 和</code>Etag<code> 两个</code>HTTP头`实现：</p><h4 id="last-modified-if-modified-since" tabindex="-1">Last-Modified / If-Modified-Since <a class="header-anchor" href="#last-modified-if-modified-since" aria-label="Permalink to &quot;Last-Modified / If-Modified-Since&quot;">​</a></h4><p>浏览器发送请求时，会将上次响应头中的 <code>Last-Modified</code> 赋值给 本次请求头中的 <code>If-Modified-Since</code> 字段。服务端中接收到请求之后，会将这个字段和当前资源最后的修改时间做对比，</p><ul><li>如果 <code>If-Modified-Since</code> （上一次资源修改时间） &lt; 服务器上资源的最后修改时间（发送请求时间晚于服务器资源最后修改时间），则说明当前资源被<strong>修改过了</strong>，服务端需要返回新的资源，此时响应 200，返回正常的响应。同时这次响应会返回新的<code>Last-Modified</code> 值，用于更新浏览器缓存。</li><li>如果 <code>If-Modified-Since</code> （上一次资源修改时间）≥ 服务器上资源的最后修改时间，则说明没有修改过资源，则返回<strong>304</strong>状态码，不会返回资源内容。</li></ul><p>弊端：</p><ul><li>短时间内资源发生了变化，这个字段并不会发生变化，缓存命中可能失效。</li><li>如果出现了服务器资源因为反复修改，但资源内容并没发生变化，此时浏览器再次请求服务器，实际上应该认为缓存命中（实际内容没有变化），但是此时通过该字段的比较会导致缓存命中失败</li></ul><h4 id="etag-if-none-match-优先级最高" tabindex="-1">Etag/ If-None-Match（优先级最高） <a class="header-anchor" href="#etag-if-none-match-优先级最高" aria-label="Permalink to &quot;Etag/ If-None-Match（优先级最高）&quot;">​</a></h4><p>为了解决 Last-Modifed 的缓存命中问题，可以通过<code>Etag</code>来管理协商缓存命中。</p><ul><li>服务端收到响应以后，根据当前资源内容重新生成一份<code>Etag</code> ，比较该值和<code>If-None-Match</code> 是否相等，相等（内容没有发生改变）则返回<strong>304</strong>，不相等则返回 200 和正常响应。但同<code>Last-Modified</code> 的区别在于即使服务器重新生成的<code>Etag</code>字段和原来的没有变化，但是因为重新生成了，304 响应中同样会返回<code>Etag</code>字段。</li></ul><hr><h2 id="📕-说说-http1-0-http1-1-http2-0-的区别" tabindex="-1">📕 说说 HTTP1.0/HTTP1.1/HTTP2.0 的区别 <a class="header-anchor" href="#📕-说说-http1-0-http1-1-http2-0-的区别" aria-label="Permalink to &quot;📕 说说 HTTP1.0/HTTP1.1/HTTP2.0 的区别&quot;">​</a></h2><h3 id="http1-0—无状态无连接" tabindex="-1">HTTP1.0—无状态无连接 <a class="header-anchor" href="#http1-0—无状态无连接" aria-label="Permalink to &quot;HTTP1.0—无状态无连接&quot;">​</a></h3><p>HTTP/1.0 规定浏览器和服务器保持短暂的连接。浏览器的每次请求都需要与服务器建立一个 TCP 连接</p><ul><li>无连接：服务器处理完成后立即断开 TCP 连接</li><li>无状态：服务器不跟踪每个客户端也不记录过去的请求</li></ul><p>问题：</p><ol><li><p>无法复用连接。每次发送请求的时候都需要完成一次 TCP 连接释放的过程，会导致网络的利用率非常低。</p></li><li><p>队头堵塞(head of line blocking)。由于 HTTP/1.0 规定下一个请求必须在前一个请求响应到达之后才能发送。如果上一个请求响应一直不到达，那么下一个请求就不发送，就到导致阻塞后面的请求。</p></li></ol><h3 id="http1-1—长连接请求管道化" tabindex="-1">HTTP1.1—长连接请求管道化 <a class="header-anchor" href="#http1-1—长连接请求管道化" aria-label="Permalink to &quot;HTTP1.1—长连接请求管道化&quot;">​</a></h3><p><strong>特点</strong>：为了解决 HTTP1.0 的问题，推出了 HTTP1.1</p><ul><li>长连接：HTTP/1.1 增加了一个<code>Connection</code>字段，通过设置<code>Keep-alive</code>（默认已设置）可以保持连接不断开，客户端可以通过在请求头中携带<code>Connection:false</code>来告知服务器关闭 TCP 连接</li><li>支持请求管道化（pipelining）：HTTP 管道化让我们把先进先出队列从客户端（请求队列）迁移到服务端（响应队列），客户端可以同时发起多个请求，但是服务端还是会按序依次发送响应</li></ul><p><strong>问题</strong>：</p><p>​ 虽然 HTTP/1.1 支持管道化，但是服务器也必须进行逐个响应的送回，依旧无法解决队头阻塞的问题</p><p><strong>增加 HTTP 头</strong>：<code>HTTP1.1</code>在<code>HTTP1.0</code>的基础上，增加更多的请求头和响应头来完善的功能，如下：</p><ul><li>引入了更多的缓存控制策略，如 cache-control, If-Match, If-None-Match 等缓存头来控制缓存策略</li><li>引入 range，允许值请求资源某个部分</li><li>引入 host，实现了在一台 WEB 服务器上可以在同一个 IP 地址和端口号上使用不同的主机名来创建多个虚拟 WEB 站点（一个服务器能够用来创建多个 Web 站点）</li></ul><p>并且还添加了其他的<strong>请求方法</strong>：<code>put</code>、<code>delete</code>、<code>options</code>...</p><h3 id="http2-0" tabindex="-1">HTTP2.0 <a class="header-anchor" href="#http2-0" aria-label="Permalink to &quot;HTTP2.0&quot;">​</a></h3><h4 id="二进制分帧" tabindex="-1">二进制分帧 <a class="header-anchor" href="#二进制分帧" aria-label="Permalink to &quot;二进制分帧&quot;">​</a></h4><p>HTTP/2 采用<strong>二进制格式</strong>传输数据，而非 HTTP/1.x 的文本格式，二进制协议解析起来<strong>更高效</strong>。HTTP/2 将请求和响应数据分割为更小的<strong>帧</strong>，并<strong>采用二进制编码</strong></p><h4 id="多路复用" tabindex="-1">多路复用 <a class="header-anchor" href="#多路复用" aria-label="Permalink to &quot;多路复用&quot;">​</a></h4><p><code>HTTP/2</code> 复用<code>TCP</code>连接，在一个连接里，客户端和浏览器都可以<strong>同时</strong>发送多个请求或回应，而且不用按照顺序一一对应，避免了”队头堵塞”</p><ul><li>同域名下所有通信都在单个连接上完成</li><li>该连接可以承载任意数量的双向数据流</li><li>每个数据流都以消息的形式发送，而消息又由一个或多个帧组成。</li><li>多个帧之间可以乱序发送，根据帧首部的流标识可以重新组装，这也是多路复用同时发送数据的实现条件</li></ul><h4 id="服务器推送" tabindex="-1">服务器推送 <a class="header-anchor" href="#服务器推送" aria-label="Permalink to &quot;服务器推送&quot;">​</a></h4><p><code>HTTP2</code>引入服务器推送，允许服务端推送资源给客户端。服务端可以在发送页面 HTML 时主动推送其它资源，而不用等到浏览器解析到相应位置，发起请求再响应</p><p>但是，客户端也有权利选择是否接收。如果服务端推送的资源已经被浏览器缓存过，浏览器可以通过发送<code>RST_STREAM</code>帧来拒收</p><h4 id="头部压缩" tabindex="-1">头部压缩 <a class="header-anchor" href="#头部压缩" aria-label="Permalink to &quot;头部压缩&quot;">​</a></h4><p>HTTP/2.0 通过在通讯双方各自<code>cache</code>一份”首部表”来跟踪和存储之前发送的键值对，每次响应和请求只发送“首部表”中差异数据，既避免了重复<code>header</code>的传输，又减小了需要传输的大小。“首部表”在连接中始终存在，由通信双方共同渐进的更新</p>', 254);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArticleMetadata = __unplugin_components_4;
  const _component_ClientOnly = resolveComponent("ClientOnly");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createVNode(_component_ClientOnly, null, {
      default: withCtx(() => {
        var _a, _b;
        return [
          (((_a = _ctx.$frontmatter) == null ? void 0 : _a.aside) ?? true) && (((_b = _ctx.$frontmatter) == null ? void 0 : _b.showArticleMetadata) ?? true) ? (openBlock(), createBlock(_component_ArticleMetadata, {
            key: 0,
            article: _ctx.$frontmatter
          }, null, 8, ["article"])) : createCommentVNode("", true)
        ];
      }),
      _: 1
    }),
    _hoisted_2
  ]);
}
const _01Http__ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _01Http__ as default
};
