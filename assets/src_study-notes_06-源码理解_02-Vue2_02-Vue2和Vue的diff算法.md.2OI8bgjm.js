import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/06-源码理解/02-Vue2/02-Vue2和Vue的diff算法.md","filePath":"src/study-notes/06-源码理解/02-Vue2/02-Vue2和Vue的diff算法.md","lastUpdated":1739881735000}');
const _sfc_main = { name: "src/study-notes/06-源码理解/02-Vue2/02-Vue2和Vue的diff算法.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h3 id="背景知识-diff-算法和虚拟-dom" tabindex="-1"><strong>背景知识：diff 算法和虚拟 DOM</strong> <a class="header-anchor" href="#背景知识-diff-算法和虚拟-dom" aria-label="Permalink to &quot;**背景知识：diff 算法和虚拟 DOM**&quot;">​</a></h3><p>虚拟 DOM（VDOM）是一个 JavaScript 对象，表示页面元素的结构，而 <strong>diff 算法</strong> 用于比较新旧虚拟 DOM 之间的差异，并最小化真实 DOM 更新的次数。这些算法的核心目标是通过高效地检测变化，避免不必要的 DOM 更新，优化性能。</p><h3 id="vue-2-和-vue-3-的-diff-算法差异" tabindex="-1"><strong>Vue 2 和 Vue 3 的 Diff 算法差异：</strong> <a class="header-anchor" href="#vue-2-和-vue-3-的-diff-算法差异" aria-label="Permalink to &quot;**Vue 2 和 Vue 3 的 Diff 算法差异：**&quot;">​</a></h3><h4 id="_1-vue-2-的-diff-算法" tabindex="-1">1. <strong>Vue 2 的 Diff 算法</strong> <a class="header-anchor" href="#_1-vue-2-的-diff-算法" aria-label="Permalink to &quot;1. **Vue 2 的 Diff 算法**&quot;">​</a></h4><p>Vue 2 使用的是 <strong>同层比较</strong> 和 <strong>基于索引的 Diff 算法</strong>，它会从 <strong>头到尾</strong> 逐一比较每一对节点。它会尽量复用 <code>key</code> 相同的节点，但是 <strong>没有很好地处理节点顺序变化时的性能</strong>。下面是 Vue 2 在 <strong>处理列表更新时</strong> 的具体行为。</p><h4 id="例子" tabindex="-1">例子： <a class="header-anchor" href="#例子" aria-label="Permalink to &quot;例子：&quot;">​</a></h4><p>假设有以下两个列表：</p><ul><li><code>old = [1, 2, 3, 4, 5]</code></li><li><code>new = [1, 4, 2, 3, 5]</code></li></ul><ol><li><p><strong>创建虚拟 DOM：</strong></p><p>Vue 会为这两个列表生成虚拟 DOM：</p><p><strong><code>old</code> 列表：</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;3&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;4&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;5&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p><strong><code>new</code> 列表：</strong></p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;1&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;1&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;4&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;4&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;2&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;2&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;3&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;3&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> key</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;5&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;5&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">li</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">ul</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div></li><li><p><strong>diff 比较过程：</strong></p><ul><li><p><strong>比较 <code>key=&quot;1&quot;</code>：</strong><br> 它们在新旧列表中都存在，并且值没有变化，因此 Vue 会复用这个节点。</p></li><li><p><strong>比较 <code>key=&quot;2&quot;</code> 和 <code>key=&quot;4&quot;</code>：</strong><br> 在 Vue 2 中，它会发现 <code>key=&quot;2&quot;</code> 不在新的列表中，而 <code>key=&quot;4&quot;</code> 出现了。因此 Vue 会 <strong>删除旧的 <code>2</code> 节点</strong>，并 <strong>插入新的 <code>4</code> 节点</strong>。</p></li><li><p><strong>比较 <code>key=&quot;3&quot;</code> 和 <code>key=&quot;2&quot;</code>：</strong><br> 同理，Vue 会看到 <code>key=&quot;3&quot;</code> 不再在新的列表中，而 <code>key=&quot;2&quot;</code> 在新的列表中。Vue 会 <strong>删除旧的 <code>3</code> 节点</strong>，并 <strong>插入新的 <code>2</code> 节点</strong>。</p></li><li><p><strong>比较 <code>key=&quot;4&quot;</code> 和 <code>key=&quot;3&quot;</code>：</strong><br> Vue 会认为 <code>key=&quot;4&quot;</code> 和 <code>key=&quot;3&quot;</code> 顺序发生了变化，因此 Vue 会 <strong>删除旧的 <code>4</code> 节点</strong>，并 <strong>插入新的 <code>3</code> 节点</strong>。</p></li><li><p><strong>比较 <code>key=&quot;5&quot;</code>：</strong><br> 它们在新旧列表中都存在，并且值没有变化，因此 Vue 会复用这个节点。</p></li></ul></li></ol><p><strong>最终效果：</strong></p><ul><li><strong>删除</strong> <code>2</code> 和 <code>3</code>。</li><li><strong>插入</strong> <code>4</code> 和 <code>2</code>。</li><li><strong>重新排序</strong> <code>3</code>。</li></ul><p><strong>性能问题：</strong></p><ul><li>Vue 2 处理这类顺序变化时会执行多次删除和插入操作，对于大量列表节点来说，这会导致性能下降。</li></ul><h4 id="_2-vue-3-的-diff-算法" tabindex="-1">2. <strong>Vue 3 的 Diff 算法</strong> <a class="header-anchor" href="#_2-vue-3-的-diff-算法" aria-label="Permalink to &quot;2. **Vue 3 的 Diff 算法**&quot;">​</a></h4><p>Vue 3 引入了 <strong>双端比较</strong>（Two-pointer strategy）来优化 <strong>顺序变化</strong>。这使得在处理节点顺序变化时，Vue 3 更加高效，通过 <strong>节点复用</strong> 和 <strong>移动</strong> 来减少不必要的删除和插入操作。</p><h4 id="例子-1" tabindex="-1">例子： <a class="header-anchor" href="#例子-1" aria-label="Permalink to &quot;例子：&quot;">​</a></h4><p>对于相同的 <code>old = [1, 2, 3, 4, 5]</code> 和 <code>new = [1, 4, 2, 3, 5]</code> 列表，Vue 3 的处理方式如下：</p><ol><li><p><strong>创建虚拟 DOM：</strong></p><p>和 Vue 2 相同，首先 Vue 会为这两个列表生成虚拟 DOM。</p></li><li><p><strong>双端比较：</strong></p><p>Vue 3 使用两个指针分别指向新旧列表的开始和结束位置，然后从两端开始进行比较，尽可能复用中间节点，优化顺序变化。</p><ul><li><p><strong>左端比较：</strong><br> 首先比较 <code>key=&quot;1&quot;</code>，它们相同，Vue 会复用这个节点。</p></li><li><p><strong>右端比较：</strong><br> 比较 <code>key=&quot;5&quot;</code>，它们也相同，因此 Vue 会复用这个节点。</p></li><li><p><strong>处理中间项：</strong></p><ul><li><strong><code>key=&quot;4&quot;</code> 和 <code>key=&quot;2&quot;</code> 的交换：</strong><br> Vue 3 会检测到 <code>key=&quot;4&quot;</code> 和 <code>key=&quot;2&quot;</code> 的顺序变化，直接 <strong>移动</strong> <code>key=&quot;4&quot;</code> 到 <code>key=&quot;2&quot;</code> 的位置，而不是销毁并插入新节点。</li><li><strong><code>key=&quot;2&quot;</code> 和 <code>key=&quot;3&quot;</code> 的交换：</strong><br> 同样，Vue 会 <strong>移动</strong> <code>key=&quot;2&quot;</code> 和 <code>key=&quot;3&quot;</code>，而不是删除再插入。</li></ul></li></ul></li><li><p><strong>结果：</strong></p><ul><li><strong>复用</strong> <code>key=&quot;1&quot;</code> 和 <code>key=&quot;5&quot;</code>。</li><li><strong>移动</strong> <code>key=&quot;4&quot;</code> 和 <code>key=&quot;2&quot;</code>，而不是销毁再插入。</li><li><strong>移动</strong> <code>key=&quot;3&quot;</code>。</li></ul></li></ol><p><strong>Vue 3 的优势：</strong></p><ul><li>Vue 3 在处理顺序变化时，通过 <strong>双端比较</strong> 能高效地进行节点 <strong>复用</strong> 和 <strong>移动</strong>，避免了 Vue 2 中的频繁删除和插入操作。</li><li>通过减少不必要的 DOM 操作，Vue 3 提供了更高效的渲染性能，尤其是在大型列表中。</li></ul><h3 id="性能对比-vue-2-vs-vue-3" tabindex="-1"><strong>性能对比：Vue 2 vs. Vue 3</strong> <a class="header-anchor" href="#性能对比-vue-2-vs-vue-3" aria-label="Permalink to &quot;**性能对比：Vue 2 vs. Vue 3**&quot;">​</a></h3><table><thead><tr><th>特性</th><th>Vue 2</th><th>Vue 3</th></tr></thead><tbody><tr><td><strong>Diff 算法</strong></td><td>同层比较，基于索引的比较</td><td>双端比较，优化节点顺序变化</td></tr><tr><td><strong>性能</strong></td><td>顺序变化时性能较差，尤其是大量节点时</td><td>优化节点复用和排序处理，大幅提升性能</td></tr><tr><td><strong><code>key</code> 使用</strong></td><td>依赖 <code>key</code> 来复用节点，但顺序变化时效率低</td><td><code>key</code> 加双端比较，大幅提高性能</td></tr><tr><td><strong>DOM 操作</strong></td><td>频繁删除和插入，性能损耗大</td><td>优化为节点复用和移动，减少 DOM 操作</td></tr><tr><td><strong>适用场景</strong></td><td>小型列表或顺序不频繁变化</td><td>适合大规模列表，特别是顺序频繁变化时</td></tr></tbody></table><h3 id="总结" tabindex="-1"><strong>总结</strong> <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;**总结**&quot;">​</a></h3><ul><li><strong>Vue 2：</strong> 处理列表顺序变化时，依赖同层比较和基于索引的策略，通常会导致频繁的节点 <strong>删除</strong> 和 <strong>插入</strong>，尤其是在长列表和顺序变化较大时，性能会下降。</li><li><strong>Vue 3：</strong> 通过引入 <strong>双端比较</strong>，能够在处理列表顺序变化时高效地 <strong>复用节点</strong> 和 <strong>移动节点</strong>，避免了不必要的 DOM 操作，从而大大提升了性能。</li></ul><p><strong>Vue 3</strong> 的 <strong>diff 算法</strong> 优化使得它在处理动态更新和复杂数据变化时，尤其是大型列表渲染时，表现得更加高效。</p><p>好的，那我将更详细地解释一下 Vue 2 和 Vue 3 在 <strong>节点移动</strong> 方面的差异，并配合源码分析。</p><h3 id="vue-2-源码解析-如何实现节点的复用和移动" tabindex="-1">Vue 2 源码解析：如何实现节点的复用和移动 <a class="header-anchor" href="#vue-2-源码解析-如何实现节点的复用和移动" aria-label="Permalink to &quot;Vue 2 源码解析：如何实现节点的复用和移动&quot;">​</a></h3><p>我们来看 Vue 2 的 <strong>节点复用</strong> 和 <strong>移动</strong> 相关的核心源码。我们主要关注的是 <code>patch</code> 函数，它是用来更新 DOM 的，而 <code>updateChildren</code> 函数则是对比新旧子节点并做相应更新的关键。</p><h4 id="_1-patch-函数-vue-2" tabindex="-1">1. <strong><code>patch</code> 函数（Vue 2）</strong> <a class="header-anchor" href="#_1-patch-函数-vue-2" aria-label="Permalink to &quot;1. **`patch` 函数（Vue 2）**&quot;">​</a></h4><p>在 Vue 2 中，<code>patch</code> 函数负责对比新旧虚拟 DOM，并进行更新。它的核心流程如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> patch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">vnode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">hydrating</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">removeOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">!</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oldVnode) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 这里是挂载新的 vnode</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    createElm</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(vnode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 这里是对比更新</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    updateChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVnode, vnode, removeOnly);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>当 <code>oldVnode</code> 存在时，<code>updateChildren</code> 会被调用。这个函数的主要目的是对比新旧虚拟节点，并判断是 <strong>复用</strong> 还是 <strong>移动</strong> 节点。</p><h4 id="_2-updatechildren-函数-vue-2" tabindex="-1">2. <strong><code>updateChildren</code> 函数（Vue 2）</strong> <a class="header-anchor" href="#_2-updatechildren-函数-vue-2" aria-label="Permalink to &quot;2. **`updateChildren` 函数（Vue 2）**&quot;">​</a></h4><p><code>updateChildren</code> 的源码是 Vue 2 实现节点复用和移动的核心部分。我们以这段代码为基础，分析它是如何进行子节点更新的：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> updateChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">parentElm</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldCh</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newCh</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">removeOnly</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[oldStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[newStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[oldEndIdx];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[newEndIdx];</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  while</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndIdx) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartVNode) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 情况 1：首节点相同，复用</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      oldStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oldStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      newStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">newStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndVNode) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 情况 2：尾节点相同，复用</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      oldEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oldEndIdx];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      newEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">--</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">newEndIdx];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 情况 3：两个节点顺序发生了变化，需要移动</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 调用 patch 函数来移动或更新节点</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">      moveVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldStartVNode, newStartVNode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      oldStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">oldStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">      newStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">newStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>这个函数的工作原理是：</p><ul><li>使用双端指针（<code>oldStartIdx</code>, <code>newStartIdx</code>, <code>oldEndIdx</code>, <code>newEndIdx</code>）来遍历新旧节点列表。</li><li>当 <strong><code>oldStartVNode === newStartVNode</code></strong> 或 <strong><code>oldEndVNode === newEndVNode</code></strong> 时，说明这些节点是相同的，可以 <strong>复用</strong>。</li><li>如果节点顺序发生了变化，Vue 会尝试进行 <strong>节点移动</strong>。</li></ul><h4 id="_3-节点移动" tabindex="-1">3. <strong>节点移动</strong> <a class="header-anchor" href="#_3-节点移动" aria-label="Permalink to &quot;3. **节点移动**&quot;">​</a></h4><p>如果节点顺序发生了变化，<code>moveVNode</code> 函数将被调用：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> moveVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // 节点移动的逻辑，通过 Vue 的 VNode API 来重新排序 DOM</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // 假设我们有一个父元素 parentElm 和需要移动的节点 oldVNode 和 newVNode</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  parentElm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(newVNode.elm, oldVNode.elm);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>这个操作会将旧节点移动到新节点的位置，或者将新节点插入到相应的位置。</p><h3 id="vue-3-源码解析-递增子序列-lis-优化" tabindex="-1">Vue 3 源码解析：递增子序列（LIS）优化 <a class="header-anchor" href="#vue-3-源码解析-递增子序列-lis-优化" aria-label="Permalink to &quot;Vue 3 源码解析：递增子序列（LIS）优化&quot;">​</a></h3><p>Vue 3 中使用 <strong>递增子序列</strong>（LIS）来优化节点更新。我们来看一下它如何实现节点复用和移动的。</p><h4 id="_1-patch-函数-vue-3" tabindex="-1">1. <strong><code>patch</code> 函数（Vue 3）</strong> <a class="header-anchor" href="#_1-patch-函数-vue-3" aria-label="Permalink to &quot;1. **`patch` 函数（Vue 3）**&quot;">​</a></h4><p>与 Vue 2 相似，Vue 3 的 <code>patch</code> 函数也负责进行节点的更新。不同之处在于，Vue 3 对于子节点的更新做了更多优化，特别是使用了 <strong>LIS</strong> 算法来减少无谓的移动。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> patch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (oldVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&amp;&amp;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldVNode.key </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">===</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newVNode.key) {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    updateChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVNode, newVNode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  } </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">else</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    createElm</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(newVNode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><p>在 <code>updateChildren</code> 过程中，Vue 3 会使用 <strong>LIS</strong> 算法来找到最长递增子序列，从而尽可能避免多余的 DOM 操作。</p><h4 id="_2-updatechildren-函数-vue-3" tabindex="-1">2. <strong><code>updateChildren</code> 函数（Vue 3）</strong> <a class="header-anchor" href="#_2-updatechildren-函数-vue-3" aria-label="Permalink to &quot;2. **`updateChildren` 函数（Vue 3）**&quot;">​</a></h4><p>在 Vue 3 中，<code>updateChildren</code> 的实现引入了 <strong>LIS</strong> 算法。具体的代码如下：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> updateChildren</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">parentElm</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldCh</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newCh</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> -</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 1</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[oldStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[newStartIdx];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[oldEndIdx];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndVNode </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[newEndIdx];</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> newKeyToIdx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {};</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newStartIdx; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newEndIdx; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    newKeyToIdx[newCh[i].key] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> seq</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> source</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [];</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // Find the longest increasing subsequence (LIS)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldStartIdx; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldEndIdx; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> oldVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[i];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> newIdx</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newKeyToIdx[oldVNode.key];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (newIdx </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">===</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> undefined</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">      // 不需要复用的节点</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">      continue</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    seq.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(newIdx);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    source.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">push</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(i);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> lis</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> longestIncreasingSubsequence</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(seq);</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // 移动节点</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  for</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> 0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">&lt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> source.</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">length</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">; i</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">++</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> oldVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> oldCh[source[i]];</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    const</span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;"> newVNode</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> newCh[lis[i]];</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    moveVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(oldVNode, newVNode);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h4 id="_3-lis-算法实现" tabindex="-1">3. <strong>LIS 算法实现</strong> <a class="header-anchor" href="#_3-lis-算法实现" aria-label="Permalink to &quot;3. **LIS 算法实现**&quot;">​</a></h4><p>LIS 算法是用来计算一个 <strong>最长递增子序列</strong>，它通过 <code>seq</code> 数组找到哪些节点在新旧列表中顺序不变，从而避免移动这些节点。</p><p>具体步骤：</p><ol><li><strong>新旧节点的 key 映射</strong>：首先通过新节点 <code>key</code> 创建一个映射，帮助快速查找每个旧节点在新节点中的位置。</li><li><strong>计算 LIS</strong>：使用动态规划算法来计算旧节点在新节点中的最长递增子序列，尽量这些节点的顺序不变。</li><li><strong>移动节点</strong>：对于不在 LIS 中的节点，Vue 3 会执行移动操作。</li></ol><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> longestIncreasingSubsequence</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">arr</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">  // 经典的 LIS 算法，O(n log n)</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> lis </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> [];</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  arr.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">forEach</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">((</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">x</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=&gt;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    let</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> i </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> binarySearch</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(lis, x);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    lis[i] </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> x;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  });</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">  return</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> lis;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h4 id="_4-节点移动" tabindex="-1">4. <strong>节点移动</strong> <a class="header-anchor" href="#_4-节点移动" aria-label="Permalink to &quot;4. **节点移动**&quot;">​</a></h4><p>Vue 3 的 <strong>LIS</strong> 算法减少了节点移动的次数，只对 <strong>不在 LIS 中的节点</strong> 进行移动，从而提高了性能。</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> moveVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">oldVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">newVNode</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">  parentElm.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">insertBefore</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(newVNode.elm, oldVNode.elm);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span></code></pre></div><h3 id="vue-2-与-vue-3-的比较" tabindex="-1">Vue 2 与 Vue 3 的比较 <a class="header-anchor" href="#vue-2-与-vue-3-的比较" aria-label="Permalink to &quot;Vue 2 与 Vue 3 的比较&quot;">​</a></h3><ul><li><strong>Vue 2</strong> 使用双端指针法，通过节点的 <code>key</code> 来复用和移动节点。它的核心思想是尽量复用旧节点，只有在顺序发生变化时才会移动节点。</li><li><strong>Vue 3</strong> 引入了 <strong>LIS 算法</strong>，通过计算最长递增子序列来减少不必要的节点移动。它优化了 Vue 2 中的移动操作，特别是在复杂的列表更新场景中，提高了性能。</li></ul><h2 id="总结-1" tabindex="-1">总结 <a class="header-anchor" href="#总结-1" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p>Vue 2 的行为： 在 Vue 2 中，当需要更新子节点时，使用的是 双端指针法（双端比较）。从两端开始比较，如果节点是相同的（通过 key 对比），就 复用节点，如果顺序发生了变化，Vue 会通过 移动节点 来调整顺序。而对于中间那些顺序发生了变化的节点，Vue 会 直接删除并重新插入，也就是说，它并不进行排序，而是基于旧的节点和新的节点来决定哪些需要删除、哪些需要移动。</p><p>所以，在 Vue 2 中，如果节点顺序发生了变化，Vue 会删除掉旧的节点并重新插入新节点，特别是对于那些顺序变化较大的部分，可能会导致不必要的重新渲染和 DOM 操作。</p><p>Vue 3 的优化（LIS）： 在 Vue 3 中，递增子序列算法（LIS） 被引入来优化这一过程。具体来说，Vue 3 会先通过 LIS 算法 找出一个 最长递增子序列，这个子序列中的节点顺序是不变的，意味着这些节点的顺序没有发生变化，Vue 3 会 复用这些节点。</p><p>对于 不在递增子序列中的节点，Vue 3 会执行移动操作来调整它们的位置，而不是直接删除并重新插入。通过这种方式，Vue 3 可以 减少不必要的 DOM 操作，提高性能，尤其是在节点数量比较多或者节点顺序发生较大变化的情况下。</p><p>总结： Vue 2：会直接删除并插入那些顺序发生变化的节点，并通过双端指针法比较，不能对节点进行排序优化。 Vue 3：引入了 LIS 算法，通过查找最长递增子序列来复用顺序不变的节点，减少无谓的节点移动和 DOM 操作，从而优化了性能。</p>', 66);
const _hoisted_67 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_67);
}
const _02Vue2_Vue_diff__ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _02Vue2_Vue_diff__ as default
};
