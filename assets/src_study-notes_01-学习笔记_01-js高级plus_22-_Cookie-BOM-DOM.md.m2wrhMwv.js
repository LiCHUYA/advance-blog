import { _ as __unplugin_components_4 } from "./chunks/ArticleMetadata.l7JwFtuX.js";
import { _ as _export_sfc, D as resolveComponent, o as openBlock, c as createElementBlock, I as createVNode, w as withCtx, k as createBaseVNode, a as createTextVNode, R as createStaticVNode, b as createBlock, e as createCommentVNode } from "./chunks/framework.b55ravPP.js";
const _imports_0 = "/advance-blog/assets/image-20240902210639646.e9xEZvUA.png";
const _imports_1 = "/advance-blog/assets/image-20240902212743763.W9MWw_t3.png";
const _imports_2 = "/advance-blog/assets/image-20240902213154305.vmGZjeYH.png";
const _imports_3 = "/advance-blog/assets/image-20240902214406033.2m0FuXUf.png";
const _imports_4 = "/advance-blog/assets/image-20240903100853837.HQgfiHZG.png";
const _imports_5 = "/advance-blog/assets/image-20240903101629503.R3n429P7.png";
const __pageData = JSON.parse('{"title":"Cookie","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/01-js高级plus/22-_Cookie-BOM-DOM.md","filePath":"src/study-notes/01-学习笔记/01-js高级plus/22-_Cookie-BOM-DOM.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/01-js高级plus/22-_Cookie-BOM-DOM.md" };
const _hoisted_1 = /* @__PURE__ */ createBaseVNode("h1", {
  id: "cookie",
  tabindex: "-1"
}, [
  /* @__PURE__ */ createTextVNode("Cookie "),
  /* @__PURE__ */ createBaseVNode("a", {
    class: "header-anchor",
    href: "#cookie",
    "aria-label": 'Permalink to "Cookie"'
  }, "​")
], -1);
const _hoisted_2 = /* @__PURE__ */ createStaticVNode('<p><img src="' + _imports_0 + '" alt="image-20240902210639646"></p><ul><li><p>js获取不到服务器设置的<code>cookie</code></p></li><li><p>在JavaScript中，删除服务端返回的cookie并不像设置或读取cookie那么直接。原因在于，JavaScript无法直接从服务端删除cookie，但可以通过<strong>设置一个相同名字、路径，并且过期时间设置为过去的时间的cookie</strong>来实现删除效果。</p><h3 id="删除cookie的步骤" tabindex="-1">删除Cookie的步骤 <a class="header-anchor" href="#删除cookie的步骤" aria-label="Permalink to &quot;删除Cookie的步骤&quot;">​</a></h3><ol><li><strong>确保与服务器设置的cookie具有相同的名字、路径和域名</strong>：当删除cookie时，名字、路径和域名必须与原始cookie完全匹配。否则，只能修改或删除与这些属性匹配的cookie。</li><li><strong>将cookie的过期时间设置为过去</strong>：通过将<code>expires</code>属性设置为一个过去的日期，浏览器会自动删除这个cookie。</li></ol><h3 id="代码示例" tabindex="-1">代码示例 <a class="header-anchor" href="#代码示例" aria-label="Permalink to &quot;代码示例&quot;">​</a></h3><p>假设服务器返回了一个名为<code>userSession</code>的cookie，你可以通过以下代码删除它：</p><div class="language-js vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">js</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;"> deleteCookie</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">name</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">    // 设置cookie的名字，路径和域名（如果需要）</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    document.cookie </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> name </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">+</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;"> &quot;=; path=/; expires=Thu, 01 Jan 1970 00:00:00 GMT&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">;</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 调用函数删除cookie</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">deleteCookie</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;userSession&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div></li></ul><h1 id="bom" tabindex="-1">BOM <a class="header-anchor" href="#bom" aria-label="Permalink to &quot;BOM&quot;">​</a></h1>', 3);
const _hoisted_5 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createBaseVNode("img", {
    src: _imports_1,
    alt: "image-20240902212743763"
  })
], -1);
const _hoisted_6 = /* @__PURE__ */ createBaseVNode("blockquote", null, [
  /* @__PURE__ */ createBaseVNode("p", null, "浏览器为了让js更好的操作浏览器,提供了一系列的API")
], -1);
const _hoisted_7 = /* @__PURE__ */ createBaseVNode("p", null, [
  /* @__PURE__ */ createBaseVNode("img", {
    src: _imports_2,
    alt: "image-20240902213154305"
  })
], -1);
const _hoisted_8 = /* @__PURE__ */ createBaseVNode("h1", {
  id: "dom",
  tabindex: "-1"
}, [
  /* @__PURE__ */ createTextVNode("DOM "),
  /* @__PURE__ */ createBaseVNode("a", {
    class: "header-anchor",
    href: "#dom",
    "aria-label": 'Permalink to "DOM"'
  }, "​")
], -1);
const _hoisted_9 = /* @__PURE__ */ createStaticVNode('<p><img src="' + _imports_3 + '" alt="image-20240902214406033"></p><h2 id="事件流" tabindex="-1">事件流 <a class="header-anchor" href="#事件流" aria-label="Permalink to &quot;事件流&quot;">​</a></h2><p>好的，我们可以更深入地探讨DOM事件流的细节，并探讨一些常见的用法和实际应用。</p><h3 id="_1-dom事件模型的历史背景" tabindex="-1">1. DOM事件模型的历史背景 <a class="header-anchor" href="#_1-dom事件模型的历史背景" aria-label="Permalink to &quot;1. DOM事件模型的历史背景&quot;">​</a></h3><p>DOM事件模型起源于浏览器早期的发展阶段。当时，微软的IE浏览器和Netscape Navigator两大主流浏览器分别引入了不同的事件模型。IE采用的是<strong>冒泡事件模型</strong>，而Netscape则采用了<strong>捕获事件模型</strong>。随着时间的推移，W3C最终标准化了DOM事件模型，结合了捕获和冒泡机制，形成了现在通用的三阶段事件流。</p><p><img src="' + _imports_4 + '" alt="image-20240903100853837"></p><h3 id="_2-捕获阶段详细解析" tabindex="-1">2. 捕获阶段详细解析 <a class="header-anchor" href="#_2-捕获阶段详细解析" aria-label="Permalink to &quot;2. 捕获阶段详细解析&quot;">​</a></h3><p>捕获阶段的意义在于提供一种机制，允许上层元素在事件到达目标元素之前进行预处理。例如，如果我们在文档的根节点（<code>document</code>）上监听捕获阶段的点击事件，我们可以在任何元素处理它之前，对整个页面的点击进行监控和处理。</p><p>捕获阶段主要用于以下场景：</p><ul><li><strong>全局监听</strong>：在捕获阶段处理事件可以确保在事件到达目标元素之前进行预处理，这对于全局事件监听非常有用。</li><li><strong>权限控制</strong>：有时，开发者可能需要根据某些条件阻止事件到达某些子元素，捕获阶段可以提供这种能力。</li></ul><h3 id="_3-目标阶段的深入探讨" tabindex="-1">3. 目标阶段的深入探讨 <a class="header-anchor" href="#_3-目标阶段的深入探讨" aria-label="Permalink to &quot;3. 目标阶段的深入探讨&quot;">​</a></h3><p>在目标阶段，事件到达目标元素并执行目标元素上的事件处理程序。这是事件的核心处理阶段。在这个阶段，事件在目标元素上被触发，触发的处理程序数量和顺序取决于为该元素注册的事件监听器。</p><h3 id="_4-冒泡阶段的实际应用" tabindex="-1">4. 冒泡阶段的实际应用 <a class="header-anchor" href="#_4-冒泡阶段的实际应用" aria-label="Permalink to &quot;4. 冒泡阶段的实际应用&quot;">​</a></h3><p>冒泡阶段的最大优势在于<strong>事件委托</strong>，这一技术在复杂的Web应用中被广泛使用。</p><h4 id="事件委托的原理" tabindex="-1"><strong>事件委托的原理</strong> <a class="header-anchor" href="#事件委托的原理" aria-label="Permalink to &quot;**事件委托的原理**&quot;">​</a></h4><p>事件委托是利用冒泡阶段在父元素上监听事件，而不是为每一个子元素单独绑定事件处理程序。由于事件会冒泡到父元素，我们可以在父元素上统一处理子元素的事件。这在动态生成大量子元素时尤其有用，因为可以减少绑定的事件处理程序数量，优化性能。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (event.target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">matches</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;.clickable-item&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Clickable item clicked:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.target);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><p>这个例子展示了如何使用事件委托在<code>&lt;body&gt;</code>元素上统一监听<code>.clickable-item</code>元素的点击事件，而不是为每个<code>.clickable-item</code>单独绑定事件处理程序。</p><h3 id="_5-dom事件对象详解" tabindex="-1">5. DOM事件对象详解 <a class="header-anchor" href="#_5-dom事件对象详解" aria-label="Permalink to &quot;5. DOM事件对象详解&quot;">​</a></h3><p>在事件流中，浏览器会为每个事件创建一个事件对象（<code>Event</code>对象）。这个对象包含了事件的详细信息，比如：</p><ul><li><code>target</code>：指向触发事件的元素。</li><li><code>currentTarget</code>：指向事件处理程序当前绑定的元素。</li><li><code>eventPhase</code>：表示事件当前处于哪个阶段（1表示捕获阶段，2表示目标阶段，3表示冒泡阶段）。</li><li><code>bubbles</code>：一个布尔值，表示事件是否冒泡。</li><li><code>cancelable</code>：一个布尔值，表示事件是否可以取消默认行为。</li><li><code>defaultPrevented</code>：一个布尔值，指示是否已经调用<code>preventDefault()</code>来阻止默认行为。</li></ul><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Event phase:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.eventPhase);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Event target:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.target);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Current target:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.currentTarget);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Bubbles:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.bubbles);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Cancelable:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.cancelable);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><h3 id="_6-阻止事件传播的深入解析" tabindex="-1">6. 阻止事件传播的深入解析 <a class="header-anchor" href="#_6-阻止事件传播的深入解析" aria-label="Permalink to &quot;6. 阻止事件传播的深入解析&quot;">​</a></h3><h4 id="stoppropagation-的作用" tabindex="-1"><strong><code>stopPropagation()</code>的作用</strong> <a class="header-anchor" href="#stoppropagation-的作用" aria-label="Permalink to &quot;**`stopPropagation()`的作用**&quot;">​</a></h4><p><code>event.stopPropagation()</code>方法只阻止事件继续传播到更高层次的元素（停止冒泡或捕获）。然而，这并不会阻止当前元素上其他事件处理程序的执行。</p><h4 id="stopimmediatepropagation-的作用" tabindex="-1"><strong><code>stopImmediatePropagation()</code>的作用</strong> <a class="header-anchor" href="#stopimmediatepropagation-的作用" aria-label="Permalink to &quot;**`stopImmediatePropagation()`的作用**&quot;">​</a></h4><p><code>event.stopImmediatePropagation()</code>不仅阻止事件传播，还阻止当前元素上其他事件处理程序的执行。这对于希望在特定条件下阻止所有事件处理的情况特别有用。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">stopPropagation</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Propagation stopped&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">stopImmediatePropagation</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;This will not run if stopImmediatePropagation is called earlier&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><h3 id="_7-复杂场景中的dom事件流" tabindex="-1">7. 复杂场景中的DOM事件流 <a class="header-anchor" href="#_7-复杂场景中的dom事件流" aria-label="Permalink to &quot;7. 复杂场景中的DOM事件流&quot;">​</a></h3><p>在复杂的Web应用中，理解DOM事件流是至关重要的。例如，在拖拽操作中，事件流的处理变得更加复杂，需要同时处理捕获和冒泡阶段的事件，以确保事件在适当的时机被处理或拦截。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 复杂的拖拽事件处理</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;dragstart&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Drag started&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.target);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 捕获阶段监听</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;dragover&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 必须阻止默认行为才能触发drop事件</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Dragging over&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.target);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;drop&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">();</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Dropped&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.target);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 冒泡阶段监听</span></span></code></pre></div><h3 id="_8-异步事件处理与dom事件流" tabindex="-1">8. 异步事件处理与DOM事件流 <a class="header-anchor" href="#_8-异步事件处理与dom事件流" aria-label="Permalink to &quot;8. 异步事件处理与DOM事件流&quot;">​</a></h3><p>JavaScript中的事件处理通常是同步执行的，但在处理异步任务时，理解事件流的顺序仍然很重要。使用<code>setTimeout</code>或<code>Promise</code>等异步操作，可以将某些处理任务推迟到事件流之外的时间点进行处理，这样可以避免与事件流中其他同步任务产生冲突。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">element.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Clicked&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    setTimeout</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;This runs after the event flow&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">0</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div><h2 id="dom-事件处理机制" tabindex="-1">DOM 事件处理机制 <a class="header-anchor" href="#dom-事件处理机制" aria-label="Permalink to &quot;DOM 事件处理机制&quot;">​</a></h2><p>DOM0、DOM1、DOM2 是 Web 开发中的不同阶段的 DOM 事件处理机制，它们的发展反映了 Web 技术随着时间的演进而解决的各种问题。我们可以从它们的历史背景、解决的问题和优点等方面进行详细讲解。</p><h3 id="_1-dom0-事件模型" tabindex="-1">1. DOM0 事件模型 <a class="header-anchor" href="#_1-dom0-事件模型" aria-label="Permalink to &quot;1. DOM0 事件模型&quot;">​</a></h3><h4 id="背景与历史" tabindex="-1"><strong>背景与历史</strong> <a class="header-anchor" href="#背景与历史" aria-label="Permalink to &quot;**背景与历史**&quot;">​</a></h4><p>DOM0 是最早期的 DOM 事件处理方式，它出现在 JavaScript 的早期阶段，约在 1995 年左右。那时，Web 还处于初期发展阶段，浏览器的功能比较简单，开发者开始使用 JavaScript 来处理用户的交互。</p><h4 id="实现方式" tabindex="-1"><strong>实现方式</strong> <a class="header-anchor" href="#实现方式" aria-label="Permalink to &quot;**实现方式**&quot;">​</a></h4><p>DOM0 事件模型通过直接在 HTML 元素的属性中绑定事件处理函数来实现。例如：</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#6CB6FF;"> onclick</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">alert</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">(&#39;Button clicked!&#39;)&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;Click me&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#8DDB8C;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">&gt;</span></span></code></pre></div><p>或者在 JavaScript 中：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> button </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;myButton&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">onclick</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> =</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Button clicked!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">};</span></span></code></pre></div><h4 id="优点" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点" aria-label="Permalink to &quot;**优点**&quot;">​</a></h4><ul><li><strong>简单易用</strong>：DOM0 的实现非常简单，只需将处理函数直接赋值给元素的事件属性。</li><li><strong>直接访问元素</strong>：开发者可以直接在 HTML 元素上定义事件处理程序，无需引入额外的复杂性。</li></ul><h4 id="局限性" tabindex="-1"><strong>局限性</strong> <a class="header-anchor" href="#局限性" aria-label="Permalink to &quot;**局限性**&quot;">​</a></h4><ul><li><strong>每个元素只能绑定一个事件处理程序</strong>：如果对同一个元素绑定多个事件处理程序，前一个会被后一个覆盖。</li><li><strong>缺乏事件流控制</strong>：DOM0 仅支持最基本的事件绑定，没有捕获或冒泡机制，无法控制事件的传播。</li></ul><h3 id="_2-dom1-事件模型" tabindex="-1">2. DOM1 事件模型 <a class="header-anchor" href="#_2-dom1-事件模型" aria-label="Permalink to &quot;2. DOM1 事件模型&quot;">​</a></h3><h4 id="背景与历史-1" tabindex="-1"><strong>背景与历史</strong> <a class="header-anchor" href="#背景与历史-1" aria-label="Permalink to &quot;**背景与历史**&quot;">​</a></h4><p>随着 Web 技术的发展，W3C（World Wide Web Consortium）意识到需要标准化和扩展事件处理能力。于是，在 1998 年左右，W3C 推出了 DOM1 规范，首次标准化了浏览器与文档交互的方式。</p><h4 id="主要特性" tabindex="-1"><strong>主要特性</strong> <a class="header-anchor" href="#主要特性" aria-label="Permalink to &quot;**主要特性**&quot;">​</a></h4><p>DOM1 主要关注的是基础的文档结构和节点操作，但在事件处理方面并没有带来显著的改进。DOM1 标准化了文档和节点的访问方式，但事件处理仍然主要依赖于 DOM0 机制。因此，DOM1 并未在事件处理方面提供新的解决方案。</p><h4 id="局限性-1" tabindex="-1"><strong>局限性</strong> <a class="header-anchor" href="#局限性-1" aria-label="Permalink to &quot;**局限性**&quot;">​</a></h4><ul><li><strong>缺乏统一的事件处理机制</strong>：虽然 DOM1 标准化了文档访问，但不同浏览器仍然在事件处理上存在差异。</li><li><strong>不支持捕获和冒泡</strong>：DOM1 没有扩展事件流的处理机制，这使得复杂的用户交互处理仍然受到限制。</li></ul><h3 id="_3-dom2-事件模型" tabindex="-1">3. DOM2 事件模型 <a class="header-anchor" href="#_3-dom2-事件模型" aria-label="Permalink to &quot;3. DOM2 事件模型&quot;">​</a></h3><h4 id="背景与历史-2" tabindex="-1"><strong>背景与历史</strong> <a class="header-anchor" href="#背景与历史-2" aria-label="Permalink to &quot;**背景与历史**&quot;">​</a></h4><p>DOM2 事件模型在 2000 年左右被引入，旨在解决 DOM0 和 DOM1 在事件处理上的不足。DOM2 事件模型是 W3C 标准的一部分，它引入了更强大的事件处理机制，包括事件捕获、冒泡和事件监听器。</p><h4 id="实现方式-1" tabindex="-1"><strong>实现方式</strong> <a class="header-anchor" href="#实现方式-1" aria-label="Permalink to &quot;**实现方式**&quot;">​</a></h4><p>DOM2 事件模型通过 <code>addEventListener</code> 方法来绑定事件处理程序：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">var</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> button </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">=</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;myButton&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">button.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">() {</span></span>\n<span class="line"><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">    alert</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Button clicked!&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">false</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span></code></pre></div><p>在 <code>addEventListener</code> 中，第三个参数 <code>false</code> 表示在冒泡阶段触发事件处理程序，<code>true</code> 则表示在捕获阶段触发。</p><h4 id="优点-1" tabindex="-1"><strong>优点</strong> <a class="header-anchor" href="#优点-1" aria-label="Permalink to &quot;**优点**&quot;">​</a></h4><ul><li><strong>支持多个事件处理程序</strong>：同一个元素可以绑定多个事件处理程序，所有处理程序都会被依次触发。</li><li><strong>事件流控制</strong>：DOM2 引入了捕获和冒泡阶段，使得开发者可以更精确地控制事件的传播路径。</li><li><strong>跨浏览器兼容性</strong>：DOM2 规范由 W3C 制定，旨在统一各大浏览器的行为，减少了浏览器之间的差异。</li><li><strong>更灵活的事件管理</strong>：开发者可以动态地添加和移除事件处理程序，这为开发复杂的交互功能提供了极大的灵活性。</li></ul><h4 id="局限性-2" tabindex="-1"><strong>局限性</strong> <a class="header-anchor" href="#局限性-2" aria-label="Permalink to &quot;**局限性**&quot;">​</a></h4><ul><li><strong>兼容性问题</strong>：虽然 DOM2 旨在统一标准，但在早期，部分旧版浏览器对该标准的支持并不完善。</li><li><strong>复杂性增加</strong>：相对于 DOM0，DOM2 的复杂性增加，需要开发者理解事件流和事件处理的机制。</li></ul><h3 id="_4-总结与发展" tabindex="-1">4. 总结与发展 <a class="header-anchor" href="#_4-总结与发展" aria-label="Permalink to &quot;4. 总结与发展&quot;">​</a></h3><p>DOM 事件模型从 DOM0 到 DOM2 的演进，反映了 Web 技术从简单到复杂，从浏览器之间的不一致到标准化发展的过程。</p><ul><li><strong>DOM0</strong> 提供了最基础的事件处理机制，但局限性明显。</li><li><strong>DOM1</strong> 规范化了文档结构和节点访问，但未显著改进事件处理。</li><li><strong>DOM2</strong> 则引入了全面的事件处理标准，使得开发者可以更加灵活地控制用户交互，处理复杂的事件流。</li></ul><p>DOM2 事件模型解决了早期事件处理的诸多问题，为现代 Web 开发奠定了坚实的基础，并且这一模型在之后的 DOM3 中得到了进一步扩展和优化。掌握这些不同阶段的事件模型，可以帮助开发者更好地理解浏览器事件处理的演变过程，以及如何在实际开发中选择合适的事件处理方法。</p><h2 id="为什么会出现事件冒泡和事件捕获" tabindex="-1">为什么会出现事件冒泡和事件捕获 <a class="header-anchor" href="#为什么会出现事件冒泡和事件捕获" aria-label="Permalink to &quot;为什么会出现事件冒泡和事件捕获&quot;">​</a></h2><h3 id="_1-事件冒泡的背景与目的" tabindex="-1">1. 事件冒泡的背景与目的 <a class="header-anchor" href="#_1-事件冒泡的背景与目的" aria-label="Permalink to &quot;1. 事件冒泡的背景与目的&quot;">​</a></h3><h4 id="背景" tabindex="-1"><strong>背景</strong> <a class="header-anchor" href="#背景" aria-label="Permalink to &quot;**背景**&quot;">​</a></h4><p>事件冒泡（Event Bubbling）是由微软在开发早期的 Internet Explorer 浏览器时提出的概念。随着 Web 应用的复杂性增加，用户在一个网页上执行的操作可能影响到多个元素。例如，当用户点击一个按钮，这个点击事件不仅仅对按钮本身有意义，还可能影响到包含这个按钮的其他容器元素。</p><h4 id="目的" tabindex="-1"><strong>目的</strong> <a class="header-anchor" href="#目的" aria-label="Permalink to &quot;**目的**&quot;">​</a></h4><p>事件冒泡的设计初衷是让事件从具体的目标元素逐层向上传播到它的父级元素，直到根节点。这样，开发者可以在父级元素上捕获子元素的事件，而无需为每个子元素单独绑定事件处理程序。</p><ul><li><strong>简化事件处理</strong>：在父级元素上监听事件，可以避免为每一个子元素绑定事件处理程序，从而简化代码和提升性能。</li><li><strong>事件委托</strong>：事件冒泡为事件委托提供了基础。事件委托允许开发者在一个父元素上统一管理多个子元素的事件，从而有效地处理动态生成或大量的 DOM 元素。</li></ul><h3 id="_2-事件捕获的背景与目的" tabindex="-1">2. 事件捕获的背景与目的 <a class="header-anchor" href="#_2-事件捕获的背景与目的" aria-label="Permalink to &quot;2. 事件捕获的背景与目的&quot;">​</a></h3><h4 id="背景-1" tabindex="-1"><strong>背景</strong> <a class="header-anchor" href="#背景-1" aria-label="Permalink to &quot;**背景**&quot;">​</a></h4><p>事件捕获（Event Capturing）最早由 Netscape 在其浏览器中引入，作为与事件冒泡相对的机制。事件捕获的想法是，从文档的根节点开始，事件逐层向下传播到目标元素。虽然事件捕获最初没有得到广泛支持，但随着 DOM2 的引入，W3C 将捕获和冒泡机制结合在一起，成为标准事件流的一部分。</p><h4 id="目的-1" tabindex="-1"><strong>目的</strong> <a class="header-anchor" href="#目的-1" aria-label="Permalink to &quot;**目的**&quot;">​</a></h4><p>事件捕获允许开发者在事件到达目标元素之前，先对事件进行预处理或拦截。这在某些特定的应用场景中非常有用，例如：</p><ul><li><strong>全局控制</strong>：在复杂应用中，开发者可能需要在事件到达某些具体元素之前，先执行一些全局性的检查或控制。捕获阶段为这种需求提供了可能。</li><li><strong>安全和权限管理</strong>：通过在捕获阶段控制事件的传播，开发者可以在事件到达目标元素之前，决定是否允许其继续传播，从而实现更精细的权限控制。</li></ul><h3 id="_3-为什么同时存在冒泡和捕获机制" tabindex="-1">3. 为什么同时存在冒泡和捕获机制 <a class="header-anchor" href="#_3-为什么同时存在冒泡和捕获机制" aria-label="Permalink to &quot;3. 为什么同时存在冒泡和捕获机制&quot;">​</a></h3><p>同时支持事件冒泡和事件捕获机制，使得事件处理更加灵活和可控。每种机制都有其适用场景，因此同时存在有助于开发者根据实际需求选择合适的事件处理策略。</p><ul><li><p><strong>灵活性</strong>：不同的应用场景对事件处理有不同的需求，有时开发者希望先处理父级元素的逻辑（捕获），有时希望先处理子元素的逻辑（冒泡）。通过同时支持两种机制，开发者可以更自由地设计交互流程。</p></li><li><p><strong>标准化</strong>：W3C 的 DOM2 规范将两种机制结合在一起，使事件流分为捕获、目标、冒泡三个阶段，从而统一了事件处理模型。这不仅减少了不同浏览器之间的行为差异，还使得 Web 开发的复杂交互场景得以顺利实现。</p></li></ul><h3 id="_4-实际应用中的选择" tabindex="-1">4. 实际应用中的选择 <a class="header-anchor" href="#_4-实际应用中的选择" aria-label="Permalink to &quot;4. 实际应用中的选择&quot;">​</a></h3><p>在实际开发中，开发者通常更常用的是事件冒泡，特别是在使用事件委托的场景下。而事件捕获则用于更特殊的情况，如全局监控、权限管理或在特定阶段控制事件的传播。</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 事件冒泡的例子：事件委托</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.body.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">    if</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> (event.target.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">matches</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;.item&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">)) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">        console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Item clicked:&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, event.target);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    }</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span>\n<span class="line"></span>\n<span class="line"><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 事件捕获的例子：全局控制</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;click&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&#39;Document clicked, captured in the capturing phase&#39;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">}, </span><span style="--shiki-light:#005CC5;--shiki-dark:#6CB6FF;">true</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 捕获阶段监听</span></span></code></pre></div><h2 id="事件" tabindex="-1">事件 <a class="header-anchor" href="#事件" aria-label="Permalink to &quot;事件&quot;">​</a></h2><p><img src="' + _imports_5 + '" alt="image-20240903101629503"></p><p>在 JavaScript 中，事件对象（Event Object）是非常重要的概念，特别是在处理用户交互和浏览器事件时。事件对象是浏览器在事件发生时自动创建的对象，包含了与该事件相关的所有信息。以下是关于事件对象的详细介绍：</p><h3 id="_1-事件对象的来源" tabindex="-1">1. <strong>事件对象的来源</strong> <a class="header-anchor" href="#_1-事件对象的来源" aria-label="Permalink to &quot;1. **事件对象的来源**&quot;">​</a></h3><p>当一个事件（例如点击、键盘按下、鼠标移动等）发生时，浏览器会自动创建一个事件对象，并将其作为参数传递给事件处理函数。这个对象包含了事件的所有信息，比如事件的类型、触发事件的元素、鼠标位置、按下的键等。</p><h3 id="_2-事件对象的常用属性" tabindex="-1">2. <strong>事件对象的常用属性</strong> <a class="header-anchor" href="#_2-事件对象的常用属性" aria-label="Permalink to &quot;2. **事件对象的常用属性**&quot;">​</a></h3><p>事件对象中包含了许多有用的属性和方法，以下是一些常见的属性：</p><ul><li><strong><code>type</code></strong>：表示事件的类型，例如 <code>&quot;click&quot;</code>、<code>&quot;keydown&quot;</code> 等。</li><li><strong><code>target</code></strong>：指向触发事件的 DOM 元素。例如，如果用户点击了一个按钮，<code>target</code> 属性将指向该按钮。</li><li><strong><code>currentTarget</code></strong>：通常指向绑定事件处理程序的元素。在事件委托中，它与 <code>target</code> 不同。</li><li><strong><code>timeStamp</code></strong>：表示事件生成的时间戳，通常用于计算事件触发的时间间隔。</li><li><strong><code>preventDefault()</code></strong>：阻止事件的默认行为。例如，可以阻止表单的提交或链接的跳转。</li><li><strong><code>stopPropagation()</code></strong>：停止事件冒泡，阻止事件向父元素传播。</li><li><strong><code>stopImmediatePropagation()</code></strong>：除了停止冒泡，还阻止其他相同事件类型的事件处理程序的执行。</li></ul><h3 id="_3-鼠标事件的特定属性" tabindex="-1">3. <strong>鼠标事件的特定属性</strong> <a class="header-anchor" href="#_3-鼠标事件的特定属性" aria-label="Permalink to &quot;3. **鼠标事件的特定属性**&quot;">​</a></h3><p>对于鼠标相关的事件（如 <code>click</code>、<code>mousemove</code> 等），事件对象还有一些特定的属性：</p><ul><li><strong><code>clientX</code></strong> 和 <strong><code>clientY</code></strong>：鼠标指针相对于浏览器窗口的 x 和 y 坐标。</li><li><strong><code>pageX</code></strong> 和 <strong><code>pageY</code></strong>：鼠标指针相对于文档的 x 和 y 坐标。</li><li><strong><code>button</code></strong>：表示哪个鼠标按钮被点击（0 为左键，1 为中键，2 为右键）。</li><li><strong><code>ctrlKey</code></strong>、<strong><code>shiftKey</code></strong>、<strong><code>altKey</code></strong>、<strong><code>metaKey</code></strong>：这些属性为布尔值，表示是否按下了对应的修饰键（Ctrl、Shift、Alt 或 Meta）。</li></ul><h3 id="_4-键盘事件的特定属性" tabindex="-1">4. <strong>键盘事件的特定属性</strong> <a class="header-anchor" href="#_4-键盘事件的特定属性" aria-label="Permalink to &quot;4. **键盘事件的特定属性**&quot;">​</a></h3><p>对于键盘相关的事件（如 <code>keydown</code>、<code>keypress</code>、<code>keyup</code>），事件对象包含以下特定属性：</p><ul><li><strong><code>key</code></strong>：表示按下的键的值，例如 <code>&quot;a&quot;</code>、<code>&quot;Enter&quot;</code>。</li><li><strong><code>code</code></strong>：表示按下的键的物理键位代码，例如 <code>&quot;KeyA&quot;</code>、<code>&quot;Enter&quot;</code>。</li><li><strong><code>keyCode</code></strong>：表示按下的键的数字代码，这个属性较为过时，现代浏览器推荐使用 <code>key</code> 或 <code>code</code>。</li></ul><h3 id="_5-事件对象的传播机制" tabindex="-1">5. <strong>事件对象的传播机制</strong> <a class="header-anchor" href="#_5-事件对象的传播机制" aria-label="Permalink to &quot;5. **事件对象的传播机制**&quot;">​</a></h3><p>事件传播分为三个阶段：</p><ul><li><strong>捕获阶段</strong>：事件从 <code>window</code> 向目标元素传播。</li><li><strong>目标阶段</strong>：事件到达目标元素。</li><li><strong>冒泡阶段</strong>：事件从目标元素向上传播到 <code>window</code>。</li></ul><p>默认情况下，大部分事件处理程序都在冒泡阶段被触发。如果你想在捕获阶段处理事件，可以在添加事件监听器时将第三个参数设置为 <code>true</code>。</p><h3 id="_6-示例代码" tabindex="-1">6. <strong>示例代码</strong> <a class="header-anchor" href="#_6-示例代码" aria-label="Permalink to &quot;6. **示例代码**&quot;">​</a></h3><p>以下是一个简单的示例，展示了如何使用事件对象：</p><div class="language-javascript vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">javascript</span><pre class="shiki shiki-themes github-light github-dark-dimmed vp-code"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">document.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">getElementById</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;myButton&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">).</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">addEventListener</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;click&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">, </span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;">function</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#E36209;--shiki-dark:#F69D50;">event</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">) {</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;事件类型：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> event.type);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    console.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">log</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(</span><span style="--shiki-light:#032F62;--shiki-dark:#96D0FF;">&quot;触发事件的元素：&quot;</span><span style="--shiki-light:#D73A49;--shiki-dark:#F47067;"> +</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;"> event.target.tagName);</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">preventDefault</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 阻止默认行为</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">    event.</span><span style="--shiki-light:#6F42C1;--shiki-dark:#DCBDFB;">stopPropagation</span><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">(); </span><span style="--shiki-light:#6A737D;--shiki-dark:#768390;">// 阻止事件冒泡</span></span>\n<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#ADBAC7;">});</span></span></code></pre></div>', 110);
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  const _component_ArticleMetadata = __unplugin_components_4;
  const _component_ClientOnly = resolveComponent("ClientOnly");
  return openBlock(), createElementBlock("div", null, [
    _hoisted_1,
    createVNode(_component_ClientOnly, null, {
      default: withCtx(() => {
        var _a, _b;
        return [
          (((_a = _ctx.$frontmatter) == null ? void 0 : _a.aside) ?? true) && (((_b = _ctx.$frontmatter) == null ? void 0 : _b.showArticleMetadata) ?? true) ? (openBlock(), createBlock(_component_ArticleMetadata, {
            key: 0,
            article: _ctx.$frontmatter
          }, null, 8, ["article"])) : createCommentVNode("", true)
        ];
      }),
      _: 1
    }),
    _hoisted_2,
    createVNode(_component_ClientOnly, null, {
      default: withCtx(() => {
        var _a, _b;
        return [
          (((_a = _ctx.$frontmatter) == null ? void 0 : _a.aside) ?? true) && (((_b = _ctx.$frontmatter) == null ? void 0 : _b.showArticleMetadata) ?? true) ? (openBlock(), createBlock(_component_ArticleMetadata, {
            key: 0,
            article: _ctx.$frontmatter
          }, null, 8, ["article"])) : createCommentVNode("", true)
        ];
      }),
      _: 1
    }),
    _hoisted_5,
    _hoisted_6,
    _hoisted_7,
    _hoisted_8,
    createVNode(_component_ClientOnly, null, {
      default: withCtx(() => {
        var _a, _b;
        return [
          (((_a = _ctx.$frontmatter) == null ? void 0 : _a.aside) ?? true) && (((_b = _ctx.$frontmatter) == null ? void 0 : _b.showArticleMetadata) ?? true) ? (openBlock(), createBlock(_component_ArticleMetadata, {
            key: 0,
            article: _ctx.$frontmatter
          }, null, 8, ["article"])) : createCommentVNode("", true)
        ];
      }),
      _: 1
    }),
    _hoisted_9
  ]);
}
const _22_CookieBOMDOM = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _22_CookieBOMDOM as default
};
