import { _ as _export_sfc, o as openBlock, c as createElementBlock, R as createStaticVNode } from "./chunks/framework.b55ravPP.js";
const __pageData = JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"src/study-notes/01-学习笔记/01-js高级plus/30-补充_执行上下文.md","filePath":"src/study-notes/01-学习笔记/01-js高级plus/30-补充_执行上下文.md","lastUpdated":1739460242000}');
const _sfc_main = { name: "src/study-notes/01-学习笔记/01-js高级plus/30-补充_执行上下文.md" };
const _hoisted_1 = /* @__PURE__ */ createStaticVNode('<h3 id="执行上下文详解" tabindex="-1">执行上下文详解 <a class="header-anchor" href="#执行上下文详解" aria-label="Permalink to &quot;执行上下文详解&quot;">​</a></h3><p>在JavaScript中，<strong>执行上下文（Execution Context）</strong> 是一个非常重要的概念，它决定了代码在什么环境中执行，以及如何管理代码的执行过程。</p><h3 id="_1-为什么会有执行上下文" tabindex="-1">1. 为什么会有执行上下文？ <a class="header-anchor" href="#_1-为什么会有执行上下文" aria-label="Permalink to &quot;1. 为什么会有执行上下文？&quot;">​</a></h3><p><strong>执行上下文</strong>是JavaScript运行时管理代码执行的机制。因为JavaScript是一种解释性语言，代码是逐行解释和执行的。因此，JavaScript需要一个机制来管理代码的执行环境，确保正确地处理变量、函数和<code>this</code>等关键要素。这就是执行上下文的作用。</p><p><strong>执行上下文</strong>可以理解为一个&quot;包装器&quot;，它包含了代码执行时所需的所有信息。这些信息包括：</p><ul><li><strong>词法环境（Lexical Environment）</strong>：保存变量和函数声明。</li><li><strong>环境变量（Variable Environment）</strong>：保存<code>var</code>声明的变量（在ES6之前，只有这一种）。</li><li><strong><code>this</code>绑定（This Binding）</strong>：保存<code>this</code>的值。</li></ul><h3 id="_2-什么时候会创建执行上下文" tabindex="-1">2. 什么时候会创建执行上下文？ <a class="header-anchor" href="#_2-什么时候会创建执行上下文" aria-label="Permalink to &quot;2. 什么时候会创建执行上下文？&quot;">​</a></h3><p><strong>执行上下文</strong>在以下三种情况下被创建：</p><ol><li><p><strong>全局代码（Global Code）</strong>：当JavaScript代码首次被加载和执行时，浏览器或Node.js环境会创建一个全局执行上下文。这个全局执行上下文会贯穿整个程序的生命周期，直到应用程序退出。</p></li><li><p><strong>函数调用（Function Invocation）</strong>：每当一个函数被调用时，JavaScript引擎会为该函数创建一个新的执行上下文。这是函数独立执行的环境，可以理解为&quot;为函数创建的独立执行空间&quot;。</p></li><li><p><strong><code>eval</code>代码执行</strong>：虽然不常用，但当使用<code>eval</code>函数执行一段字符串代码时，会为该字符串代码创建一个执行上下文。</p></li></ol><h3 id="_3-执行上下文的种类" tabindex="-1">3. 执行上下文的种类 <a class="header-anchor" href="#_3-执行上下文的种类" aria-label="Permalink to &quot;3. 执行上下文的种类&quot;">​</a></h3><p>总共有三种不同的执行上下文：</p><ol><li><p><strong>全局执行上下文（Global Execution Context）</strong>：</p><ul><li>这是默认的、最基本的执行上下文。任何不在函数内部的代码都在全局执行上下文中运行。</li><li>全局上下文的<code>this</code>指向全局对象（在浏览器中是<code>window</code>对象，在Node.js中是<code>global</code>对象）。</li></ul></li><li><p><strong>函数执行上下文（Function Execution Context）</strong>：</p><ul><li>每当函数被调用时，都会为该函数创建一个独立的执行上下文。</li><li>每个函数调用都会有自己独立的执行上下文，即使是同一个函数被多次调用，也会为每次调用创建新的执行上下文。</li><li>函数执行上下文中的<code>this</code>值由调用该函数的方式决定。</li></ul></li><li><p><strong><code>eval</code>执行上下文</strong>：</p><ul><li>当使用<code>eval</code>函数执行代码时，会为该代码片段创建一个执行上下文。</li><li>不建议使用<code>eval</code>，因为它带来安全性和性能上的问题。</li></ul></li></ol><h3 id="_4-执行上下文的作用" tabindex="-1">4. 执行上下文的作用 <a class="header-anchor" href="#_4-执行上下文的作用" aria-label="Permalink to &quot;4. 执行上下文的作用&quot;">​</a></h3><p><strong>执行上下文</strong>的主要作用包括：</p><ol><li><p><strong>变量、函数的解析与管理</strong>：执行上下文管理当前作用域内的变量和函数声明，并确保代码执行时能够正确地访问这些变量和函数。</p></li><li><p><strong>管理<code>this</code>绑定</strong>：执行上下文确定了<code>this</code>在代码中的值，这对于方法调用、构造函数调用等非常关键。</p></li><li><p><strong>作用域链的建立</strong>：每个执行上下文都包含一个词法环境，词法环境通过外部引用指向外部环境，形成作用域链。执行上下文通过作用域链管理变量查找。</p></li><li><p><strong>闭包的支持</strong>：执行上下文允许函数在创建时捕获周围的词法环境，从而支持闭包的实现。</p></li></ol><h3 id="_5-执行上下文的执行顺序" tabindex="-1">5. 执行上下文的执行顺序 <a class="header-anchor" href="#_5-执行上下文的执行顺序" aria-label="Permalink to &quot;5. 执行上下文的执行顺序&quot;">​</a></h3><p><strong>执行上下文的执行顺序</strong>遵循以下流程：</p><ol><li><p><strong>创建阶段（Creation Phase）</strong>：</p><ul><li><strong>创建词法环境（Lexical Environment）</strong>： <ul><li>为当前作用域中的<code>let</code>、<code>const</code>声明的变量和函数定义分配空间。</li></ul></li><li><strong>创建环境变量（Variable Environment）</strong>： <ul><li>为<code>var</code>声明的变量分配空间。</li></ul></li><li><strong>确定<code>this</code>绑定</strong>： <ul><li>确定<code>this</code>的值，根据调用方式设置正确的<code>this</code>绑定。</li></ul></li></ul></li><li><p><strong>执行阶段（Execution Phase）</strong>：</p><ul><li>变量分配的内存位置会在创建阶段确定，但直到执行阶段才会赋值。</li><li>函数代码在执行阶段才会执行，并可能会产生更多的执行上下文。</li></ul></li></ol><h3 id="_6-执行上下文栈-execution-context-stack" tabindex="-1">6. 执行上下文栈（Execution Context Stack） <a class="header-anchor" href="#_6-执行上下文栈-execution-context-stack" aria-label="Permalink to &quot;6. 执行上下文栈（Execution Context Stack）&quot;">​</a></h3><p>JavaScript通过执行上下文栈（也叫调用栈）来管理执行上下文的顺序。当代码执行时：</p><ol><li><strong>全局上下文</strong>被推入栈中。</li><li>每当一个函数被调用，其对应的<strong>函数执行上下文</strong>被推入栈顶。</li><li>当函数执行完毕，栈顶的上下文被弹出，控制权返回到下一个执行上下文。</li><li>当所有代码执行完毕，栈中只剩下全局上下文。</li></ol><h3 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h3><ul><li><strong>执行上下文</strong>是JavaScript运行时管理代码执行的机制，决定了代码如何执行，变量如何解析，以及<code>this</code>的值。</li><li><strong>执行上下文</strong>分为三种：全局执行上下文、函数执行上下文和<code>eval</code>执行上下文。</li><li>每当JavaScript代码执行时，都会创建新的执行上下文，并按顺序推入执行上下文栈中。</li><li><strong>执行上下文</strong>的主要作用包括管理变量和函数声明、确定<code>this</code>值、支持作用域链和闭包。</li></ul>', 23);
const _hoisted_24 = [
  _hoisted_1
];
function _sfc_render(_ctx, _cache, $props, $setup, $data, $options) {
  return openBlock(), createElementBlock("div", null, _hoisted_24);
}
const _30_________ = /* @__PURE__ */ _export_sfc(_sfc_main, [["render", _sfc_render]]);
export {
  __pageData,
  _30_________ as default
};
